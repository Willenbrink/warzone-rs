use ::libc;
extern "C" {
    #[no_mangle]
    fn memset(_: *mut libc::c_void, _: libc::c_int, _: libc::c_uint)
     -> *mut libc::c_void;
    #[no_mangle]
    fn strcpy(_: *mut libc::c_char, _: *const libc::c_char)
     -> *mut libc::c_char;
    #[no_mangle]
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    #[no_mangle]
    fn memcpy(_: *mut libc::c_void, _: *const libc::c_void, _: libc::c_uint)
     -> *mut libc::c_void;
    #[no_mangle]
    fn strlen(_: *const libc::c_char) -> libc::c_uint;
    #[no_mangle]
    fn sprintf(_: *mut libc::c_char, _: *const libc::c_char, _: ...)
     -> libc::c_int;
    #[no_mangle]
    fn vsprintf(_: *mut libc::c_char, _: *const libc::c_char,
                _: __builtin_va_list) -> libc::c_int;
    /* *
 * Output printf style format str with additional arguments.
 *
 * Only outputs if debugging of part was formerly enabled with debug_enable_switch.
 *
 * \param	part	Code part to associate with this message
 * \param	str		printf style formatstring
 */
    #[no_mangle]
    fn debug(part: code_part, str: *const libc::c_char, _: ...);
    #[no_mangle]
    fn malloc(_: libc::c_uint) -> *mut libc::c_void;
    #[no_mangle]
    fn free(__ptr: *mut libc::c_void);
    #[no_mangle]
    fn abort() -> !;
    #[no_mangle]
    fn memMallocRelease(Size: size_t) -> *mut libc::c_void;
    #[no_mangle]
    fn memFreeRelease(pMemToFree: *mut libc::c_void);
    //return last imd resource
    #[no_mangle]
    fn GetLastResourceFilename() -> *mut libc::c_char;
    /* Check if two types are equivalent */
    #[no_mangle]
    fn interpCheckEquiv(to: INTERP_TYPE, from: INTERP_TYPE) -> BOOL;
    /* The table of user types */
    /* The table of external variables and their access functions */
    /* The table of object variable access routines */
    /* The table of instinct function type definitions */
    /* The table of constant variables */
    /* The table of callback triggers */
    /* Set the current input buffer for the lexer */
    #[no_mangle]
    fn scriptSetInputBuffer(pBuffer: *mut libc::c_char, size: UDWORD);
    #[no_mangle]
    fn scriptGetErrorData(pLine: *mut libc::c_int,
                          ppText: *mut *mut libc::c_char);
    #[no_mangle]
    fn widgCopyString(pDest: *mut STRING, pSrc: *mut STRING);
    /* A Bison parser, made by GNU Bison 3.5.4.  */
    /*
 * script.y
 *
 * The yacc grammar for the scipt files.
 */
    /* Bison implementation for Yacc-like parsers in C

   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2020 Free Software Foundation,
   Inc.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
    #[no_mangle]
    fn scr_lex() -> libc::c_int;
    /* Identify Bison output.  */
    #[no_mangle]
    static mut STRSTACK: [[libc::c_char; 255]; 6000];
    // just a simple string "stack"
    #[no_mangle]
    static mut CURSTACKSTR: UDWORD;
}
pub type __builtin_va_list = *mut libc::c_char;
pub type size_t = libc::c_uint;
pub type va_list = __builtin_va_list;
/*
 * types.h
 *
 * Simple type definitions.
 *
 */
/* Check the header files have been included from frame.h if they
 * are used outside of the framework library.
 */
// WIN32
/* Compilers that have support for C99 have all of the above defined in stdint.h */
// _MSC_VER
/* Basic numeric types */
pub type UBYTE = libc::c_uchar;
pub type STRING = libc::c_char;
pub type UWORD = libc::c_ushort;
pub type SWORD = libc::c_short;
pub type UDWORD = libc::c_uint;
pub type SDWORD = libc::c_int;
pub type BOOL = libc::c_int;
/* Check the header files have been included from frame.h if they
 * are used outside of the framework library.
 */
/* ***************************************************************************************
 *
 * Basic debugging macro's
 *
 */
/*
 *
 * ASSERT
 *
 * Rewritten version of assert that allows a printf format text string to be passed
 * to ASSERT along with the condition.
 *
 * Arguments:	ASSERT( condition, "Format string with variables: %d, %d", var1, var2 );
 */
/* ***************************************************************************************
 *
 * Conditional debugging macro's that can be selectively turned on or off on a file
 * by file basis.
 *
 * Modified to not output nothing under no conditions
 *
 */
/* **
 ***
 ***  New debug logging output interface below. Heavily inspired
 ***  by similar code in Freeciv. Parts ripped directly.
 ***
 ***/
/* Want to use GCC's __attribute__ keyword to check variadic
 * parameters to printf-like functions, without upsetting other
 * compilers: put any required defines magic here.
 * If other compilers have something equivalent, could also
 * work that out here.   Should this use configure stuff somehow?
 * --dwp
 */
/* Must match code_part_names in debug.c */
pub type code_part = libc::c_uint;
pub const LOG_LAST: code_part = 12;
/* _must_ be last! */
/* if too verbose for anything but dedicated debugging... */
pub const LOG_SCRIPT: code_part = 11;
/* special; on by default */
pub const LOG_NEVER: code_part = 10;
pub const LOG_ERROR: code_part = 9;
pub const LOG_MEMORY: code_part = 8;
pub const LOG_NET: code_part = 7;
pub const LOG_TEXTURE: code_part = 6;
pub const LOG_3D: code_part = 5;
pub const LOG_WZ: code_part = 4;
pub const LOG_VIDEO: code_part = 3;
pub const LOG_SOUND: code_part = 2;
/* special: sets all to on */
pub const LOG_MAIN: code_part = 1;
pub const LOG_ALL: code_part = 0;
pub type _interp_type = libc::c_uint;
pub const VAL_USERTYPESTART: _interp_type = 6;
pub const VAL_VOID: _interp_type = 5;
pub const VAL_EVENT: _interp_type = 4;
pub const VAL_TRIGGER: _interp_type = 3;
pub const VAL_STRING: _interp_type = 2;
pub const VAL_INT: _interp_type = 1;
pub const VAL_BOOL: _interp_type = 0;
/*
 * Interp.h
 *
 * Script interpreter definitions
 */
/* The possible value types for scripts */
pub type INTERP_TYPE = _interp_type;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _interp_val {
    pub type_0: INTERP_TYPE,
    pub v: C2RustUnnamed,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed {
    pub bval: BOOL,
    pub ival: SDWORD,
    pub sval: *mut STRING,
    pub oval: *mut libc::c_void,
    pub pVoid: *mut libc::c_void,
}
// Basic types
//	VAL_FLOAT,
// events and triggers
/* Type used by the compiler for functions that do not return a value */
// user defined types should start with this id
/* A value consists of its type and value */
pub type INTERP_VAL = _interp_val;
pub type _op_code = libc::c_uint;
pub const OP_PUSHLOCALREF: _op_code = 34;
pub const OP_PUSHLOCAL: _op_code = 33;
pub const OP_POPLOCAL: _op_code = 32;
pub const OP_FUNC: _op_code = 31;
pub const OP_LESS: _op_code = 30;
pub const OP_GREATER: _op_code = 29;
pub const OP_LESSEQUAL: _op_code = 28;
pub const OP_GREATEREQUAL: _op_code = 27;
pub const OP_NOTEQUAL: _op_code = 26;
pub const OP_EQUAL: _op_code = 25;
pub const OP_CANC: _op_code = 24;
pub const OP_NOT: _op_code = 23;
pub const OP_OR: _op_code = 22;
pub const OP_AND: _op_code = 21;
pub const OP_NEG: _op_code = 20;
pub const OP_DIV: _op_code = 19;
pub const OP_MUL: _op_code = 18;
pub const OP_SUB: _op_code = 17;
pub const OP_ADD: _op_code = 16;
pub const OP_PAUSE: _op_code = 15;
pub const OP_EXIT: _op_code = 14;
pub const OP_UNARYOP: _op_code = 13;
pub const OP_BINARYOP: _op_code = 12;
pub const OP_JUMPFALSE: _op_code = 11;
pub const OP_JUMPTRUE: _op_code = 10;
pub const OP_JUMP: _op_code = 9;
pub const OP_VARCALL: _op_code = 8;
pub const OP_CALL: _op_code = 7;
pub const OP_POPARRAYGLOBAL: _op_code = 6;
pub const OP_PUSHARRAYGLOBAL: _op_code = 5;
pub const OP_POPGLOBAL: _op_code = 4;
pub const OP_PUSHGLOBAL: _op_code = 3;
pub const OP_POP: _op_code = 2;
pub const OP_PUSHREF: _op_code = 1;
pub const OP_PUSH: _op_code = 0;
// VAL_BOOL
// VAL_INT
//		float		fval;		// VAL_FLOAT
// VAL_STRING
// VAL_OBJECT
// VAL_VOIDPTR
/* Opcodes for the script interpreter */
pub type OPCODE = _op_code;
// Push value onto stack
// Push a pointer to a variable onto the stack
// Pop value from stack
// Push the value of a global variable onto the stack
// Pop a value from the stack into a global variable
// Push the value of a global array variable onto the stack
// Pop a value from the stack into a global array variable
// Call the 'C' function pointed to by the next value
// Call the variable access 'C' function pointed to by the next value
// Jump to a different location in the script
// Jump if the top stack value is true
// Jump if the top stack value is false
// Call a binary maths/boolean operator
// Call a unary maths/boolean operator
// End the program
// temporarily pause the current event
// The following operations are secondary data to OP_BINARYOP and OP_UNARYOP
// Maths operators
// Boolean operators
//String cancatenation
// Comparison operators
//custom (in-script) function call
//local var
//variable of object type (pointer)
/* The mask for the number of array elements stored in the data part of an opcode */
/* The type of function called by an OP_CALL */
pub type SCRIPT_FUNC = Option<unsafe extern "C" fn() -> BOOL>;
/* The type of function called to access an object or in-game variable */
pub type SCRIPT_VARFUNC = Option<unsafe extern "C" fn(_: UDWORD) -> BOOL>;
pub type _storage_type = libc::c_uint;
pub const ST_LOCAL: _storage_type = 4;
pub const ST_EXTERN: _storage_type = 3;
pub const ST_OBJECT: _storage_type = 2;
pub const ST_PRIVATE: _storage_type = 1;
pub const ST_PUBLIC: _storage_type = 0;
pub type STORAGE_TYPE = UBYTE;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _var_debug {
    pub pIdent: *mut STRING,
    pub storage: STORAGE_TYPE,
}
/* Variable debugging info for a script */
pub type VAR_DEBUG = _var_debug;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _array_data {
    pub base: UDWORD,
    pub type_0: UBYTE,
    pub dimensions: UBYTE,
    pub elements: [UBYTE; 4],
}
/* Array info for a script */
pub type ARRAY_DATA = _array_data;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _array_debug {
    pub pIdent: *mut STRING,
    pub storage: UBYTE,
}
// the base index of the array values
// the array data type
/* Array debug info for a script */
pub type ARRAY_DEBUG = _array_debug;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _script_debug {
    pub offset: UDWORD,
    pub line: UDWORD,
    pub pLabel: *mut STRING,
}
/* Line debugging information for a script */
pub type SCRIPT_DEBUG = _script_debug;
pub type _trigger_type = libc::c_uint;
pub const TR_CALLBACKSTART: _trigger_type = 5;
pub const TR_PAUSE: _trigger_type = 4;
pub const TR_EVERY: _trigger_type = 3;
pub const TR_WAIT: _trigger_type = 2;
pub const TR_CODE: _trigger_type = 1;
pub const TR_INIT: _trigger_type = 0;
// Offset in the compiled script that corresponds to
// this line in the original script.
// the trigger/event that starts at this line
/* Different types of triggers */
pub type TRIGGER_TYPE = _trigger_type;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _trigger_data {
    pub type_0: UWORD,
    pub code: UWORD,
    pub time: UDWORD,
}
// Trigger fires when the script is first run
// Trigger uses script code
// Trigger after a time pause
// Trigger at repeated intervals
// Event has paused for an interval and will restart in the middle of it's code
// The user defined callback triggers should start with this id
/* Description of a trigger for the SCRIPT_CODE */
pub type TRIGGER_DATA = _trigger_data;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _script_code {
    pub size: UDWORD,
    pub pCode: *mut UDWORD,
    pub numTriggers: UWORD,
    pub numEvents: UWORD,
    pub pTriggerTab: *mut UWORD,
    pub psTriggerData: *mut TRIGGER_DATA,
    pub pEventTab: *mut UWORD,
    pub pEventLinks: *mut SWORD,
    pub numGlobals: UWORD,
    pub numArrays: UWORD,
    pub arraySize: UDWORD,
    pub pGlobals: *mut INTERP_TYPE,
    pub ppsLocalVars: *mut *mut INTERP_TYPE,
    pub numLocalVars: *mut UDWORD,
    pub ppsLocalVarVal: *mut *mut INTERP_VAL,
    pub numParams: *mut UDWORD,
    pub psVarDebug: *mut VAR_DEBUG,
    pub psArrayInfo: *mut ARRAY_DATA,
    pub psArrayDebug: *mut ARRAY_DEBUG,
    pub debugEntries: UWORD,
    pub psDebug: *mut SCRIPT_DEBUG,
}
// Type of trigger
// BOOL - is there code with this trigger
// How often to check the trigger
/* A compiled script and its associated data */
pub type SCRIPT_CODE = _script_code;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _code_block {
    pub size: UDWORD,
    pub pCode: *mut UDWORD,
    pub debugEntries: UDWORD,
    pub psDebug: *mut SCRIPT_DEBUG,
    pub type_0: INTERP_TYPE,
}
// The size (in bytes) of the compiled code
// Pointer to the compiled code
// The number of triggers
// The number of events
// The table of trigger offsets
// The extra info for each trigger
// The table of event offsets
// The original trigger/event linkage
// -1 for no link
// The number of global variables
// the number of arrays in the program
// the number of elements in all the defined arrays
// Types of the global variables
//storage for local vars (type)
//number of local vars each event has
//Values of the local vars used during interpreting process
//number of arguments this event has
// The names and storage types of variables
// The sizes of the program arrays
// Debug info for the arrays
// Number of entries in psDebug
// Debugging info for the script
/*
 * Parse.h
 *
 * Definitions for the script parser
 */
/* Maximum number of TEXT items in any one Yacc rule */
/* Definition for the chunks of code that are used within the compiler */
pub type CODE_BLOCK = _code_block;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _param_block {
    pub numParams: UDWORD,
    pub aParams: *mut INTERP_TYPE,
    pub size: UDWORD,
    pub pCode: *mut UDWORD,
}
// size of the code block
// pointer to the code data
// Debugging info for the script.
// The type of the code block
/* The chunk of code returned from parsing a parameter list. */
pub type PARAM_BLOCK = _param_block;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _param_decl {
    pub numParams: UDWORD,
    pub aParams: *mut INTERP_TYPE,
}
// List of parameter types
// The code that puts the parameters onto the stack
/* The types of a functions parameters, returned from parsing a parameter declaration */
pub type PARAM_DECL = _param_decl;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _cond_block {
    pub numOffsets: UDWORD,
    pub aOffsets: *mut UDWORD,
    pub size: UDWORD,
    pub pCode: *mut UDWORD,
    pub debugEntries: UDWORD,
    pub psDebug: *mut SCRIPT_DEBUG,
}
/* The chunk of code used while parsing a conditional statement */
pub type COND_BLOCK = _cond_block;
pub type _access_type = libc::c_uint;
pub const AT_OBJECT: _access_type = 1;
pub const AT_SIMPLE: _access_type = 0;
// Positions in the code that have to be
// replaced with the offset to the end of the
							// conditional statment (for the jumps).
// Number of debugging entries in psDebug.
// Debugging info for the script.
// function pointer for script variable saving
// if pBuffer is NULL the script system is just asking how much space the saved variable will require
// otherwise pBuffer points to an array to store the value in
pub type SCR_VAL_SAVE
    =
    Option<unsafe extern "C" fn(_: INTERP_TYPE, _: UDWORD,
                                _: *mut libc::c_char, _: *mut UDWORD)
               -> BOOL>;
// function pointer for script variable loading
pub type SCR_VAL_LOAD
    =
    Option<unsafe extern "C" fn(_: SDWORD, _: INTERP_TYPE,
                                _: *mut libc::c_char, _: UDWORD,
                                _: *mut UDWORD) -> BOOL>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _type_symbol {
    pub typeID: SWORD,
    pub accessType: SWORD,
    pub pIdent: *mut STRING,
    pub saveFunc: SCR_VAL_SAVE,
    pub loadFunc: SCR_VAL_LOAD,
}
/* Type for a user type symbol */
pub type TYPE_SYMBOL = _type_symbol;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _var_ident_decl {
    pub pIdent: *mut STRING,
    pub dimensions: SDWORD,
    pub elements: [SDWORD; 4],
}
// The type id to use in the type field of values
// Whether the type is an object or a simple value
// Type identifier
// load and save functions
// 
/* Type for a variable identifier declaration */
pub type VAR_IDENT_DECL = _var_ident_decl;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _var_symbol {
    pub pIdent: *mut STRING,
    pub type_0: INTERP_TYPE,
    pub storage: STORAGE_TYPE,
    pub objType: INTERP_TYPE,
    pub index: UDWORD,
    pub get: SCRIPT_VARFUNC,
    pub set: SCRIPT_VARFUNC,
    pub dimensions: SDWORD,
    pub elements: [SDWORD; 4],
    pub psNext: *mut _var_symbol,
}
// variable identifier
// number of dimensions of an array - 0 for normal var
// number of elements in an array 
/* Type for a variable symbol */
pub type VAR_SYMBOL = _var_symbol;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _array_block {
    pub psArrayVar: *mut VAR_SYMBOL,
    pub dimensions: SDWORD,
    pub size: UDWORD,
    pub pCode: *mut UDWORD,
    pub debugEntries: UDWORD,
    pub psDebug: *mut SCRIPT_DEBUG,
}
// variable's identifier
// variable type
// Where the variable is stored
// The object type if this is an object variable
// Index of the variable in its data space
// Access functions if the variable is stored in an object/in-game
// number of dimensions of an array - 0 for normal var
// number of elements in an array 
/* Type for an array access block */
pub type ARRAY_BLOCK = _array_block;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _const_symbol {
    pub pIdent: *mut STRING,
    pub type_0: INTERP_TYPE,
    pub bval: BOOL,
    pub ival: SDWORD,
    pub oval: *mut libc::c_void,
    pub sval: *mut STRING,
}
// Number of debugging entries in psDebug.
// Debugging info for the script.
/* Type for a constant symbol */
pub type CONST_SYMBOL = _const_symbol;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _objvar_block {
    pub psObjVar: *mut VAR_SYMBOL,
    pub size: UDWORD,
    pub pCode: *mut UDWORD,
}
// variable's identifier
// variable type
/* The actual value of the constant. 
	 * Only one of these will be valid depending on type.
	 * A union is not used as a union cannot be statically initialised
	 */
//String values
//	float			fval;
/* The chunk of code used to reference an object variable */
pub type OBJVAR_BLOCK = _objvar_block;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _func_symbol {
    pub pIdent: *mut STRING,
    pub pFunc: SCRIPT_FUNC,
    pub type_0: INTERP_TYPE,
    pub numParams: UDWORD,
    pub aParams: [INTERP_TYPE; 20],
    pub script: BOOL,
    pub size: UDWORD,
    pub pCode: *mut UDWORD,
    pub location: UDWORD,
    pub debugEntries: UDWORD,
    pub psDebug: *mut SCRIPT_DEBUG,
    pub psNext: *mut _func_symbol,
}
// The object variables symbol
// The code to get the object value on the stack
/* The maximum number of parameters for an instinct function */
/* Type for a function symbol */
pub type FUNC_SYMBOL = _func_symbol;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _var_decl {
    pub type_0: INTERP_TYPE,
    pub storage: STORAGE_TYPE,
}
// function's identifier
// Pointer to the instinct function
// function type
// Number of parameters to the function
// List of parameter types
// Whether the function is defined in the script
// or a C instinct function
// The size of script code
// The code for a function if it is defined in the script
// The position of the function in the final code block
// Number of debugging entries in psDebug.
// Debugging info for the script.
/* The type for a variable declaration */
pub type VAR_DECL = _var_decl;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _trigger_decl {
    pub type_0: TRIGGER_TYPE,
    pub size: UDWORD,
    pub pCode: *mut UDWORD,
    pub time: UDWORD,
}
/* The type for a trigger sub declaration */
pub type TRIGGER_DECL = _trigger_decl;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _trigger_symbol {
    pub pIdent: *mut STRING,
    pub index: UDWORD,
    pub type_0: TRIGGER_TYPE,
    pub size: UDWORD,
    pub pCode: *mut UDWORD,
    pub time: UDWORD,
    pub debugEntries: UDWORD,
    pub psDebug: *mut SCRIPT_DEBUG,
    pub psNext: *mut _trigger_symbol,
}
/* Type for a trigger symbol */
pub type TRIGGER_SYMBOL = _trigger_symbol;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _callback_symbol {
    pub pIdent: *mut STRING,
    pub type_0: TRIGGER_TYPE,
    pub pFunc: SCRIPT_FUNC,
    pub numParams: UDWORD,
    pub aParams: [INTERP_TYPE; 20],
}
// Trigger's identifier
// The triggers index number
// Trigger type
// Code size for the trigger
// The trigger code
// How often to check the trigger
/* The type for a callback trigger symbol */
pub type CALLBACK_SYMBOL = _callback_symbol;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _event_symbol {
    pub pIdent: *mut STRING,
    pub index: UDWORD,
    pub size: UDWORD,
    pub pCode: *mut UDWORD,
    pub trigger: SDWORD,
    pub debugEntries: UDWORD,
    pub psDebug: *mut SCRIPT_DEBUG,
    pub numParams: UDWORD,
    pub numLocalVars: UDWORD,
    pub bFunction: BOOL,
    pub bDeclared: BOOL,
    pub retType: INTERP_TYPE,
    pub aParams: [INTERP_TYPE; 20],
    pub psNext: *mut _event_symbol,
}
// Callback identifier
// user defined callback id >= TR_CALLBACKSTART
// Pointer to the instinct function
// Number of parameters to the function
// List of parameter types
/* Type for an event symbol */
pub type EVENT_SYMBOL = _event_symbol;
// Event's identifier
// the events index number
// Code size for the event
// Event code
// Index of the event's trigger
//functions stuff
//Number of parameters to the function
//local variables
//if this event is defined as a function
//if function was declared before
//return type if a function
/* Stored state numbers (used for stacks). */
pub type yy_state_t = yytype_int16;
pub type yytype_int16 = libc::c_short;
/* Tokens.  */
// Calculate the code size
// Add the trigger code size
// Add the trigger code size
// Allocate the program
//store local vars
					//allocate array for holding an array of local vars for each event
//how many local vars each event has
//how many arguments each event has
//remember how many local vars this event has
//remember how many parameters this event has
//debug(LOG_SCRIPT, "remembering loc var ");
								//debug(LOG_SCRIPT, "%d - %d \n",i,j);
//save type, order is reversed
/* Value type.  */
//this event has no local vars
#[derive(Copy, Clone)]
#[repr(C)]
pub union YYSTYPE {
    pub bval: BOOL,
    pub ival: SDWORD,
    pub sval: *mut STRING,
    pub tval: INTERP_TYPE,
    pub stype: STORAGE_TYPE,
    pub vSymbol: *mut VAR_SYMBOL,
    pub cSymbol: *mut CONST_SYMBOL,
    pub fSymbol: *mut FUNC_SYMBOL,
    pub tSymbol: *mut TRIGGER_SYMBOL,
    pub eSymbol: *mut EVENT_SYMBOL,
    pub cbSymbol: *mut CALLBACK_SYMBOL,
    pub cblock: *mut CODE_BLOCK,
    pub condBlock: *mut COND_BLOCK,
    pub objVarBlock: *mut OBJVAR_BLOCK,
    pub arrayBlock: *mut ARRAY_BLOCK,
    pub pblock: *mut PARAM_BLOCK,
    pub pdecl: *mut PARAM_DECL,
    pub tdecl: *mut TRIGGER_DECL,
    pub integer_val: UDWORD,
    pub vdecl: *mut VAR_DECL,
    pub videcl: *mut VAR_IDENT_DECL,
}
pub type yytype_uint8 = libc::c_uchar;
/* !YY_SCR_Y_TAB_H_INCLUDED  */
// Check the event was declared and has a code body
/* On compilers that do not define __PTRDIFF_MAX__ etc., make sure
   <limits.h> and (if available) <stdint.h> are included
   so that the code can choose integer types of a good width.  */
// Store the event offset
// Store the trigger link
// Store the label
// Store debug info
// Store the code
/* Narrow types that promote to a signed type and that can represent a
   signed or unsigned integer of at least N bits.  In tables they can
   save space and decrease cache pressure.  Promoting to a signed type
   helps avoid bugs in integer arithmetic.  */
// Note the end of the final event
pub type yytype_int8 = libc::c_schar;
// Allocate debug info for the variables if necessary
/* State numbers in computations.  */
pub type yy_state_fast_t = libc::c_int;
pub const CE_PARSE: _code_error = 2;
/* Error return codes for code generation functions */
pub type CODE_ERROR = _code_error;
pub type _code_error = libc::c_uint;
pub const CE_MEMORY: _code_error = 1;
pub const CE_OK: _code_error = 0;
/* As a special exception, you may create a larger work that contains
   part or all of the Bison parser skeleton and distribute that work
   under terms of your choice, so long as that work isn't itself a
   parser generator using the skeleton or a modified version thereof
   as a parser skeleton.  Alternatively, if you modify or redistribute
   the parser skeleton itself, you may (at your option) remove this
   special exception, which will cause the skeleton and the resulting
   Bison output files to be licensed under the GNU General Public
   License without this special exception.

   This special exception was added by the Free Software Foundation in
   version 2.2 of Bison.  */
// No error
// Out of memory
// A parse error occured
/* ! defined yyoverflow || YYERROR_VERBOSE */
/* A type that is properly aligned for any stack member.  */
#[derive(Copy, Clone)]
#[repr(C)]
pub union yyalloc {
    pub yyss_alloc: yy_state_t,
    pub yyvs_alloc: YYSTYPE,
}
pub type _scr_debugtype = libc::c_uint;
pub const SCR_NODEBUG: _scr_debugtype = 1;
pub const SCR_DEBUGINFO: _scr_debugtype = 0;
/*
 * Script.h
 *
 * Interface to the script library
 */
/* Whether to include debug info when compiling */
pub type SCR_DEBUGTYPE = _scr_debugtype;
// Generate debug info
// Do not generate debug info
/* Turn off a couple of warnings that the yacc generated code gives */
/* Pointer to the compiled code */
static mut psFinalProg: *mut SCRIPT_CODE =
    0 as *const SCRIPT_CODE as *mut SCRIPT_CODE;
/* Pointer to current block of compiled code */
static mut psCurrBlock: *mut CODE_BLOCK =
    0 as *const CODE_BLOCK as *mut CODE_BLOCK;
/* C LALR(1) parser skeleton written by Richard Stallman, by
   simplifying the original so-called "semantic" parser.  */
/* Pointer to current block of conditional code */
static mut psCondBlock: *mut COND_BLOCK =
    0 as *const COND_BLOCK as *mut COND_BLOCK;
/* All symbols defined below should begin with yy or YY, to avoid
   infringing on user name space.  This should be done even for local
   variables, as they might otherwise be expanded by user macros.
   There are some unavoidable exceptions within include files to
   define necessary library symbols; they are noted "INFRINGES ON
   USER NAME SPACE" below.  */
/* Pointer to current block of object variable code */
static mut psObjVarBlock: *mut OBJVAR_BLOCK =
    0 as *const OBJVAR_BLOCK as *mut OBJVAR_BLOCK;
/* Pointer to current block of compiled parameter code */
static mut psCurrPBlock: *mut PARAM_BLOCK =
    0 as *const PARAM_BLOCK as *mut PARAM_BLOCK;
//String support
//-----------------------------
/* Undocumented macros, especially those whose name start with YY_,
   are private implementation details.  Do not rely on them.  */
#[no_mangle]
pub static mut msg: [libc::c_char; 255] = [0; 255];
//Current string index
/* Bison version.  */
/* Pointer into the current code block */
static mut ip: *mut UDWORD = 0 as *const UDWORD as *mut UDWORD;
/* Skeleton name.  */
/* Pointer to current parameter declaration block */
//static PARAM_DECL	*psCurrParamDecl=NULL;
/* Pure parsers.  */
/* Pointer to current trigger subdeclaration */
static mut psCurrTDecl: *mut TRIGGER_DECL =
    0 as *const TRIGGER_DECL as *mut TRIGGER_DECL;
/* Push parsers.  */
/* Pointer to current variable subdeclaration */
static mut psCurrVDecl: *mut VAR_DECL = 0 as *const VAR_DECL as *mut VAR_DECL;
/* Pull parsers.  */
/* Pointer to the current variable identifier declaration */
static mut psCurrVIdentDecl: *mut VAR_IDENT_DECL =
    0 as *const VAR_IDENT_DECL as *mut VAR_IDENT_DECL;
/* Pointer to the current array access block */
/* Substitute the variable and function names.  */
static mut psCurrArrayBlock: *mut ARRAY_BLOCK =
    0 as *const ARRAY_BLOCK as *mut ARRAY_BLOCK;
static mut codeRet: CODE_ERROR = CE_OK;
static mut psGlobalVars: *mut VAR_SYMBOL =
    0 as *const VAR_SYMBOL as *mut VAR_SYMBOL;
/* The list of global arrays */
/* First part of user prologue.  */
static mut psGlobalArrays: *mut VAR_SYMBOL =
    0 as *const VAR_SYMBOL as *mut VAR_SYMBOL;
/* The list of current local variables */
static mut psLocalVars: *mut VAR_SYMBOL =
    0 as *const VAR_SYMBOL as *mut VAR_SYMBOL;
static mut psLocalVarsB: [*mut VAR_SYMBOL; 1200] =
    [0 as *const VAR_SYMBOL as *mut VAR_SYMBOL; 1200];
/* local var storage */
static mut numEventLocalVars: [UDWORD; 1200] = [0; 1200];
/* number of declard local vars for each event */
static mut psLocalVarsTemp: *mut VAR_SYMBOL =
    0 as *const VAR_SYMBOL as *mut VAR_SYMBOL;
/* temporary storage for local vars, before current event declaration is found */
#[no_mangle]
pub static mut psCurEvent: *mut EVENT_SYMBOL =
    0 as *const EVENT_SYMBOL as *mut EVENT_SYMBOL;
/* stores current event: for local var declaration */
/* The list of function definitions */
static mut psFunctions: *mut FUNC_SYMBOL =
    0 as *const FUNC_SYMBOL as *mut FUNC_SYMBOL;
/* The current object variable context */
static mut objVarContext: INTERP_TYPE = VAL_BOOL;
/* Control whether debug info is generated */
static mut genDebugInfo: BOOL = 1 as libc::c_int;
/* Currently defined triggers */
static mut psTriggers: *mut TRIGGER_SYMBOL =
    0 as *const TRIGGER_SYMBOL as *mut TRIGGER_SYMBOL;
static mut numTriggers: UDWORD = 0;
/* Currently defined events */
static mut psEvents: *mut EVENT_SYMBOL =
    0 as *const EVENT_SYMBOL as *mut EVENT_SYMBOL;
static mut numEvents: UDWORD = 0;
/* This is true when local variables are being defined.
 * (So local variables can have the same name as global ones)
 */
static mut localVariableDef: BOOL = 0 as libc::c_int;
/* The identifier for the current script function being defined */
//static STRING *pCurrFuncIdent=NULL;
/* A temporary store for a line number - used when
 * generating debugging info for functions, conditionals and loops.
 */
static mut debugLine: UDWORD = 0;
/* The table of user types */
#[no_mangle]
pub static mut asScrTypeTab: *mut TYPE_SYMBOL =
    0 as *const TYPE_SYMBOL as *mut TYPE_SYMBOL;
/* The table of instinct function type definitions */
#[no_mangle]
pub static mut asScrInstinctTab: *mut FUNC_SYMBOL =
    0 as *const FUNC_SYMBOL as *mut FUNC_SYMBOL;
/* The table of external variables and their access functions */
#[no_mangle]
pub static mut asScrExternalTab: *mut VAR_SYMBOL =
    0 as *const VAR_SYMBOL as *mut VAR_SYMBOL;
/* The table of object variables and their access functions. */
#[no_mangle]
pub static mut asScrObjectVarTab: *mut VAR_SYMBOL =
    0 as *const VAR_SYMBOL as *mut VAR_SYMBOL;
/* The table of constant variables */
#[no_mangle]
pub static mut asScrConstantTab: *mut CONST_SYMBOL =
    0 as *const CONST_SYMBOL as *mut CONST_SYMBOL;
/* The table of callback triggers */
#[no_mangle]
pub static mut asScrCallbackTab: *mut CALLBACK_SYMBOL =
    0 as *const CALLBACK_SYMBOL as *mut CALLBACK_SYMBOL;
/* ***************************************************************************************
 *
 * Code Block Macros
 *
 * These macros are used to allocate and free the different types of code
 * block used within the compiler
 */
/* What the macro should do if it has an allocation error.
 * This is different depending on whether the macro is used
 * in a function, or in a rule body.
 *
 * This definition is used within the code generation functions
 * and is then changed for use within a rule body.
 */
/* Macro to allocate a program structure */
/* Macro to allocate a code block */
/* Macro to free a code block */
/* Macro to allocate a parameter block */
/* Macro to free a parameter block */
/* Macro to allocate a parameter declaration block */
/* Macro to free a parameter declaration block */
/* Macro to allocate a conditional block */
/* Macro to free a conditional block */
/* Macro to allocate a code block */
/* Macro to free a code block */
/* Macro to allocate an object variable block */
/* Macro to free an object variable block */
/* Macro to allocate an array variable block */
/* Macro to free an object variable block */
/* Allocate a trigger subdecl */
/* Free a trigger subdecl */
/* Allocate a variable declaration block */
/* Free a variable declaration block */
/* Allocate a variable declaration block */
/* Free a variable declaration block */
/* ***************************************************************************************
 *
 * Code block manipulation macros.
 *
 * These are used to copy chunks of code from one block to another
 * or to insert opcodes or other values into a code block.
 * All the macros use the ip parameter.  This is a pointer into the code
 * block that is incremented by the macro. This ensures that it always points
 * to the next free space in the code block.
 */
/* Macro to store an opcode in a code block */
/* Macro to put a packed opcode in a code block */
/* Macro to store the data part of an INTERP_VAL in a code block */
/* Macros to store a value in a code block */
/*#define PUT_FLOAT(ip, value) \
	((INTERP_VAL *)(ip))->type = VAL_FLOAT; \
	((INTERP_VAL *)(ip))->v.fval = (value); \
	((INTERP_VAL *)(ip)) += 1*/
/*#define PUT_OBJECT(ip, value) \
	((INTERP_VAL *)(ip))->type = VAL_OBJECT; \
	((INTERP_VAL *)(ip))->v.oval = (value); \
	((INTERP_VAL *)(ip)) += 1*/
/* Macro to store a function pointer in a code block */
/* Macro to store a function pointer in a code block */
/* Macro to store a reference to a script function. */
/* This will be converted to a program location at the link stage */
/* Macro to store a variable index number in a code block */
/* Macro to store a jump offset in a code block */
/* Macro to copy a code block into another code block */
/* **********************************************************************************
 *
 * Debugging information macros
 *
 * These macros are only used to generate debugging information for scripts.
 */
/* Macro to allocate debugging info for a CODE_BLOCK or a COND_BLOCK */
/* Macro to free debugging info */
/* Macro to copy the debugging information from one block to another */
/* Macro to combine the debugging information in two blocks into a third block */
static mut _dbEntry: UDWORD = 0;
static mut _psCurr: *mut SCRIPT_DEBUG =
    0 as *const SCRIPT_DEBUG as *mut SCRIPT_DEBUG;
/* Macro to append some debugging information onto a block, given the instruction
   offset of the debugging information already in the destination block */
/* Macro to store a label in the debug info */
/* **************************************************************************************
 *
 * Code generation functions
 *
 * These functions are used within rule bodies to generate code.
 */
/* Macro to deal with the errors returned by code generation functions.
 * Used within the rule body.
 */
/* Generate the code for a function call, checking the parameter
 * types match.
 */
#[no_mangle]
pub unsafe extern "C" fn scriptCodeFunction(mut psFSymbol: *mut FUNC_SYMBOL,
                                            mut psPBlock: *mut PARAM_BLOCK,
                                            mut expContext: BOOL,
                                            mut ppsCBlock:
                                                *mut *mut CODE_BLOCK)
 -> CODE_ERROR 
 // The generated code block
 {
    let mut size: UDWORD = 0;
    let mut i: UDWORD = 0;
    let mut ip_0: *mut UDWORD = 0 as *mut UDWORD;
    let mut typeError: BOOL = 0 as libc::c_int;
    let mut aErrorString: [STRING; 255] = [0; 255];
    if !psFSymbol.is_null() {
    } else {
        debug(LOG_ERROR,
              b"ais_CodeFunction: Invalid function symbol pointer\x00" as
                  *const u8 as *const libc::c_char);
    };
    if !psFSymbol.is_null() {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              682 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 19],
                                        &[libc::c_char; 19]>(b"scriptCodeFunction\x00")).as_ptr(),
              b"psFSymbol != NULL\x00" as *const u8 as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeFunction: Invalid param block pointer\x00" as
                  *const u8 as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              684 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 19],
                                        &[libc::c_char; 19]>(b"scriptCodeFunction\x00")).as_ptr(),
              b"PTRVALID(psPBlock, sizeof(PARAM_BLOCK))\x00" as *const u8 as
                  *const libc::c_char);
    };
    if (*psPBlock).size == 0 as libc::c_int as libc::c_uint ||
           1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeFunction: Invalid parameter code pointer\x00" as
                  *const u8 as *const libc::c_char);
    };
    if (*psPBlock).size == 0 as libc::c_int as libc::c_uint ||
           1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              686 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 19],
                                        &[libc::c_char; 19]>(b"scriptCodeFunction\x00")).as_ptr(),
              b"(psPBlock->size == 0) || PTRVALID(psPBlock->pCode, psPBlock->size)\x00"
                  as *const u8 as *const libc::c_char);
    };
    if !ppsCBlock.is_null() {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeFunction: Invalid generated code block pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if !ppsCBlock.is_null() {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              688 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 19],
                                        &[libc::c_char; 19]>(b"scriptCodeFunction\x00")).as_ptr(),
              b"ppsCBlock != NULL\x00" as *const u8 as *const libc::c_char);
    };
    /* Check the parameter types match what the function needs */
    i = 0 as libc::c_int as UDWORD;
    while i < (*psFSymbol).numParams && i < (*psPBlock).numParams {
        /*		if (psFSymbol->aParams[i] != VAL_VOID &&
			psFSymbol->aParams[i] != psPBlock->aParams[i])*/
		//TODO: string support
        if (*psFSymbol).aParams[i as usize] as libc::c_uint !=
               VAL_STRING as libc::c_int as libc::c_uint {
            // string - allow mixed types if string is parameter type
            if interpCheckEquiv((*psFSymbol).aParams[i as usize],
                                *(*psPBlock).aParams.offset(i as isize)) == 0
               {
                debug(LOG_ERROR,
                      b"scriptCodeFunction: Type mismatch for paramter %d\x00"
                          as *const u8 as *const libc::c_char, i);
                sprintf(aErrorString.as_mut_ptr(),
                        b"Type mismatch for paramter %d\x00" as *const u8 as
                            *const libc::c_char, i);
                scr_error(aErrorString.as_mut_ptr());
                typeError = 1 as libc::c_int
            }
        }
        i = i.wrapping_add(1)
        //else
		//{
		//	debug(LOG_SCRIPT, "scriptCodeFunction: %s takes string as parameter %d (provided: %d)", psFSymbol->pIdent, i, psPBlock->aParams[i]);
		//}
    }
    /* Check the number of parameters matches that expected */
    if (*psFSymbol).numParams != (*psPBlock).numParams {
        sprintf(aErrorString.as_mut_ptr(),
                b"Expected %d parameters\x00" as *const u8 as
                    *const libc::c_char, (*psFSymbol).numParams);
        scr_error(aErrorString.as_mut_ptr());
        *ppsCBlock = 0 as *mut CODE_BLOCK;
        return CE_PARSE
    }
    if typeError != 0 {
        /* Report the error here so all the */
		/* type mismatches are reported */
        *ppsCBlock = 0 as *mut CODE_BLOCK;
        return CE_PARSE
    }
    size =
        (*psPBlock).size.wrapping_add(::std::mem::size_of::<OPCODE>() as
                                          libc::c_ulong).wrapping_add(::std::mem::size_of::<SCRIPT_FUNC>()
                                                                          as
                                                                          libc::c_ulong);
    if expContext == 0 &&
           (*psFSymbol).type_0 as libc::c_uint !=
               VAL_VOID as libc::c_int as libc::c_uint {
        size =
            (size as
                 libc::c_uint).wrapping_add(::std::mem::size_of::<OPCODE>() as
                                                libc::c_ulong) as UDWORD as
                UDWORD
    }
    *ppsCBlock =
        memMallocRelease(::std::mem::size_of::<CODE_BLOCK>() as libc::c_ulong)
            as *mut CODE_BLOCK;
    if (*ppsCBlock).is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        return CE_MEMORY
    }
    (**ppsCBlock).pCode = memMallocRelease(size) as *mut UDWORD;
    if (**ppsCBlock).pCode.is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        memFreeRelease(*ppsCBlock as *mut libc::c_void);
        *ppsCBlock = 0 as *mut CODE_BLOCK;
        return CE_MEMORY
    }
    (**ppsCBlock).size = size;
    ip_0 = (**ppsCBlock).pCode;
    (**ppsCBlock).type_0 = (*psFSymbol).type_0;
    /* Copy in the code for the parameters */
    memcpy(ip_0 as *mut libc::c_void,
           (*psPBlock).pCode as *const libc::c_void, (*psPBlock).size);
    ip_0 =
        (ip_0 as *mut UBYTE).offset((*psPBlock).size as isize) as *mut UDWORD;
    memFreeRelease((*psPBlock).pCode as *mut libc::c_void);
    (*psPBlock).pCode = 0 as *mut UDWORD;
    memFreeRelease((*psPBlock).aParams as *mut libc::c_void);
    (*psPBlock).aParams = 0 as *mut INTERP_TYPE;
    memFreeRelease(psPBlock as *mut libc::c_void);
    psPBlock = 0 as *mut PARAM_BLOCK;
    /* Make the function call */
    if !((*psFSymbol).script != 0) {
        /* call an instinct function */
        *ip_0 = ((OP_CALL as libc::c_int) << 24 as libc::c_int) as UDWORD;
        ip_0 = ip_0.offset(1 as libc::c_int as isize);
        *ip_0 =
            ::std::mem::transmute::<SCRIPT_FUNC, UDWORD>((*psFSymbol).pFunc);
        ip_0 = ip_0.offset(1 as libc::c_int as isize)
    }
    if expContext == 0 &&
           (*psFSymbol).type_0 as libc::c_uint !=
               VAL_VOID as libc::c_int as libc::c_uint {
        /* Clear the return value from the stack */
        *ip_0 = ((OP_POP as libc::c_int) << 24 as libc::c_int) as UDWORD;
        ip_0 = ip_0.offset(1 as libc::c_int as isize)
    }
    return CE_OK;
}
/* Function call: Check the parameter types match, assumes param count matched */
#[no_mangle]
pub unsafe extern "C" fn checkFuncParamTypes(mut psFSymbol: *mut EVENT_SYMBOL,
                                             mut psPBlock: *mut PARAM_BLOCK)
 -> UDWORD 
 // The generated code block
 {
    let mut size: UDWORD = 0;
    let mut i: UDWORD = 0;
    let mut ip_0: *mut UDWORD = 0 as *mut UDWORD;
    let mut typeError: BOOL = 0 as libc::c_int;
    let mut aErrorString: [STRING; 255] = [0; 255];
    //debug(LOG_SCRIPT,"checkFuncParamTypes");
    /* Check the parameter types match what the function needs */
    i = 0 as libc::c_int as UDWORD;
    while i < (*psFSymbol).numParams && i < (*psPBlock).numParams {
        //TODO: string support
		//if(psFSymbol->aParams[i] != VAL_STRING)	// string - allow mixed types if string is parameter type
		//{
        if interpCheckEquiv((*psFSymbol).aParams[i as usize],
                            *(*psPBlock).aParams.offset(i as isize)) == 0 {
            debug(LOG_ERROR,
                  b"checkFuncParamTypes: Type mismatch for paramter %d (\'1\' based) in Function \'%s\' (provided type: %d, expected: %d)\x00"
                      as *const u8 as *const libc::c_char,
                  i.wrapping_add(1 as libc::c_int as libc::c_uint),
                  (*psFSymbol).pIdent,
                  *(*psPBlock).aParams.offset(i as isize) as libc::c_uint,
                  (*psFSymbol).aParams[i as usize] as libc::c_uint);
            return i.wrapping_add(1 as libc::c_int as libc::c_uint)
        }
        i = i.wrapping_add(1)
        //}
    }
    //debug(LOG_SCRIPT,"END checkFuncParamTypes");
    return 0 as libc::c_int as UDWORD;
    //all ok
}
/*
 *  function call
 */
#[no_mangle]
pub unsafe extern "C" fn scriptCodeCallFunction(mut psFSymbol:
                                                    *mut FUNC_SYMBOL,
                                                mut psPBlock:
                                                    *mut PARAM_BLOCK,
                                                mut ppsCBlock:
                                                    *mut *mut CODE_BLOCK)
 -> CODE_ERROR 
 // The generated code block
 {
    let mut size: UDWORD = 0;
    let mut i: UDWORD = 0;
    let mut ip_0: *mut UDWORD = 0 as *mut UDWORD;
    let mut typeError: BOOL = 0 as libc::c_int;
    let mut aErrorString: [STRING; 255] = [0; 255];
    //debug(LOG_SCRIPT, "scriptCodeCallFunction");
    if !psFSymbol.is_null() {
    } else {
        debug(LOG_ERROR,
              b"ais_CodeFunction: Invalid function symbol pointer\x00" as
                  *const u8 as *const libc::c_char);
    };
    if !psFSymbol.is_null() {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              809 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 23],
                                        &[libc::c_char; 23]>(b"scriptCodeCallFunction\x00")).as_ptr(),
              b"psFSymbol != NULL\x00" as *const u8 as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeFunction: Invalid param block pointer\x00" as
                  *const u8 as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              811 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 23],
                                        &[libc::c_char; 23]>(b"scriptCodeCallFunction\x00")).as_ptr(),
              b"PTRVALID(psPBlock, sizeof(PARAM_BLOCK))\x00" as *const u8 as
                  *const libc::c_char);
    };
    if (*psPBlock).size == 0 as libc::c_int as libc::c_uint ||
           1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeFunction: Invalid parameter code pointer\x00" as
                  *const u8 as *const libc::c_char);
    };
    if (*psPBlock).size == 0 as libc::c_int as libc::c_uint ||
           1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              813 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 23],
                                        &[libc::c_char; 23]>(b"scriptCodeCallFunction\x00")).as_ptr(),
              b"(psPBlock->size == 0) || PTRVALID(psPBlock->pCode, psPBlock->size)\x00"
                  as *const u8 as *const libc::c_char);
    };
    if !ppsCBlock.is_null() {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeFunction: Invalid generated code block pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if !ppsCBlock.is_null() {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              815 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 23],
                                        &[libc::c_char; 23]>(b"scriptCodeCallFunction\x00")).as_ptr(),
              b"ppsCBlock != NULL\x00" as *const u8 as *const libc::c_char);
    };
    size =
        (*psPBlock).size.wrapping_add(::std::mem::size_of::<OPCODE>() as
                                          libc::c_ulong).wrapping_add(::std::mem::size_of::<SCRIPT_FUNC>()
                                                                          as
                                                                          libc::c_ulong);
    *ppsCBlock =
        memMallocRelease(::std::mem::size_of::<CODE_BLOCK>() as libc::c_ulong)
            as *mut CODE_BLOCK;
    if (*ppsCBlock).is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        return CE_MEMORY
    }
    (**ppsCBlock).pCode = memMallocRelease(size) as *mut UDWORD;
    if (**ppsCBlock).pCode.is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        memFreeRelease(*ppsCBlock as *mut libc::c_void);
        *ppsCBlock = 0 as *mut CODE_BLOCK;
        return CE_MEMORY
    }
    (**ppsCBlock).size = size;
    ip_0 = (**ppsCBlock).pCode;
    (**ppsCBlock).type_0 = (*psFSymbol).type_0;
    /* Copy in the code for the parameters */
    memcpy(ip_0 as *mut libc::c_void,
           (*psPBlock).pCode as *const libc::c_void, (*psPBlock).size);
    ip_0 =
        (ip_0 as *mut UBYTE).offset((*psPBlock).size as isize) as *mut UDWORD;
    memFreeRelease((*psPBlock).pCode as *mut libc::c_void);
    (*psPBlock).pCode = 0 as *mut UDWORD;
    memFreeRelease((*psPBlock).aParams as *mut libc::c_void);
    (*psPBlock).aParams = 0 as *mut INTERP_TYPE;
    memFreeRelease(psPBlock as *mut libc::c_void);
    psPBlock = 0 as *mut PARAM_BLOCK;
    /* Make the function call */
    *ip_0 = ((OP_CALL as libc::c_int) << 24 as libc::c_int) as UDWORD;
    ip_0 = ip_0.offset(1 as libc::c_int as isize);
    *ip_0 = ::std::mem::transmute::<SCRIPT_FUNC, UDWORD>((*psFSymbol).pFunc);
    ip_0 = ip_0.offset(1 as libc::c_int as isize);
    //debug(LOG_SCRIPT, "END scriptCodeCallFunction");
    return CE_OK;
}
/* Generate the code for a parameter callback, checking the parameter
 * types match.
 */
#[no_mangle]
pub unsafe extern "C" fn scriptCodeCallbackParams(mut psCBSymbol:
                                                      *mut CALLBACK_SYMBOL,
                                                  mut psPBlock:
                                                      *mut PARAM_BLOCK,
                                                  mut ppsTDecl:
                                                      *mut *mut TRIGGER_DECL)
 -> CODE_ERROR 
 // The generated code block
 {
    let mut size: UDWORD = 0;
    let mut i: UDWORD = 0;
    let mut ip_0: *mut UDWORD = 0 as *mut UDWORD;
    let mut typeError: BOOL = 0 as libc::c_int;
    let mut aErrorString: [STRING; 255] = [0; 255];
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeCallbackParams: Invalid param block pointer\x00" as
                  *const u8 as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              851 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 25],
                                        &[libc::c_char; 25]>(b"scriptCodeCallbackParams\x00")).as_ptr(),
              b"PTRVALID(psPBlock, sizeof(PARAM_BLOCK))\x00" as *const u8 as
                  *const libc::c_char);
    };
    if (*psPBlock).size == 0 as libc::c_int as libc::c_uint ||
           1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeCallbackParams: Invalid parameter code pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if (*psPBlock).size == 0 as libc::c_int as libc::c_uint ||
           1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              853 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 25],
                                        &[libc::c_char; 25]>(b"scriptCodeCallbackParams\x00")).as_ptr(),
              b"(psPBlock->size == 0) || PTRVALID(psPBlock->pCode, psPBlock->size)\x00"
                  as *const u8 as *const libc::c_char);
    };
    if !ppsTDecl.is_null() {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeCallbackParams: Invalid generated code block pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if !ppsTDecl.is_null() {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              855 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 25],
                                        &[libc::c_char; 25]>(b"scriptCodeCallbackParams\x00")).as_ptr(),
              b"ppsTDecl != NULL\x00" as *const u8 as *const libc::c_char);
    };
    if (*psCBSymbol).pFunc.is_some() {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeCallbackParams: Expected function pointer for callback symbol\x00"
                  as *const u8 as *const libc::c_char);
    };
    if (*psCBSymbol).pFunc.is_some() {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              857 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 25],
                                        &[libc::c_char; 25]>(b"scriptCodeCallbackParams\x00")).as_ptr(),
              b"psCBSymbol->pFunc != NULL\x00" as *const u8 as
                  *const libc::c_char);
    };
    /* Check the parameter types match what the function needs */
    i = 0 as libc::c_int as UDWORD;
    while i < (*psCBSymbol).numParams && i < (*psPBlock).numParams {
        if interpCheckEquiv((*psCBSymbol).aParams[i as usize],
                            *(*psPBlock).aParams.offset(i as isize)) == 0 {
            sprintf(aErrorString.as_mut_ptr(),
                    b"Type mismatch for paramter %d\x00" as *const u8 as
                        *const libc::c_char, i);
            scr_error(aErrorString.as_mut_ptr());
            typeError = 1 as libc::c_int
        }
        i = i.wrapping_add(1)
    }
    /* Check the number of parameters matches that expected */
    if (*psPBlock).numParams == 0 as libc::c_int as libc::c_uint {
        scr_error(b"Expected parameters to callback\x00" as *const u8 as
                      *const libc::c_char as *mut libc::c_char);
        *ppsTDecl = 0 as *mut TRIGGER_DECL;
        return CE_PARSE
    } else {
        if (*psCBSymbol).numParams != (*psPBlock).numParams {
            sprintf(aErrorString.as_mut_ptr(),
                    b"Expected %d parameters\x00" as *const u8 as
                        *const libc::c_char, (*psCBSymbol).numParams);
            scr_error(aErrorString.as_mut_ptr());
            *ppsTDecl = 0 as *mut TRIGGER_DECL;
            return CE_PARSE
        }
    }
    if typeError != 0 {
        /* Return the error here so all the */
		/* type mismatches are reported */
        *ppsTDecl = 0 as *mut TRIGGER_DECL;
        return CE_PARSE
    }
    size =
        (*psPBlock).size.wrapping_add(::std::mem::size_of::<OPCODE>() as
                                          libc::c_ulong).wrapping_add(::std::mem::size_of::<SCRIPT_FUNC>()
                                                                          as
                                                                          libc::c_ulong);
    *ppsTDecl =
        memMallocRelease(::std::mem::size_of::<TRIGGER_DECL>() as
                             libc::c_ulong) as *mut TRIGGER_DECL;
    if (*ppsTDecl).is_null() {
        scr_error(b"Out of memory\x00" as *const u8 as *const libc::c_char as
                      *mut libc::c_char);
        return CE_MEMORY
    }
    (**ppsTDecl).type_0 = (*psCBSymbol).type_0;
    (**ppsTDecl).time = 0 as libc::c_int as UDWORD;
    if size > 0 as libc::c_int as libc::c_uint {
        (**ppsTDecl).pCode = memMallocRelease(size) as *mut UDWORD;
        if (**ppsTDecl).pCode.is_null() {
            scr_error(b"Out of memory\x00" as *const u8 as *const libc::c_char
                          as *mut libc::c_char);
            return CE_MEMORY
        }
        (**ppsTDecl).size = size
    } else {
        (**ppsTDecl).pCode = 0 as *mut UDWORD;
        (**ppsTDecl).size = 0 as libc::c_int as UDWORD
    }
    ip_0 = (**ppsTDecl).pCode;
    /* Copy in the code for the parameters */
    memcpy(ip_0 as *mut libc::c_void,
           (*psPBlock).pCode as *const libc::c_void, (*psPBlock).size);
    ip_0 =
        (ip_0 as *mut UBYTE).offset((*psPBlock).size as isize) as *mut UDWORD;
    memFreeRelease((*psPBlock).pCode as *mut libc::c_void);
    (*psPBlock).pCode = 0 as *mut UDWORD;
    memFreeRelease((*psPBlock).aParams as *mut libc::c_void);
    (*psPBlock).aParams = 0 as *mut INTERP_TYPE;
    memFreeRelease(psPBlock as *mut libc::c_void);
    psPBlock = 0 as *mut PARAM_BLOCK;
    /* call the instinct function */
    *ip_0 = ((OP_CALL as libc::c_int) << 24 as libc::c_int) as UDWORD;
    ip_0 = ip_0.offset(1 as libc::c_int as isize);
    *ip_0 = ::std::mem::transmute::<SCRIPT_FUNC, UDWORD>((*psCBSymbol).pFunc);
    ip_0 = ip_0.offset(1 as libc::c_int as isize);
    return CE_OK;
}
/* Generate code for assigning a value to a variable */
#[no_mangle]
pub unsafe extern "C" fn scriptCodeAssignment(mut psVariable: *mut VAR_SYMBOL,
                                              mut psValue: *mut CODE_BLOCK,
                                              mut ppsBlock:
                                                  *mut *mut CODE_BLOCK)
 -> CODE_ERROR 
 // Generated code
 {
    let mut size: SDWORD = 0;
    if !psVariable.is_null() {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeAssignment: Invalid variable symbol pointer\x00" as
                  *const u8 as *const libc::c_char);
    };
    if !psVariable.is_null() {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              918 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 21],
                                        &[libc::c_char; 21]>(b"scriptCodeAssignment\x00")).as_ptr(),
              b"psVariable != NULL\x00" as *const u8 as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeAssignment: Invalid value code block pointer\x00" as
                  *const u8 as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              920 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 21],
                                        &[libc::c_char; 21]>(b"scriptCodeAssignment\x00")).as_ptr(),
              b"PTRVALID(psValue, sizeof(CODE_BLOCK))\x00" as *const u8 as
                  *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeAssignment: Invalid value code pointer\x00" as
                  *const u8 as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              922 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 21],
                                        &[libc::c_char; 21]>(b"scriptCodeAssignment\x00")).as_ptr(),
              b"PTRVALID(psValue->pCode, psValue->size)\x00" as *const u8 as
                  *const libc::c_char);
    };
    if !ppsBlock.is_null() {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeAssignment: Invalid generated code block pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if !ppsBlock.is_null() {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              924 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 21],
                                        &[libc::c_char; 21]>(b"scriptCodeAssignment\x00")).as_ptr(),
              b"ppsBlock != NULL\x00" as *const u8 as *const libc::c_char);
    };
    size =
        (*psValue).size.wrapping_add(::std::mem::size_of::<OPCODE>() as
                                         libc::c_ulong) as SDWORD;
    if (*psVariable).storage as libc::c_int == ST_EXTERN as libc::c_int {
        // Check there is a set function
        if (*psVariable).set.is_none() {
            scr_error(b"No set function for external variable\x00" as
                          *const u8 as *const libc::c_char as
                          *mut libc::c_char);
            return CE_PARSE
        }
        size =
            (size as
                 libc::c_uint).wrapping_add(::std::mem::size_of::<SCRIPT_VARFUNC>()
                                                as libc::c_ulong) as SDWORD as
                SDWORD
    }
    *ppsBlock =
        memMallocRelease(::std::mem::size_of::<CODE_BLOCK>() as libc::c_ulong)
            as *mut CODE_BLOCK;
    if (*ppsBlock).is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        return CE_MEMORY
    }
    (**ppsBlock).pCode = memMallocRelease(size as size_t) as *mut UDWORD;
    if (**ppsBlock).pCode.is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        memFreeRelease(*ppsBlock as *mut libc::c_void);
        *ppsBlock = 0 as *mut CODE_BLOCK;
        return CE_MEMORY
    }
    (**ppsBlock).size = size as UDWORD;
    ip = (**ppsBlock).pCode;
    /* Copy in the code for the expression */
    memcpy(ip as *mut libc::c_void, (*psValue).pCode as *const libc::c_void,
           (*psValue).size);
    ip = (ip as *mut UBYTE).offset((*psValue).size as isize) as *mut UDWORD;
    memFreeRelease((*psValue).pCode as *mut libc::c_void);
    (*psValue).pCode = 0 as *mut UDWORD;
    memFreeRelease(psValue as *mut libc::c_void);
    psValue = 0 as *mut CODE_BLOCK;
    /* Code to get the value from the stack into the variable */
    match (*psVariable).storage as libc::c_int {
        0 | 1 => {
            *ip =
                (*psVariable).index & 0xffffff as libc::c_int as libc::c_uint;
            *ip =
                (OP_POPGLOBAL as libc::c_int as UDWORD) << 24 as libc::c_int |
                    *ip;
            ip = ip.offset(1 as libc::c_int as isize)
        }
        4 => {
            *ip =
                (*psVariable).index & 0xffffff as libc::c_int as libc::c_uint;
            *ip =
                (OP_POPLOCAL as libc::c_int as UDWORD) << 24 as libc::c_int |
                    *ip;
            ip = ip.offset(1 as libc::c_int as isize)
        }
        3 => {
            *ip =
                (*psVariable).index & 0xffffff as libc::c_int as libc::c_uint;
            *ip =
                (OP_VARCALL as libc::c_int as UDWORD) << 24 as libc::c_int |
                    *ip;
            ip = ip.offset(1 as libc::c_int as isize);
            *ip =
                ::std::mem::transmute::<SCRIPT_VARFUNC,
                                        UDWORD>((*psVariable).set);
            ip = ip.offset(1 as libc::c_int as isize)
        }
        2 => {
            scr_error(b"Cannot use member variables in this context\x00" as
                          *const u8 as *const libc::c_char as
                          *mut libc::c_char);
            return CE_PARSE
        }
        _ => {
            scr_error(b"Unknown storage type\x00" as *const u8 as
                          *const libc::c_char as *mut libc::c_char);
            return CE_PARSE
        }
    }
    return CE_OK;
}
/* Generate code for assigning a value to an object variable */
#[no_mangle]
pub unsafe extern "C" fn scriptCodeObjAssignment(mut psVariable:
                                                     *mut OBJVAR_BLOCK,
                                                 mut psValue: *mut CODE_BLOCK,
                                                 mut ppsBlock:
                                                     *mut *mut CODE_BLOCK)
 -> CODE_ERROR 
 // Generated code
 {
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeObjAssignment: Invalid object variable block pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              979 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 24],
                                        &[libc::c_char; 24]>(b"scriptCodeObjAssignment\x00")).as_ptr(),
              b"PTRVALID(psVariable, sizeof(OBJVAR_BLOCK))\x00" as *const u8
                  as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeObjAssignment: Invalid object variable code pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              981 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 24],
                                        &[libc::c_char; 24]>(b"scriptCodeObjAssignment\x00")).as_ptr(),
              b"PTRVALID(psVariable->pCode, psVariable->size)\x00" as
                  *const u8 as *const libc::c_char);
    };
    if !(*psVariable).psObjVar.is_null() {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeObjAssignment: Invalid object variable symbol pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if !(*psVariable).psObjVar.is_null() {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              983 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 24],
                                        &[libc::c_char; 24]>(b"scriptCodeObjAssignment\x00")).as_ptr(),
              b"psVariable->psObjVar != NULL\x00" as *const u8 as
                  *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeObjAssignment: Invalid value code block pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              985 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 24],
                                        &[libc::c_char; 24]>(b"scriptCodeObjAssignment\x00")).as_ptr(),
              b"PTRVALID(psValue, sizeof(CODE_BLOCK))\x00" as *const u8 as
                  *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeObjAssignment: Invalid value code pointer\x00" as
                  *const u8 as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              987 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 24],
                                        &[libc::c_char; 24]>(b"scriptCodeObjAssignment\x00")).as_ptr(),
              b"PTRVALID(psValue->pCode, psValue->size)\x00" as *const u8 as
                  *const libc::c_char);
    };
    if !ppsBlock.is_null() {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeObjAssignment: Invalid generated code block pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if !ppsBlock.is_null() {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              989 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 24],
                                        &[libc::c_char; 24]>(b"scriptCodeObjAssignment\x00")).as_ptr(),
              b"ppsBlock != NULL\x00" as *const u8 as *const libc::c_char);
    };
    // Check there is an access function for the variable
    if (*(*psVariable).psObjVar).set.is_none() {
        scr_error(b"No set function for object variable\x00" as *const u8 as
                      *const libc::c_char as *mut libc::c_char);
        return CE_PARSE
    }
    *ppsBlock =
        memMallocRelease(::std::mem::size_of::<CODE_BLOCK>() as libc::c_ulong)
            as *mut CODE_BLOCK;
    if (*ppsBlock).is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        return CE_MEMORY
    }
    (**ppsBlock).pCode =
        memMallocRelease((*psVariable).size.wrapping_add((*psValue).size).wrapping_add(::std::mem::size_of::<OPCODE>()
                                                                                           as
                                                                                           libc::c_ulong).wrapping_add(::std::mem::size_of::<SCRIPT_VARFUNC>()
                                                                                                                           as
                                                                                                                           libc::c_ulong))
            as *mut UDWORD;
    if (**ppsBlock).pCode.is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        memFreeRelease(*ppsBlock as *mut libc::c_void);
        *ppsBlock = 0 as *mut CODE_BLOCK;
        return CE_MEMORY
    }
    (**ppsBlock).size =
        (*psVariable).size.wrapping_add((*psValue).size).wrapping_add(::std::mem::size_of::<OPCODE>()
                                                                          as
                                                                          libc::c_ulong).wrapping_add(::std::mem::size_of::<SCRIPT_VARFUNC>()
                                                                                                          as
                                                                                                          libc::c_ulong);
    ip = (**ppsBlock).pCode;
    /* Copy in the code for the value */
    memcpy(ip as *mut libc::c_void, (*psValue).pCode as *const libc::c_void,
           (*psValue).size);
    ip = (ip as *mut UBYTE).offset((*psValue).size as isize) as *mut UDWORD;
    memFreeRelease((*psValue).pCode as *mut libc::c_void);
    (*psValue).pCode = 0 as *mut UDWORD;
    memFreeRelease(psValue as *mut libc::c_void);
    psValue = 0 as *mut CODE_BLOCK;
    /* Copy in the code for the object */
    memcpy(ip as *mut libc::c_void,
           (*psVariable).pCode as *const libc::c_void, (*psVariable).size);
    ip =
        (ip as *mut UBYTE).offset((*psVariable).size as isize) as *mut UDWORD;
    /* Code to get the value from the stack into the variable */
    *ip =
        (*(*psVariable).psObjVar).index &
            0xffffff as libc::c_int as libc::c_uint;
    *ip = (OP_VARCALL as libc::c_int as UDWORD) << 24 as libc::c_int | *ip;
    ip = ip.offset(1 as libc::c_int as isize);
    *ip =
        ::std::mem::transmute::<SCRIPT_VARFUNC,
                                UDWORD>((*(*psVariable).psObjVar).set);
    ip = ip.offset(1 as libc::c_int as isize);
    /* Free the variable block */
    memFreeRelease((*psVariable).pCode as *mut libc::c_void);
    (*psVariable).pCode = 0 as *mut UDWORD;
    memFreeRelease(psVariable as *mut libc::c_void);
    psVariable = 0 as *mut OBJVAR_BLOCK;
    return CE_OK;
}
/* Generate code for getting a value from an object variable */
#[no_mangle]
pub unsafe extern "C" fn scriptCodeObjGet(mut psVariable: *mut OBJVAR_BLOCK,
                                          mut ppsBlock: *mut *mut CODE_BLOCK)
 -> CODE_ERROR 
 // Generated code
 {
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeObjAssignment: Invalid object variable block pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1025 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 17],
                                        &[libc::c_char; 17]>(b"scriptCodeObjGet\x00")).as_ptr(),
              b"PTRVALID(psVariable, sizeof(OBJVAR_BLOCK))\x00" as *const u8
                  as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeObjAssignment: Invalid object variable code pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1027 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 17],
                                        &[libc::c_char; 17]>(b"scriptCodeObjGet\x00")).as_ptr(),
              b"PTRVALID(psVariable->pCode, psVariable->size)\x00" as
                  *const u8 as *const libc::c_char);
    };
    if !(*psVariable).psObjVar.is_null() {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeObjAssignment: Invalid object variable symbol pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if !(*psVariable).psObjVar.is_null() {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1029 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 17],
                                        &[libc::c_char; 17]>(b"scriptCodeObjGet\x00")).as_ptr(),
              b"psVariable->psObjVar != NULL\x00" as *const u8 as
                  *const libc::c_char);
    };
    if !ppsBlock.is_null() {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeObjAssignment: Invalid generated code block pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if !ppsBlock.is_null() {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1031 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 17],
                                        &[libc::c_char; 17]>(b"scriptCodeObjGet\x00")).as_ptr(),
              b"ppsBlock != NULL\x00" as *const u8 as *const libc::c_char);
    };
    // Check there is an access function for the variable
    if (*(*psVariable).psObjVar).get.is_none() {
        scr_error(b"No get function for object variable\x00" as *const u8 as
                      *const libc::c_char as *mut libc::c_char);
        return CE_PARSE
    }
    *ppsBlock =
        memMallocRelease(::std::mem::size_of::<CODE_BLOCK>() as libc::c_ulong)
            as *mut CODE_BLOCK;
    if (*ppsBlock).is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        return CE_MEMORY
    }
    (**ppsBlock).pCode =
        memMallocRelease((*psVariable).size.wrapping_add(::std::mem::size_of::<OPCODE>()
                                                             as
                                                             libc::c_ulong).wrapping_add(::std::mem::size_of::<SCRIPT_VARFUNC>()
                                                                                             as
                                                                                             libc::c_ulong))
            as *mut UDWORD;
    if (**ppsBlock).pCode.is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        memFreeRelease(*ppsBlock as *mut libc::c_void);
        *ppsBlock = 0 as *mut CODE_BLOCK;
        return CE_MEMORY
    }
    (**ppsBlock).size =
        (*psVariable).size.wrapping_add(::std::mem::size_of::<OPCODE>() as
                                            libc::c_ulong).wrapping_add(::std::mem::size_of::<SCRIPT_VARFUNC>()
                                                                            as
                                                                            libc::c_ulong);
    ip = (**ppsBlock).pCode;
    /* Copy in the code for the object */
    memcpy(ip as *mut libc::c_void,
           (*psVariable).pCode as *const libc::c_void, (*psVariable).size);
    ip =
        (ip as *mut UBYTE).offset((*psVariable).size as isize) as *mut UDWORD;
    (**ppsBlock).type_0 = (*(*psVariable).psObjVar).type_0;
    /* Code to get the value from the object onto the stack */
    *ip =
        (*(*psVariable).psObjVar).index &
            0xffffff as libc::c_int as libc::c_uint;
    *ip = (OP_VARCALL as libc::c_int as UDWORD) << 24 as libc::c_int | *ip;
    ip = ip.offset(1 as libc::c_int as isize);
    *ip =
        ::std::mem::transmute::<SCRIPT_VARFUNC,
                                UDWORD>((*(*psVariable).psObjVar).get);
    ip = ip.offset(1 as libc::c_int as isize);
    /* Free the variable block */
    memFreeRelease((*psVariable).pCode as *mut libc::c_void);
    (*psVariable).pCode = 0 as *mut UDWORD;
    memFreeRelease(psVariable as *mut libc::c_void);
    psVariable = 0 as *mut OBJVAR_BLOCK;
    return CE_OK;
}
/* Generate code for assigning a value to an array variable */
#[no_mangle]
pub unsafe extern "C" fn scriptCodeArrayAssignment(mut psVariable:
                                                       *mut ARRAY_BLOCK,
                                                   mut psValue:
                                                       *mut CODE_BLOCK,
                                                   mut ppsBlock:
                                                       *mut *mut CODE_BLOCK)
 -> CODE_ERROR 
 // Generated code
 {
    //	SDWORD		elementDWords, i;
//	UBYTE		*pElement;
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeObjAssignment: Invalid object variable block pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1069 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 26],
                                        &[libc::c_char; 26]>(b"scriptCodeArrayAssignment\x00")).as_ptr(),
              b"PTRVALID(psVariable, sizeof(ARRAY_BLOCK))\x00" as *const u8 as
                  *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeObjAssignment: Invalid object variable code pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1071 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 26],
                                        &[libc::c_char; 26]>(b"scriptCodeArrayAssignment\x00")).as_ptr(),
              b"PTRVALID(psVariable->pCode, psVariable->size)\x00" as
                  *const u8 as *const libc::c_char);
    };
    if !(*psVariable).psArrayVar.is_null() {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeObjAssignment: Invalid object variable symbol pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if !(*psVariable).psArrayVar.is_null() {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1073 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 26],
                                        &[libc::c_char; 26]>(b"scriptCodeArrayAssignment\x00")).as_ptr(),
              b"psVariable->psArrayVar != NULL\x00" as *const u8 as
                  *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeObjAssignment: Invalid value code block pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1075 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 26],
                                        &[libc::c_char; 26]>(b"scriptCodeArrayAssignment\x00")).as_ptr(),
              b"PTRVALID(psValue, sizeof(CODE_BLOCK))\x00" as *const u8 as
                  *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeObjAssignment: Invalid value code pointer\x00" as
                  *const u8 as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1077 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 26],
                                        &[libc::c_char; 26]>(b"scriptCodeArrayAssignment\x00")).as_ptr(),
              b"PTRVALID(psValue->pCode, psValue->size)\x00" as *const u8 as
                  *const libc::c_char);
    };
    if !ppsBlock.is_null() {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeObjAssignment: Invalid generated code block pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if !ppsBlock.is_null() {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1079 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 26],
                                        &[libc::c_char; 26]>(b"scriptCodeArrayAssignment\x00")).as_ptr(),
              b"ppsBlock != NULL\x00" as *const u8 as *const libc::c_char);
    };
    // Check this is an array
    if (*(*psVariable).psArrayVar).dimensions == 0 as libc::c_int {
        scr_error(b"Not an array variable\x00" as *const u8 as
                      *const libc::c_char as *mut libc::c_char);
        return CE_PARSE
    }
    // calculate the number of DWORDs needed to store the number of elements for each dimension of the array
//	elementDWords = (psVariable->psArrayVar->dimensions - 1)/4 + 1;
    //	ALLOC_BLOCK(*ppsBlock, psVariable->size + psValue->size + sizeof(OPCODE) + elementDWords*4);
    *ppsBlock =
        memMallocRelease(::std::mem::size_of::<CODE_BLOCK>() as libc::c_ulong)
            as *mut CODE_BLOCK;
    if (*ppsBlock).is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        return CE_MEMORY
    }
    (**ppsBlock).pCode =
        memMallocRelease((*psVariable).size.wrapping_add((*psValue).size).wrapping_add(::std::mem::size_of::<OPCODE>()
                                                                                           as
                                                                                           libc::c_ulong))
            as *mut UDWORD;
    if (**ppsBlock).pCode.is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        memFreeRelease(*ppsBlock as *mut libc::c_void);
        *ppsBlock = 0 as *mut CODE_BLOCK;
        return CE_MEMORY
    }
    (**ppsBlock).size =
        (*psVariable).size.wrapping_add((*psValue).size).wrapping_add(::std::mem::size_of::<OPCODE>()
                                                                          as
                                                                          libc::c_ulong);
    ip = (**ppsBlock).pCode;
    /* Copy in the code for the value */
    memcpy(ip as *mut libc::c_void, (*psValue).pCode as *const libc::c_void,
           (*psValue).size);
    ip = (ip as *mut UBYTE).offset((*psValue).size as isize) as *mut UDWORD;
    memFreeRelease((*psValue).pCode as *mut libc::c_void);
    (*psValue).pCode = 0 as *mut UDWORD;
    memFreeRelease(psValue as *mut libc::c_void);
    psValue = 0 as *mut CODE_BLOCK;
    /* Copy in the code for the array index */
    memcpy(ip as *mut libc::c_void,
           (*psVariable).pCode as *const libc::c_void, (*psVariable).size);
    ip =
        (ip as *mut UBYTE).offset((*psVariable).size as isize) as *mut UDWORD;
    /* Code to get the value from the stack into the variable */
    *ip =
        (((*(*psVariable).psArrayVar).dimensions << 20 as libc::c_int &
              0xf00000 as libc::c_int) as libc::c_uint |
             (*(*psVariable).psArrayVar).index &
                 0xfffff as libc::c_int as libc::c_uint) &
            0xffffff as libc::c_int as libc::c_uint;
    *ip =
        (OP_POPARRAYGLOBAL as libc::c_int as UDWORD) << 24 as libc::c_int |
            *ip;
    ip = ip.offset(1 as libc::c_int as isize);
    // store the size of each dimension
/*	pElement = (UBYTE *)ip;
	for(i=0; i<psVariable->psArrayVar->dimensions; i++)
	{
		*pElement = (UBYTE)psVariable->psArrayVar->elements[i];
		pElement += 1;
	}*/
    /* Free the variable block */
    memFreeRelease((*psVariable).pCode as *mut libc::c_void);
    (*psVariable).pCode = 0 as *mut UDWORD;
    memFreeRelease(psVariable as *mut libc::c_void);
    psVariable = 0 as *mut ARRAY_BLOCK;
    return CE_OK;
}
/* Generate code for getting a value from an array variable */
#[no_mangle]
pub unsafe extern "C" fn scriptCodeArrayGet(mut psVariable: *mut ARRAY_BLOCK,
                                            mut ppsBlock:
                                                *mut *mut CODE_BLOCK)
 -> CODE_ERROR 
 // Generated code
 {
    //	SDWORD		elementDWords, i;
//	UBYTE		*pElement;
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeObjAssignment: Invalid object variable block pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1130 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 19],
                                        &[libc::c_char; 19]>(b"scriptCodeArrayGet\x00")).as_ptr(),
              b"PTRVALID(psVariable, sizeof(ARRAY_BLOCK))\x00" as *const u8 as
                  *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeObjAssignment: Invalid object variable code pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1132 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 19],
                                        &[libc::c_char; 19]>(b"scriptCodeArrayGet\x00")).as_ptr(),
              b"PTRVALID(psVariable->pCode, psVariable->size)\x00" as
                  *const u8 as *const libc::c_char);
    };
    if !(*psVariable).psArrayVar.is_null() {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeObjAssignment: Invalid object variable symbol pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if !(*psVariable).psArrayVar.is_null() {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1134 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 19],
                                        &[libc::c_char; 19]>(b"scriptCodeArrayGet\x00")).as_ptr(),
              b"psVariable->psArrayVar != NULL\x00" as *const u8 as
                  *const libc::c_char);
    };
    if !ppsBlock.is_null() {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeObjAssignment: Invalid generated code block pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if !ppsBlock.is_null() {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1136 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 19],
                                        &[libc::c_char; 19]>(b"scriptCodeArrayGet\x00")).as_ptr(),
              b"ppsBlock != NULL\x00" as *const u8 as *const libc::c_char);
    };
    // Check this is an array
    if (*(*psVariable).psArrayVar).dimensions == 0 as libc::c_int {
        scr_error(b"Not an array variable\x00" as *const u8 as
                      *const libc::c_char as *mut libc::c_char);
        return CE_PARSE
    }
    // calculate the number of DWORDs needed to store the number of elements for each dimension of the array
//	elementDWords = (psVariable->psArrayVar->dimensions - 1)/4 + 1;
    //	ALLOC_BLOCK(*ppsBlock, psVariable->size + sizeof(OPCODE) + elementDWords*4);
    *ppsBlock =
        memMallocRelease(::std::mem::size_of::<CODE_BLOCK>() as libc::c_ulong)
            as *mut CODE_BLOCK;
    if (*ppsBlock).is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        return CE_MEMORY
    }
    (**ppsBlock).pCode =
        memMallocRelease((*psVariable).size.wrapping_add(::std::mem::size_of::<OPCODE>()
                                                             as
                                                             libc::c_ulong))
            as *mut UDWORD;
    if (**ppsBlock).pCode.is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        memFreeRelease(*ppsBlock as *mut libc::c_void);
        *ppsBlock = 0 as *mut CODE_BLOCK;
        return CE_MEMORY
    }
    (**ppsBlock).size =
        (*psVariable).size.wrapping_add(::std::mem::size_of::<OPCODE>() as
                                            libc::c_ulong);
    ip = (**ppsBlock).pCode;
    /* Copy in the code for the array index */
    memcpy(ip as *mut libc::c_void,
           (*psVariable).pCode as *const libc::c_void, (*psVariable).size);
    ip =
        (ip as *mut UBYTE).offset((*psVariable).size as isize) as *mut UDWORD;
    (**ppsBlock).type_0 = (*(*psVariable).psArrayVar).type_0;
    /* Code to get the value from the array onto the stack */
    *ip =
        (((*(*psVariable).psArrayVar).dimensions << 20 as libc::c_int &
              0xf00000 as libc::c_int) as libc::c_uint |
             (*(*psVariable).psArrayVar).index &
                 0xfffff as libc::c_int as libc::c_uint) &
            0xffffff as libc::c_int as libc::c_uint;
    *ip =
        (OP_PUSHARRAYGLOBAL as libc::c_int as UDWORD) << 24 as libc::c_int |
            *ip;
    ip = ip.offset(1 as libc::c_int as isize);
    // store the size of each dimension
/*	pElement = (UBYTE *)ip;
	for(i=0; i<psVariable->psArrayVar->dimensions; i++)
	{
		*pElement = (UBYTE)psVariable->psArrayVar->elements[i];
		pElement += 1;
	}*/
    /* Free the variable block */
    memFreeRelease((*psVariable).pCode as *mut libc::c_void);
    (*psVariable).pCode = 0 as *mut UDWORD;
    memFreeRelease(psVariable as *mut libc::c_void);
    psVariable = 0 as *mut ARRAY_BLOCK;
    return CE_OK;
}
/* Generate the final code block for conditional statements */
#[no_mangle]
pub unsafe extern "C" fn scriptCodeConditional(mut psCondBlock_0:
                                                   *mut COND_BLOCK,
                                               mut ppsBlock:
                                                   *mut *mut CODE_BLOCK)
 -> CODE_ERROR 
 // The final conditional code
 {
    let mut i: UDWORD = 0;
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeConditional: Invalid conditional code block pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1184 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 22],
                                        &[libc::c_char; 22]>(b"scriptCodeConditional\x00")).as_ptr(),
              b"PTRVALID(psCondBlock, sizeof(CODE_BLOCK))\x00" as *const u8 as
                  *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeConditional: Invalid conditional code pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1186 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 22],
                                        &[libc::c_char; 22]>(b"scriptCodeConditional\x00")).as_ptr(),
              b"PTRVALID(psCondBlock->pCode, psCondBlock->size)\x00" as
                  *const u8 as *const libc::c_char);
    };
    if !ppsBlock.is_null() {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeConditional: Invalid generated code block pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if !ppsBlock.is_null() {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1188 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 22],
                                        &[libc::c_char; 22]>(b"scriptCodeConditional\x00")).as_ptr(),
              b"ppsBlock != NULL\x00" as *const u8 as *const libc::c_char);
    };
    /* Allocate the final block */
    *ppsBlock =
        memMallocRelease(::std::mem::size_of::<CODE_BLOCK>() as libc::c_ulong)
            as *mut CODE_BLOCK;
    if (*ppsBlock).is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        return CE_MEMORY
    }
    (**ppsBlock).pCode =
        memMallocRelease((*psCondBlock_0).size) as *mut UDWORD;
    if (**ppsBlock).pCode.is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        memFreeRelease(*ppsBlock as *mut libc::c_void);
        *ppsBlock = 0 as *mut CODE_BLOCK;
        return CE_MEMORY
    }
    (**ppsBlock).size = (*psCondBlock_0).size;
    if genDebugInfo != 0 {
        (**ppsBlock).psDebug =
            memMallocRelease((::std::mem::size_of::<SCRIPT_DEBUG>() as
                                  libc::c_ulong).wrapping_mul((*psCondBlock_0).debugEntries))
                as *mut SCRIPT_DEBUG;
        if (**ppsBlock).psDebug.is_null() {
            scr_error(b"Out of memory\x00" as *const u8 as *const libc::c_char
                          as *mut libc::c_char);
            return CE_MEMORY
        }
        memset((**ppsBlock).psDebug as *mut libc::c_void, 0 as libc::c_int,
               (::std::mem::size_of::<SCRIPT_DEBUG>() as
                    libc::c_ulong).wrapping_mul((*psCondBlock_0).debugEntries));
        (**ppsBlock).debugEntries =
            (*psCondBlock_0).debugEntries as UWORD as UDWORD
    } else {
        (**ppsBlock).psDebug = 0 as *mut SCRIPT_DEBUG;
        (**ppsBlock).debugEntries = 0 as libc::c_int as UDWORD
    }
    ip = (**ppsBlock).pCode;
    /* Copy the code over */
    memcpy(ip as *mut libc::c_void,
           (*psCondBlock_0).pCode as *const libc::c_void,
           (*psCondBlock_0).size);
    ip =
        (ip as *mut UBYTE).offset((*psCondBlock_0).size as isize) as
            *mut UDWORD;
    /* Copy the debugging information */
    if genDebugInfo != 0 {
        memcpy((**ppsBlock).psDebug as *mut libc::c_void,
               (*psCondBlock_0).psDebug as *const libc::c_void,
               (::std::mem::size_of::<SCRIPT_DEBUG>() as
                    libc::c_ulong).wrapping_mul((*psCondBlock_0).debugEntries));
        (**ppsBlock).debugEntries = (*psCondBlock_0).debugEntries
    }
    /* Now set the offsets of jumps in the conditional to the correct value */
    i = 0 as libc::c_int as UDWORD;
    while i < (*psCondBlock_0).numOffsets {
        ip =
            (**ppsBlock).pCode.offset(*(*psCondBlock_0).aOffsets.offset(i as
                                                                            isize)
                                          as isize);
        *ip =
            (**ppsBlock).size.wrapping_div(::std::mem::size_of::<UDWORD>() as
                                               libc::c_ulong).wrapping_sub(ip.wrapping_offset_from((**ppsBlock).pCode)
                                                                               as
                                                                               libc::c_int
                                                                               as
                                                                               libc::c_uint);
        *ip =
            ((OP_JUMP as libc::c_int) << 24 as libc::c_int) as libc::c_uint |
                *ip & 0xffffff as libc::c_int as libc::c_uint;
        i = i.wrapping_add(1)
    }
    /* Free the original code */
    if genDebugInfo != 0 {
        memFreeRelease((*psCondBlock_0).psDebug as *mut libc::c_void);
        (*psCondBlock_0).psDebug = 0 as *mut SCRIPT_DEBUG
    }
    memFreeRelease((*psCondBlock_0).aOffsets as *mut libc::c_void);
    (*psCondBlock_0).aOffsets = 0 as *mut UDWORD;
    memFreeRelease((*psCondBlock_0).pCode as *mut libc::c_void);
    (*psCondBlock_0).pCode = 0 as *mut UDWORD;
    memFreeRelease(psCondBlock_0 as *mut libc::c_void);
    psCondBlock_0 = 0 as *mut COND_BLOCK;
    return CE_OK;
}
/* Generate code for function parameters */
#[no_mangle]
pub unsafe extern "C" fn scriptCodeParameter(mut psParam: *mut CODE_BLOCK,
                                             mut type_0: INTERP_TYPE,
                                             mut ppsBlock:
                                                 *mut *mut PARAM_BLOCK)
 -> CODE_ERROR 
 // Generated code
 {
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeParameter: Invalid parameter code block pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1222 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 20],
                                        &[libc::c_char; 20]>(b"scriptCodeParameter\x00")).as_ptr(),
              b"PTRVALID(psParam, sizeof(CODE_BLOCK))\x00" as *const u8 as
                  *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeParameter: Invalid parameter code pointer\x00" as
                  *const u8 as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1224 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 20],
                                        &[libc::c_char; 20]>(b"scriptCodeParameter\x00")).as_ptr(),
              b"PTRVALID(psParam->pCode, psParam->size)\x00" as *const u8 as
                  *const libc::c_char);
    };
    if !ppsBlock.is_null() {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeParameter: Invalid generated code block pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if !ppsBlock.is_null() {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1226 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 20],
                                        &[libc::c_char; 20]>(b"scriptCodeParameter\x00")).as_ptr(),
              b"ppsBlock != NULL\x00" as *const u8 as *const libc::c_char);
    };
    *ppsBlock =
        memMallocRelease(::std::mem::size_of::<PARAM_BLOCK>() as
                             libc::c_ulong) as *mut PARAM_BLOCK;
    if (*ppsBlock).is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        return CE_MEMORY
    }
    (**ppsBlock).pCode = memMallocRelease((*psParam).size) as *mut UDWORD;
    if (**ppsBlock).pCode.is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        memFreeRelease(*ppsBlock as *mut libc::c_void);
        *ppsBlock = 0 as *mut PARAM_BLOCK;
        return CE_MEMORY
    }
    (**ppsBlock).aParams =
        memMallocRelease((::std::mem::size_of::<INTERP_TYPE>() as
                              libc::c_ulong).wrapping_mul(1 as libc::c_int as
                                                              libc::c_uint))
            as *mut INTERP_TYPE;
    if (**ppsBlock).aParams.is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        memFreeRelease((**ppsBlock).pCode as *mut libc::c_void);
        (**ppsBlock).pCode = 0 as *mut UDWORD;
        memFreeRelease(*ppsBlock as *mut libc::c_void);
        *ppsBlock = 0 as *mut PARAM_BLOCK;
        return CE_MEMORY
    }
    (**ppsBlock).size = (*psParam).size;
    (**ppsBlock).numParams = 1 as libc::c_int as UDWORD;
    ip = (**ppsBlock).pCode;
    /* Copy in the code for the parameter */
    memcpy(ip as *mut libc::c_void, (*psParam).pCode as *const libc::c_void,
           (*psParam).size);
    ip = (ip as *mut UBYTE).offset((*psParam).size as isize) as *mut UDWORD;
    memFreeRelease((*psParam).pCode as *mut libc::c_void);
    (*psParam).pCode = 0 as *mut UDWORD;
    memFreeRelease(psParam as *mut libc::c_void);
    psParam = 0 as *mut CODE_BLOCK;
    *(**ppsBlock).aParams.offset(0 as libc::c_int as isize) = type_0;
    return CE_OK;
}
/* Generate code for binary operators (e.g. 2 + 2) */
#[no_mangle]
pub unsafe extern "C" fn scriptCodeBinaryOperator(mut psFirst:
                                                      *mut CODE_BLOCK,
                                                  mut psSecond:
                                                      *mut CODE_BLOCK,
                                                  mut opcode: OPCODE,
                                                  mut ppsBlock:
                                                      *mut *mut CODE_BLOCK)
 -> CODE_ERROR 
 // Generated code
 {
    *ppsBlock =
        memMallocRelease(::std::mem::size_of::<CODE_BLOCK>() as libc::c_ulong)
            as *mut CODE_BLOCK;
    if (*ppsBlock).is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        return CE_MEMORY
    }
    (**ppsBlock).pCode =
        memMallocRelease((*psFirst).size.wrapping_add((*psSecond).size).wrapping_add(::std::mem::size_of::<UDWORD>()
                                                                                         as
                                                                                         libc::c_ulong))
            as *mut UDWORD;
    if (**ppsBlock).pCode.is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        memFreeRelease(*ppsBlock as *mut libc::c_void);
        *ppsBlock = 0 as *mut CODE_BLOCK;
        return CE_MEMORY
    }
    (**ppsBlock).size =
        (*psFirst).size.wrapping_add((*psSecond).size).wrapping_add(::std::mem::size_of::<UDWORD>()
                                                                        as
                                                                        libc::c_ulong);
    ip = (**ppsBlock).pCode;
    /* Copy the already generated bits of code into the code block */
    memcpy(ip as *mut libc::c_void, (*psFirst).pCode as *const libc::c_void,
           (*psFirst).size);
    ip = (ip as *mut UBYTE).offset((*psFirst).size as isize) as *mut UDWORD;
    memcpy(ip as *mut libc::c_void, (*psSecond).pCode as *const libc::c_void,
           (*psSecond).size);
    ip = (ip as *mut UBYTE).offset((*psSecond).size as isize) as *mut UDWORD;
    /* Now put an add operator into the code */
    *ip = opcode as UDWORD & 0xffffff as libc::c_int as libc::c_uint;
    *ip = (OP_BINARYOP as libc::c_int as UDWORD) << 24 as libc::c_int | *ip;
    ip = ip.offset(1 as libc::c_int as isize);
    /* Free the two code blocks that have been copied */
    memFreeRelease((*psFirst).pCode as *mut libc::c_void);
    (*psFirst).pCode = 0 as *mut UDWORD;
    memFreeRelease(psFirst as *mut libc::c_void);
    psFirst = 0 as *mut CODE_BLOCK;
    memFreeRelease((*psSecond).pCode as *mut libc::c_void);
    (*psSecond).pCode = 0 as *mut UDWORD;
    memFreeRelease(psSecond as *mut libc::c_void);
    psSecond = 0 as *mut CODE_BLOCK;
    return CE_OK;
}
/* check if the arguments in the function definition body match the argument types
and names from function declaration (if there was any) */
#[no_mangle]
pub unsafe extern "C" fn checkFuncParamType(mut argIndex: SDWORD,
                                            mut argType: SDWORD) -> BOOL {
    let mut psCurr: *mut VAR_SYMBOL = 0 as *mut VAR_SYMBOL;
    let mut i: SDWORD = 0;
    let mut j: SDWORD = 0;
    if psCurEvent.is_null() {
        debug(LOG_ERROR,
              b"checkFuncParamType() - psCurEvent == NULL\x00" as *const u8 as
                  *const libc::c_char);
        return 0 as libc::c_int
    }
    if (argIndex as libc::c_uint) < (*psCurEvent).numParams {
        /* find the argument by the index */
        i = (*psCurEvent).index as SDWORD;
        j = 0 as libc::c_int;
        psCurr = psLocalVarsB[i as usize];
        while !psCurr.is_null() {
            if (*psCurEvent).numParams.wrapping_sub(j as
                                                        libc::c_uint).wrapping_sub(1
                                                                                       as
                                                                                       libc::c_int
                                                                                       as
                                                                                       libc::c_uint)
                   == argIndex as libc::c_uint {
                /* got to the right argument */
                if argType as libc::c_uint != (*psCurr).type_0 as libc::c_uint
                   {
                    debug(LOG_ERROR,
                          b"Argument type with index %d in event \'%s\' doesn\'t match function declaration (%d/%d)\x00"
                              as *const u8 as *const libc::c_char, argIndex,
                          (*psCurEvent).pIdent, argType,
                          (*psCurr).type_0 as libc::c_uint);
                    return 0 as libc::c_int
                } else {
                    //debug(LOG_SCRIPT, "arg matched ");
                    return 1 as libc::c_int
                }
            }
            j += 1;
            psCurr = (*psCurr).psNext
        }
    } else {
        debug(LOG_ERROR,
              b"checkFuncParamType() - argument %d has wrong argument index, event: \'%s\'\x00"
                  as *const u8 as *const libc::c_char, argIndex,
              (*psCurEvent).pIdent);
        return 0 as libc::c_int
    }
    return 0 as libc::c_int;
}
/* Generate code for accessing an object variable.  The variable symbol is
 * stored with the code for the object value so that this block can be used for
 * both setting and retrieving an object value.
 */
#[no_mangle]
pub unsafe extern "C" fn scriptCodeObjectVariable(mut psObjCode:
                                                      *mut CODE_BLOCK,
                                                  mut psVar: *mut VAR_SYMBOL,
                                                  mut ppsBlock:
                                                      *mut *mut OBJVAR_BLOCK)
 -> CODE_ERROR 
 // Generated code
 {
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeObjectVariable: Invalid object code block pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1319 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 25],
                                        &[libc::c_char; 25]>(b"scriptCodeObjectVariable\x00")).as_ptr(),
              b"PTRVALID(psObjCode, sizeof(CODE_BLOCK))\x00" as *const u8 as
                  *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeObjectVariable: Invalid object code pointer\x00" as
                  *const u8 as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1321 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 25],
                                        &[libc::c_char; 25]>(b"scriptCodeObjectVariable\x00")).as_ptr(),
              b"PTRVALID(psObjCode->pCode, psObjCode->size)\x00" as *const u8
                  as *const libc::c_char);
    };
    if !psVar.is_null() {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeObjectVariable: Invalid variable symbol pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if !psVar.is_null() {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1323 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 25],
                                        &[libc::c_char; 25]>(b"scriptCodeObjectVariable\x00")).as_ptr(),
              b"psVar != NULL\x00" as *const u8 as *const libc::c_char);
    };
    if !ppsBlock.is_null() {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeObjectVariable: Invalid generated code block pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if !ppsBlock.is_null() {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1325 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 25],
                                        &[libc::c_char; 25]>(b"scriptCodeObjectVariable\x00")).as_ptr(),
              b"ppsBlock != NULL\x00" as *const u8 as *const libc::c_char);
    };
    *ppsBlock =
        memMallocRelease(::std::mem::size_of::<OBJVAR_BLOCK>() as
                             libc::c_ulong) as *mut OBJVAR_BLOCK;
    if (*ppsBlock).is_null() {
        scr_error(b"Out of memory\x00" as *const u8 as *const libc::c_char as
                      *mut libc::c_char);
        return CE_MEMORY
    }
    (**ppsBlock).pCode = memMallocRelease((*psObjCode).size) as *mut UDWORD;
    if (**ppsBlock).pCode.is_null() {
        scr_error(b"Out of memory\x00" as *const u8 as *const libc::c_char as
                      *mut libc::c_char);
        return CE_MEMORY
    }
    (**ppsBlock).size = (*psObjCode).size;
    (**ppsBlock).psObjVar = psVar;
    ip = (**ppsBlock).pCode;
    /* Copy the already generated bit of code into the code block */
    memcpy(ip as *mut libc::c_void, (*psObjCode).pCode as *const libc::c_void,
           (*psObjCode).size);
    ip = (ip as *mut UBYTE).offset((*psObjCode).size as isize) as *mut UDWORD;
    memFreeRelease((*psObjCode).pCode as *mut libc::c_void);
    (*psObjCode).pCode = 0 as *mut UDWORD;
    memFreeRelease(psObjCode as *mut libc::c_void);
    psObjCode = 0 as *mut CODE_BLOCK;
    /* Check the variable is the correct type */
    if (*psVar).storage as libc::c_int != ST_OBJECT as libc::c_int {
        scr_error(b"Only object variables are valid in this context\x00" as
                      *const u8 as *const libc::c_char as *mut libc::c_char);
        return CE_PARSE
    }
    return CE_OK;
}
/* Generate code for accessing an array variable.  The variable symbol is
 * stored with the code for the object value so that this block can be used for
 * both setting and retrieving an array value.
 */
#[no_mangle]
pub unsafe extern "C" fn scriptCodeArrayVariable(mut psArrayCode:
                                                     *mut ARRAY_BLOCK,
                                                 mut psVar: *mut VAR_SYMBOL,
                                                 mut ppsBlock:
                                                     *mut *mut ARRAY_BLOCK)
 -> CODE_ERROR 
 // Generated code
 {
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeObjectVariable: Invalid object code block pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1354 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 24],
                                        &[libc::c_char; 24]>(b"scriptCodeArrayVariable\x00")).as_ptr(),
              b"PTRVALID(psArrayCode, sizeof(CODE_BLOCK))\x00" as *const u8 as
                  *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeObjectVariable: Invalid object code pointer\x00" as
                  *const u8 as *const libc::c_char);
    };
    if 1 as libc::c_int != 0 {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1356 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 24],
                                        &[libc::c_char; 24]>(b"scriptCodeArrayVariable\x00")).as_ptr(),
              b"PTRVALID(psArrayCode->pCode, psArrayCode->size)\x00" as
                  *const u8 as *const libc::c_char);
    };
    if !psVar.is_null() {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeObjectVariable: Invalid variable symbol pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if !psVar.is_null() {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1358 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 24],
                                        &[libc::c_char; 24]>(b"scriptCodeArrayVariable\x00")).as_ptr(),
              b"psVar != NULL\x00" as *const u8 as *const libc::c_char);
    };
    if !ppsBlock.is_null() {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeObjectVariable: Invalid generated code block pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if !ppsBlock.is_null() {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1360 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 24],
                                        &[libc::c_char; 24]>(b"scriptCodeArrayVariable\x00")).as_ptr(),
              b"ppsBlock != NULL\x00" as *const u8 as *const libc::c_char);
    };
    /*	ALLOC_ARRAYBLOCK(*ppsBlock, psArrayCode->size, psVar);
	ip = (*ppsBlock)->pCode;

	// Copy the already generated bit of code into the code block
	PUT_BLOCK(ip, psArrayCode);
	FREE_BLOCK(psArrayCode);*/
    // Check the variable is the correct type
    if (*psVar).dimensions != (*psArrayCode).dimensions {
        scr_error(b"Invalid number of array dimensions for this variable\x00"
                      as *const u8 as *const libc::c_char as
                      *mut libc::c_char);
        return CE_PARSE
    }
    (*psArrayCode).psArrayVar = psVar;
    *ppsBlock = psArrayCode;
    return CE_OK;
}
/* Generate code for a constant */
#[no_mangle]
pub unsafe extern "C" fn scriptCodeConstant(mut psConst: *mut CONST_SYMBOL,
                                            mut ppsBlock:
                                                *mut *mut CODE_BLOCK)
 -> CODE_ERROR 
 // Generated code
 {
    if !psConst.is_null() {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeConstant: Invalid constant symbol pointer\x00" as
                  *const u8 as *const libc::c_char);
    };
    if !psConst.is_null() {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1388 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 19],
                                        &[libc::c_char; 19]>(b"scriptCodeConstant\x00")).as_ptr(),
              b"psConst != NULL\x00" as *const u8 as *const libc::c_char);
    };
    if !ppsBlock.is_null() {
    } else {
        debug(LOG_ERROR,
              b"scriptCodeConstant: Invalid generated code block pointer\x00"
                  as *const u8 as *const libc::c_char);
    };
    if !ppsBlock.is_null() {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"script_parser.y\x00" as *const u8 as *const libc::c_char,
              1390 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 19],
                                        &[libc::c_char; 19]>(b"scriptCodeConstant\x00")).as_ptr(),
              b"ppsBlock != NULL\x00" as *const u8 as *const libc::c_char);
    };
    *ppsBlock =
        memMallocRelease(::std::mem::size_of::<CODE_BLOCK>() as libc::c_ulong)
            as *mut CODE_BLOCK;
    if (*ppsBlock).is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        return CE_MEMORY
    }
    (**ppsBlock).pCode =
        memMallocRelease((::std::mem::size_of::<OPCODE>() as
                              libc::c_ulong).wrapping_add(::std::mem::size_of::<UDWORD>()
                                                              as
                                                              libc::c_ulong))
            as *mut UDWORD;
    if (**ppsBlock).pCode.is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        memFreeRelease(*ppsBlock as *mut libc::c_void);
        *ppsBlock = 0 as *mut CODE_BLOCK;
        return CE_MEMORY
    }
    (**ppsBlock).size =
        (::std::mem::size_of::<OPCODE>() as
             libc::c_ulong).wrapping_add(::std::mem::size_of::<UDWORD>() as
                                             libc::c_ulong);
    ip = (**ppsBlock).pCode;
    (**ppsBlock).type_0 = (*psConst).type_0;
    /* Put the value onto the stack */
    match (*psConst).type_0 as libc::c_uint {
        0 => {
            *ip =
                VAL_BOOL as libc::c_int as UDWORD &
                    0xffffff as libc::c_int as libc::c_uint;
            *ip =
                (OP_PUSH as libc::c_int as UDWORD) << 24 as libc::c_int | *ip;
            ip = ip.offset(1 as libc::c_int as isize);
            *ip = (*psConst).bval as UDWORD;
            ip = ip.offset(1 as libc::c_int as isize)
        }
        1 => {
            *ip =
                VAL_INT as libc::c_int as UDWORD &
                    0xffffff as libc::c_int as libc::c_uint;
            *ip =
                (OP_PUSH as libc::c_int as UDWORD) << 24 as libc::c_int | *ip;
            ip = ip.offset(1 as libc::c_int as isize);
            *ip = (*psConst).ival as UDWORD;
            ip = ip.offset(1 as libc::c_int as isize)
        }
        2 => {
            *ip =
                VAL_STRING as libc::c_int as UDWORD &
                    0xffffff as libc::c_int as libc::c_uint;
            *ip =
                (OP_PUSH as libc::c_int as UDWORD) << 24 as libc::c_int | *ip;
            ip = ip.offset(1 as libc::c_int as isize);
            *ip = (*psConst).sval as UDWORD;
            ip = ip.offset(1 as libc::c_int as isize)
        }
        _ => {
            *ip =
                (*psConst).type_0 as UDWORD &
                    0xffffff as libc::c_int as libc::c_uint;
            *ip =
                (OP_PUSH as libc::c_int as UDWORD) << 24 as libc::c_int | *ip;
            ip = ip.offset(1 as libc::c_int as isize);
            *ip = (*psConst).oval as UDWORD;
            ip = ip.offset(1 as libc::c_int as isize)
        }
    }
    return CE_OK;
}
/* Generate code for getting a variables value */
#[no_mangle]
pub unsafe extern "C" fn scriptCodeVarGet(mut psVariable: *mut VAR_SYMBOL,
                                          mut ppsBlock: *mut *mut CODE_BLOCK)
 -> CODE_ERROR 
 // Generated code
 {
    let mut size: SDWORD = 0;
    size = ::std::mem::size_of::<OPCODE>() as libc::c_ulong as SDWORD;
    if (*psVariable).storage as libc::c_int == ST_EXTERN as libc::c_int {
        // Check there is a set function
        if (*psVariable).get.is_none() {
            scr_error(b"No get function for external variable\x00" as
                          *const u8 as *const libc::c_char as
                          *mut libc::c_char);
            return CE_PARSE
        }
        size =
            (size as
                 libc::c_uint).wrapping_add(::std::mem::size_of::<SCRIPT_VARFUNC>()
                                                as libc::c_ulong) as SDWORD as
                SDWORD
    }
    *ppsBlock =
        memMallocRelease(::std::mem::size_of::<CODE_BLOCK>() as libc::c_ulong)
            as *mut CODE_BLOCK;
    if (*ppsBlock).is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        return CE_MEMORY
    }
    (**ppsBlock).pCode = memMallocRelease(size as size_t) as *mut UDWORD;
    if (**ppsBlock).pCode.is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        memFreeRelease(*ppsBlock as *mut libc::c_void);
        *ppsBlock = 0 as *mut CODE_BLOCK;
        return CE_MEMORY
    }
    (**ppsBlock).size = size as UDWORD;
    ip = (**ppsBlock).pCode;
    (**ppsBlock).type_0 = (*psVariable).type_0;
    /* Code to get the value onto the stack */
    match (*psVariable).storage as libc::c_int {
        0 | 1 => {
            *ip =
                (*psVariable).index &
                    0xffffff as libc::c_int as
                        libc::c_uint; //opcode + event index
            *ip =
                (OP_PUSHGLOBAL as libc::c_int as UDWORD) << 24 as libc::c_int
                    | *ip;
            ip = ip.offset(1 as libc::c_int as isize)
        }
        4 => {
            *ip =
                (*psVariable).index & 0xffffff as libc::c_int as libc::c_uint;
            *ip =
                (OP_PUSHLOCAL as libc::c_int as UDWORD) << 24 as libc::c_int |
                    *ip;
            ip = ip.offset(1 as libc::c_int as isize)
        }
        3 => {
            *ip =
                (*psVariable).index & 0xffffff as libc::c_int as libc::c_uint;
            *ip =
                (OP_VARCALL as libc::c_int as UDWORD) << 24 as libc::c_int |
                    *ip;
            ip = ip.offset(1 as libc::c_int as isize);
            *ip =
                ::std::mem::transmute::<SCRIPT_VARFUNC,
                                        UDWORD>((*psVariable).get);
            ip = ip.offset(1 as libc::c_int as isize)
        }
        2 => {
            scr_error(b"Cannot use member variables in this context\x00" as
                          *const u8 as *const libc::c_char as
                          *mut libc::c_char);
            return CE_PARSE
        }
        _ => {
            scr_error(b"Unknown storage type\x00" as *const u8 as
                          *const libc::c_char as *mut libc::c_char);
            return CE_PARSE
        }
    }
    return CE_OK;
}
/* Generate code for getting a variables value */
#[no_mangle]
pub unsafe extern "C" fn scriptCodeVarRef(mut psVariable: *mut VAR_SYMBOL,
                                          mut ppsBlock: *mut *mut PARAM_BLOCK)
 -> CODE_ERROR 
 // Generated code
 {
    let mut size: SDWORD = 0;
    size =
        (::std::mem::size_of::<OPCODE>() as
             libc::c_ulong).wrapping_add(::std::mem::size_of::<SDWORD>() as
                                             libc::c_ulong) as SDWORD;
    *ppsBlock =
        memMallocRelease(::std::mem::size_of::<PARAM_BLOCK>() as
                             libc::c_ulong) as *mut PARAM_BLOCK;
    if (*ppsBlock).is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        return CE_MEMORY
    }
    (**ppsBlock).pCode = memMallocRelease(size as size_t) as *mut UDWORD;
    if (**ppsBlock).pCode.is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        memFreeRelease(*ppsBlock as *mut libc::c_void);
        *ppsBlock = 0 as *mut PARAM_BLOCK;
        return CE_MEMORY
    }
    (**ppsBlock).aParams =
        memMallocRelease((::std::mem::size_of::<INTERP_TYPE>() as
                              libc::c_ulong).wrapping_mul(1 as libc::c_int as
                                                              libc::c_uint))
            as *mut INTERP_TYPE;
    if (**ppsBlock).aParams.is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        memFreeRelease((**ppsBlock).pCode as *mut libc::c_void);
        (**ppsBlock).pCode = 0 as *mut UDWORD;
        memFreeRelease(*ppsBlock as *mut libc::c_void);
        *ppsBlock = 0 as *mut PARAM_BLOCK;
        return CE_MEMORY
    }
    (**ppsBlock).size = size as UDWORD;
    (**ppsBlock).numParams = 1 as libc::c_int as UDWORD;
    ip = (**ppsBlock).pCode;
    *(**ppsBlock).aParams.offset(0 as libc::c_int as isize) =
        ((*psVariable).type_0 as libc::c_uint |
             0x100000 as libc::c_int as libc::c_uint) as INTERP_TYPE;
    /* Code to get the value onto the stack */
    match (*psVariable).storage as libc::c_int {
        0 | 1 => {
            *ip =
                *(**ppsBlock).aParams.offset(0 as libc::c_int as isize) as
                    UDWORD & 0xffffff as libc::c_int as libc::c_uint;
            *ip =
                (OP_PUSHREF as libc::c_int as UDWORD) << 24 as libc::c_int |
                    *ip;
            ip = ip.offset(1 as libc::c_int as isize);
            *ip = (*psVariable).index;
            ip = ip.offset(1 as libc::c_int as isize)
        }
        4 => {
            *ip =
                *(**ppsBlock).aParams.offset(0 as libc::c_int as isize) as
                    UDWORD & 0xffffff as libc::c_int as libc::c_uint;
            *ip =
                (OP_PUSHLOCALREF as libc::c_int as UDWORD) <<
                    24 as libc::c_int | *ip;
            ip = ip.offset(1 as libc::c_int as isize);
            *ip = (*psVariable).index;
            ip = ip.offset(1 as libc::c_int as isize)
        }
        3 => {
            scr_error(b"Cannot use external variables in this context\x00" as
                          *const u8 as *const libc::c_char as
                          *mut libc::c_char);
            return CE_PARSE
        }
        2 => {
            scr_error(b"Cannot use member variables in this context\x00" as
                          *const u8 as *const libc::c_char as
                          *mut libc::c_char);
            return CE_PARSE
        }
        _ => {
            scr_error(b"Unknown storage type: %d\x00" as *const u8 as
                          *const libc::c_char as *mut libc::c_char,
                      (*psVariable).storage as libc::c_int);
            return CE_PARSE
        }
    }
    return CE_OK;
}
/* Generate the code for a trigger and store it in the trigger list */
#[no_mangle]
pub unsafe extern "C" fn scriptCodeTrigger(mut pIdent: *mut STRING,
                                           mut psCode: *mut CODE_BLOCK)
 -> CODE_ERROR {
    let mut psNewBlock: *mut CODE_BLOCK = 0 as *mut CODE_BLOCK;
    let mut line: UDWORD = 0;
    let mut pDummy: *mut STRING = 0 as *mut STRING;
    pIdent = pIdent;
    // Have to add the exit code to the end of the event
    psNewBlock =
        memMallocRelease(::std::mem::size_of::<CODE_BLOCK>() as libc::c_ulong)
            as *mut CODE_BLOCK;
    if psNewBlock.is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        return CE_MEMORY
    }
    (*psNewBlock).pCode =
        memMallocRelease((*psCode).size.wrapping_add(::std::mem::size_of::<OPCODE>()
                                                         as libc::c_ulong)) as
            *mut UDWORD;
    if (*psNewBlock).pCode.is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        memFreeRelease(psNewBlock as *mut libc::c_void);
        psNewBlock = 0 as *mut CODE_BLOCK;
        return CE_MEMORY
    }
    (*psNewBlock).size =
        (*psCode).size.wrapping_add(::std::mem::size_of::<OPCODE>() as
                                        libc::c_ulong);
    ip = (*psNewBlock).pCode;
    memcpy(ip as *mut libc::c_void, (*psCode).pCode as *const libc::c_void,
           (*psCode).size);
    ip = (ip as *mut UBYTE).offset((*psCode).size as isize) as *mut UDWORD;
    *ip = ((OP_EXIT as libc::c_int) << 24 as libc::c_int) as UDWORD;
    ip = ip.offset(1 as libc::c_int as isize);
    // Add the debug info
    if genDebugInfo != 0 {
        (*psNewBlock).psDebug =
            memMallocRelease((::std::mem::size_of::<SCRIPT_DEBUG>() as
                                  libc::c_ulong).wrapping_mul((*psCode).debugEntries.wrapping_add(1
                                                                                                      as
                                                                                                      libc::c_int
                                                                                                      as
                                                                                                      libc::c_uint)))
                as *mut SCRIPT_DEBUG;
        if (*psNewBlock).psDebug.is_null() {
            scr_error(b"Out of memory\x00" as *const u8 as *const libc::c_char
                          as *mut libc::c_char);
            return CE_MEMORY
        }
        memset((*psNewBlock).psDebug as *mut libc::c_void, 0 as libc::c_int,
               (::std::mem::size_of::<SCRIPT_DEBUG>() as
                    libc::c_ulong).wrapping_mul((*psCode).debugEntries.wrapping_add(1
                                                                                        as
                                                                                        libc::c_int
                                                                                        as
                                                                                        libc::c_uint)));
        (*psNewBlock).debugEntries =
            (*psCode).debugEntries.wrapping_add(1 as libc::c_int as
                                                    libc::c_uint) as UWORD as
                UDWORD
    } else {
        (*psNewBlock).psDebug = 0 as *mut SCRIPT_DEBUG;
        (*psNewBlock).debugEntries = 0 as libc::c_int as UDWORD
    }
    if genDebugInfo != 0 {
        memcpy((*psNewBlock).psDebug as *mut libc::c_void,
               (*psCode).psDebug as *const libc::c_void,
               (::std::mem::size_of::<SCRIPT_DEBUG>() as
                    libc::c_ulong).wrapping_mul((*psCode).debugEntries));
        (*psNewBlock).debugEntries = (*psCode).debugEntries
    }
    if genDebugInfo != 0 {
        /* Add debugging info for the EXIT instruction */
        scriptGetErrorData(&mut line as *mut UDWORD as *mut SDWORD,
                           &mut pDummy);
        (*(*psNewBlock).psDebug.offset((*psNewBlock).debugEntries as
                                           isize)).line = line;
        (*(*psNewBlock).psDebug.offset((*psNewBlock).debugEntries as
                                           isize)).offset =
            ip.wrapping_offset_from((*psNewBlock).pCode) as libc::c_int as
                UDWORD;
        (*psNewBlock).debugEntries =
            (*psNewBlock).debugEntries.wrapping_add(1)
    }
    memFreeRelease((*psCode).pCode as *mut libc::c_void);
    (*psCode).pCode = 0 as *mut UDWORD;
    memFreeRelease(psCode as *mut libc::c_void);
    psCode = 0 as *mut CODE_BLOCK;
    // Create the trigger
/*	if (!scriptAddTrigger(pIdent, psNewBlock))
	{
		return CE_MEMORY;
	}*/
    return CE_OK;
}
/* Generate the code for an event and store it in the event list */
#[no_mangle]
pub unsafe extern "C" fn scriptCodeEvent(mut psEvent: *mut EVENT_SYMBOL,
                                         mut psTrig: *mut TRIGGER_SYMBOL,
                                         mut psCode: *mut CODE_BLOCK)
 -> CODE_ERROR {
    let mut psNewBlock: *mut CODE_BLOCK = 0 as *mut CODE_BLOCK;
    let mut line: UDWORD = 0;
    let mut pDummy: *mut STRING = 0 as *mut STRING;
    // Have to add the exit code to the end of the event
    psNewBlock =
        memMallocRelease(::std::mem::size_of::<CODE_BLOCK>() as libc::c_ulong)
            as *mut CODE_BLOCK;
    if psNewBlock.is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        return CE_MEMORY
    }
    (*psNewBlock).pCode =
        memMallocRelease((*psCode).size.wrapping_add(::std::mem::size_of::<OPCODE>()
                                                         as libc::c_ulong)) as
            *mut UDWORD;
    if (*psNewBlock).pCode.is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        memFreeRelease(psNewBlock as *mut libc::c_void);
        psNewBlock = 0 as *mut CODE_BLOCK;
        return CE_MEMORY
    }
    (*psNewBlock).size =
        (*psCode).size.wrapping_add(::std::mem::size_of::<OPCODE>() as
                                        libc::c_ulong);
    ip = (*psNewBlock).pCode;
    memcpy(ip as *mut libc::c_void, (*psCode).pCode as *const libc::c_void,
           (*psCode).size);
    ip = (ip as *mut UBYTE).offset((*psCode).size as isize) as *mut UDWORD;
    *ip = ((OP_EXIT as libc::c_int) << 24 as libc::c_int) as UDWORD;
    ip = ip.offset(1 as libc::c_int as isize);
    // Add the debug info
    if genDebugInfo != 0 {
        (*psNewBlock).psDebug =
            memMallocRelease((::std::mem::size_of::<SCRIPT_DEBUG>() as
                                  libc::c_ulong).wrapping_mul((*psCode).debugEntries.wrapping_add(1
                                                                                                      as
                                                                                                      libc::c_int
                                                                                                      as
                                                                                                      libc::c_uint)))
                as *mut SCRIPT_DEBUG;
        if (*psNewBlock).psDebug.is_null() {
            scr_error(b"Out of memory\x00" as *const u8 as *const libc::c_char
                          as *mut libc::c_char);
            return CE_MEMORY
        }
        memset((*psNewBlock).psDebug as *mut libc::c_void, 0 as libc::c_int,
               (::std::mem::size_of::<SCRIPT_DEBUG>() as
                    libc::c_ulong).wrapping_mul((*psCode).debugEntries.wrapping_add(1
                                                                                        as
                                                                                        libc::c_int
                                                                                        as
                                                                                        libc::c_uint)));
        (*psNewBlock).debugEntries =
            (*psCode).debugEntries.wrapping_add(1 as libc::c_int as
                                                    libc::c_uint) as UWORD as
                UDWORD
    } else {
        (*psNewBlock).psDebug = 0 as *mut SCRIPT_DEBUG;
        (*psNewBlock).debugEntries = 0 as libc::c_int as UDWORD
    }
    if genDebugInfo != 0 {
        memcpy((*psNewBlock).psDebug as *mut libc::c_void,
               (*psCode).psDebug as *const libc::c_void,
               (::std::mem::size_of::<SCRIPT_DEBUG>() as
                    libc::c_ulong).wrapping_mul((*psCode).debugEntries));
        (*psNewBlock).debugEntries = (*psCode).debugEntries
    }
    if genDebugInfo != 0 {
        /* Add debugging info for the EXIT instruction */
        scriptGetErrorData(&mut line as *mut UDWORD as *mut SDWORD,
                           &mut pDummy);
        (*(*psNewBlock).psDebug.offset((*psNewBlock).debugEntries as
                                           isize)).line = line;
        (*(*psNewBlock).psDebug.offset((*psNewBlock).debugEntries as
                                           isize)).offset =
            ip.wrapping_offset_from((*psNewBlock).pCode) as libc::c_int as
                UDWORD;
        (*psNewBlock).debugEntries =
            (*psNewBlock).debugEntries.wrapping_add(1)
    }
    memFreeRelease((*psCode).pCode as *mut libc::c_void);
    (*psCode).pCode = 0 as *mut UDWORD;
    memFreeRelease(psCode as *mut libc::c_void);
    psCode = 0 as *mut CODE_BLOCK;
    // Create the event
    if scriptDefineEvent(psEvent, psNewBlock, (*psTrig).index as SDWORD) == 0
       {
        return CE_MEMORY
    }
    return CE_OK;
}
/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
   as returned by yylex.  */
static mut yytranslate: [yytype_int8; 322] =
    [0 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     29 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     76 as libc::c_int as yytype_int8, 77 as libc::c_int as yytype_int8,
     30 as libc::c_int as yytype_int8, 28 as libc::c_int as yytype_int8,
     75 as libc::c_int as yytype_int8, 27 as libc::c_int as yytype_int8,
     81 as libc::c_int as yytype_int8, 31 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 72 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 80 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 73 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 74 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 78 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 79 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     3 as libc::c_int as yytype_int8, 4 as libc::c_int as yytype_int8,
     5 as libc::c_int as yytype_int8, 6 as libc::c_int as yytype_int8,
     7 as libc::c_int as yytype_int8, 8 as libc::c_int as yytype_int8,
     9 as libc::c_int as yytype_int8, 10 as libc::c_int as yytype_int8,
     11 as libc::c_int as yytype_int8, 12 as libc::c_int as yytype_int8,
     13 as libc::c_int as yytype_int8, 14 as libc::c_int as yytype_int8,
     15 as libc::c_int as yytype_int8, 16 as libc::c_int as yytype_int8,
     17 as libc::c_int as yytype_int8, 18 as libc::c_int as yytype_int8,
     19 as libc::c_int as yytype_int8, 20 as libc::c_int as yytype_int8,
     21 as libc::c_int as yytype_int8, 22 as libc::c_int as yytype_int8,
     23 as libc::c_int as yytype_int8, 24 as libc::c_int as yytype_int8,
     25 as libc::c_int as yytype_int8, 26 as libc::c_int as yytype_int8,
     32 as libc::c_int as yytype_int8, 33 as libc::c_int as yytype_int8,
     34 as libc::c_int as yytype_int8, 35 as libc::c_int as yytype_int8,
     36 as libc::c_int as yytype_int8, 37 as libc::c_int as yytype_int8,
     38 as libc::c_int as yytype_int8, 39 as libc::c_int as yytype_int8,
     40 as libc::c_int as yytype_int8, 41 as libc::c_int as yytype_int8,
     42 as libc::c_int as yytype_int8, 43 as libc::c_int as yytype_int8,
     44 as libc::c_int as yytype_int8, 45 as libc::c_int as yytype_int8,
     46 as libc::c_int as yytype_int8, 47 as libc::c_int as yytype_int8,
     48 as libc::c_int as yytype_int8, 49 as libc::c_int as yytype_int8,
     50 as libc::c_int as yytype_int8, 51 as libc::c_int as yytype_int8,
     52 as libc::c_int as yytype_int8, 53 as libc::c_int as yytype_int8,
     54 as libc::c_int as yytype_int8, 55 as libc::c_int as yytype_int8,
     56 as libc::c_int as yytype_int8, 57 as libc::c_int as yytype_int8,
     58 as libc::c_int as yytype_int8, 59 as libc::c_int as yytype_int8,
     60 as libc::c_int as yytype_int8, 61 as libc::c_int as yytype_int8,
     62 as libc::c_int as yytype_int8, 63 as libc::c_int as yytype_int8,
     64 as libc::c_int as yytype_int8, 65 as libc::c_int as yytype_int8,
     66 as libc::c_int as yytype_int8, 67 as libc::c_int as yytype_int8,
     68 as libc::c_int as yytype_int8, 69 as libc::c_int as yytype_int8,
     70 as libc::c_int as yytype_int8, 71 as libc::c_int as yytype_int8];
/* psCurEvent->bFunction = TRUE; */
							/* psEvent->retType = $2; */
/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
     STATE-NUM.  */
//debug(LOG_SCRIPT, "func_subdecl:FUNCTION EVENT_SYM. ");
static mut yypact: [yytype_int16; 403] =
    [40 as libc::c_int as yytype_int16, 36 as libc::c_int as yytype_int16,
     76 as libc::c_int as yytype_int16, 23 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16, 11 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16, 18 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16, 51 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16, 84 as libc::c_int as yytype_int16,
     -(48 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     138 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16, 78 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16, 84 as libc::c_int as yytype_int16,
     124 as libc::c_int as yytype_int16, 75 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     134 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16, 92 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16, 95 as libc::c_int as yytype_int16,
     149 as libc::c_int as yytype_int16, -(6 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16, 56 as libc::c_int as yytype_int16,
     -(38 as libc::c_int) as yytype_int16, 120 as libc::c_int as yytype_int16,
     126 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     147 as libc::c_int as yytype_int16, 206 as libc::c_int as yytype_int16,
     777 as libc::c_int as yytype_int16, 339 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     843 as libc::c_int as yytype_int16, -(24 as libc::c_int) as yytype_int16,
     177 as libc::c_int as yytype_int16, 51 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     162 as libc::c_int as yytype_int16, 169 as libc::c_int as yytype_int16,
     184 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     939 as libc::c_int as yytype_int16, 1417 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     179 as libc::c_int as yytype_int16, 179 as libc::c_int as yytype_int16,
     179 as libc::c_int as yytype_int16, 179 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     205 as libc::c_int as yytype_int16, 216 as libc::c_int as yytype_int16,
     221 as libc::c_int as yytype_int16, 223 as libc::c_int as yytype_int16,
     226 as libc::c_int as yytype_int16, 229 as libc::c_int as yytype_int16,
     230 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     207 as libc::c_int as yytype_int16, 939 as libc::c_int as yytype_int16,
     203 as libc::c_int as yytype_int16, 745 as libc::c_int as yytype_int16,
     12 as libc::c_int as yytype_int16, 47 as libc::c_int as yytype_int16,
     -(4 as libc::c_int) as yytype_int16, 65 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     231 as libc::c_int as yytype_int16, 236 as libc::c_int as yytype_int16,
     238 as libc::c_int as yytype_int16, 387 as libc::c_int as yytype_int16,
     241 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(28 as libc::c_int) as yytype_int16, 9 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     1346 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     282 as libc::c_int as yytype_int16, 292 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     1417 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     246 as libc::c_int as yytype_int16, 46 as libc::c_int as yytype_int16,
     1417 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     260 as libc::c_int as yytype_int16, 260 as libc::c_int as yytype_int16,
     260 as libc::c_int as yytype_int16, 260 as libc::c_int as yytype_int16,
     85 as libc::c_int as yytype_int16, 85 as libc::c_int as yytype_int16,
     85 as libc::c_int as yytype_int16, 85 as libc::c_int as yytype_int16,
     85 as libc::c_int as yytype_int16, 85 as libc::c_int as yytype_int16,
     85 as libc::c_int as yytype_int16, 85 as libc::c_int as yytype_int16,
     -(2 as libc::c_int) as yytype_int16, 33 as libc::c_int as yytype_int16,
     263 as libc::c_int as yytype_int16, 1417 as libc::c_int as yytype_int16,
     1417 as libc::c_int as yytype_int16, 1417 as libc::c_int as yytype_int16,
     1417 as libc::c_int as yytype_int16, 1417 as libc::c_int as yytype_int16,
     1417 as libc::c_int as yytype_int16, 1417 as libc::c_int as yytype_int16,
     1417 as libc::c_int as yytype_int16, 1417 as libc::c_int as yytype_int16,
     1417 as libc::c_int as yytype_int16, 939 as libc::c_int as yytype_int16,
     939 as libc::c_int as yytype_int16, 939 as libc::c_int as yytype_int16,
     939 as libc::c_int as yytype_int16, 302 as libc::c_int as yytype_int16,
     1287 as libc::c_int as yytype_int16, 1287 as libc::c_int as yytype_int16,
     172 as libc::c_int as yytype_int16, 172 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     259 as libc::c_int as yytype_int16, 261 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     305 as libc::c_int as yytype_int16, 264 as libc::c_int as yytype_int16,
     311 as libc::c_int as yytype_int16, 270 as libc::c_int as yytype_int16,
     639 as libc::c_int as yytype_int16, 262 as libc::c_int as yytype_int16,
     273 as libc::c_int as yytype_int16, 278 as libc::c_int as yytype_int16,
     275 as libc::c_int as yytype_int16, 276 as libc::c_int as yytype_int16,
     279 as libc::c_int as yytype_int16, 280 as libc::c_int as yytype_int16,
     283 as libc::c_int as yytype_int16, 284 as libc::c_int as yytype_int16,
     289 as libc::c_int as yytype_int16, 291 as libc::c_int as yytype_int16,
     293 as libc::c_int as yytype_int16, 303 as libc::c_int as yytype_int16,
     308 as libc::c_int as yytype_int16, 309 as libc::c_int as yytype_int16,
     310 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     1382 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     286 as libc::c_int as yytype_int16, 296 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     380 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     316 as libc::c_int as yytype_int16, 317 as libc::c_int as yytype_int16,
     332 as libc::c_int as yytype_int16, 333 as libc::c_int as yytype_int16,
     334 as libc::c_int as yytype_int16, 337 as libc::c_int as yytype_int16,
     342 as libc::c_int as yytype_int16, 344 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     139 as libc::c_int as yytype_int16, 43 as libc::c_int as yytype_int16,
     1417 as libc::c_int as yytype_int16, 168 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     355 as libc::c_int as yytype_int16, 891 as libc::c_int as yytype_int16,
     17 as libc::c_int as yytype_int16, -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     745 as libc::c_int as yytype_int16, 404 as libc::c_int as yytype_int16,
     204 as libc::c_int as yytype_int16, 47 as libc::c_int as yytype_int16,
     -(4 as libc::c_int) as yytype_int16, 58 as libc::c_int as yytype_int16,
     59 as libc::c_int as yytype_int16, 81 as libc::c_int as yytype_int16,
     82 as libc::c_int as yytype_int16, 97 as libc::c_int as yytype_int16,
     102 as libc::c_int as yytype_int16, 360 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     301 as libc::c_int as yytype_int16, 301 as libc::c_int as yytype_int16,
     301 as libc::c_int as yytype_int16, 301 as libc::c_int as yytype_int16,
     301 as libc::c_int as yytype_int16, 301 as libc::c_int as yytype_int16,
     69 as libc::c_int as yytype_int16, 69 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     129 as libc::c_int as yytype_int16, 129 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     181 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     246 as libc::c_int as yytype_int16, 388 as libc::c_int as yytype_int16,
     246 as libc::c_int as yytype_int16, 51 as libc::c_int as yytype_int16,
     51 as libc::c_int as yytype_int16, 362 as libc::c_int as yytype_int16,
     434 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16, 51 as libc::c_int as yytype_int16,
     84 as libc::c_int as yytype_int16, -(317 as libc::c_int) as yytype_int16,
     373 as libc::c_int as yytype_int16, 745 as libc::c_int as yytype_int16,
     404 as libc::c_int as yytype_int16, 204 as libc::c_int as yytype_int16,
     -(4 as libc::c_int) as yytype_int16, 939 as libc::c_int as yytype_int16,
     939 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     416 as libc::c_int as yytype_int16, 1287 as libc::c_int as yytype_int16,
     939 as libc::c_int as yytype_int16, 1417 as libc::c_int as yytype_int16,
     172 as libc::c_int as yytype_int16, 200 as libc::c_int as yytype_int16,
     85 as libc::c_int as yytype_int16, 85 as libc::c_int as yytype_int16,
     85 as libc::c_int as yytype_int16, 85 as libc::c_int as yytype_int16,
     85 as libc::c_int as yytype_int16, 85 as libc::c_int as yytype_int16,
     85 as libc::c_int as yytype_int16, 372 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(11 as libc::c_int) as yytype_int16,
     1417 as libc::c_int as yytype_int16, 939 as libc::c_int as yytype_int16,
     1287 as libc::c_int as yytype_int16, 172 as libc::c_int as yytype_int16,
     1417 as libc::c_int as yytype_int16, 939 as libc::c_int as yytype_int16,
     172 as libc::c_int as yytype_int16, 1287 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     164 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16, 85 as libc::c_int as yytype_int16,
     -(21 as libc::c_int) as yytype_int16, 85 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     891 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     1346 as libc::c_int as yytype_int16, 1346 as libc::c_int as yytype_int16,
     51 as libc::c_int as yytype_int16, 1346 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16, 44 as libc::c_int as yytype_int16,
     83 as libc::c_int as yytype_int16, 375 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     204 as libc::c_int as yytype_int16, 301 as libc::c_int as yytype_int16,
     246 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     200 as libc::c_int as yytype_int16, 404 as libc::c_int as yytype_int16,
     106 as libc::c_int as yytype_int16, 109 as libc::c_int as yytype_int16,
     113 as libc::c_int as yytype_int16, 170 as libc::c_int as yytype_int16,
     189 as libc::c_int as yytype_int16, 190 as libc::c_int as yytype_int16,
     195 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     1382 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     301 as libc::c_int as yytype_int16, 204 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     246 as libc::c_int as yytype_int16, 301 as libc::c_int as yytype_int16,
     204 as libc::c_int as yytype_int16, 246 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     202 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     745 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     204 as libc::c_int as yytype_int16, 1000 as libc::c_int as yytype_int16,
     1052 as libc::c_int as yytype_int16, 1346 as libc::c_int as yytype_int16,
     1382 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     381 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     382 as libc::c_int as yytype_int16, 384 as libc::c_int as yytype_int16,
     389 as libc::c_int as yytype_int16, 1104 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     1156 as libc::c_int as yytype_int16, 383 as libc::c_int as yytype_int16,
     376 as libc::c_int as yytype_int16, 386 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     1382 as libc::c_int as yytype_int16, 1382 as libc::c_int as yytype_int16,
     1208 as libc::c_int as yytype_int16, 1260 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16];
/* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
     Performed when YYTABLE does not specify something else to do.  Zero
     means the default is an error.  */
static mut yydefact: [yytype_uint8; 403] =
    [4 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 8 as libc::c_int as yytype_uint8,
     5 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     1 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     6 as libc::c_int as yytype_uint8, 2 as libc::c_int as yytype_uint8,
     9 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 7 as libc::c_int as yytype_uint8,
     13 as libc::c_int as yytype_uint8, 14 as libc::c_int as yytype_uint8,
     12 as libc::c_int as yytype_uint8, 22 as libc::c_int as yytype_uint8,
     10 as libc::c_int as yytype_uint8, 18 as libc::c_int as yytype_uint8,
     20 as libc::c_int as yytype_uint8, 11 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 23 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 16 as libc::c_int as yytype_uint8,
     19 as libc::c_int as yytype_uint8, 21 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 24 as libc::c_int as yytype_uint8,
     3 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     32 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 34 as libc::c_int as yytype_uint8,
     35 as libc::c_int as yytype_uint8, 33 as libc::c_int as yytype_uint8,
     59 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     8 as libc::c_int as yytype_uint8, 15 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 179 as libc::c_int as yytype_uint8,
     28 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 162 as libc::c_int as yytype_uint8,
     140 as libc::c_int as yytype_uint8, 173 as libc::c_int as yytype_uint8,
     158 as libc::c_int as yytype_uint8, 136 as libc::c_int as yytype_uint8,
     181 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 159 as libc::c_int as yytype_uint8,
     137 as libc::c_int as yytype_uint8, 174 as libc::c_int as yytype_uint8,
     182 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     178 as libc::c_int as yytype_uint8, 180 as libc::c_int as yytype_uint8,
     29 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     138 as libc::c_int as yytype_uint8, 160 as libc::c_int as yytype_uint8,
     175 as libc::c_int as yytype_uint8, 185 as libc::c_int as yytype_uint8,
     139 as libc::c_int as yytype_uint8, 161 as libc::c_int as yytype_uint8,
     186 as libc::c_int as yytype_uint8, 176 as libc::c_int as yytype_uint8,
     42 as libc::c_int as yytype_uint8, 36 as libc::c_int as yytype_uint8,
     37 as libc::c_int as yytype_uint8, 38 as libc::c_int as yytype_uint8,
     39 as libc::c_int as yytype_uint8, 40 as libc::c_int as yytype_uint8,
     41 as libc::c_int as yytype_uint8, 43 as libc::c_int as yytype_uint8,
     179 as libc::c_int as yytype_uint8, 178 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     55 as libc::c_int as yytype_uint8, 51 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     60 as libc::c_int as yytype_uint8, 67 as libc::c_int as yytype_uint8,
     17 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 154 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 132 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 193 as libc::c_int as yytype_uint8,
     198 as libc::c_int as yytype_uint8, 196 as libc::c_int as yytype_uint8,
     195 as libc::c_int as yytype_uint8, 197 as libc::c_int as yytype_uint8,
     105 as libc::c_int as yytype_uint8, 105 as libc::c_int as yytype_uint8,
     105 as libc::c_int as yytype_uint8, 105 as libc::c_int as yytype_uint8,
     105 as libc::c_int as yytype_uint8, 105 as libc::c_int as yytype_uint8,
     105 as libc::c_int as yytype_uint8, 105 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     187 as libc::c_int as yytype_uint8, 189 as libc::c_int as yytype_uint8,
     188 as libc::c_int as yytype_uint8, 190 as libc::c_int as yytype_uint8,
     191 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 62 as libc::c_int as yytype_uint8,
     50 as libc::c_int as yytype_uint8, 45 as libc::c_int as yytype_uint8,
     44 as libc::c_int as yytype_uint8, 47 as libc::c_int as yytype_uint8,
     46 as libc::c_int as yytype_uint8, 49 as libc::c_int as yytype_uint8,
     48 as libc::c_int as yytype_uint8, 53 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 56 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     181 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 69 as libc::c_int as yytype_uint8,
     81 as libc::c_int as yytype_uint8, 67 as libc::c_int as yytype_uint8,
     72 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 78 as libc::c_int as yytype_uint8,
     119 as libc::c_int as yytype_uint8, 121 as libc::c_int as yytype_uint8,
     79 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     185 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 186 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 26 as libc::c_int as yytype_uint8,
     27 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 140 as libc::c_int as yytype_uint8,
     148 as libc::c_int as yytype_uint8, 136 as libc::c_int as yytype_uint8,
     146 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     106 as libc::c_int as yytype_uint8, 113 as libc::c_int as yytype_uint8,
     108 as libc::c_int as yytype_uint8, 110 as libc::c_int as yytype_uint8,
     109 as libc::c_int as yytype_uint8, 111 as libc::c_int as yytype_uint8,
     112 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 30 as libc::c_int as yytype_uint8,
     133 as libc::c_int as yytype_uint8, 155 as libc::c_int as yytype_uint8,
     31 as libc::c_int as yytype_uint8, 163 as libc::c_int as yytype_uint8,
     166 as libc::c_int as yytype_uint8, 170 as libc::c_int as yytype_uint8,
     169 as libc::c_int as yytype_uint8, 171 as libc::c_int as yytype_uint8,
     172 as libc::c_int as yytype_uint8, 129 as libc::c_int as yytype_uint8,
     128 as libc::c_int as yytype_uint8, 130 as libc::c_int as yytype_uint8,
     131 as libc::c_int as yytype_uint8, 152 as libc::c_int as yytype_uint8,
     153 as libc::c_int as yytype_uint8, 150 as libc::c_int as yytype_uint8,
     151 as libc::c_int as yytype_uint8, 25 as libc::c_int as yytype_uint8,
     164 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     167 as libc::c_int as yytype_uint8, 165 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 168 as libc::c_int as yytype_uint8,
     8 as libc::c_int as yytype_uint8, 8 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     52 as libc::c_int as yytype_uint8, 8 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 68 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 83 as libc::c_int as yytype_uint8,
     84 as libc::c_int as yytype_uint8, 85 as libc::c_int as yytype_uint8,
     86 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 80 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     105 as libc::c_int as yytype_uint8, 105 as libc::c_int as yytype_uint8,
     105 as libc::c_int as yytype_uint8, 105 as libc::c_int as yytype_uint8,
     105 as libc::c_int as yytype_uint8, 105 as libc::c_int as yytype_uint8,
     105 as libc::c_int as yytype_uint8, 81 as libc::c_int as yytype_uint8,
     73 as libc::c_int as yytype_uint8, 74 as libc::c_int as yytype_uint8,
     75 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     192 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     117 as libc::c_int as yytype_uint8, 115 as libc::c_int as yytype_uint8,
     114 as libc::c_int as yytype_uint8, 118 as libc::c_int as yytype_uint8,
     116 as libc::c_int as yytype_uint8, 105 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     156 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     134 as libc::c_int as yytype_uint8, 177 as libc::c_int as yytype_uint8,
     183 as libc::c_int as yytype_uint8, 157 as libc::c_int as yytype_uint8,
     135 as libc::c_int as yytype_uint8, 184 as libc::c_int as yytype_uint8,
     67 as libc::c_int as yytype_uint8, 67 as libc::c_int as yytype_uint8,
     8 as libc::c_int as yytype_uint8, 67 as libc::c_int as yytype_uint8,
     54 as libc::c_int as yytype_uint8, 70 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 91 as libc::c_int as yytype_uint8,
     88 as libc::c_int as yytype_uint8, 87 as libc::c_int as yytype_uint8,
     90 as libc::c_int as yytype_uint8, 149 as libc::c_int as yytype_uint8,
     147 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     89 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     65 as libc::c_int as yytype_uint8, 67 as libc::c_int as yytype_uint8,
     120 as libc::c_int as yytype_uint8, 122 as libc::c_int as yytype_uint8,
     92 as libc::c_int as yytype_uint8, 93 as libc::c_int as yytype_uint8,
     94 as libc::c_int as yytype_uint8, 95 as libc::c_int as yytype_uint8,
     96 as libc::c_int as yytype_uint8, 97 as libc::c_int as yytype_uint8,
     99 as libc::c_int as yytype_uint8, 98 as libc::c_int as yytype_uint8,
     194 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     144 as libc::c_int as yytype_uint8, 107 as libc::c_int as yytype_uint8,
     142 as libc::c_int as yytype_uint8, 141 as libc::c_int as yytype_uint8,
     143 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 67 as libc::c_int as yytype_uint8,
     67 as libc::c_int as yytype_uint8, 126 as libc::c_int as yytype_uint8,
     124 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     104 as libc::c_int as yytype_uint8, 101 as libc::c_int as yytype_uint8,
     100 as libc::c_int as yytype_uint8, 102 as libc::c_int as yytype_uint8,
     103 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     145 as libc::c_int as yytype_uint8, 64 as libc::c_int as yytype_uint8,
     61 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     81 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 82 as libc::c_int as yytype_uint8,
     76 as libc::c_int as yytype_uint8, 77 as libc::c_int as yytype_uint8,
     123 as libc::c_int as yytype_uint8, 63 as libc::c_int as yytype_uint8,
     66 as libc::c_int as yytype_uint8, 67 as libc::c_int as yytype_uint8,
     67 as libc::c_int as yytype_uint8, 0 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 127 as libc::c_int as yytype_uint8,
     125 as libc::c_int as yytype_uint8];
/* YYPGOTO[NTERM-NUM].  */
//debug(LOG_SCRIPT, "argument_decl_head 1 ");
static mut yypgoto: [yytype_int16; 59] =
    [-(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     462 as libc::c_int as yytype_int16, -(41 as libc::c_int) as yytype_int16,
     -(9 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(18 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     419 as libc::c_int as yytype_int16, 443 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     304 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     445 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(192 as libc::c_int) as yytype_int16,
     -(316 as libc::c_int) as yytype_int16,
     -(194 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(91 as libc::c_int) as yytype_int16, 151 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     187 as libc::c_int as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16,
     437 as libc::c_int as yytype_int16,
     -(178 as libc::c_int) as yytype_int16,
     469 as libc::c_int as yytype_int16, 450 as libc::c_int as yytype_int16,
     257 as libc::c_int as yytype_int16, 495 as libc::c_int as yytype_int16,
     -(114 as libc::c_int) as yytype_int16,
     -(109 as libc::c_int) as yytype_int16,
     -(76 as libc::c_int) as yytype_int16,
     -(26 as libc::c_int) as yytype_int16,
     -(317 as libc::c_int) as yytype_int16, 37 as libc::c_int as yytype_int16,
     -(17 as libc::c_int) as yytype_int16, 49 as libc::c_int as yytype_int16,
     72 as libc::c_int as yytype_int16, 131 as libc::c_int as yytype_int16];
//debug(LOG_SCRIPT, "argument_decl_head 10 ");
/* YYDEFGOTO[NTERM-NUM].  */
/* handle ident part */
static mut yydefgoto: [yytype_int16; 59] =
    [-(1 as libc::c_int) as yytype_int16, 2 as libc::c_int as yytype_int16,
     17 as libc::c_int as yytype_int16, 3 as libc::c_int as yytype_int16,
     4 as libc::c_int as yytype_int16, 9 as libc::c_int as yytype_int16,
     10 as libc::c_int as yytype_int16, 11 as libc::c_int as yytype_int16,
     27 as libc::c_int as yytype_int16, 28 as libc::c_int as yytype_int16,
     20 as libc::c_int as yytype_int16, 12 as libc::c_int as yytype_int16,
     24 as libc::c_int as yytype_int16, 84 as libc::c_int as yytype_int16,
     25 as libc::c_int as yytype_int16, 34 as libc::c_int as yytype_int16,
     35 as libc::c_int as yytype_int16, 105 as libc::c_int as yytype_int16,
     36 as libc::c_int as yytype_int16, 111 as libc::c_int as yytype_int16,
     112 as libc::c_int as yytype_int16, 113 as libc::c_int as yytype_int16,
     49 as libc::c_int as yytype_int16, 37 as libc::c_int as yytype_int16,
     38 as libc::c_int as yytype_int16, 268 as libc::c_int as yytype_int16,
     197 as libc::c_int as yytype_int16, 198 as libc::c_int as yytype_int16,
     199 as libc::c_int as yytype_int16, 200 as libc::c_int as yytype_int16,
     274 as libc::c_int as yytype_int16, 201 as libc::c_int as yytype_int16,
     202 as libc::c_int as yytype_int16, 227 as libc::c_int as yytype_int16,
     228 as libc::c_int as yytype_int16, 229 as libc::c_int as yytype_int16,
     203 as libc::c_int as yytype_int16, 204 as libc::c_int as yytype_int16,
     352 as libc::c_int as yytype_int16, 205 as libc::c_int as yytype_int16,
     390 as libc::c_int as yytype_int16, 206 as libc::c_int as yytype_int16,
     389 as libc::c_int as yytype_int16, 230 as libc::c_int as yytype_int16,
     231 as libc::c_int as yytype_int16, 232 as libc::c_int as yytype_int16,
     233 as libc::c_int as yytype_int16, 122 as libc::c_int as yytype_int16,
     89 as libc::c_int as yytype_int16, 90 as libc::c_int as yytype_int16,
     91 as libc::c_int as yytype_int16, 92 as libc::c_int as yytype_int16,
     93 as libc::c_int as yytype_int16, 125 as libc::c_int as yytype_int16,
     126 as libc::c_int as yytype_int16, 94 as libc::c_int as yytype_int16,
     95 as libc::c_int as yytype_int16, 96 as libc::c_int as yytype_int16,
     97 as libc::c_int as yytype_int16];
/* return the variable type */
					/* $$ = psCurrVDecl; */
/* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
     positive, shift that token.  If negative, reduce the rule whose
     number is the opposite.  If YYTABLE_NINF, syntax error.  */
/* not needed? */
static mut yytable: [yytype_int16; 1494] =
    [18 as libc::c_int as yytype_int16, 207 as libc::c_int as yytype_int16,
     276 as libc::c_int as yytype_int16, 182 as libc::c_int as yytype_int16,
     29 as libc::c_int as yytype_int16, 296 as libc::c_int as yytype_int16,
     208 as libc::c_int as yytype_int16, 295 as libc::c_int as yytype_int16,
     319 as libc::c_int as yytype_int16, 115 as libc::c_int as yytype_int16,
     369 as libc::c_int as yytype_int16, 370 as libc::c_int as yytype_int16,
     109 as libc::c_int as yytype_int16, 372 as libc::c_int as yytype_int16,
     158 as libc::c_int as yytype_int16, 159 as libc::c_int as yytype_int16,
     141 as libc::c_int as yytype_int16, 142 as libc::c_int as yytype_int16,
     143 as libc::c_int as yytype_int16, 144 as libc::c_int as yytype_int16,
     145 as libc::c_int as yytype_int16, 146 as libc::c_int as yytype_int16,
     14 as libc::c_int as yytype_int16, 15 as libc::c_int as yytype_int16,
     21 as libc::c_int as yytype_int16, 147 as libc::c_int as yytype_int16,
     148 as libc::c_int as yytype_int16, 22 as libc::c_int as yytype_int16,
     149 as libc::c_int as yytype_int16, 150 as libc::c_int as yytype_int16,
     151 as libc::c_int as yytype_int16, 152 as libc::c_int as yytype_int16,
     43 as libc::c_int as yytype_int16, 1 as libc::c_int as yytype_int16,
     46 as libc::c_int as yytype_int16, 383 as libc::c_int as yytype_int16,
     153 as libc::c_int as yytype_int16, 154 as libc::c_int as yytype_int16,
     47 as libc::c_int as yytype_int16, 209 as libc::c_int as yytype_int16,
     235 as libc::c_int as yytype_int16, 236 as libc::c_int as yytype_int16,
     237 as libc::c_int as yytype_int16, 238 as libc::c_int as yytype_int16,
     239 as libc::c_int as yytype_int16, 240 as libc::c_int as yytype_int16,
     241 as libc::c_int as yytype_int16, 176 as libc::c_int as yytype_int16,
     316 as libc::c_int as yytype_int16, 177 as libc::c_int as yytype_int16,
     1 as libc::c_int as yytype_int16, 151 as libc::c_int as yytype_int16,
     152 as libc::c_int as yytype_int16, 110 as libc::c_int as yytype_int16,
     16 as libc::c_int as yytype_int16, 387 as libc::c_int as yytype_int16,
     364 as libc::c_int as yytype_int16, 153 as libc::c_int as yytype_int16,
     154 as libc::c_int as yytype_int16, 31 as libc::c_int as yytype_int16,
     7 as libc::c_int as yytype_int16, 32 as libc::c_int as yytype_int16,
     151 as libc::c_int as yytype_int16, 152 as libc::c_int as yytype_int16,
     44 as libc::c_int as yytype_int16, 156 as libc::c_int as yytype_int16,
     157 as libc::c_int as yytype_int16, 351 as libc::c_int as yytype_int16,
     153 as libc::c_int as yytype_int16, 154 as libc::c_int as yytype_int16,
     147 as libc::c_int as yytype_int16, 148 as libc::c_int as yytype_int16,
     5 as libc::c_int as yytype_int16, 149 as libc::c_int as yytype_int16,
     150 as libc::c_int as yytype_int16, 242 as libc::c_int as yytype_int16,
     6 as libc::c_int as yytype_int16, 160 as libc::c_int as yytype_int16,
     31 as libc::c_int as yytype_int16, 23 as libc::c_int as yytype_int16,
     32 as libc::c_int as yytype_int16, 399 as libc::c_int as yytype_int16,
     400 as libc::c_int as yytype_int16, 13 as libc::c_int as yytype_int16,
     178 as libc::c_int as yytype_int16, 207 as libc::c_int as yytype_int16,
     179 as libc::c_int as yytype_int16, 155 as libc::c_int as yytype_int16,
     7 as libc::c_int as yytype_int16, 210 as libc::c_int as yytype_int16,
     208 as libc::c_int as yytype_int16, 175 as libc::c_int as yytype_int16,
     317 as libc::c_int as yytype_int16, 55 as libc::c_int as yytype_int16,
     318 as libc::c_int as yytype_int16, 162 as libc::c_int as yytype_int16,
     220 as libc::c_int as yytype_int16, 164 as libc::c_int as yytype_int16,
     211 as libc::c_int as yytype_int16, 149 as libc::c_int as yytype_int16,
     150 as libc::c_int as yytype_int16, 151 as libc::c_int as yytype_int16,
     152 as libc::c_int as yytype_int16, 127 as libc::c_int as yytype_int16,
     128 as libc::c_int as yytype_int16, 129 as libc::c_int as yytype_int16,
     18 as libc::c_int as yytype_int16, 153 as libc::c_int as yytype_int16,
     154 as libc::c_int as yytype_int16, 342 as libc::c_int as yytype_int16,
     243 as libc::c_int as yytype_int16, 57 as libc::c_int as yytype_int16,
     58 as libc::c_int as yytype_int16, 161 as libc::c_int as yytype_int16,
     162 as libc::c_int as yytype_int16, 163 as libc::c_int as yytype_int16,
     164 as libc::c_int as yytype_int16, 308 as libc::c_int as yytype_int16,
     59 as libc::c_int as yytype_int16, 221 as libc::c_int as yytype_int16,
     222 as libc::c_int as yytype_int16, 373 as libc::c_int as yytype_int16,
     19 as libc::c_int as yytype_int16, 209 as libc::c_int as yytype_int16,
     61 as libc::c_int as yytype_int16, 62 as libc::c_int as yytype_int16,
     223 as libc::c_int as yytype_int16, 64 as libc::c_int as yytype_int16,
     224 as libc::c_int as yytype_int16, 65 as libc::c_int as yytype_int16,
     66 as libc::c_int as yytype_int16, 67 as libc::c_int as yytype_int16,
     68 as libc::c_int as yytype_int16, 317 as libc::c_int as yytype_int16,
     317 as libc::c_int as yytype_int16, 320 as libc::c_int as yytype_int16,
     321 as libc::c_int as yytype_int16, 69 as libc::c_int as yytype_int16,
     70 as libc::c_int as yytype_int16, 71 as libc::c_int as yytype_int16,
     72 as libc::c_int as yytype_int16, 367 as libc::c_int as yytype_int16,
     23 as libc::c_int as yytype_int16, 73 as libc::c_int as yytype_int16,
     74 as libc::c_int as yytype_int16, 75 as libc::c_int as yytype_int16,
     76 as libc::c_int as yytype_int16, 151 as libc::c_int as yytype_int16,
     152 as libc::c_int as yytype_int16, 77 as libc::c_int as yytype_int16,
     78 as libc::c_int as yytype_int16, 26 as libc::c_int as yytype_int16,
     79 as libc::c_int as yytype_int16, 225 as libc::c_int as yytype_int16,
     80 as libc::c_int as yytype_int16, 81 as libc::c_int as yytype_int16,
     317 as libc::c_int as yytype_int16, 317 as libc::c_int as yytype_int16,
     322 as libc::c_int as yytype_int16, 323 as libc::c_int as yytype_int16,
     374 as libc::c_int as yytype_int16, 226 as libc::c_int as yytype_int16,
     30 as libc::c_int as yytype_int16, 316 as libc::c_int as yytype_int16,
     212 as libc::c_int as yytype_int16, 40 as libc::c_int as yytype_int16,
     147 as libc::c_int as yytype_int16, 148 as libc::c_int as yytype_int16,
     39 as libc::c_int as yytype_int16, 149 as libc::c_int as yytype_int16,
     150 as libc::c_int as yytype_int16, 41 as libc::c_int as yytype_int16,
     317 as libc::c_int as yytype_int16, 210 as libc::c_int as yytype_int16,
     324 as libc::c_int as yytype_int16, 296 as libc::c_int as yytype_int16,
     296 as libc::c_int as yytype_int16, 317 as libc::c_int as yytype_int16,
     296 as libc::c_int as yytype_int16, 325 as libc::c_int as yytype_int16,
     388 as libc::c_int as yytype_int16, 317 as libc::c_int as yytype_int16,
     211 as libc::c_int as yytype_int16, 376 as libc::c_int as yytype_int16,
     317 as libc::c_int as yytype_int16, 42 as libc::c_int as yytype_int16,
     377 as libc::c_int as yytype_int16, 213 as libc::c_int as yytype_int16,
     317 as libc::c_int as yytype_int16, 296 as libc::c_int as yytype_int16,
     378 as libc::c_int as yytype_int16, 147 as libc::c_int as yytype_int16,
     148 as libc::c_int as yytype_int16, 296 as libc::c_int as yytype_int16,
     149 as libc::c_int as yytype_int16, 150 as libc::c_int as yytype_int16,
     48 as libc::c_int as yytype_int16, 343 as libc::c_int as yytype_int16,
     344 as libc::c_int as yytype_int16, 345 as libc::c_int as yytype_int16,
     346 as libc::c_int as yytype_int16, 347 as libc::c_int as yytype_int16,
     348 as libc::c_int as yytype_int16, 349 as libc::c_int as yytype_int16,
     50 as libc::c_int as yytype_int16, 296 as libc::c_int as yytype_int16,
     296 as libc::c_int as yytype_int16, 310 as libc::c_int as yytype_int16,
     311 as libc::c_int as yytype_int16, 312 as libc::c_int as yytype_int16,
     313 as libc::c_int as yytype_int16, 314 as libc::c_int as yytype_int16,
     207 as libc::c_int as yytype_int16, 207 as libc::c_int as yytype_int16,
     64 as libc::c_int as yytype_int16, 207 as libc::c_int as yytype_int16,
     242 as libc::c_int as yytype_int16, 208 as libc::c_int as yytype_int16,
     208 as libc::c_int as yytype_int16, 68 as libc::c_int as yytype_int16,
     208 as libc::c_int as yytype_int16, 51 as libc::c_int as yytype_int16,
     151 as libc::c_int as yytype_int16, 152 as libc::c_int as yytype_int16,
     363 as libc::c_int as yytype_int16, 326 as libc::c_int as yytype_int16,
     327 as libc::c_int as yytype_int16, 72 as libc::c_int as yytype_int16,
     153 as libc::c_int as yytype_int16, 154 as libc::c_int as yytype_int16,
     329 as libc::c_int as yytype_int16, 163 as libc::c_int as yytype_int16,
     164 as libc::c_int as yytype_int16, 76 as libc::c_int as yytype_int16,
     339 as libc::c_int as yytype_int16, 222 as libc::c_int as yytype_int16,
     116 as libc::c_int as yytype_int16, 207 as libc::c_int as yytype_int16,
     362 as libc::c_int as yytype_int16, 79 as libc::c_int as yytype_int16,
     52 as libc::c_int as yytype_int16, 340 as libc::c_int as yytype_int16,
     208 as libc::c_int as yytype_int16, 224 as libc::c_int as yytype_int16,
     117 as libc::c_int as yytype_int16, 317 as libc::c_int as yytype_int16,
     214 as libc::c_int as yytype_int16, 379 as libc::c_int as yytype_int16,
     212 as libc::c_int as yytype_int16, 114 as libc::c_int as yytype_int16,
     209 as libc::c_int as yytype_int16, 209 as libc::c_int as yytype_int16,
     124 as libc::c_int as yytype_int16, 209 as libc::c_int as yytype_int16,
     330 as libc::c_int as yytype_int16, 207 as libc::c_int as yytype_int16,
     207 as libc::c_int as yytype_int16, 207 as libc::c_int as yytype_int16,
     207 as libc::c_int as yytype_int16, 118 as libc::c_int as yytype_int16,
     208 as libc::c_int as yytype_int16, 208 as libc::c_int as yytype_int16,
     208 as libc::c_int as yytype_int16, 208 as libc::c_int as yytype_int16,
     317 as libc::c_int as yytype_int16, 317 as libc::c_int as yytype_int16,
     380 as libc::c_int as yytype_int16, 381 as libc::c_int as yytype_int16,
     225 as libc::c_int as yytype_int16, 207 as libc::c_int as yytype_int16,
     317 as libc::c_int as yytype_int16, 213 as libc::c_int as yytype_int16,
     382 as libc::c_int as yytype_int16, 207 as libc::c_int as yytype_int16,
     208 as libc::c_int as yytype_int16, 209 as libc::c_int as yytype_int16,
     341 as libc::c_int as yytype_int16, 317 as libc::c_int as yytype_int16,
     208 as libc::c_int as yytype_int16, 384 as libc::c_int as yytype_int16,
     140 as libc::c_int as yytype_int16, 130 as libc::c_int as yytype_int16,
     137 as libc::c_int as yytype_int16, 207 as libc::c_int as yytype_int16,
     207 as libc::c_int as yytype_int16, 207 as libc::c_int as yytype_int16,
     207 as libc::c_int as yytype_int16, 371 as libc::c_int as yytype_int16,
     208 as libc::c_int as yytype_int16, 208 as libc::c_int as yytype_int16,
     208 as libc::c_int as yytype_int16, 208 as libc::c_int as yytype_int16,
     131 as libc::c_int as yytype_int16, 209 as libc::c_int as yytype_int16,
     209 as libc::c_int as yytype_int16, 209 as libc::c_int as yytype_int16,
     209 as libc::c_int as yytype_int16, 132 as libc::c_int as yytype_int16,
     88 as libc::c_int as yytype_int16, 133 as libc::c_int as yytype_int16,
     210 as libc::c_int as yytype_int16, 210 as libc::c_int as yytype_int16,
     134 as libc::c_int as yytype_int16, 210 as libc::c_int as yytype_int16,
     88 as libc::c_int as yytype_int16, 135 as libc::c_int as yytype_int16,
     136 as libc::c_int as yytype_int16, 209 as libc::c_int as yytype_int16,
     165 as libc::c_int as yytype_int16, 211 as libc::c_int as yytype_int16,
     211 as libc::c_int as yytype_int16, 209 as libc::c_int as yytype_int16,
     211 as libc::c_int as yytype_int16, 166 as libc::c_int as yytype_int16,
     88 as libc::c_int as yytype_int16, 167 as libc::c_int as yytype_int16,
     215 as libc::c_int as yytype_int16, 18 as libc::c_int as yytype_int16,
     18 as libc::c_int as yytype_int16, -(58 as libc::c_int) as yytype_int16,
     18 as libc::c_int as yytype_int16, 209 as libc::c_int as yytype_int16,
     209 as libc::c_int as yytype_int16, 209 as libc::c_int as yytype_int16,
     209 as libc::c_int as yytype_int16, 210 as libc::c_int as yytype_int16,
     216 as libc::c_int as yytype_int16, 160 as libc::c_int as yytype_int16,
     147 as libc::c_int as yytype_int16, 148 as libc::c_int as yytype_int16,
     214 as libc::c_int as yytype_int16, 149 as libc::c_int as yytype_int16,
     150 as libc::c_int as yytype_int16, 219 as libc::c_int as yytype_int16,
     211 as libc::c_int as yytype_int16, 244 as libc::c_int as yytype_int16,
     259 as libc::c_int as yytype_int16, 266 as libc::c_int as yytype_int16,
     279 as libc::c_int as yytype_int16, 267 as libc::c_int as yytype_int16,
     88 as libc::c_int as yytype_int16, 269 as libc::c_int as yytype_int16,
     271 as libc::c_int as yytype_int16, 210 as libc::c_int as yytype_int16,
     210 as libc::c_int as yytype_int16, 210 as libc::c_int as yytype_int16,
     210 as libc::c_int as yytype_int16, 272 as libc::c_int as yytype_int16,
     -(57 as libc::c_int) as yytype_int16, 280 as libc::c_int as yytype_int16,
     281 as libc::c_int as yytype_int16, 282 as libc::c_int as yytype_int16,
     211 as libc::c_int as yytype_int16, 211 as libc::c_int as yytype_int16,
     211 as libc::c_int as yytype_int16, 211 as libc::c_int as yytype_int16,
     283 as libc::c_int as yytype_int16, 210 as libc::c_int as yytype_int16,
     297 as libc::c_int as yytype_int16, 284 as libc::c_int as yytype_int16,
     285 as libc::c_int as yytype_int16, 210 as libc::c_int as yytype_int16,
     18 as libc::c_int as yytype_int16, 286 as libc::c_int as yytype_int16,
     287 as libc::c_int as yytype_int16, 288 as libc::c_int as yytype_int16,
     211 as libc::c_int as yytype_int16, 289 as libc::c_int as yytype_int16,
     298 as libc::c_int as yytype_int16, 290 as libc::c_int as yytype_int16,
     211 as libc::c_int as yytype_int16, 210 as libc::c_int as yytype_int16,
     210 as libc::c_int as yytype_int16, 210 as libc::c_int as yytype_int16,
     210 as libc::c_int as yytype_int16, 212 as libc::c_int as yytype_int16,
     212 as libc::c_int as yytype_int16, 98 as libc::c_int as yytype_int16,
     212 as libc::c_int as yytype_int16, 291 as libc::c_int as yytype_int16,
     211 as libc::c_int as yytype_int16, 211 as libc::c_int as yytype_int16,
     211 as libc::c_int as yytype_int16, 211 as libc::c_int as yytype_int16,
     292 as libc::c_int as yytype_int16, 293 as libc::c_int as yytype_int16,
     294 as libc::c_int as yytype_int16, 234 as libc::c_int as yytype_int16,
     234 as libc::c_int as yytype_int16, 234 as libc::c_int as yytype_int16,
     234 as libc::c_int as yytype_int16, 234 as libc::c_int as yytype_int16,
     234 as libc::c_int as yytype_int16, 234 as libc::c_int as yytype_int16,
     234 as libc::c_int as yytype_int16, 299 as libc::c_int as yytype_int16,
     300 as libc::c_int as yytype_int16, 301 as libc::c_int as yytype_int16,
     213 as libc::c_int as yytype_int16, 213 as libc::c_int as yytype_int16,
     212 as libc::c_int as yytype_int16, 213 as libc::c_int as yytype_int16,
     99 as libc::c_int as yytype_int16, 100 as libc::c_int as yytype_int16,
     101 as libc::c_int as yytype_int16, 102 as libc::c_int as yytype_int16,
     103 as libc::c_int as yytype_int16, 104 as libc::c_int as yytype_int16,
     88 as libc::c_int as yytype_int16, 88 as libc::c_int as yytype_int16,
     88 as libc::c_int as yytype_int16, 88 as libc::c_int as yytype_int16,
     302 as libc::c_int as yytype_int16, 303 as libc::c_int as yytype_int16,
     304 as libc::c_int as yytype_int16, 263 as libc::c_int as yytype_int16,
     265 as libc::c_int as yytype_int16, 305 as libc::c_int as yytype_int16,
     212 as libc::c_int as yytype_int16, 212 as libc::c_int as yytype_int16,
     212 as libc::c_int as yytype_int16, 212 as libc::c_int as yytype_int16,
     306 as libc::c_int as yytype_int16, 213 as libc::c_int as yytype_int16,
     307 as libc::c_int as yytype_int16, 19 as libc::c_int as yytype_int16,
     168 as libc::c_int as yytype_int16, 169 as libc::c_int as yytype_int16,
     170 as libc::c_int as yytype_int16, 171 as libc::c_int as yytype_int16,
     172 as libc::c_int as yytype_int16, 315 as libc::c_int as yytype_int16,
     212 as libc::c_int as yytype_int16, 319 as libc::c_int as yytype_int16,
     173 as libc::c_int as yytype_int16, 317 as libc::c_int as yytype_int16,
     212 as libc::c_int as yytype_int16, 278 as libc::c_int as yytype_int16,
     174 as libc::c_int as yytype_int16, 164 as libc::c_int as yytype_int16,
     328 as libc::c_int as yytype_int16, 213 as libc::c_int as yytype_int16,
     213 as libc::c_int as yytype_int16, 213 as libc::c_int as yytype_int16,
     213 as libc::c_int as yytype_int16, 331 as libc::c_int as yytype_int16,
     212 as libc::c_int as yytype_int16, 212 as libc::c_int as yytype_int16,
     212 as libc::c_int as yytype_int16, 212 as libc::c_int as yytype_int16,
     334 as libc::c_int as yytype_int16, 350 as libc::c_int as yytype_int16,
     375 as libc::c_int as yytype_int16, 391 as libc::c_int as yytype_int16,
     397 as libc::c_int as yytype_int16, 213 as libc::c_int as yytype_int16,
     392 as libc::c_int as yytype_int16, 214 as libc::c_int as yytype_int16,
     214 as libc::c_int as yytype_int16, 213 as libc::c_int as yytype_int16,
     214 as libc::c_int as yytype_int16, 393 as libc::c_int as yytype_int16,
     396 as libc::c_int as yytype_int16,
     -(183 as libc::c_int) as yytype_int16,
     398 as libc::c_int as yytype_int16, 8 as libc::c_int as yytype_int16,
     108 as libc::c_int as yytype_int16, 33 as libc::c_int as yytype_int16,
     365 as libc::c_int as yytype_int16, 213 as libc::c_int as yytype_int16,
     213 as libc::c_int as yytype_int16, 213 as libc::c_int as yytype_int16,
     213 as libc::c_int as yytype_int16, 168 as libc::c_int as yytype_int16,
     169 as libc::c_int as yytype_int16, 170 as libc::c_int as yytype_int16,
     171 as libc::c_int as yytype_int16, 172 as libc::c_int as yytype_int16,
     85 as libc::c_int as yytype_int16, 45 as libc::c_int as yytype_int16,
     270 as libc::c_int as yytype_int16, 173 as libc::c_int as yytype_int16,
     214 as libc::c_int as yytype_int16, 88 as libc::c_int as yytype_int16,
     85 as libc::c_int as yytype_int16, 174 as libc::c_int as yytype_int16,
     353 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 87 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     85 as libc::c_int as yytype_int16, 121 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 87 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     214 as libc::c_int as yytype_int16, 214 as libc::c_int as yytype_int16,
     214 as libc::c_int as yytype_int16, 214 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 87 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     86 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     214 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     86 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     214 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     138 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     119 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     214 as libc::c_int as yytype_int16, 214 as libc::c_int as yytype_int16,
     214 as libc::c_int as yytype_int16, 214 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 87 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     88 as libc::c_int as yytype_int16, 88 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 88 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 338 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 234 as libc::c_int as yytype_int16,
     234 as libc::c_int as yytype_int16, 234 as libc::c_int as yytype_int16,
     234 as libc::c_int as yytype_int16, 234 as libc::c_int as yytype_int16,
     234 as libc::c_int as yytype_int16, 234 as libc::c_int as yytype_int16,
     139 as libc::c_int as yytype_int16, 123 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 217 as libc::c_int as yytype_int16,
     88 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     357 as libc::c_int as yytype_int16, 218 as libc::c_int as yytype_int16,
     88 as libc::c_int as yytype_int16, 360 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     234 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     234 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     88 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     245 as libc::c_int as yytype_int16, 246 as libc::c_int as yytype_int16,
     247 as libc::c_int as yytype_int16, 248 as libc::c_int as yytype_int16,
     249 as libc::c_int as yytype_int16, 250 as libc::c_int as yytype_int16,
     251 as libc::c_int as yytype_int16, 252 as libc::c_int as yytype_int16,
     253 as libc::c_int as yytype_int16, 254 as libc::c_int as yytype_int16,
     85 as libc::c_int as yytype_int16, 85 as libc::c_int as yytype_int16,
     85 as libc::c_int as yytype_int16, 85 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 87 as libc::c_int as yytype_int16,
     87 as libc::c_int as yytype_int16, 87 as libc::c_int as yytype_int16,
     87 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     260 as libc::c_int as yytype_int16, 262 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 123 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 275 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 123 as libc::c_int as yytype_int16,
     255 as libc::c_int as yytype_int16, 256 as libc::c_int as yytype_int16,
     257 as libc::c_int as yytype_int16, 258 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     87 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     123 as libc::c_int as yytype_int16, 123 as libc::c_int as yytype_int16,
     123 as libc::c_int as yytype_int16, 123 as libc::c_int as yytype_int16,
     123 as libc::c_int as yytype_int16, 123 as libc::c_int as yytype_int16,
     123 as libc::c_int as yytype_int16, 123 as libc::c_int as yytype_int16,
     123 as libc::c_int as yytype_int16, 123 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 55 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 277 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 261 as libc::c_int as yytype_int16,
     261 as libc::c_int as yytype_int16, 264 as libc::c_int as yytype_int16,
     264 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     309 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 138 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 57 as libc::c_int as yytype_int16,
     58 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     59 as libc::c_int as yytype_int16, 221 as libc::c_int as yytype_int16,
     222 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     87 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     61 as libc::c_int as yytype_int16, 62 as libc::c_int as yytype_int16,
     223 as libc::c_int as yytype_int16, 64 as libc::c_int as yytype_int16,
     224 as libc::c_int as yytype_int16, 65 as libc::c_int as yytype_int16,
     66 as libc::c_int as yytype_int16, 67 as libc::c_int as yytype_int16,
     68 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 69 as libc::c_int as yytype_int16,
     70 as libc::c_int as yytype_int16, 71 as libc::c_int as yytype_int16,
     72 as libc::c_int as yytype_int16, 139 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 73 as libc::c_int as yytype_int16,
     74 as libc::c_int as yytype_int16, 75 as libc::c_int as yytype_int16,
     76 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 77 as libc::c_int as yytype_int16,
     78 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     79 as libc::c_int as yytype_int16, 225 as libc::c_int as yytype_int16,
     80 as libc::c_int as yytype_int16, 81 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 273 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     123 as libc::c_int as yytype_int16, 226 as libc::c_int as yytype_int16,
     85 as libc::c_int as yytype_int16, 85 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 85 as libc::c_int as yytype_int16,
     337 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 87 as libc::c_int as yytype_int16,
     87 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 335 as libc::c_int as yytype_int16,
     87 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 354 as libc::c_int as yytype_int16,
     85 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 358 as libc::c_int as yytype_int16,
     85 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     332 as libc::c_int as yytype_int16, 333 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 87 as libc::c_int as yytype_int16,
     356 as libc::c_int as yytype_int16, 336 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 87 as libc::c_int as yytype_int16,
     366 as libc::c_int as yytype_int16, 361 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 141 as libc::c_int as yytype_int16,
     142 as libc::c_int as yytype_int16, 143 as libc::c_int as yytype_int16,
     144 as libc::c_int as yytype_int16, 145 as libc::c_int as yytype_int16,
     146 as libc::c_int as yytype_int16, 87 as libc::c_int as yytype_int16,
     355 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     147 as libc::c_int as yytype_int16, 148 as libc::c_int as yytype_int16,
     359 as libc::c_int as yytype_int16, 149 as libc::c_int as yytype_int16,
     150 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     261 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     123 as libc::c_int as yytype_int16, 264 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 53 as libc::c_int as yytype_int16,
     54 as libc::c_int as yytype_int16, 55 as libc::c_int as yytype_int16,
     56 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     368 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 123 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 261 as libc::c_int as yytype_int16,
     264 as libc::c_int as yytype_int16, 123 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 264 as libc::c_int as yytype_int16,
     261 as libc::c_int as yytype_int16, 57 as libc::c_int as yytype_int16,
     58 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     59 as libc::c_int as yytype_int16, 60 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     61 as libc::c_int as yytype_int16, 62 as libc::c_int as yytype_int16,
     63 as libc::c_int as yytype_int16, 64 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 65 as libc::c_int as yytype_int16,
     66 as libc::c_int as yytype_int16, 67 as libc::c_int as yytype_int16,
     68 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 69 as libc::c_int as yytype_int16,
     70 as libc::c_int as yytype_int16, 71 as libc::c_int as yytype_int16,
     72 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 73 as libc::c_int as yytype_int16,
     74 as libc::c_int as yytype_int16, 75 as libc::c_int as yytype_int16,
     76 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 77 as libc::c_int as yytype_int16,
     78 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     79 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     80 as libc::c_int as yytype_int16, 81 as libc::c_int as yytype_int16,
     82 as libc::c_int as yytype_int16, 53 as libc::c_int as yytype_int16,
     54 as libc::c_int as yytype_int16, 106 as libc::c_int as yytype_int16,
     56 as libc::c_int as yytype_int16, 83 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 57 as libc::c_int as yytype_int16,
     58 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     59 as libc::c_int as yytype_int16, 60 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     61 as libc::c_int as yytype_int16, 62 as libc::c_int as yytype_int16,
     63 as libc::c_int as yytype_int16, 64 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 65 as libc::c_int as yytype_int16,
     66 as libc::c_int as yytype_int16, 67 as libc::c_int as yytype_int16,
     68 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 69 as libc::c_int as yytype_int16,
     70 as libc::c_int as yytype_int16, 71 as libc::c_int as yytype_int16,
     72 as libc::c_int as yytype_int16, 55 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 73 as libc::c_int as yytype_int16,
     74 as libc::c_int as yytype_int16, 75 as libc::c_int as yytype_int16,
     76 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 77 as libc::c_int as yytype_int16,
     78 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     79 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     107 as libc::c_int as yytype_int16, 81 as libc::c_int as yytype_int16,
     82 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 57 as libc::c_int as yytype_int16,
     58 as libc::c_int as yytype_int16, 83 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     59 as libc::c_int as yytype_int16, 221 as libc::c_int as yytype_int16,
     222 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     61 as libc::c_int as yytype_int16, 62 as libc::c_int as yytype_int16,
     223 as libc::c_int as yytype_int16, 64 as libc::c_int as yytype_int16,
     224 as libc::c_int as yytype_int16, 65 as libc::c_int as yytype_int16,
     66 as libc::c_int as yytype_int16, 67 as libc::c_int as yytype_int16,
     68 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 69 as libc::c_int as yytype_int16,
     70 as libc::c_int as yytype_int16, 71 as libc::c_int as yytype_int16,
     72 as libc::c_int as yytype_int16, 55 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 73 as libc::c_int as yytype_int16,
     74 as libc::c_int as yytype_int16, 75 as libc::c_int as yytype_int16,
     76 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 77 as libc::c_int as yytype_int16,
     78 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     79 as libc::c_int as yytype_int16, 225 as libc::c_int as yytype_int16,
     80 as libc::c_int as yytype_int16, 81 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 57 as libc::c_int as yytype_int16,
     58 as libc::c_int as yytype_int16, 226 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     59 as libc::c_int as yytype_int16, 60 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     61 as libc::c_int as yytype_int16, 62 as libc::c_int as yytype_int16,
     63 as libc::c_int as yytype_int16, 64 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 65 as libc::c_int as yytype_int16,
     66 as libc::c_int as yytype_int16, 67 as libc::c_int as yytype_int16,
     68 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 69 as libc::c_int as yytype_int16,
     70 as libc::c_int as yytype_int16, 71 as libc::c_int as yytype_int16,
     72 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 73 as libc::c_int as yytype_int16,
     74 as libc::c_int as yytype_int16, 75 as libc::c_int as yytype_int16,
     76 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 77 as libc::c_int as yytype_int16,
     78 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     79 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     80 as libc::c_int as yytype_int16, 81 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     180 as libc::c_int as yytype_int16, 181 as libc::c_int as yytype_int16,
     182 as libc::c_int as yytype_int16, 83 as libc::c_int as yytype_int16,
     183 as libc::c_int as yytype_int16, 184 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 185 as libc::c_int as yytype_int16,
     186 as libc::c_int as yytype_int16, 187 as libc::c_int as yytype_int16,
     188 as libc::c_int as yytype_int16, 189 as libc::c_int as yytype_int16,
     65 as libc::c_int as yytype_int16, 66 as libc::c_int as yytype_int16,
     67 as libc::c_int as yytype_int16, 68 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 72 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 190 as libc::c_int as yytype_int16,
     191 as libc::c_int as yytype_int16, 192 as libc::c_int as yytype_int16,
     193 as libc::c_int as yytype_int16, 194 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 195 as libc::c_int as yytype_int16,
     180 as libc::c_int as yytype_int16, 181 as libc::c_int as yytype_int16,
     182 as libc::c_int as yytype_int16, 79 as libc::c_int as yytype_int16,
     183 as libc::c_int as yytype_int16, 184 as libc::c_int as yytype_int16,
     196 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 385 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 185 as libc::c_int as yytype_int16,
     186 as libc::c_int as yytype_int16, 187 as libc::c_int as yytype_int16,
     188 as libc::c_int as yytype_int16, 189 as libc::c_int as yytype_int16,
     65 as libc::c_int as yytype_int16, 66 as libc::c_int as yytype_int16,
     67 as libc::c_int as yytype_int16, 68 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 72 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 190 as libc::c_int as yytype_int16,
     191 as libc::c_int as yytype_int16, 192 as libc::c_int as yytype_int16,
     193 as libc::c_int as yytype_int16, 194 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 195 as libc::c_int as yytype_int16,
     180 as libc::c_int as yytype_int16, 181 as libc::c_int as yytype_int16,
     182 as libc::c_int as yytype_int16, 79 as libc::c_int as yytype_int16,
     183 as libc::c_int as yytype_int16, 184 as libc::c_int as yytype_int16,
     196 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 386 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 185 as libc::c_int as yytype_int16,
     186 as libc::c_int as yytype_int16, 187 as libc::c_int as yytype_int16,
     188 as libc::c_int as yytype_int16, 189 as libc::c_int as yytype_int16,
     65 as libc::c_int as yytype_int16, 66 as libc::c_int as yytype_int16,
     67 as libc::c_int as yytype_int16, 68 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 72 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 190 as libc::c_int as yytype_int16,
     191 as libc::c_int as yytype_int16, 192 as libc::c_int as yytype_int16,
     193 as libc::c_int as yytype_int16, 194 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 195 as libc::c_int as yytype_int16,
     180 as libc::c_int as yytype_int16, 181 as libc::c_int as yytype_int16,
     182 as libc::c_int as yytype_int16, 79 as libc::c_int as yytype_int16,
     183 as libc::c_int as yytype_int16, 184 as libc::c_int as yytype_int16,
     196 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 394 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 185 as libc::c_int as yytype_int16,
     186 as libc::c_int as yytype_int16, 187 as libc::c_int as yytype_int16,
     188 as libc::c_int as yytype_int16, 189 as libc::c_int as yytype_int16,
     65 as libc::c_int as yytype_int16, 66 as libc::c_int as yytype_int16,
     67 as libc::c_int as yytype_int16, 68 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 72 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 190 as libc::c_int as yytype_int16,
     191 as libc::c_int as yytype_int16, 192 as libc::c_int as yytype_int16,
     193 as libc::c_int as yytype_int16, 194 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 195 as libc::c_int as yytype_int16,
     180 as libc::c_int as yytype_int16, 181 as libc::c_int as yytype_int16,
     182 as libc::c_int as yytype_int16, 79 as libc::c_int as yytype_int16,
     183 as libc::c_int as yytype_int16, 184 as libc::c_int as yytype_int16,
     196 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 395 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 185 as libc::c_int as yytype_int16,
     186 as libc::c_int as yytype_int16, 187 as libc::c_int as yytype_int16,
     188 as libc::c_int as yytype_int16, 189 as libc::c_int as yytype_int16,
     65 as libc::c_int as yytype_int16, 66 as libc::c_int as yytype_int16,
     67 as libc::c_int as yytype_int16, 68 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 72 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 190 as libc::c_int as yytype_int16,
     191 as libc::c_int as yytype_int16, 192 as libc::c_int as yytype_int16,
     193 as libc::c_int as yytype_int16, 194 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 195 as libc::c_int as yytype_int16,
     180 as libc::c_int as yytype_int16, 181 as libc::c_int as yytype_int16,
     182 as libc::c_int as yytype_int16, 79 as libc::c_int as yytype_int16,
     183 as libc::c_int as yytype_int16, 184 as libc::c_int as yytype_int16,
     196 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 401 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 55 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 185 as libc::c_int as yytype_int16,
     186 as libc::c_int as yytype_int16, 187 as libc::c_int as yytype_int16,
     188 as libc::c_int as yytype_int16, 189 as libc::c_int as yytype_int16,
     65 as libc::c_int as yytype_int16, 66 as libc::c_int as yytype_int16,
     67 as libc::c_int as yytype_int16, 68 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 72 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 190 as libc::c_int as yytype_int16,
     191 as libc::c_int as yytype_int16, 192 as libc::c_int as yytype_int16,
     193 as libc::c_int as yytype_int16, 194 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 195 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     61 as libc::c_int as yytype_int16, 79 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 64 as libc::c_int as yytype_int16,
     196 as libc::c_int as yytype_int16, 65 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     68 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 402 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 71 as libc::c_int as yytype_int16,
     72 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 75 as libc::c_int as yytype_int16,
     76 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     79 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     80 as libc::c_int as yytype_int16, 81 as libc::c_int as yytype_int16,
     180 as libc::c_int as yytype_int16, 181 as libc::c_int as yytype_int16,
     182 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     183 as libc::c_int as yytype_int16, 184 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 7 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 185 as libc::c_int as yytype_int16,
     186 as libc::c_int as yytype_int16, 187 as libc::c_int as yytype_int16,
     188 as libc::c_int as yytype_int16, 189 as libc::c_int as yytype_int16,
     65 as libc::c_int as yytype_int16, 66 as libc::c_int as yytype_int16,
     67 as libc::c_int as yytype_int16, 68 as libc::c_int as yytype_int16,
     180 as libc::c_int as yytype_int16, 181 as libc::c_int as yytype_int16,
     182 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     183 as libc::c_int as yytype_int16, 184 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 72 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 190 as libc::c_int as yytype_int16,
     191 as libc::c_int as yytype_int16, 192 as libc::c_int as yytype_int16,
     193 as libc::c_int as yytype_int16, 194 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 195 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 79 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     196 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 185 as libc::c_int as yytype_int16,
     186 as libc::c_int as yytype_int16, 187 as libc::c_int as yytype_int16,
     188 as libc::c_int as yytype_int16, 189 as libc::c_int as yytype_int16,
     65 as libc::c_int as yytype_int16, 66 as libc::c_int as yytype_int16,
     67 as libc::c_int as yytype_int16, 68 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 72 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 190 as libc::c_int as yytype_int16,
     191 as libc::c_int as yytype_int16, 192 as libc::c_int as yytype_int16,
     193 as libc::c_int as yytype_int16, 194 as libc::c_int as yytype_int16,
     58 as libc::c_int as yytype_int16, 195 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 79 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 60 as libc::c_int as yytype_int16,
     196 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     63 as libc::c_int as yytype_int16, 64 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 67 as libc::c_int as yytype_int16,
     68 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     70 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     72 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     74 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     76 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     78 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     79 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 0 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 120 as libc::c_int as yytype_int16];
//debug(LOG_SCRIPT, "event_decl 1. ");
static mut yycheck: [yytype_int16; 1494] =
    [9 as libc::c_int as yytype_int16, 115 as libc::c_int as yytype_int16,
     180 as libc::c_int as yytype_int16, 14 as libc::c_int as yytype_int16,
     22 as libc::c_int as yytype_int16, 199 as libc::c_int as yytype_int16,
     115 as libc::c_int as yytype_int16, 199 as libc::c_int as yytype_int16,
     29 as libc::c_int as yytype_int16, 50 as libc::c_int as yytype_int16,
     326 as libc::c_int as yytype_int16, 327 as libc::c_int as yytype_int16,
     36 as libc::c_int as yytype_int16, 329 as libc::c_int as yytype_int16,
     18 as libc::c_int as yytype_int16, 19 as libc::c_int as yytype_int16,
     18 as libc::c_int as yytype_int16, 19 as libc::c_int as yytype_int16,
     20 as libc::c_int as yytype_int16, 21 as libc::c_int as yytype_int16,
     22 as libc::c_int as yytype_int16, 23 as libc::c_int as yytype_int16,
     4 as libc::c_int as yytype_int16, 5 as libc::c_int as yytype_int16,
     72 as libc::c_int as yytype_int16, 27 as libc::c_int as yytype_int16,
     28 as libc::c_int as yytype_int16, 75 as libc::c_int as yytype_int16,
     30 as libc::c_int as yytype_int16, 31 as libc::c_int as yytype_int16,
     18 as libc::c_int as yytype_int16, 19 as libc::c_int as yytype_int16,
     38 as libc::c_int as yytype_int16, 10 as libc::c_int as yytype_int16,
     72 as libc::c_int as yytype_int16, 351 as libc::c_int as yytype_int16,
     24 as libc::c_int as yytype_int16, 25 as libc::c_int as yytype_int16,
     76 as libc::c_int as yytype_int16, 115 as libc::c_int as yytype_int16,
     131 as libc::c_int as yytype_int16, 132 as libc::c_int as yytype_int16,
     133 as libc::c_int as yytype_int16, 134 as libc::c_int as yytype_int16,
     135 as libc::c_int as yytype_int16, 136 as libc::c_int as yytype_int16,
     137 as libc::c_int as yytype_int16, 75 as libc::c_int as yytype_int16,
     226 as libc::c_int as yytype_int16, 77 as libc::c_int as yytype_int16,
     10 as libc::c_int as yytype_int16, 18 as libc::c_int as yytype_int16,
     19 as libc::c_int as yytype_int16, 77 as libc::c_int as yytype_int16,
     36 as libc::c_int as yytype_int16, 371 as libc::c_int as yytype_int16,
     77 as libc::c_int as yytype_int16, 24 as libc::c_int as yytype_int16,
     25 as libc::c_int as yytype_int16, 3 as libc::c_int as yytype_int16,
     37 as libc::c_int as yytype_int16, 5 as libc::c_int as yytype_int16,
     18 as libc::c_int as yytype_int16, 19 as libc::c_int as yytype_int16,
     70 as libc::c_int as yytype_int16, 18 as libc::c_int as yytype_int16,
     19 as libc::c_int as yytype_int16, 78 as libc::c_int as yytype_int16,
     24 as libc::c_int as yytype_int16, 25 as libc::c_int as yytype_int16,
     27 as libc::c_int as yytype_int16, 28 as libc::c_int as yytype_int16,
     36 as libc::c_int as yytype_int16, 30 as libc::c_int as yytype_int16,
     31 as libc::c_int as yytype_int16, 77 as libc::c_int as yytype_int16,
     0 as libc::c_int as yytype_int16, 81 as libc::c_int as yytype_int16,
     3 as libc::c_int as yytype_int16, 4 as libc::c_int as yytype_int16,
     5 as libc::c_int as yytype_int16, 397 as libc::c_int as yytype_int16,
     398 as libc::c_int as yytype_int16, 72 as libc::c_int as yytype_int16,
     75 as libc::c_int as yytype_int16, 199 as libc::c_int as yytype_int16,
     77 as libc::c_int as yytype_int16, 75 as libc::c_int as yytype_int16,
     37 as libc::c_int as yytype_int16, 115 as libc::c_int as yytype_int16,
     199 as libc::c_int as yytype_int16, 109 as libc::c_int as yytype_int16,
     75 as libc::c_int as yytype_int16, 8 as libc::c_int as yytype_int16,
     77 as libc::c_int as yytype_int16, 49 as libc::c_int as yytype_int16,
     11 as libc::c_int as yytype_int16, 51 as libc::c_int as yytype_int16,
     115 as libc::c_int as yytype_int16, 30 as libc::c_int as yytype_int16,
     31 as libc::c_int as yytype_int16, 18 as libc::c_int as yytype_int16,
     19 as libc::c_int as yytype_int16, 66 as libc::c_int as yytype_int16,
     67 as libc::c_int as yytype_int16, 68 as libc::c_int as yytype_int16,
     115 as libc::c_int as yytype_int16, 24 as libc::c_int as yytype_int16,
     25 as libc::c_int as yytype_int16, 287 as libc::c_int as yytype_int16,
     77 as libc::c_int as yytype_int16, 26 as libc::c_int as yytype_int16,
     27 as libc::c_int as yytype_int16, 48 as libc::c_int as yytype_int16,
     49 as libc::c_int as yytype_int16, 50 as libc::c_int as yytype_int16,
     51 as libc::c_int as yytype_int16, 74 as libc::c_int as yytype_int16,
     33 as libc::c_int as yytype_int16, 34 as libc::c_int as yytype_int16,
     35 as libc::c_int as yytype_int16, 77 as libc::c_int as yytype_int16,
     38 as libc::c_int as yytype_int16, 199 as libc::c_int as yytype_int16,
     39 as libc::c_int as yytype_int16, 40 as libc::c_int as yytype_int16,
     41 as libc::c_int as yytype_int16, 42 as libc::c_int as yytype_int16,
     43 as libc::c_int as yytype_int16, 44 as libc::c_int as yytype_int16,
     45 as libc::c_int as yytype_int16, 46 as libc::c_int as yytype_int16,
     47 as libc::c_int as yytype_int16, 75 as libc::c_int as yytype_int16,
     75 as libc::c_int as yytype_int16, 77 as libc::c_int as yytype_int16,
     77 as libc::c_int as yytype_int16, 52 as libc::c_int as yytype_int16,
     53 as libc::c_int as yytype_int16, 54 as libc::c_int as yytype_int16,
     55 as libc::c_int as yytype_int16, 319 as libc::c_int as yytype_int16,
     4 as libc::c_int as yytype_int16, 58 as libc::c_int as yytype_int16,
     59 as libc::c_int as yytype_int16, 60 as libc::c_int as yytype_int16,
     61 as libc::c_int as yytype_int16, 18 as libc::c_int as yytype_int16,
     19 as libc::c_int as yytype_int16, 64 as libc::c_int as yytype_int16,
     65 as libc::c_int as yytype_int16, 73 as libc::c_int as yytype_int16,
     67 as libc::c_int as yytype_int16, 68 as libc::c_int as yytype_int16,
     69 as libc::c_int as yytype_int16, 70 as libc::c_int as yytype_int16,
     75 as libc::c_int as yytype_int16, 75 as libc::c_int as yytype_int16,
     77 as libc::c_int as yytype_int16, 77 as libc::c_int as yytype_int16,
     77 as libc::c_int as yytype_int16, 76 as libc::c_int as yytype_int16,
     38 as libc::c_int as yytype_int16, 341 as libc::c_int as yytype_int16,
     115 as libc::c_int as yytype_int16, 73 as libc::c_int as yytype_int16,
     27 as libc::c_int as yytype_int16, 28 as libc::c_int as yytype_int16,
     34 as libc::c_int as yytype_int16, 30 as libc::c_int as yytype_int16,
     31 as libc::c_int as yytype_int16, 76 as libc::c_int as yytype_int16,
     75 as libc::c_int as yytype_int16, 199 as libc::c_int as yytype_int16,
     77 as libc::c_int as yytype_int16, 369 as libc::c_int as yytype_int16,
     370 as libc::c_int as yytype_int16, 75 as libc::c_int as yytype_int16,
     372 as libc::c_int as yytype_int16, 77 as libc::c_int as yytype_int16,
     372 as libc::c_int as yytype_int16, 75 as libc::c_int as yytype_int16,
     199 as libc::c_int as yytype_int16, 77 as libc::c_int as yytype_int16,
     75 as libc::c_int as yytype_int16, 36 as libc::c_int as yytype_int16,
     77 as libc::c_int as yytype_int16, 115 as libc::c_int as yytype_int16,
     75 as libc::c_int as yytype_int16, 383 as libc::c_int as yytype_int16,
     77 as libc::c_int as yytype_int16, 27 as libc::c_int as yytype_int16,
     28 as libc::c_int as yytype_int16, 387 as libc::c_int as yytype_int16,
     30 as libc::c_int as yytype_int16, 31 as libc::c_int as yytype_int16,
     76 as libc::c_int as yytype_int16, 288 as libc::c_int as yytype_int16,
     289 as libc::c_int as yytype_int16, 290 as libc::c_int as yytype_int16,
     291 as libc::c_int as yytype_int16, 292 as libc::c_int as yytype_int16,
     293 as libc::c_int as yytype_int16, 294 as libc::c_int as yytype_int16,
     78 as libc::c_int as yytype_int16, 399 as libc::c_int as yytype_int16,
     400 as libc::c_int as yytype_int16, 39 as libc::c_int as yytype_int16,
     40 as libc::c_int as yytype_int16, 41 as libc::c_int as yytype_int16,
     42 as libc::c_int as yytype_int16, 43 as libc::c_int as yytype_int16,
     326 as libc::c_int as yytype_int16, 327 as libc::c_int as yytype_int16,
     42 as libc::c_int as yytype_int16, 329 as libc::c_int as yytype_int16,
     77 as libc::c_int as yytype_int16, 326 as libc::c_int as yytype_int16,
     327 as libc::c_int as yytype_int16, 47 as libc::c_int as yytype_int16,
     329 as libc::c_int as yytype_int16, 74 as libc::c_int as yytype_int16,
     18 as libc::c_int as yytype_int16, 19 as libc::c_int as yytype_int16,
     315 as libc::c_int as yytype_int16, 266 as libc::c_int as yytype_int16,
     267 as libc::c_int as yytype_int16, 55 as libc::c_int as yytype_int16,
     24 as libc::c_int as yytype_int16, 25 as libc::c_int as yytype_int16,
     271 as libc::c_int as yytype_int16, 50 as libc::c_int as yytype_int16,
     51 as libc::c_int as yytype_int16, 61 as libc::c_int as yytype_int16,
     34 as libc::c_int as yytype_int16, 35 as libc::c_int as yytype_int16,
     74 as libc::c_int as yytype_int16, 351 as libc::c_int as yytype_int16,
     74 as libc::c_int as yytype_int16, 67 as libc::c_int as yytype_int16,
     34 as libc::c_int as yytype_int16, 41 as libc::c_int as yytype_int16,
     351 as libc::c_int as yytype_int16, 43 as libc::c_int as yytype_int16,
     75 as libc::c_int as yytype_int16, 75 as libc::c_int as yytype_int16,
     115 as libc::c_int as yytype_int16, 77 as libc::c_int as yytype_int16,
     199 as libc::c_int as yytype_int16, 72 as libc::c_int as yytype_int16,
     326 as libc::c_int as yytype_int16, 327 as libc::c_int as yytype_int16,
     73 as libc::c_int as yytype_int16, 329 as libc::c_int as yytype_int16,
     272 as libc::c_int as yytype_int16, 369 as libc::c_int as yytype_int16,
     370 as libc::c_int as yytype_int16, 371 as libc::c_int as yytype_int16,
     372 as libc::c_int as yytype_int16, 75 as libc::c_int as yytype_int16,
     369 as libc::c_int as yytype_int16, 370 as libc::c_int as yytype_int16,
     371 as libc::c_int as yytype_int16, 372 as libc::c_int as yytype_int16,
     75 as libc::c_int as yytype_int16, 75 as libc::c_int as yytype_int16,
     77 as libc::c_int as yytype_int16, 77 as libc::c_int as yytype_int16,
     68 as libc::c_int as yytype_int16, 383 as libc::c_int as yytype_int16,
     75 as libc::c_int as yytype_int16, 199 as libc::c_int as yytype_int16,
     77 as libc::c_int as yytype_int16, 387 as libc::c_int as yytype_int16,
     383 as libc::c_int as yytype_int16, 351 as libc::c_int as yytype_int16,
     76 as libc::c_int as yytype_int16, 75 as libc::c_int as yytype_int16,
     387 as libc::c_int as yytype_int16, 77 as libc::c_int as yytype_int16,
     77 as libc::c_int as yytype_int16, 76 as libc::c_int as yytype_int16,
     75 as libc::c_int as yytype_int16, 397 as libc::c_int as yytype_int16,
     398 as libc::c_int as yytype_int16, 399 as libc::c_int as yytype_int16,
     400 as libc::c_int as yytype_int16, 328 as libc::c_int as yytype_int16,
     397 as libc::c_int as yytype_int16, 398 as libc::c_int as yytype_int16,
     399 as libc::c_int as yytype_int16, 400 as libc::c_int as yytype_int16,
     76 as libc::c_int as yytype_int16, 369 as libc::c_int as yytype_int16,
     370 as libc::c_int as yytype_int16, 371 as libc::c_int as yytype_int16,
     372 as libc::c_int as yytype_int16, 76 as libc::c_int as yytype_int16,
     41 as libc::c_int as yytype_int16, 76 as libc::c_int as yytype_int16,
     326 as libc::c_int as yytype_int16, 327 as libc::c_int as yytype_int16,
     76 as libc::c_int as yytype_int16, 329 as libc::c_int as yytype_int16,
     47 as libc::c_int as yytype_int16, 76 as libc::c_int as yytype_int16,
     76 as libc::c_int as yytype_int16, 383 as libc::c_int as yytype_int16,
     77 as libc::c_int as yytype_int16, 326 as libc::c_int as yytype_int16,
     327 as libc::c_int as yytype_int16, 387 as libc::c_int as yytype_int16,
     329 as libc::c_int as yytype_int16, 77 as libc::c_int as yytype_int16,
     57 as libc::c_int as yytype_int16, 77 as libc::c_int as yytype_int16,
     34 as libc::c_int as yytype_int16, 326 as libc::c_int as yytype_int16,
     327 as libc::c_int as yytype_int16, 78 as libc::c_int as yytype_int16,
     329 as libc::c_int as yytype_int16, 397 as libc::c_int as yytype_int16,
     398 as libc::c_int as yytype_int16, 399 as libc::c_int as yytype_int16,
     400 as libc::c_int as yytype_int16, 351 as libc::c_int as yytype_int16,
     34 as libc::c_int as yytype_int16, 81 as libc::c_int as yytype_int16,
     27 as libc::c_int as yytype_int16, 28 as libc::c_int as yytype_int16,
     199 as libc::c_int as yytype_int16, 30 as libc::c_int as yytype_int16,
     31 as libc::c_int as yytype_int16, 73 as libc::c_int as yytype_int16,
     351 as libc::c_int as yytype_int16, 72 as libc::c_int as yytype_int16,
     34 as libc::c_int as yytype_int16, 78 as libc::c_int as yytype_int16,
     76 as libc::c_int as yytype_int16, 78 as libc::c_int as yytype_int16,
     83 as libc::c_int as yytype_int16, 36 as libc::c_int as yytype_int16,
     78 as libc::c_int as yytype_int16, 369 as libc::c_int as yytype_int16,
     370 as libc::c_int as yytype_int16, 371 as libc::c_int as yytype_int16,
     372 as libc::c_int as yytype_int16, 36 as libc::c_int as yytype_int16,
     78 as libc::c_int as yytype_int16, 76 as libc::c_int as yytype_int16,
     72 as libc::c_int as yytype_int16, 76 as libc::c_int as yytype_int16,
     369 as libc::c_int as yytype_int16, 370 as libc::c_int as yytype_int16,
     371 as libc::c_int as yytype_int16, 372 as libc::c_int as yytype_int16,
     80 as libc::c_int as yytype_int16, 383 as libc::c_int as yytype_int16,
     72 as libc::c_int as yytype_int16, 80 as libc::c_int as yytype_int16,
     80 as libc::c_int as yytype_int16, 387 as libc::c_int as yytype_int16,
     371 as libc::c_int as yytype_int16, 80 as libc::c_int as yytype_int16,
     80 as libc::c_int as yytype_int16, 76 as libc::c_int as yytype_int16,
     383 as libc::c_int as yytype_int16, 76 as libc::c_int as yytype_int16,
     72 as libc::c_int as yytype_int16, 76 as libc::c_int as yytype_int16,
     387 as libc::c_int as yytype_int16, 397 as libc::c_int as yytype_int16,
     398 as libc::c_int as yytype_int16, 399 as libc::c_int as yytype_int16,
     400 as libc::c_int as yytype_int16, 326 as libc::c_int as yytype_int16,
     327 as libc::c_int as yytype_int16, 38 as libc::c_int as yytype_int16,
     329 as libc::c_int as yytype_int16, 76 as libc::c_int as yytype_int16,
     397 as libc::c_int as yytype_int16, 398 as libc::c_int as yytype_int16,
     399 as libc::c_int as yytype_int16, 400 as libc::c_int as yytype_int16,
     76 as libc::c_int as yytype_int16, 76 as libc::c_int as yytype_int16,
     76 as libc::c_int as yytype_int16, 130 as libc::c_int as yytype_int16,
     131 as libc::c_int as yytype_int16, 132 as libc::c_int as yytype_int16,
     133 as libc::c_int as yytype_int16, 134 as libc::c_int as yytype_int16,
     135 as libc::c_int as yytype_int16, 136 as libc::c_int as yytype_int16,
     137 as libc::c_int as yytype_int16, 15 as libc::c_int as yytype_int16,
     80 as libc::c_int as yytype_int16, 80 as libc::c_int as yytype_int16,
     326 as libc::c_int as yytype_int16, 327 as libc::c_int as yytype_int16,
     351 as libc::c_int as yytype_int16, 329 as libc::c_int as yytype_int16,
     63 as libc::c_int as yytype_int16, 64 as libc::c_int as yytype_int16,
     65 as libc::c_int as yytype_int16, 66 as libc::c_int as yytype_int16,
     67 as libc::c_int as yytype_int16, 68 as libc::c_int as yytype_int16,
     151 as libc::c_int as yytype_int16, 152 as libc::c_int as yytype_int16,
     153 as libc::c_int as yytype_int16, 154 as libc::c_int as yytype_int16,
     80 as libc::c_int as yytype_int16, 80 as libc::c_int as yytype_int16,
     80 as libc::c_int as yytype_int16, 158 as libc::c_int as yytype_int16,
     159 as libc::c_int as yytype_int16, 80 as libc::c_int as yytype_int16,
     369 as libc::c_int as yytype_int16, 370 as libc::c_int as yytype_int16,
     371 as libc::c_int as yytype_int16, 372 as libc::c_int as yytype_int16,
     80 as libc::c_int as yytype_int16, 351 as libc::c_int as yytype_int16,
     80 as libc::c_int as yytype_int16, 38 as libc::c_int as yytype_int16,
     39 as libc::c_int as yytype_int16, 40 as libc::c_int as yytype_int16,
     41 as libc::c_int as yytype_int16, 42 as libc::c_int as yytype_int16,
     43 as libc::c_int as yytype_int16, 76 as libc::c_int as yytype_int16,
     383 as libc::c_int as yytype_int16, 29 as libc::c_int as yytype_int16,
     47 as libc::c_int as yytype_int16, 75 as libc::c_int as yytype_int16,
     387 as libc::c_int as yytype_int16, 180 as libc::c_int as yytype_int16,
     51 as libc::c_int as yytype_int16, 51 as libc::c_int as yytype_int16,
     78 as libc::c_int as yytype_int16, 369 as libc::c_int as yytype_int16,
     370 as libc::c_int as yytype_int16, 371 as libc::c_int as yytype_int16,
     372 as libc::c_int as yytype_int16, 72 as libc::c_int as yytype_int16,
     397 as libc::c_int as yytype_int16, 398 as libc::c_int as yytype_int16,
     399 as libc::c_int as yytype_int16, 400 as libc::c_int as yytype_int16,
     34 as libc::c_int as yytype_int16, 79 as libc::c_int as yytype_int16,
     77 as libc::c_int as yytype_int16, 72 as libc::c_int as yytype_int16,
     78 as libc::c_int as yytype_int16, 383 as libc::c_int as yytype_int16,
     72 as libc::c_int as yytype_int16, 326 as libc::c_int as yytype_int16,
     327 as libc::c_int as yytype_int16, 387 as libc::c_int as yytype_int16,
     329 as libc::c_int as yytype_int16, 72 as libc::c_int as yytype_int16,
     79 as libc::c_int as yytype_int16, 81 as libc::c_int as yytype_int16,
     78 as libc::c_int as yytype_int16, 3 as libc::c_int as yytype_int16,
     47 as libc::c_int as yytype_int16, 24 as libc::c_int as yytype_int16,
     317 as libc::c_int as yytype_int16, 397 as libc::c_int as yytype_int16,
     398 as libc::c_int as yytype_int16, 399 as libc::c_int as yytype_int16,
     400 as libc::c_int as yytype_int16, 39 as libc::c_int as yytype_int16,
     40 as libc::c_int as yytype_int16, 41 as libc::c_int as yytype_int16,
     42 as libc::c_int as yytype_int16, 43 as libc::c_int as yytype_int16,
     41 as libc::c_int as yytype_int16, 34 as libc::c_int as yytype_int16,
     176 as libc::c_int as yytype_int16, 47 as libc::c_int as yytype_int16,
     351 as libc::c_int as yytype_int16, 226 as libc::c_int as yytype_int16,
     47 as libc::c_int as yytype_int16, 51 as libc::c_int as yytype_int16,
     299 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 41 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     57 as libc::c_int as yytype_int16, 58 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 47 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     369 as libc::c_int as yytype_int16, 370 as libc::c_int as yytype_int16,
     371 as libc::c_int as yytype_int16, 372 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 57 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     41 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     383 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     47 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     387 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     83 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     57 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     397 as libc::c_int as yytype_int16, 398 as libc::c_int as yytype_int16,
     399 as libc::c_int as yytype_int16, 400 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 83 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     279 as libc::c_int as yytype_int16, 280 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 284 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 286 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 288 as libc::c_int as yytype_int16,
     289 as libc::c_int as yytype_int16, 290 as libc::c_int as yytype_int16,
     291 as libc::c_int as yytype_int16, 292 as libc::c_int as yytype_int16,
     293 as libc::c_int as yytype_int16, 294 as libc::c_int as yytype_int16,
     83 as libc::c_int as yytype_int16, 58 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 120 as libc::c_int as yytype_int16,
     301 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     303 as libc::c_int as yytype_int16, 124 as libc::c_int as yytype_int16,
     305 as libc::c_int as yytype_int16, 306 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     315 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     317 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     319 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     141 as libc::c_int as yytype_int16, 142 as libc::c_int as yytype_int16,
     143 as libc::c_int as yytype_int16, 144 as libc::c_int as yytype_int16,
     145 as libc::c_int as yytype_int16, 146 as libc::c_int as yytype_int16,
     147 as libc::c_int as yytype_int16, 148 as libc::c_int as yytype_int16,
     149 as libc::c_int as yytype_int16, 150 as libc::c_int as yytype_int16,
     151 as libc::c_int as yytype_int16, 152 as libc::c_int as yytype_int16,
     153 as libc::c_int as yytype_int16, 154 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 151 as libc::c_int as yytype_int16,
     152 as libc::c_int as yytype_int16, 153 as libc::c_int as yytype_int16,
     154 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     156 as libc::c_int as yytype_int16, 157 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 120 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 180 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 124 as libc::c_int as yytype_int16,
     151 as libc::c_int as yytype_int16, 152 as libc::c_int as yytype_int16,
     153 as libc::c_int as yytype_int16, 154 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     180 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     141 as libc::c_int as yytype_int16, 142 as libc::c_int as yytype_int16,
     143 as libc::c_int as yytype_int16, 144 as libc::c_int as yytype_int16,
     145 as libc::c_int as yytype_int16, 146 as libc::c_int as yytype_int16,
     147 as libc::c_int as yytype_int16, 148 as libc::c_int as yytype_int16,
     149 as libc::c_int as yytype_int16, 150 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 8 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 180 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 156 as libc::c_int as yytype_int16,
     157 as libc::c_int as yytype_int16, 158 as libc::c_int as yytype_int16,
     159 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     219 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 226 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 26 as libc::c_int as yytype_int16,
     27 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     33 as libc::c_int as yytype_int16, 34 as libc::c_int as yytype_int16,
     35 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     226 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     39 as libc::c_int as yytype_int16, 40 as libc::c_int as yytype_int16,
     41 as libc::c_int as yytype_int16, 42 as libc::c_int as yytype_int16,
     43 as libc::c_int as yytype_int16, 44 as libc::c_int as yytype_int16,
     45 as libc::c_int as yytype_int16, 46 as libc::c_int as yytype_int16,
     47 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 52 as libc::c_int as yytype_int16,
     53 as libc::c_int as yytype_int16, 54 as libc::c_int as yytype_int16,
     55 as libc::c_int as yytype_int16, 226 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 58 as libc::c_int as yytype_int16,
     59 as libc::c_int as yytype_int16, 60 as libc::c_int as yytype_int16,
     61 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 64 as libc::c_int as yytype_int16,
     65 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     67 as libc::c_int as yytype_int16, 68 as libc::c_int as yytype_int16,
     69 as libc::c_int as yytype_int16, 70 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 72 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     219 as libc::c_int as yytype_int16, 76 as libc::c_int as yytype_int16,
     279 as libc::c_int as yytype_int16, 280 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 284 as libc::c_int as yytype_int16,
     285 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 279 as libc::c_int as yytype_int16,
     280 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 283 as libc::c_int as yytype_int16,
     284 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 300 as libc::c_int as yytype_int16,
     301 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 304 as libc::c_int as yytype_int16,
     305 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     279 as libc::c_int as yytype_int16, 280 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 301 as libc::c_int as yytype_int16,
     302 as libc::c_int as yytype_int16, 284 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 305 as libc::c_int as yytype_int16,
     319 as libc::c_int as yytype_int16, 307 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 18 as libc::c_int as yytype_int16,
     19 as libc::c_int as yytype_int16, 20 as libc::c_int as yytype_int16,
     21 as libc::c_int as yytype_int16, 22 as libc::c_int as yytype_int16,
     23 as libc::c_int as yytype_int16, 319 as libc::c_int as yytype_int16,
     301 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     27 as libc::c_int as yytype_int16, 28 as libc::c_int as yytype_int16,
     305 as libc::c_int as yytype_int16, 30 as libc::c_int as yytype_int16,
     31 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     283 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     285 as libc::c_int as yytype_int16, 286 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 6 as libc::c_int as yytype_int16,
     7 as libc::c_int as yytype_int16, 8 as libc::c_int as yytype_int16,
     9 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     319 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 300 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 302 as libc::c_int as yytype_int16,
     303 as libc::c_int as yytype_int16, 304 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 306 as libc::c_int as yytype_int16,
     307 as libc::c_int as yytype_int16, 26 as libc::c_int as yytype_int16,
     27 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     33 as libc::c_int as yytype_int16, 34 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     39 as libc::c_int as yytype_int16, 40 as libc::c_int as yytype_int16,
     41 as libc::c_int as yytype_int16, 42 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 44 as libc::c_int as yytype_int16,
     45 as libc::c_int as yytype_int16, 46 as libc::c_int as yytype_int16,
     47 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 52 as libc::c_int as yytype_int16,
     53 as libc::c_int as yytype_int16, 54 as libc::c_int as yytype_int16,
     55 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 58 as libc::c_int as yytype_int16,
     59 as libc::c_int as yytype_int16, 60 as libc::c_int as yytype_int16,
     61 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 64 as libc::c_int as yytype_int16,
     65 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     67 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     69 as libc::c_int as yytype_int16, 70 as libc::c_int as yytype_int16,
     71 as libc::c_int as yytype_int16, 6 as libc::c_int as yytype_int16,
     7 as libc::c_int as yytype_int16, 8 as libc::c_int as yytype_int16,
     9 as libc::c_int as yytype_int16, 76 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 26 as libc::c_int as yytype_int16,
     27 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     33 as libc::c_int as yytype_int16, 34 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     39 as libc::c_int as yytype_int16, 40 as libc::c_int as yytype_int16,
     41 as libc::c_int as yytype_int16, 42 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 44 as libc::c_int as yytype_int16,
     45 as libc::c_int as yytype_int16, 46 as libc::c_int as yytype_int16,
     47 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 52 as libc::c_int as yytype_int16,
     53 as libc::c_int as yytype_int16, 54 as libc::c_int as yytype_int16,
     55 as libc::c_int as yytype_int16, 8 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 58 as libc::c_int as yytype_int16,
     59 as libc::c_int as yytype_int16, 60 as libc::c_int as yytype_int16,
     61 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 64 as libc::c_int as yytype_int16,
     65 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     67 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     69 as libc::c_int as yytype_int16, 70 as libc::c_int as yytype_int16,
     71 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 26 as libc::c_int as yytype_int16,
     27 as libc::c_int as yytype_int16, 76 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     33 as libc::c_int as yytype_int16, 34 as libc::c_int as yytype_int16,
     35 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     39 as libc::c_int as yytype_int16, 40 as libc::c_int as yytype_int16,
     41 as libc::c_int as yytype_int16, 42 as libc::c_int as yytype_int16,
     43 as libc::c_int as yytype_int16, 44 as libc::c_int as yytype_int16,
     45 as libc::c_int as yytype_int16, 46 as libc::c_int as yytype_int16,
     47 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 52 as libc::c_int as yytype_int16,
     53 as libc::c_int as yytype_int16, 54 as libc::c_int as yytype_int16,
     55 as libc::c_int as yytype_int16, 8 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 58 as libc::c_int as yytype_int16,
     59 as libc::c_int as yytype_int16, 60 as libc::c_int as yytype_int16,
     61 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 64 as libc::c_int as yytype_int16,
     65 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     67 as libc::c_int as yytype_int16, 68 as libc::c_int as yytype_int16,
     69 as libc::c_int as yytype_int16, 70 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 26 as libc::c_int as yytype_int16,
     27 as libc::c_int as yytype_int16, 76 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     33 as libc::c_int as yytype_int16, 34 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     39 as libc::c_int as yytype_int16, 40 as libc::c_int as yytype_int16,
     41 as libc::c_int as yytype_int16, 42 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 44 as libc::c_int as yytype_int16,
     45 as libc::c_int as yytype_int16, 46 as libc::c_int as yytype_int16,
     47 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 52 as libc::c_int as yytype_int16,
     53 as libc::c_int as yytype_int16, 54 as libc::c_int as yytype_int16,
     55 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 58 as libc::c_int as yytype_int16,
     59 as libc::c_int as yytype_int16, 60 as libc::c_int as yytype_int16,
     61 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 64 as libc::c_int as yytype_int16,
     65 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     67 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     69 as libc::c_int as yytype_int16, 70 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     12 as libc::c_int as yytype_int16, 13 as libc::c_int as yytype_int16,
     14 as libc::c_int as yytype_int16, 76 as libc::c_int as yytype_int16,
     16 as libc::c_int as yytype_int16, 17 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 39 as libc::c_int as yytype_int16,
     40 as libc::c_int as yytype_int16, 41 as libc::c_int as yytype_int16,
     42 as libc::c_int as yytype_int16, 43 as libc::c_int as yytype_int16,
     44 as libc::c_int as yytype_int16, 45 as libc::c_int as yytype_int16,
     46 as libc::c_int as yytype_int16, 47 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 55 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 57 as libc::c_int as yytype_int16,
     58 as libc::c_int as yytype_int16, 59 as libc::c_int as yytype_int16,
     60 as libc::c_int as yytype_int16, 61 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 63 as libc::c_int as yytype_int16,
     12 as libc::c_int as yytype_int16, 13 as libc::c_int as yytype_int16,
     14 as libc::c_int as yytype_int16, 67 as libc::c_int as yytype_int16,
     16 as libc::c_int as yytype_int16, 17 as libc::c_int as yytype_int16,
     70 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 79 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 39 as libc::c_int as yytype_int16,
     40 as libc::c_int as yytype_int16, 41 as libc::c_int as yytype_int16,
     42 as libc::c_int as yytype_int16, 43 as libc::c_int as yytype_int16,
     44 as libc::c_int as yytype_int16, 45 as libc::c_int as yytype_int16,
     46 as libc::c_int as yytype_int16, 47 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 55 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 57 as libc::c_int as yytype_int16,
     58 as libc::c_int as yytype_int16, 59 as libc::c_int as yytype_int16,
     60 as libc::c_int as yytype_int16, 61 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 63 as libc::c_int as yytype_int16,
     12 as libc::c_int as yytype_int16, 13 as libc::c_int as yytype_int16,
     14 as libc::c_int as yytype_int16, 67 as libc::c_int as yytype_int16,
     16 as libc::c_int as yytype_int16, 17 as libc::c_int as yytype_int16,
     70 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 79 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 39 as libc::c_int as yytype_int16,
     40 as libc::c_int as yytype_int16, 41 as libc::c_int as yytype_int16,
     42 as libc::c_int as yytype_int16, 43 as libc::c_int as yytype_int16,
     44 as libc::c_int as yytype_int16, 45 as libc::c_int as yytype_int16,
     46 as libc::c_int as yytype_int16, 47 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 55 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 57 as libc::c_int as yytype_int16,
     58 as libc::c_int as yytype_int16, 59 as libc::c_int as yytype_int16,
     60 as libc::c_int as yytype_int16, 61 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 63 as libc::c_int as yytype_int16,
     12 as libc::c_int as yytype_int16, 13 as libc::c_int as yytype_int16,
     14 as libc::c_int as yytype_int16, 67 as libc::c_int as yytype_int16,
     16 as libc::c_int as yytype_int16, 17 as libc::c_int as yytype_int16,
     70 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 79 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 39 as libc::c_int as yytype_int16,
     40 as libc::c_int as yytype_int16, 41 as libc::c_int as yytype_int16,
     42 as libc::c_int as yytype_int16, 43 as libc::c_int as yytype_int16,
     44 as libc::c_int as yytype_int16, 45 as libc::c_int as yytype_int16,
     46 as libc::c_int as yytype_int16, 47 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 55 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 57 as libc::c_int as yytype_int16,
     58 as libc::c_int as yytype_int16, 59 as libc::c_int as yytype_int16,
     60 as libc::c_int as yytype_int16, 61 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 63 as libc::c_int as yytype_int16,
     12 as libc::c_int as yytype_int16, 13 as libc::c_int as yytype_int16,
     14 as libc::c_int as yytype_int16, 67 as libc::c_int as yytype_int16,
     16 as libc::c_int as yytype_int16, 17 as libc::c_int as yytype_int16,
     70 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 79 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 39 as libc::c_int as yytype_int16,
     40 as libc::c_int as yytype_int16, 41 as libc::c_int as yytype_int16,
     42 as libc::c_int as yytype_int16, 43 as libc::c_int as yytype_int16,
     44 as libc::c_int as yytype_int16, 45 as libc::c_int as yytype_int16,
     46 as libc::c_int as yytype_int16, 47 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 55 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 57 as libc::c_int as yytype_int16,
     58 as libc::c_int as yytype_int16, 59 as libc::c_int as yytype_int16,
     60 as libc::c_int as yytype_int16, 61 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 63 as libc::c_int as yytype_int16,
     12 as libc::c_int as yytype_int16, 13 as libc::c_int as yytype_int16,
     14 as libc::c_int as yytype_int16, 67 as libc::c_int as yytype_int16,
     16 as libc::c_int as yytype_int16, 17 as libc::c_int as yytype_int16,
     70 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 79 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 8 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 39 as libc::c_int as yytype_int16,
     40 as libc::c_int as yytype_int16, 41 as libc::c_int as yytype_int16,
     42 as libc::c_int as yytype_int16, 43 as libc::c_int as yytype_int16,
     44 as libc::c_int as yytype_int16, 45 as libc::c_int as yytype_int16,
     46 as libc::c_int as yytype_int16, 47 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 55 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 57 as libc::c_int as yytype_int16,
     58 as libc::c_int as yytype_int16, 59 as libc::c_int as yytype_int16,
     60 as libc::c_int as yytype_int16, 61 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 63 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     39 as libc::c_int as yytype_int16, 67 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 42 as libc::c_int as yytype_int16,
     70 as libc::c_int as yytype_int16, 44 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     47 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 79 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 54 as libc::c_int as yytype_int16,
     55 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 60 as libc::c_int as yytype_int16,
     61 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     67 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     69 as libc::c_int as yytype_int16, 70 as libc::c_int as yytype_int16,
     12 as libc::c_int as yytype_int16, 13 as libc::c_int as yytype_int16,
     14 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     16 as libc::c_int as yytype_int16, 17 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 37 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 39 as libc::c_int as yytype_int16,
     40 as libc::c_int as yytype_int16, 41 as libc::c_int as yytype_int16,
     42 as libc::c_int as yytype_int16, 43 as libc::c_int as yytype_int16,
     44 as libc::c_int as yytype_int16, 45 as libc::c_int as yytype_int16,
     46 as libc::c_int as yytype_int16, 47 as libc::c_int as yytype_int16,
     12 as libc::c_int as yytype_int16, 13 as libc::c_int as yytype_int16,
     14 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     16 as libc::c_int as yytype_int16, 17 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 55 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 57 as libc::c_int as yytype_int16,
     58 as libc::c_int as yytype_int16, 59 as libc::c_int as yytype_int16,
     60 as libc::c_int as yytype_int16, 61 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 63 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 67 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     70 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 39 as libc::c_int as yytype_int16,
     40 as libc::c_int as yytype_int16, 41 as libc::c_int as yytype_int16,
     42 as libc::c_int as yytype_int16, 43 as libc::c_int as yytype_int16,
     44 as libc::c_int as yytype_int16, 45 as libc::c_int as yytype_int16,
     46 as libc::c_int as yytype_int16, 47 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 55 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 57 as libc::c_int as yytype_int16,
     58 as libc::c_int as yytype_int16, 59 as libc::c_int as yytype_int16,
     60 as libc::c_int as yytype_int16, 61 as libc::c_int as yytype_int16,
     27 as libc::c_int as yytype_int16, 63 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 67 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 34 as libc::c_int as yytype_int16,
     70 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     41 as libc::c_int as yytype_int16, 42 as libc::c_int as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 46 as libc::c_int as yytype_int16,
     47 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     53 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     55 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     59 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     61 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     65 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     67 as libc::c_int as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, -(1 as libc::c_int) as yytype_int16,
     -(1 as libc::c_int) as yytype_int16, 76 as libc::c_int as yytype_int16];
/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
     symbol of state STATE-NUM.  */
static mut yystos: [yytype_uint8; 403] =
    [0 as libc::c_int as yytype_uint8, 10 as libc::c_int as yytype_uint8,
     83 as libc::c_int as yytype_uint8, 85 as libc::c_int as yytype_uint8,
     86 as libc::c_int as yytype_uint8, 36 as libc::c_int as yytype_uint8,
     0 as libc::c_int as yytype_uint8, 37 as libc::c_int as yytype_uint8,
     86 as libc::c_int as yytype_uint8, 87 as libc::c_int as yytype_uint8,
     88 as libc::c_int as yytype_uint8, 89 as libc::c_int as yytype_uint8,
     93 as libc::c_int as yytype_uint8, 72 as libc::c_int as yytype_uint8,
     4 as libc::c_int as yytype_uint8, 5 as libc::c_int as yytype_uint8,
     36 as libc::c_int as yytype_uint8, 84 as libc::c_int as yytype_uint8,
     88 as libc::c_int as yytype_uint8, 38 as libc::c_int as yytype_uint8,
     92 as libc::c_int as yytype_uint8, 72 as libc::c_int as yytype_uint8,
     75 as libc::c_int as yytype_uint8, 4 as libc::c_int as yytype_uint8,
     94 as libc::c_int as yytype_uint8, 96 as libc::c_int as yytype_uint8,
     73 as libc::c_int as yytype_uint8, 90 as libc::c_int as yytype_uint8,
     91 as libc::c_int as yytype_uint8, 92 as libc::c_int as yytype_uint8,
     38 as libc::c_int as yytype_uint8, 3 as libc::c_int as yytype_uint8,
     5 as libc::c_int as yytype_uint8, 96 as libc::c_int as yytype_uint8,
     97 as libc::c_int as yytype_uint8, 98 as libc::c_int as yytype_uint8,
     100 as libc::c_int as yytype_uint8, 105 as libc::c_int as yytype_uint8,
     106 as libc::c_int as yytype_uint8, 34 as libc::c_int as yytype_uint8,
     73 as libc::c_int as yytype_uint8, 76 as libc::c_int as yytype_uint8,
     36 as libc::c_int as yytype_uint8, 38 as libc::c_int as yytype_uint8,
     70 as libc::c_int as yytype_uint8, 106 as libc::c_int as yytype_uint8,
     72 as libc::c_int as yytype_uint8, 76 as libc::c_int as yytype_uint8,
     76 as libc::c_int as yytype_uint8, 104 as libc::c_int as yytype_uint8,
     78 as libc::c_int as yytype_uint8, 74 as libc::c_int as yytype_uint8,
     34 as libc::c_int as yytype_uint8, 6 as libc::c_int as yytype_uint8,
     7 as libc::c_int as yytype_uint8, 8 as libc::c_int as yytype_uint8,
     9 as libc::c_int as yytype_uint8, 26 as libc::c_int as yytype_uint8,
     27 as libc::c_int as yytype_uint8, 33 as libc::c_int as yytype_uint8,
     34 as libc::c_int as yytype_uint8, 39 as libc::c_int as yytype_uint8,
     40 as libc::c_int as yytype_uint8, 41 as libc::c_int as yytype_uint8,
     42 as libc::c_int as yytype_uint8, 44 as libc::c_int as yytype_uint8,
     45 as libc::c_int as yytype_uint8, 46 as libc::c_int as yytype_uint8,
     47 as libc::c_int as yytype_uint8, 52 as libc::c_int as yytype_uint8,
     53 as libc::c_int as yytype_uint8, 54 as libc::c_int as yytype_uint8,
     55 as libc::c_int as yytype_uint8, 58 as libc::c_int as yytype_uint8,
     59 as libc::c_int as yytype_uint8, 60 as libc::c_int as yytype_uint8,
     61 as libc::c_int as yytype_uint8, 64 as libc::c_int as yytype_uint8,
     65 as libc::c_int as yytype_uint8, 67 as libc::c_int as yytype_uint8,
     69 as libc::c_int as yytype_uint8, 70 as libc::c_int as yytype_uint8,
     71 as libc::c_int as yytype_uint8, 76 as libc::c_int as yytype_uint8,
     95 as libc::c_int as yytype_uint8, 125 as libc::c_int as yytype_uint8,
     127 as libc::c_int as yytype_uint8, 128 as libc::c_int as yytype_uint8,
     129 as libc::c_int as yytype_uint8, 130 as libc::c_int as yytype_uint8,
     131 as libc::c_int as yytype_uint8, 132 as libc::c_int as yytype_uint8,
     133 as libc::c_int as yytype_uint8, 134 as libc::c_int as yytype_uint8,
     137 as libc::c_int as yytype_uint8, 138 as libc::c_int as yytype_uint8,
     139 as libc::c_int as yytype_uint8, 140 as libc::c_int as yytype_uint8,
     38 as libc::c_int as yytype_uint8, 63 as libc::c_int as yytype_uint8,
     64 as libc::c_int as yytype_uint8, 65 as libc::c_int as yytype_uint8,
     66 as libc::c_int as yytype_uint8, 67 as libc::c_int as yytype_uint8,
     68 as libc::c_int as yytype_uint8, 99 as libc::c_int as yytype_uint8,
     8 as libc::c_int as yytype_uint8, 69 as libc::c_int as yytype_uint8,
     95 as libc::c_int as yytype_uint8, 36 as libc::c_int as yytype_uint8,
     77 as libc::c_int as yytype_uint8, 101 as libc::c_int as yytype_uint8,
     102 as libc::c_int as yytype_uint8, 103 as libc::c_int as yytype_uint8,
     72 as libc::c_int as yytype_uint8, 87 as libc::c_int as yytype_uint8,
     74 as libc::c_int as yytype_uint8, 75 as libc::c_int as yytype_uint8,
     75 as libc::c_int as yytype_uint8, 127 as libc::c_int as yytype_uint8,
     76 as libc::c_int as yytype_uint8, 125 as libc::c_int as yytype_uint8,
     129 as libc::c_int as yytype_uint8, 130 as libc::c_int as yytype_uint8,
     73 as libc::c_int as yytype_uint8, 135 as libc::c_int as yytype_uint8,
     136 as libc::c_int as yytype_uint8, 136 as libc::c_int as yytype_uint8,
     136 as libc::c_int as yytype_uint8, 136 as libc::c_int as yytype_uint8,
     76 as libc::c_int as yytype_uint8, 76 as libc::c_int as yytype_uint8,
     76 as libc::c_int as yytype_uint8, 76 as libc::c_int as yytype_uint8,
     76 as libc::c_int as yytype_uint8, 76 as libc::c_int as yytype_uint8,
     76 as libc::c_int as yytype_uint8, 75 as libc::c_int as yytype_uint8,
     125 as libc::c_int as yytype_uint8, 127 as libc::c_int as yytype_uint8,
     77 as libc::c_int as yytype_uint8, 18 as libc::c_int as yytype_uint8,
     19 as libc::c_int as yytype_uint8, 20 as libc::c_int as yytype_uint8,
     21 as libc::c_int as yytype_uint8, 22 as libc::c_int as yytype_uint8,
     23 as libc::c_int as yytype_uint8, 27 as libc::c_int as yytype_uint8,
     28 as libc::c_int as yytype_uint8, 30 as libc::c_int as yytype_uint8,
     31 as libc::c_int as yytype_uint8, 18 as libc::c_int as yytype_uint8,
     19 as libc::c_int as yytype_uint8, 24 as libc::c_int as yytype_uint8,
     25 as libc::c_int as yytype_uint8, 75 as libc::c_int as yytype_uint8,
     18 as libc::c_int as yytype_uint8, 19 as libc::c_int as yytype_uint8,
     18 as libc::c_int as yytype_uint8, 19 as libc::c_int as yytype_uint8,
     81 as libc::c_int as yytype_uint8, 48 as libc::c_int as yytype_uint8,
     49 as libc::c_int as yytype_uint8, 50 as libc::c_int as yytype_uint8,
     51 as libc::c_int as yytype_uint8, 77 as libc::c_int as yytype_uint8,
     77 as libc::c_int as yytype_uint8, 77 as libc::c_int as yytype_uint8,
     39 as libc::c_int as yytype_uint8, 40 as libc::c_int as yytype_uint8,
     41 as libc::c_int as yytype_uint8, 42 as libc::c_int as yytype_uint8,
     43 as libc::c_int as yytype_uint8, 47 as libc::c_int as yytype_uint8,
     51 as libc::c_int as yytype_uint8, 92 as libc::c_int as yytype_uint8,
     75 as libc::c_int as yytype_uint8, 77 as libc::c_int as yytype_uint8,
     75 as libc::c_int as yytype_uint8, 77 as libc::c_int as yytype_uint8,
     12 as libc::c_int as yytype_uint8, 13 as libc::c_int as yytype_uint8,
     14 as libc::c_int as yytype_uint8, 16 as libc::c_int as yytype_uint8,
     17 as libc::c_int as yytype_uint8, 39 as libc::c_int as yytype_uint8,
     40 as libc::c_int as yytype_uint8, 41 as libc::c_int as yytype_uint8,
     42 as libc::c_int as yytype_uint8, 43 as libc::c_int as yytype_uint8,
     57 as libc::c_int as yytype_uint8, 58 as libc::c_int as yytype_uint8,
     59 as libc::c_int as yytype_uint8, 60 as libc::c_int as yytype_uint8,
     61 as libc::c_int as yytype_uint8, 63 as libc::c_int as yytype_uint8,
     70 as libc::c_int as yytype_uint8, 108 as libc::c_int as yytype_uint8,
     109 as libc::c_int as yytype_uint8, 110 as libc::c_int as yytype_uint8,
     111 as libc::c_int as yytype_uint8, 113 as libc::c_int as yytype_uint8,
     114 as libc::c_int as yytype_uint8, 118 as libc::c_int as yytype_uint8,
     119 as libc::c_int as yytype_uint8, 121 as libc::c_int as yytype_uint8,
     123 as libc::c_int as yytype_uint8, 131 as libc::c_int as yytype_uint8,
     132 as libc::c_int as yytype_uint8, 133 as libc::c_int as yytype_uint8,
     134 as libc::c_int as yytype_uint8, 137 as libc::c_int as yytype_uint8,
     138 as libc::c_int as yytype_uint8, 139 as libc::c_int as yytype_uint8,
     140 as libc::c_int as yytype_uint8, 34 as libc::c_int as yytype_uint8,
     34 as libc::c_int as yytype_uint8, 125 as libc::c_int as yytype_uint8,
     125 as libc::c_int as yytype_uint8, 73 as libc::c_int as yytype_uint8,
     11 as libc::c_int as yytype_uint8, 34 as libc::c_int as yytype_uint8,
     35 as libc::c_int as yytype_uint8, 41 as libc::c_int as yytype_uint8,
     43 as libc::c_int as yytype_uint8, 68 as libc::c_int as yytype_uint8,
     76 as libc::c_int as yytype_uint8, 115 as libc::c_int as yytype_uint8,
     116 as libc::c_int as yytype_uint8, 117 as libc::c_int as yytype_uint8,
     125 as libc::c_int as yytype_uint8, 126 as libc::c_int as yytype_uint8,
     127 as libc::c_int as yytype_uint8, 128 as libc::c_int as yytype_uint8,
     129 as libc::c_int as yytype_uint8, 115 as libc::c_int as yytype_uint8,
     115 as libc::c_int as yytype_uint8, 115 as libc::c_int as yytype_uint8,
     115 as libc::c_int as yytype_uint8, 115 as libc::c_int as yytype_uint8,
     115 as libc::c_int as yytype_uint8, 115 as libc::c_int as yytype_uint8,
     77 as libc::c_int as yytype_uint8, 77 as libc::c_int as yytype_uint8,
     72 as libc::c_int as yytype_uint8, 125 as libc::c_int as yytype_uint8,
     125 as libc::c_int as yytype_uint8, 125 as libc::c_int as yytype_uint8,
     125 as libc::c_int as yytype_uint8, 125 as libc::c_int as yytype_uint8,
     125 as libc::c_int as yytype_uint8, 125 as libc::c_int as yytype_uint8,
     125 as libc::c_int as yytype_uint8, 125 as libc::c_int as yytype_uint8,
     125 as libc::c_int as yytype_uint8, 127 as libc::c_int as yytype_uint8,
     127 as libc::c_int as yytype_uint8, 127 as libc::c_int as yytype_uint8,
     127 as libc::c_int as yytype_uint8, 34 as libc::c_int as yytype_uint8,
     128 as libc::c_int as yytype_uint8, 130 as libc::c_int as yytype_uint8,
     128 as libc::c_int as yytype_uint8, 129 as libc::c_int as yytype_uint8,
     130 as libc::c_int as yytype_uint8, 129 as libc::c_int as yytype_uint8,
     78 as libc::c_int as yytype_uint8, 78 as libc::c_int as yytype_uint8,
     107 as libc::c_int as yytype_uint8, 36 as libc::c_int as yytype_uint8,
     101 as libc::c_int as yytype_uint8, 78 as libc::c_int as yytype_uint8,
     36 as libc::c_int as yytype_uint8, 72 as libc::c_int as yytype_uint8,
     112 as libc::c_int as yytype_uint8, 125 as libc::c_int as yytype_uint8,
     126 as libc::c_int as yytype_uint8, 127 as libc::c_int as yytype_uint8,
     129 as libc::c_int as yytype_uint8, 76 as libc::c_int as yytype_uint8,
     76 as libc::c_int as yytype_uint8, 72 as libc::c_int as yytype_uint8,
     76 as libc::c_int as yytype_uint8, 80 as libc::c_int as yytype_uint8,
     80 as libc::c_int as yytype_uint8, 80 as libc::c_int as yytype_uint8,
     80 as libc::c_int as yytype_uint8, 80 as libc::c_int as yytype_uint8,
     76 as libc::c_int as yytype_uint8, 76 as libc::c_int as yytype_uint8,
     76 as libc::c_int as yytype_uint8, 76 as libc::c_int as yytype_uint8,
     76 as libc::c_int as yytype_uint8, 76 as libc::c_int as yytype_uint8,
     76 as libc::c_int as yytype_uint8, 109 as libc::c_int as yytype_uint8,
     111 as libc::c_int as yytype_uint8, 72 as libc::c_int as yytype_uint8,
     72 as libc::c_int as yytype_uint8, 15 as libc::c_int as yytype_uint8,
     80 as libc::c_int as yytype_uint8, 80 as libc::c_int as yytype_uint8,
     80 as libc::c_int as yytype_uint8, 80 as libc::c_int as yytype_uint8,
     80 as libc::c_int as yytype_uint8, 80 as libc::c_int as yytype_uint8,
     80 as libc::c_int as yytype_uint8, 80 as libc::c_int as yytype_uint8,
     74 as libc::c_int as yytype_uint8, 125 as libc::c_int as yytype_uint8,
     39 as libc::c_int as yytype_uint8, 40 as libc::c_int as yytype_uint8,
     41 as libc::c_int as yytype_uint8, 42 as libc::c_int as yytype_uint8,
     43 as libc::c_int as yytype_uint8, 76 as libc::c_int as yytype_uint8,
     126 as libc::c_int as yytype_uint8, 75 as libc::c_int as yytype_uint8,
     77 as libc::c_int as yytype_uint8, 29 as libc::c_int as yytype_uint8,
     77 as libc::c_int as yytype_uint8, 77 as libc::c_int as yytype_uint8,
     77 as libc::c_int as yytype_uint8, 77 as libc::c_int as yytype_uint8,
     77 as libc::c_int as yytype_uint8, 77 as libc::c_int as yytype_uint8,
     87 as libc::c_int as yytype_uint8, 87 as libc::c_int as yytype_uint8,
     78 as libc::c_int as yytype_uint8, 87 as libc::c_int as yytype_uint8,
     92 as libc::c_int as yytype_uint8, 72 as libc::c_int as yytype_uint8,
     127 as libc::c_int as yytype_uint8, 127 as libc::c_int as yytype_uint8,
     34 as libc::c_int as yytype_uint8, 128 as libc::c_int as yytype_uint8,
     127 as libc::c_int as yytype_uint8, 125 as libc::c_int as yytype_uint8,
     129 as libc::c_int as yytype_uint8, 34 as libc::c_int as yytype_uint8,
     41 as libc::c_int as yytype_uint8, 76 as libc::c_int as yytype_uint8,
     126 as libc::c_int as yytype_uint8, 115 as libc::c_int as yytype_uint8,
     115 as libc::c_int as yytype_uint8, 115 as libc::c_int as yytype_uint8,
     115 as libc::c_int as yytype_uint8, 115 as libc::c_int as yytype_uint8,
     115 as libc::c_int as yytype_uint8, 115 as libc::c_int as yytype_uint8,
     79 as libc::c_int as yytype_uint8, 78 as libc::c_int as yytype_uint8,
     120 as libc::c_int as yytype_uint8, 121 as libc::c_int as yytype_uint8,
     125 as libc::c_int as yytype_uint8, 127 as libc::c_int as yytype_uint8,
     128 as libc::c_int as yytype_uint8, 129 as libc::c_int as yytype_uint8,
     125 as libc::c_int as yytype_uint8, 127 as libc::c_int as yytype_uint8,
     129 as libc::c_int as yytype_uint8, 128 as libc::c_int as yytype_uint8,
     74 as libc::c_int as yytype_uint8, 115 as libc::c_int as yytype_uint8,
     77 as libc::c_int as yytype_uint8, 116 as libc::c_int as yytype_uint8,
     125 as libc::c_int as yytype_uint8, 126 as libc::c_int as yytype_uint8,
     127 as libc::c_int as yytype_uint8, 110 as libc::c_int as yytype_uint8,
     110 as libc::c_int as yytype_uint8, 87 as libc::c_int as yytype_uint8,
     110 as libc::c_int as yytype_uint8, 77 as libc::c_int as yytype_uint8,
     77 as libc::c_int as yytype_uint8, 77 as libc::c_int as yytype_uint8,
     77 as libc::c_int as yytype_uint8, 77 as libc::c_int as yytype_uint8,
     77 as libc::c_int as yytype_uint8, 77 as libc::c_int as yytype_uint8,
     77 as libc::c_int as yytype_uint8, 77 as libc::c_int as yytype_uint8,
     77 as libc::c_int as yytype_uint8, 110 as libc::c_int as yytype_uint8,
     77 as libc::c_int as yytype_uint8, 79 as libc::c_int as yytype_uint8,
     79 as libc::c_int as yytype_uint8, 110 as libc::c_int as yytype_uint8,
     109 as libc::c_int as yytype_uint8, 124 as libc::c_int as yytype_uint8,
     122 as libc::c_int as yytype_uint8, 72 as libc::c_int as yytype_uint8,
     72 as libc::c_int as yytype_uint8, 72 as libc::c_int as yytype_uint8,
     79 as libc::c_int as yytype_uint8, 79 as libc::c_int as yytype_uint8,
     79 as libc::c_int as yytype_uint8, 78 as libc::c_int as yytype_uint8,
     78 as libc::c_int as yytype_uint8, 110 as libc::c_int as yytype_uint8,
     110 as libc::c_int as yytype_uint8, 79 as libc::c_int as yytype_uint8,
     79 as libc::c_int as yytype_uint8];
/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
static mut yyr1: [yytype_uint8; 199] =
    [0 as libc::c_int as yytype_uint8, 82 as libc::c_int as yytype_uint8,
     84 as libc::c_int as yytype_uint8, 83 as libc::c_int as yytype_uint8,
     85 as libc::c_int as yytype_uint8, 85 as libc::c_int as yytype_uint8,
     85 as libc::c_int as yytype_uint8, 86 as libc::c_int as yytype_uint8,
     87 as libc::c_int as yytype_uint8, 87 as libc::c_int as yytype_uint8,
     87 as libc::c_int as yytype_uint8, 88 as libc::c_int as yytype_uint8,
     89 as libc::c_int as yytype_uint8, 89 as libc::c_int as yytype_uint8,
     89 as libc::c_int as yytype_uint8, 90 as libc::c_int as yytype_uint8,
     91 as libc::c_int as yytype_uint8, 91 as libc::c_int as yytype_uint8,
     92 as libc::c_int as yytype_uint8, 92 as libc::c_int as yytype_uint8,
     93 as libc::c_int as yytype_uint8, 93 as libc::c_int as yytype_uint8,
     94 as libc::c_int as yytype_uint8, 94 as libc::c_int as yytype_uint8,
     94 as libc::c_int as yytype_uint8, 95 as libc::c_int as yytype_uint8,
     95 as libc::c_int as yytype_uint8, 95 as libc::c_int as yytype_uint8,
     95 as libc::c_int as yytype_uint8, 95 as libc::c_int as yytype_uint8,
     95 as libc::c_int as yytype_uint8, 96 as libc::c_int as yytype_uint8,
     97 as libc::c_int as yytype_uint8, 97 as libc::c_int as yytype_uint8,
     98 as libc::c_int as yytype_uint8, 98 as libc::c_int as yytype_uint8,
     99 as libc::c_int as yytype_uint8, 99 as libc::c_int as yytype_uint8,
     99 as libc::c_int as yytype_uint8, 99 as libc::c_int as yytype_uint8,
     99 as libc::c_int as yytype_uint8, 99 as libc::c_int as yytype_uint8,
     100 as libc::c_int as yytype_uint8, 100 as libc::c_int as yytype_uint8,
     101 as libc::c_int as yytype_uint8, 101 as libc::c_int as yytype_uint8,
     101 as libc::c_int as yytype_uint8, 101 as libc::c_int as yytype_uint8,
     101 as libc::c_int as yytype_uint8, 101 as libc::c_int as yytype_uint8,
     101 as libc::c_int as yytype_uint8, 102 as libc::c_int as yytype_uint8,
     102 as libc::c_int as yytype_uint8, 103 as libc::c_int as yytype_uint8,
     103 as libc::c_int as yytype_uint8, 104 as libc::c_int as yytype_uint8,
     104 as libc::c_int as yytype_uint8, 105 as libc::c_int as yytype_uint8,
     105 as libc::c_int as yytype_uint8, 106 as libc::c_int as yytype_uint8,
     106 as libc::c_int as yytype_uint8, 106 as libc::c_int as yytype_uint8,
     107 as libc::c_int as yytype_uint8, 106 as libc::c_int as yytype_uint8,
     106 as libc::c_int as yytype_uint8, 106 as libc::c_int as yytype_uint8,
     106 as libc::c_int as yytype_uint8, 108 as libc::c_int as yytype_uint8,
     108 as libc::c_int as yytype_uint8, 109 as libc::c_int as yytype_uint8,
     109 as libc::c_int as yytype_uint8, 110 as libc::c_int as yytype_uint8,
     110 as libc::c_int as yytype_uint8, 110 as libc::c_int as yytype_uint8,
     111 as libc::c_int as yytype_uint8, 111 as libc::c_int as yytype_uint8,
     111 as libc::c_int as yytype_uint8, 111 as libc::c_int as yytype_uint8,
     111 as libc::c_int as yytype_uint8, 111 as libc::c_int as yytype_uint8,
     111 as libc::c_int as yytype_uint8, 111 as libc::c_int as yytype_uint8,
     111 as libc::c_int as yytype_uint8, 112 as libc::c_int as yytype_uint8,
     112 as libc::c_int as yytype_uint8, 112 as libc::c_int as yytype_uint8,
     112 as libc::c_int as yytype_uint8, 113 as libc::c_int as yytype_uint8,
     113 as libc::c_int as yytype_uint8, 113 as libc::c_int as yytype_uint8,
     113 as libc::c_int as yytype_uint8, 113 as libc::c_int as yytype_uint8,
     113 as libc::c_int as yytype_uint8, 113 as libc::c_int as yytype_uint8,
     113 as libc::c_int as yytype_uint8, 113 as libc::c_int as yytype_uint8,
     113 as libc::c_int as yytype_uint8, 113 as libc::c_int as yytype_uint8,
     113 as libc::c_int as yytype_uint8, 113 as libc::c_int as yytype_uint8,
     114 as libc::c_int as yytype_uint8, 114 as libc::c_int as yytype_uint8,
     114 as libc::c_int as yytype_uint8, 114 as libc::c_int as yytype_uint8,
     114 as libc::c_int as yytype_uint8, 115 as libc::c_int as yytype_uint8,
     115 as libc::c_int as yytype_uint8, 115 as libc::c_int as yytype_uint8,
     116 as libc::c_int as yytype_uint8, 116 as libc::c_int as yytype_uint8,
     116 as libc::c_int as yytype_uint8, 116 as libc::c_int as yytype_uint8,
     116 as libc::c_int as yytype_uint8, 116 as libc::c_int as yytype_uint8,
     117 as libc::c_int as yytype_uint8, 117 as libc::c_int as yytype_uint8,
     117 as libc::c_int as yytype_uint8, 117 as libc::c_int as yytype_uint8,
     117 as libc::c_int as yytype_uint8, 118 as libc::c_int as yytype_uint8,
     118 as libc::c_int as yytype_uint8, 119 as libc::c_int as yytype_uint8,
     119 as libc::c_int as yytype_uint8, 120 as libc::c_int as yytype_uint8,
     122 as libc::c_int as yytype_uint8, 121 as libc::c_int as yytype_uint8,
     124 as libc::c_int as yytype_uint8, 123 as libc::c_int as yytype_uint8,
     125 as libc::c_int as yytype_uint8, 125 as libc::c_int as yytype_uint8,
     125 as libc::c_int as yytype_uint8, 125 as libc::c_int as yytype_uint8,
     125 as libc::c_int as yytype_uint8, 125 as libc::c_int as yytype_uint8,
     125 as libc::c_int as yytype_uint8, 125 as libc::c_int as yytype_uint8,
     125 as libc::c_int as yytype_uint8, 125 as libc::c_int as yytype_uint8,
     125 as libc::c_int as yytype_uint8, 125 as libc::c_int as yytype_uint8,
     125 as libc::c_int as yytype_uint8, 126 as libc::c_int as yytype_uint8,
     126 as libc::c_int as yytype_uint8, 126 as libc::c_int as yytype_uint8,
     126 as libc::c_int as yytype_uint8, 126 as libc::c_int as yytype_uint8,
     126 as libc::c_int as yytype_uint8, 126 as libc::c_int as yytype_uint8,
     126 as libc::c_int as yytype_uint8, 126 as libc::c_int as yytype_uint8,
     127 as libc::c_int as yytype_uint8, 127 as libc::c_int as yytype_uint8,
     127 as libc::c_int as yytype_uint8, 127 as libc::c_int as yytype_uint8,
     127 as libc::c_int as yytype_uint8, 127 as libc::c_int as yytype_uint8,
     127 as libc::c_int as yytype_uint8, 127 as libc::c_int as yytype_uint8,
     127 as libc::c_int as yytype_uint8, 127 as libc::c_int as yytype_uint8,
     127 as libc::c_int as yytype_uint8, 127 as libc::c_int as yytype_uint8,
     127 as libc::c_int as yytype_uint8, 127 as libc::c_int as yytype_uint8,
     127 as libc::c_int as yytype_uint8, 127 as libc::c_int as yytype_uint8,
     127 as libc::c_int as yytype_uint8, 127 as libc::c_int as yytype_uint8,
     127 as libc::c_int as yytype_uint8, 127 as libc::c_int as yytype_uint8,
     127 as libc::c_int as yytype_uint8, 127 as libc::c_int as yytype_uint8,
     127 as libc::c_int as yytype_uint8, 128 as libc::c_int as yytype_uint8,
     128 as libc::c_int as yytype_uint8, 128 as libc::c_int as yytype_uint8,
     128 as libc::c_int as yytype_uint8, 128 as libc::c_int as yytype_uint8,
     128 as libc::c_int as yytype_uint8, 128 as libc::c_int as yytype_uint8,
     128 as libc::c_int as yytype_uint8, 129 as libc::c_int as yytype_uint8,
     129 as libc::c_int as yytype_uint8, 129 as libc::c_int as yytype_uint8,
     129 as libc::c_int as yytype_uint8, 129 as libc::c_int as yytype_uint8,
     129 as libc::c_int as yytype_uint8, 130 as libc::c_int as yytype_uint8,
     131 as libc::c_int as yytype_uint8, 132 as libc::c_int as yytype_uint8,
     133 as libc::c_int as yytype_uint8, 134 as libc::c_int as yytype_uint8,
     135 as libc::c_int as yytype_uint8, 136 as libc::c_int as yytype_uint8,
     136 as libc::c_int as yytype_uint8, 137 as libc::c_int as yytype_uint8,
     138 as libc::c_int as yytype_uint8, 139 as libc::c_int as yytype_uint8,
     140 as libc::c_int as yytype_uint8];
/* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
static mut yyr2: [yytype_int8; 199] =
    [0 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     0 as libc::c_int as yytype_int8, 5 as libc::c_int as yytype_int8,
     0 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 3 as libc::c_int as yytype_int8,
     0 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 3 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 4 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 3 as libc::c_int as yytype_int8,
     0 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 3 as libc::c_int as yytype_int8,
     3 as libc::c_int as yytype_int8, 3 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     3 as libc::c_int as yytype_int8, 6 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     3 as libc::c_int as yytype_int8, 3 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     3 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     4 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     3 as libc::c_int as yytype_int8, 4 as libc::c_int as yytype_int8,
     3 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     3 as libc::c_int as yytype_int8, 8 as libc::c_int as yytype_int8,
     0 as libc::c_int as yytype_int8, 9 as libc::c_int as yytype_int8,
     8 as libc::c_int as yytype_int8, 6 as libc::c_int as yytype_int8,
     9 as libc::c_int as yytype_int8, 0 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     3 as libc::c_int as yytype_int8, 0 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     5 as libc::c_int as yytype_int8, 5 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     5 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 3 as libc::c_int as yytype_int8,
     3 as libc::c_int as yytype_int8, 3 as libc::c_int as yytype_int8,
     3 as libc::c_int as yytype_int8, 3 as libc::c_int as yytype_int8,
     3 as libc::c_int as yytype_int8, 3 as libc::c_int as yytype_int8,
     3 as libc::c_int as yytype_int8, 3 as libc::c_int as yytype_int8,
     3 as libc::c_int as yytype_int8, 3 as libc::c_int as yytype_int8,
     3 as libc::c_int as yytype_int8, 3 as libc::c_int as yytype_int8,
     4 as libc::c_int as yytype_int8, 4 as libc::c_int as yytype_int8,
     4 as libc::c_int as yytype_int8, 4 as libc::c_int as yytype_int8,
     4 as libc::c_int as yytype_int8, 0 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 3 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     3 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     3 as libc::c_int as yytype_int8, 3 as libc::c_int as yytype_int8,
     0 as libc::c_int as yytype_int8, 8 as libc::c_int as yytype_int8,
     0 as libc::c_int as yytype_int8, 8 as libc::c_int as yytype_int8,
     3 as libc::c_int as yytype_int8, 3 as libc::c_int as yytype_int8,
     3 as libc::c_int as yytype_int8, 3 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 3 as libc::c_int as yytype_int8,
     4 as libc::c_int as yytype_int8, 4 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 3 as libc::c_int as yytype_int8,
     3 as libc::c_int as yytype_int8, 3 as libc::c_int as yytype_int8,
     3 as libc::c_int as yytype_int8, 4 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     3 as libc::c_int as yytype_int8, 3 as libc::c_int as yytype_int8,
     3 as libc::c_int as yytype_int8, 3 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 3 as libc::c_int as yytype_int8,
     4 as libc::c_int as yytype_int8, 4 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 3 as libc::c_int as yytype_int8,
     3 as libc::c_int as yytype_int8, 3 as libc::c_int as yytype_int8,
     3 as libc::c_int as yytype_int8, 3 as libc::c_int as yytype_int8,
     3 as libc::c_int as yytype_int8, 3 as libc::c_int as yytype_int8,
     3 as libc::c_int as yytype_int8, 3 as libc::c_int as yytype_int8,
     3 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 4 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 4 as libc::c_int as yytype_int8,
     4 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     1 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     3 as libc::c_int as yytype_int8, 1 as libc::c_int as yytype_int8,
     4 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8, 2 as libc::c_int as yytype_int8,
     2 as libc::c_int as yytype_int8];
// can only have a positive pause
/* Allocate the code block */
/* Store the instruction */
/* Add the debugging information */
//debug(LOG_SCRIPT, "return_exp:		expression");
					/* Just pass the code up the tree */
//debug(LOG_SCRIPT, "return_exp:		stringexp");
					/* Just pass the code up the tree */
//debug(LOG_SCRIPT, "return_exp:		boolexp");
					/* Just pass the code up the tree */
//debug(LOG_SCRIPT, "return_exp:		objexp");
					/* Just pass the code up the tree */
					/* $1->type =  */
//debug(LOG_SCRIPT, "END return_exp:		objexp");
/* Return the code block */
/* Return the code block */
/* Return the code block */
/* Return the code block */
/* Return the code block */
/* Return the code block */
/* Return the code block */
/* Return the code block */
/* Return the code block */
/* Return the code block */
/* Return the code block */
/* Return the code block */
/* Return the code block */
/* YYERROR_VERBOSE */
/*-----------------------------------------------.
| Release the memory associated to this symbol.  |
`-----------------------------------------------*/
unsafe extern "C" fn yydestruct(mut yymsg: *const libc::c_char,
                                mut yytype: libc::c_int,
                                mut yyvaluep: *mut YYSTYPE) {
    if yymsg.is_null() {
        yymsg = b"Deleting\x00" as *const u8 as *const libc::c_char
    };
    /* Return the code block */
}
/* The lookahead symbol.  */
#[no_mangle]
pub static mut scr_char: libc::c_int = 0;
/* Generate the code for the function call */
/* The semantic value of the lookahead symbol.  */
#[no_mangle]
pub static mut scr_lval: YYSTYPE = YYSTYPE{bval: 0,};
/* Number of syntax errors so far.  */
/* Return the code block */
#[no_mangle]
pub static mut scr_nerrs: libc::c_int = 0;
/* Set off the scenario file parser */
// Note the end of the final trigger
/*----------.
| yyparse.  |
`----------*/
/* Generate the code for the function call */
#[no_mangle]
pub unsafe extern "C" fn scr_parse() -> libc::c_int {
    let mut current_block: u64;
    let mut yystate: yy_state_fast_t = 0;
    /* Number of tokens to shift before error messages enabled.  */
    let mut yyerrstatus: libc::c_int = 0;
    /* The stacks and their tools:
       'yyss': related to states.
       'yyvs': related to semantic values.

       Refer to the stacks through separate pointers, to allow yyoverflow
       to reallocate them elsewhere.  */
    /* Generate the code for the function call */
    /* The state stack.  */
    /* Return the code block */
    let mut yyssa: [yy_state_t; 200] = [0; 200];
    let mut yyss: *mut yy_state_t = 0 as *mut yy_state_t;
    let mut yyssp: *mut yy_state_t = 0 as *mut yy_state_t;
    /* The semantic value stack.  */
    let mut yyvsa: [YYSTYPE; 200] = [YYSTYPE{bval: 0,}; 200];
    let mut yyvs: *mut YYSTYPE = 0 as *mut YYSTYPE;
    let mut yyvsp: *mut YYSTYPE = 0 as *mut YYSTYPE;
    let mut yystacksize: libc::c_int = 0;
    let mut yyn: libc::c_int = 0;
    let mut yyresult: libc::c_int = 0;
    /* Lookahead token as an internal (translated) token number.  */
    let mut yytoken: libc::c_int = 0 as libc::c_int;
    /* The variables used to return semantic value and location from the
     action routines.  */
    let mut yyval: YYSTYPE = YYSTYPE{bval: 0,};
    /* create a dummy pblock containing nothing */
    /* The number of symbols on the RHS of the reduced rule.
     Keep to zero when no symbol should be popped.  */
    let mut yylen: libc::c_int =
        0 as libc::c_int; /* Cause a token to be read.  */
    yyss = yyssa.as_mut_ptr();
    yyssp = yyss;
    yyvs = yyvsa.as_mut_ptr();
    yyvsp = yyvs;
    yystacksize = 200 as libc::c_int;
    yystate = 0 as libc::c_int;
    yyerrstatus = 0 as libc::c_int;
    scr_nerrs = 0 as libc::c_int;
    scr_char = -(2 as libc::c_int);
    's_88:
        loop 
             /* Free the old pblocks */
             {
            (0 as libc::c_int != 0 &&
                 (0 as libc::c_int <= yystate &&
                      yystate < 403 as libc::c_int)) as libc::c_int;
            *yyssp = yystate as yy_state_t;
            if yyss.offset(yystacksize as
                               isize).offset(-(1 as libc::c_int as isize)) <=
                   yyssp {
                /* Get the current used size of the three stacks, in elements.  */
                let mut yysize: libc::c_int =
                    yyssp.wrapping_offset_from(yyss) as libc::c_int +
                        1 as libc::c_int;
                /* Return the code block */
                /* Generate the code for the parameter */
                /* Return the code block */
                /* Generate the code for the parameter */
                /* defined YYSTACK_RELOCATE */
                /* Return the code block */
                /* Extend the stack our own way.  */
                if 10000 as libc::c_int <= yystacksize {
                    current_block = 14131958400073952123;
                    break ;
                }
                yystacksize *= 2 as libc::c_int;
                if (10000 as libc::c_int) < yystacksize {
                    /* Generate the code for the parameter */
                    yystacksize = 10000 as libc::c_int
                }
                let mut yyss1: *mut yy_state_t = yyss;
                /* Return the code block */
                let mut yyptr: *mut yyalloc =
                    malloc((yystacksize *
                                (::std::mem::size_of::<yy_state_t>() as
                                     libc::c_ulong as libc::c_int +
                                     ::std::mem::size_of::<YYSTYPE>() as
                                         libc::c_ulong as libc::c_int) +
                                (::std::mem::size_of::<yyalloc>() as
                                     libc::c_ulong as libc::c_int -
                                     1 as libc::c_int)) as libc::c_uint) as
                        *mut yyalloc;
                if yyptr.is_null() {
                    current_block = 14131958400073952123;
                    break ;
                }
                //debug(LOG_SCRIPT, "objexp, scriptCodeParameter");
                let mut yynewbytes: libc::c_int = 0;
                libc::memcpy(&mut (*yyptr).yyss_alloc as *mut yy_state_t as
                                 *mut libc::c_void,
                             yyss as *const libc::c_void,
                             (yysize as
                                  libc::c_uint).wrapping_mul(::std::mem::size_of::<yy_state_t>()
                                                                 as
                                                                 libc::c_ulong)
                                 as libc::size_t);
                yyss = &mut (*yyptr).yyss_alloc;
                yynewbytes =
                    yystacksize *
                        ::std::mem::size_of::<yy_state_t>() as libc::c_ulong
                            as libc::c_int +
                        (::std::mem::size_of::<yyalloc>() as libc::c_ulong as
                             libc::c_int - 1 as libc::c_int);
                yyptr =
                    yyptr.offset((yynewbytes /
                                      ::std::mem::size_of::<yyalloc>() as
                                          libc::c_ulong as libc::c_int) as
                                     isize);
                let mut yynewbytes_0: libc::c_int = 0;
                libc::memcpy(&mut (*yyptr).yyvs_alloc as *mut YYSTYPE as
                                 *mut libc::c_void,
                             yyvs as *const libc::c_void,
                             (yysize as
                                  libc::c_uint).wrapping_mul(::std::mem::size_of::<YYSTYPE>()
                                                                 as
                                                                 libc::c_ulong)
                                 as libc::size_t);
                yyvs = &mut (*yyptr).yyvs_alloc;
                yynewbytes_0 =
                    yystacksize *
                        ::std::mem::size_of::<YYSTYPE>() as libc::c_ulong as
                            libc::c_int +
                        (::std::mem::size_of::<yyalloc>() as libc::c_ulong as
                             libc::c_int - 1 as libc::c_int);
                yyptr =
                    yyptr.offset((yynewbytes_0 /
                                      ::std::mem::size_of::<yyalloc>() as
                                          libc::c_ulong as libc::c_int) as
                                     isize);
                /* Generate the code for the parameter */
                if yyss1 != yyssa.as_mut_ptr() {
                    free(yyss1 as *mut libc::c_void);
                }
                /* Return the code block */
                yyssp =
                    yyss.offset(yysize as
                                    isize).offset(-(1 as libc::c_int as
                                                        isize));
                yyvsp =
                    yyvs.offset(yysize as
                                    isize).offset(-(1 as libc::c_int as
                                                        isize));
                /* just pass the variable reference up the tree */
                if yyss.offset(yystacksize as
                                   isize).offset(-(1 as libc::c_int as isize))
                       <= yyssp {
                    current_block = 10563765182283539921;
                    break ;
                }
            }
            /* !defined yyoverflow && !defined YYSTACK_RELOCATE */
            if yystate == 6 as libc::c_int {
                /*-------------------------------------.
| yyacceptlab -- YYACCEPT comes here.  |
`-------------------------------------*/
                yyresult = 0 as libc::c_int;
                current_block = 8424494659389369407;
                break ;
            } else {
                /*-----------.
| yybackup.  |
`-----------*/
                /* Return the code block */
                /* Do appropriate processing given the current state.  Read a
     lookahead token if we need one and don't already have one.  */
                /* First try to decide what to do without reference to lookahead token.  */
                yyn = yypact[yystate as usize] as libc::c_int;
                if yyn == -(317 as libc::c_int) {
                    current_block = 15442955482004205486;
                    /* Return the code block */
                } else {
                    /* Not known => get a lookahead token if don't already have one.  */
                    /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
                    if scr_char == -(2 as libc::c_int) {
                        scr_char = scr_lex()
                    }
                    if scr_char <= 0 as libc::c_int {
                        yytoken = 0 as libc::c_int;
                        scr_char = yytoken
                    } else {
                        /* Return the code block */
                        yytoken =
                            if 0 as libc::c_int <= scr_char &&
                                   scr_char <= 321 as libc::c_int {
                                yytranslate[scr_char as usize] as libc::c_int
                            } else { 2 as libc::c_int }
                    }
                    /* If the proper action on seeing token YYTOKEN is to reduce or to
     detect an error, take that action.  */
                    yyn += yytoken;
                    if yyn < 0 as libc::c_int || (1493 as libc::c_int) < yyn
                           || yycheck[yyn as usize] as libc::c_int != yytoken
                       {
                        current_block = 15442955482004205486;
                    } else {
                        yyn = yytable[yyn as usize] as libc::c_int;
                        if yyn <= 0 as libc::c_int {
                            yyn = -yyn;
                            current_block = 3461518400278752287;
                        } else {
                            /* Count tokens shifted since error; after three, turn off error
     status.  */
                            if yyerrstatus != 0 { yyerrstatus -= 1 }
                            /* Shift the lookahead token.  */
                            /* Store the two blocks of code */
                            yystate = yyn;
                            yyvsp = yyvsp.offset(1);
                            *yyvsp = scr_lval;
                            /* Discard the shifted token.  */
                            scr_char = -(2 as libc::c_int);
                            current_block = 8100955437375066155;
                        }
                    }
                }
                match current_block {
                    15442955482004205486 =>
                    /* Put in the debugging information */
                    /*-----------------------------------------------------------.
| yydefault -- do the default action for the current state.  |
`-----------------------------------------------------------*/
                    /* Free the code blocks */
                    {
                        yyn = yydefact[yystate as usize] as libc::c_int;
                        if yyn == 0 as libc::c_int {
                            /*--------------------------------------.
| yyerrlab -- here on detecting error.  |
`--------------------------------------*/
                            /* Make sure we have latest lookahead translation.  See comments at
     user semantic actions for why this is necessary.  */
                            yytoken =
                                if scr_char == -(2 as libc::c_int) {
                                    -(2 as libc::c_int)
                                } else if 0 as libc::c_int <= scr_char &&
                                              scr_char <= 321 as libc::c_int {
                                    yytranslate[scr_char as usize] as
                                        libc::c_int
                                } else { 2 as libc::c_int };
                            /* If not already recovering from an error, report this error.  */
                            if yyerrstatus == 0 {
                                scr_nerrs += 1;
                                scr_error(b"syntax error\x00" as *const u8 as
                                              *const libc::c_char as
                                              *mut libc::c_char);
                            }
                            if yyerrstatus == 3 as libc::c_int {
                                /* If just tried and failed to reuse lookahead token after an
         error, discard it.  */
                                if scr_char <= 0 as libc::c_int {
                                    /* Return failure if at end of input.  */
                                    if scr_char == 0 as libc::c_int {
                                        current_block = 10563765182283539921;
                                        break ;
                                    }
                                } else {
                                    yydestruct(b"Error: discarding\x00" as
                                                   *const u8 as
                                                   *const libc::c_char,
                                               yytoken, &mut scr_lval);
                                    scr_char = -(2 as libc::c_int)
                                }
                            }
                            /* Else will try to reuse lookahead token after shifting the error
     token.  */
                            current_block = 15689129494514526393;
                        } else { current_block = 3461518400278752287; }
                    }
                    _ => { }
                }
                match current_block {
                    3461518400278752287 =>
                    /* Do the final processing of the conditional */
                    /*-----------------------------.
| yyreduce -- do a reduction.  |
`-----------------------------*/
                    /* yyn is the number of a rule to reduce with.  */
                    {
                        yylen = yyr2[yyn as usize] as libc::c_int;
                        /* If YYLEN is nonzero, implement the default value of the action:
     '$$ = $1'.

     Otherwise, the following line sets YYVAL to garbage.
     This behavior is undocumented and Bison
     users should not rely upon it.  Assigning to YYVAL
     unconditionally makes the parser a bit smaller, and it avoids a
     GCC warning that YYVAL may be used uninitialized.  */
                        yyval =
                            *yyvsp.offset((1 as libc::c_int - yylen) as
                                              isize);
                        /* Store the two blocks of code */
                        match yyn {
                            2 => {
                                /* Copy over the offset information */
                                current_block =
                                    9320480655893135347; /* Put in the debugging information */
                            }
                            3 => {
                                let mut size: SDWORD = 0;
                                let mut debug_i: SDWORD = 0;
                                let mut i: SDWORD = 0;
                                let mut dimension: SDWORD = 0;
                                let mut arraySize: SDWORD = 0;
                                let mut totalArraySize: SDWORD = 0;
                                let mut numArrays: SDWORD = 0;
                                let mut base: UDWORD = 0;
                                let mut psCurr: *mut VAR_SYMBOL =
                                    0 as *mut VAR_SYMBOL;
                                let mut psTrig: *mut TRIGGER_SYMBOL =
                                    0 as *mut TRIGGER_SYMBOL;
                                let mut psEvent: *mut EVENT_SYMBOL =
                                    0 as *mut EVENT_SYMBOL;
                                let mut numVars: UDWORD = 0;
                                let mut pCurEvLocalVars: *mut INTERP_TYPE =
                                    0 as *mut INTERP_TYPE;
                                let mut j: UDWORD = 0;
                                size = 0 as libc::c_int;
                                debug_i = 0 as libc::c_int;
                                psTrig = psTriggers;
                                while !psTrig.is_null() {
                                    size =
                                        (size as
                                             libc::c_uint).wrapping_add((*psTrig).size)
                                            as SDWORD as SDWORD;
                                    debug_i =
                                        (debug_i as
                                             libc::c_uint).wrapping_add((*psTrig).debugEntries)
                                            as SDWORD as SDWORD;
                                    psTrig = (*psTrig).psNext
                                }
                                psEvent = psEvents;
                                while !psEvent.is_null() {
                                    size =
                                        (size as
                                             libc::c_uint).wrapping_add((*psEvent).size)
                                            as SDWORD as SDWORD;
                                    debug_i =
                                        (debug_i as
                                             libc::c_uint).wrapping_add((*psEvent).debugEntries)
                                            as SDWORD as SDWORD;
                                    psEvent = (*psEvent).psNext
                                }
                                numVars =
                                    if !psGlobalVars.is_null() {
                                        (*psGlobalVars).index.wrapping_add(1
                                                                               as
                                                                               libc::c_int
                                                                               as
                                                                               libc::c_uint)
                                    } else {
                                        0 as libc::c_int as libc::c_uint
                                    };
                                numArrays =
                                    if !psGlobalArrays.is_null() {
                                        (*psGlobalArrays).index.wrapping_add(1
                                                                                 as
                                                                                 libc::c_int
                                                                                 as
                                                                                 libc::c_uint)
                                    } else {
                                        0 as libc::c_int as libc::c_uint
                                    } as SDWORD;
                                totalArraySize = 0 as libc::c_int;
                                psCurr = psGlobalArrays;
                                while !psCurr.is_null() {
                                    arraySize = 1 as libc::c_int;
                                    dimension = 0 as libc::c_int;
                                    while dimension < (*psCurr).dimensions {
                                        arraySize *=
                                            (*psCurr).elements[dimension as
                                                                   usize];
                                        dimension += 1 as libc::c_int
                                    }
                                    totalArraySize += arraySize;
                                    psCurr = (*psCurr).psNext
                                }
                                psFinalProg =
                                    memMallocRelease(::std::mem::size_of::<SCRIPT_CODE>()
                                                         as libc::c_ulong) as
                                        *mut SCRIPT_CODE;
                                if psFinalProg.is_null() {
                                    debug(LOG_ERROR,
                                          b"Out of memory\x00" as *const u8 as
                                              *const libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psFinalProg).pCode =
                                        memMallocRelease(size as size_t) as
                                            *mut UDWORD;
                                    if (*psFinalProg).pCode.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        if numVars >
                                               0 as libc::c_int as
                                                   libc::c_uint {
                                            (*psFinalProg).pGlobals =
                                                memMallocRelease((::std::mem::size_of::<INTERP_TYPE>()
                                                                      as
                                                                      libc::c_ulong).wrapping_mul(numVars))
                                                    as *mut INTERP_TYPE;
                                            if (*psFinalProg).pGlobals.is_null()
                                               {
                                                debug(LOG_ERROR,
                                                      b"Out of memory\x00" as
                                                          *const u8 as
                                                          *const libc::c_char);
                                                current_block =
                                                    10563765182283539921;
                                                break ;
                                            }
                                        } else {
                                            (*psFinalProg).pGlobals =
                                                0 as *mut INTERP_TYPE
                                        }
                                        if numArrays > 0 as libc::c_int {
                                            (*psFinalProg).psArrayInfo =
                                                memMallocRelease((::std::mem::size_of::<ARRAY_DATA>()
                                                                      as
                                                                      libc::c_ulong).wrapping_mul(numArrays
                                                                                                      as
                                                                                                      libc::c_uint))
                                                    as *mut ARRAY_DATA;
                                            if (*psFinalProg).psArrayInfo.is_null()
                                               {
                                                debug(LOG_ERROR,
                                                      b"Out of memory\x00" as
                                                          *const u8 as
                                                          *const libc::c_char);
                                                current_block =
                                                    10563765182283539921;
                                                break ;
                                            }
                                        } else {
                                            (*psFinalProg).psArrayInfo =
                                                0 as *mut ARRAY_DATA
                                        }
                                        (*psFinalProg).numArrays =
                                            numArrays as UWORD;
                                        if numTriggers >
                                               0 as libc::c_int as
                                                   libc::c_uint {
                                            (*psFinalProg).pTriggerTab =
                                                memMallocRelease((::std::mem::size_of::<UWORD>()
                                                                      as
                                                                      libc::c_ulong).wrapping_mul(numTriggers.wrapping_add(1
                                                                                                                               as
                                                                                                                               libc::c_int
                                                                                                                               as
                                                                                                                               libc::c_uint)))
                                                    as *mut UWORD;
                                            if (*psFinalProg).pTriggerTab.is_null()
                                               {
                                                debug(LOG_ERROR,
                                                      b"Out of memory\x00" as
                                                          *const u8 as
                                                          *const libc::c_char);
                                                current_block =
                                                    10563765182283539921;
                                                break ;
                                            } else {
                                                (*psFinalProg).psTriggerData =
                                                    memMallocRelease((::std::mem::size_of::<TRIGGER_DATA>()
                                                                          as
                                                                          libc::c_ulong).wrapping_mul(numTriggers))
                                                        as *mut TRIGGER_DATA;
                                                if (*psFinalProg).psTriggerData.is_null()
                                                   {
                                                    debug(LOG_ERROR,
                                                          b"Out of memory\x00"
                                                              as *const u8 as
                                                              *const libc::c_char);
                                                    current_block =
                                                        10563765182283539921;
                                                    break ;
                                                }
                                            }
                                        } else {
                                            (*psFinalProg).pTriggerTab =
                                                0 as *mut UWORD;
                                            (*psFinalProg).psTriggerData =
                                                0 as *mut TRIGGER_DATA
                                        }
                                        (*psFinalProg).pEventTab =
                                            memMallocRelease((::std::mem::size_of::<UWORD>()
                                                                  as
                                                                  libc::c_ulong).wrapping_mul(numEvents.wrapping_add(1
                                                                                                                         as
                                                                                                                         libc::c_int
                                                                                                                         as
                                                                                                                         libc::c_uint)))
                                                as *mut UWORD;
                                        if (*psFinalProg).pEventTab.is_null()
                                           {
                                            debug(LOG_ERROR,
                                                  b"Out of memory\x00" as
                                                      *const u8 as
                                                      *const libc::c_char);
                                            current_block =
                                                10563765182283539921;
                                            break ;
                                        } else {
                                            (*psFinalProg).pEventLinks =
                                                memMallocRelease((::std::mem::size_of::<SWORD>()
                                                                      as
                                                                      libc::c_ulong).wrapping_mul(numEvents))
                                                    as *mut SWORD;
                                            if (*psFinalProg).pEventLinks.is_null()
                                               {
                                                debug(LOG_ERROR,
                                                      b"Out of memory\x00" as
                                                          *const u8 as
                                                          *const libc::c_char);
                                                current_block =
                                                    10563765182283539921;
                                                break ;
                                            } else {
                                                (*psFinalProg).numGlobals =
                                                    numVars as UWORD;
                                                (*psFinalProg).numTriggers =
                                                    numTriggers as UWORD;
                                                (*psFinalProg).numEvents =
                                                    numEvents as UWORD;
                                                (*psFinalProg).size =
                                                    size as UDWORD;
                                                (*psFinalProg).ppsLocalVars =
                                                    memMallocRelease((::std::mem::size_of::<*mut INTERP_TYPE>()
                                                                          as
                                                                          libc::c_ulong).wrapping_mul(numEvents))
                                                        as
                                                        *mut *mut INTERP_TYPE;
                                                (*psFinalProg).numLocalVars =
                                                    memMallocRelease((::std::mem::size_of::<UDWORD>()
                                                                          as
                                                                          libc::c_ulong).wrapping_mul(numEvents))
                                                        as *mut UDWORD;
                                                (*psFinalProg).numParams =
                                                    memMallocRelease((::std::mem::size_of::<UDWORD>()
                                                                          as
                                                                          libc::c_ulong).wrapping_mul(numEvents))
                                                        as *mut UDWORD;
                                                i = 0 as libc::c_int;
                                                psEvent = psEvents;
                                                while !psEvent.is_null() {
                                                    (*psEvent).numLocalVars =
                                                        numEventLocalVars[i as
                                                                              usize];
                                                    *(*psFinalProg).numLocalVars.offset(i
                                                                                            as
                                                                                            isize)
                                                        =
                                                        numEventLocalVars[i as
                                                                              usize];
                                                    *(*psFinalProg).numParams.offset(i
                                                                                         as
                                                                                         isize)
                                                        =
                                                        (*psEvent).numParams;
                                                    if numEventLocalVars[i as
                                                                             usize]
                                                           >
                                                           0 as libc::c_int as
                                                               libc::c_uint {
                                                        pCurEvLocalVars =
                                                            memMallocRelease((::std::mem::size_of::<INTERP_TYPE>()
                                                                                  as
                                                                                  libc::c_ulong).wrapping_mul(numEventLocalVars[i
                                                                                                                                    as
                                                                                                                                    usize]))
                                                                as
                                                                *mut INTERP_TYPE;
                                                        j =
                                                            0 as libc::c_int
                                                                as UDWORD;
                                                        psCurr =
                                                            psLocalVarsB[i as
                                                                             usize];
                                                        while !psCurr.is_null()
                                                              {
                                                            *pCurEvLocalVars.offset(numEventLocalVars[i
                                                                                                          as
                                                                                                          usize].wrapping_sub(j).wrapping_sub(1
                                                                                                                                                  as
                                                                                                                                                  libc::c_int
                                                                                                                                                  as
                                                                                                                                                  libc::c_uint)
                                                                                        as
                                                                                        isize)
                                                                =
                                                                (*psCurr).type_0;
                                                            j =
                                                                j.wrapping_add(1);
                                                            psCurr =
                                                                (*psCurr).psNext
                                                        }
                                                    } else {
                                                        pCurEvLocalVars =
                                                            0 as
                                                                *mut INTERP_TYPE
                                                    }
                                                    let ref mut fresh0 =
                                                        *(*psFinalProg).ppsLocalVars.offset(i
                                                                                                as
                                                                                                isize);
                                                    *fresh0 = pCurEvLocalVars;
                                                    i += 1;
                                                    psEvent =
                                                        (*psEvent).psNext
                                                }
                                                if genDebugInfo != 0 {
                                                    (*psFinalProg).psDebug =
                                                        memMallocRelease((::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                              as
                                                                              libc::c_ulong).wrapping_mul(debug_i
                                                                                                              as
                                                                                                              libc::c_uint))
                                                            as
                                                            *mut SCRIPT_DEBUG;
                                                    if (*psFinalProg).psDebug.is_null()
                                                       {
                                                        scr_error(b"Out of memory\x00"
                                                                      as
                                                                      *const u8
                                                                      as
                                                                      *const libc::c_char
                                                                      as
                                                                      *mut libc::c_char);
                                                        current_block =
                                                            10563765182283539921;
                                                        break ;
                                                    } else {
                                                        memset((*psFinalProg).psDebug
                                                                   as
                                                                   *mut libc::c_void,
                                                               0 as
                                                                   libc::c_int,
                                                               (::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                    as
                                                                    libc::c_ulong).wrapping_mul(debug_i
                                                                                                    as
                                                                                                    libc::c_uint));
                                                        (*psFinalProg).debugEntries
                                                            = debug_i as UWORD
                                                    }
                                                } else {
                                                    (*psFinalProg).psDebug =
                                                        0 as
                                                            *mut SCRIPT_DEBUG;
                                                    (*psFinalProg).debugEntries
                                                        =
                                                        0 as libc::c_int as
                                                            UWORD
                                                }
                                                (*psFinalProg).debugEntries =
                                                    0 as libc::c_int as UWORD;
                                                ip = (*psFinalProg).pCode;
                                                i = 0 as libc::c_int;
                                                psTrig = psTriggers;
                                                while !psTrig.is_null() {
                                                    *(*psFinalProg).pTriggerTab.offset(i
                                                                                           as
                                                                                           isize)
                                                        =
                                                        ip.wrapping_offset_from((*psFinalProg).pCode)
                                                            as libc::c_int as
                                                            UWORD;
                                                    if !(*psTrig).pCode.is_null()
                                                       {
                                                        if genDebugInfo != 0 {
                                                            let ref mut fresh1 =
                                                                (*(*psFinalProg).psDebug.offset((*psFinalProg).debugEntries
                                                                                                    as
                                                                                                    isize)).pLabel;
                                                            *fresh1 =
                                                                memMallocRelease(strlen((*psTrig).pIdent).wrapping_add(1
                                                                                                                           as
                                                                                                                           libc::c_int
                                                                                                                           as
                                                                                                                           libc::c_uint))
                                                                    as
                                                                    *mut STRING;
                                                            if (*(*psFinalProg).psDebug.offset((*psFinalProg).debugEntries
                                                                                                   as
                                                                                                   isize)).pLabel.is_null()
                                                               {
                                                                scr_error(b"Out of memory\x00"
                                                                              as
                                                                              *const u8
                                                                              as
                                                                              *const libc::c_char
                                                                              as
                                                                              *mut libc::c_char);
                                                                current_block
                                                                    =
                                                                    10563765182283539921;
                                                                break 's_88 ;
                                                            } else {
                                                                strcpy((*(*psFinalProg).psDebug.offset((*psFinalProg).debugEntries
                                                                                                           as
                                                                                                           isize)).pLabel,
                                                                       (*psTrig).pIdent);
                                                            }
                                                        }
                                                        if genDebugInfo != 0 {
                                                            _dbEntry =
                                                                0 as
                                                                    libc::c_int
                                                                    as UDWORD;
                                                            while _dbEntry <
                                                                      (*psTrig).debugEntries
                                                                  {
                                                                _psCurr =
                                                                    (*psFinalProg).psDebug.offset((*psFinalProg).debugEntries
                                                                                                      as
                                                                                                      libc::c_int
                                                                                                      as
                                                                                                      isize).offset(_dbEntry
                                                                                                                        as
                                                                                                                        isize);
                                                                (*_psCurr).line
                                                                    =
                                                                    (*(*psTrig).psDebug.offset(_dbEntry
                                                                                                   as
                                                                                                   isize)).line;
                                                                (*_psCurr).offset
                                                                    =
                                                                    (*(*psTrig).psDebug.offset(_dbEntry
                                                                                                   as
                                                                                                   isize)).offset.wrapping_add(ip.wrapping_offset_from((*psFinalProg).pCode)
                                                                                                                                   as
                                                                                                                                   libc::c_int
                                                                                                                                   as
                                                                                                                                   libc::c_uint);
                                                                _dbEntry =
                                                                    _dbEntry.wrapping_add(1)
                                                            }
                                                            (*psFinalProg).debugEntries
                                                                =
                                                                ((*psFinalProg).debugEntries
                                                                     as
                                                                     libc::c_uint).wrapping_add((*psTrig).debugEntries)
                                                                    as UWORD
                                                        }
                                                        memcpy(ip as
                                                                   *mut libc::c_void,
                                                               (*psTrig).pCode
                                                                   as
                                                                   *const libc::c_void,
                                                               (*psTrig).size);
                                                        ip =
                                                            (ip as
                                                                 *mut UBYTE).offset((*psTrig).size
                                                                                        as
                                                                                        isize)
                                                                as
                                                                *mut UDWORD;
                                                        (*(*psFinalProg).psTriggerData.offset(i
                                                                                                  as
                                                                                                  isize)).code
                                                            =
                                                            1 as libc::c_int
                                                                as UWORD
                                                    } else {
                                                        (*(*psFinalProg).psTriggerData.offset(i
                                                                                                  as
                                                                                                  isize)).code
                                                            =
                                                            0 as libc::c_int
                                                                as UWORD
                                                    }
                                                    (*(*psFinalProg).psTriggerData.offset(i
                                                                                              as
                                                                                              isize)).type_0
                                                        =
                                                        (*psTrig).type_0 as
                                                            UWORD;
                                                    (*(*psFinalProg).psTriggerData.offset(i
                                                                                              as
                                                                                              isize)).time
                                                        = (*psTrig).time;
                                                    i = i + 1 as libc::c_int;
                                                    psTrig = (*psTrig).psNext
                                                }
                                                *(*psFinalProg).pTriggerTab.offset(i
                                                                                       as
                                                                                       isize)
                                                    =
                                                    ip.wrapping_offset_from((*psFinalProg).pCode)
                                                        as libc::c_int as
                                                        UWORD;
                                                i = 0 as libc::c_int;
                                                psEvent = psEvents;
                                                while !psEvent.is_null() {
                                                    if (*psEvent).pCode.is_null()
                                                       {
                                                        scr_error(b"Event %s declared without being defined\x00"
                                                                      as
                                                                      *const u8
                                                                      as
                                                                      *const libc::c_char
                                                                      as
                                                                      *mut libc::c_char,
                                                                  (*psEvent).pIdent);
                                                        current_block =
                                                            10563765182283539921;
                                                        break 's_88 ;
                                                    } else {
                                                        *(*psFinalProg).pEventTab.offset(i
                                                                                             as
                                                                                             isize)
                                                            =
                                                            ip.wrapping_offset_from((*psFinalProg).pCode)
                                                                as libc::c_int
                                                                as UWORD;
                                                        *(*psFinalProg).pEventLinks.offset(i
                                                                                               as
                                                                                               isize)
                                                            =
                                                            (*psEvent).trigger
                                                                as SWORD;
                                                        if genDebugInfo != 0 {
                                                            let ref mut fresh2 =
                                                                (*(*psFinalProg).psDebug.offset((*psFinalProg).debugEntries
                                                                                                    as
                                                                                                    isize)).pLabel;
                                                            *fresh2 =
                                                                memMallocRelease(strlen((*psEvent).pIdent).wrapping_add(1
                                                                                                                            as
                                                                                                                            libc::c_int
                                                                                                                            as
                                                                                                                            libc::c_uint))
                                                                    as
                                                                    *mut STRING;
                                                            if (*(*psFinalProg).psDebug.offset((*psFinalProg).debugEntries
                                                                                                   as
                                                                                                   isize)).pLabel.is_null()
                                                               {
                                                                scr_error(b"Out of memory\x00"
                                                                              as
                                                                              *const u8
                                                                              as
                                                                              *const libc::c_char
                                                                              as
                                                                              *mut libc::c_char);
                                                                current_block
                                                                    =
                                                                    10563765182283539921;
                                                                break 's_88 ;
                                                            } else {
                                                                strcpy((*(*psFinalProg).psDebug.offset((*psFinalProg).debugEntries
                                                                                                           as
                                                                                                           isize)).pLabel,
                                                                       (*psEvent).pIdent);
                                                            }
                                                        }
                                                        if genDebugInfo != 0 {
                                                            _dbEntry =
                                                                0 as
                                                                    libc::c_int
                                                                    as UDWORD;
                                                            while _dbEntry <
                                                                      (*psEvent).debugEntries
                                                                  {
                                                                _psCurr =
                                                                    (*psFinalProg).psDebug.offset((*psFinalProg).debugEntries
                                                                                                      as
                                                                                                      libc::c_int
                                                                                                      as
                                                                                                      isize).offset(_dbEntry
                                                                                                                        as
                                                                                                                        isize);
                                                                (*_psCurr).line
                                                                    =
                                                                    (*(*psEvent).psDebug.offset(_dbEntry
                                                                                                    as
                                                                                                    isize)).line;
                                                                (*_psCurr).offset
                                                                    =
                                                                    (*(*psEvent).psDebug.offset(_dbEntry
                                                                                                    as
                                                                                                    isize)).offset.wrapping_add(ip.wrapping_offset_from((*psFinalProg).pCode)
                                                                                                                                    as
                                                                                                                                    libc::c_int
                                                                                                                                    as
                                                                                                                                    libc::c_uint);
                                                                _dbEntry =
                                                                    _dbEntry.wrapping_add(1)
                                                            }
                                                            (*psFinalProg).debugEntries
                                                                =
                                                                ((*psFinalProg).debugEntries
                                                                     as
                                                                     libc::c_uint).wrapping_add((*psEvent).debugEntries)
                                                                    as UWORD
                                                        }
                                                        memcpy(ip as
                                                                   *mut libc::c_void,
                                                               (*psEvent).pCode
                                                                   as
                                                                   *const libc::c_void,
                                                               (*psEvent).size);
                                                        ip =
                                                            (ip as
                                                                 *mut UBYTE).offset((*psEvent).size
                                                                                        as
                                                                                        isize)
                                                                as
                                                                *mut UDWORD;
                                                        i =
                                                            i +
                                                                1 as
                                                                    libc::c_int;
                                                        psEvent =
                                                            (*psEvent).psNext
                                                    }
                                                }
                                                *(*psFinalProg).pEventTab.offset(i
                                                                                     as
                                                                                     isize)
                                                    =
                                                    ip.wrapping_offset_from((*psFinalProg).pCode)
                                                        as libc::c_int as
                                                        UWORD;
                                                if genDebugInfo != 0 {
                                                    if numVars >
                                                           0 as libc::c_int as
                                                               libc::c_uint {
                                                        (*psFinalProg).psVarDebug
                                                            =
                                                            memMallocRelease((::std::mem::size_of::<VAR_DEBUG>()
                                                                                  as
                                                                                  libc::c_ulong).wrapping_mul(numVars))
                                                                as
                                                                *mut VAR_DEBUG;
                                                        if (*psFinalProg).psVarDebug.is_null()
                                                           {
                                                            scr_error(b"Out of memory\x00"
                                                                          as
                                                                          *const u8
                                                                          as
                                                                          *const libc::c_char
                                                                          as
                                                                          *mut libc::c_char);
                                                            current_block =
                                                                10563765182283539921;
                                                            break ;
                                                        }
                                                    } else {
                                                        (*psFinalProg).psVarDebug
                                                            =
                                                            0 as
                                                                *mut VAR_DEBUG
                                                    }
                                                    if numArrays >
                                                           0 as libc::c_int {
                                                        (*psFinalProg).psArrayDebug
                                                            =
                                                            memMallocRelease((::std::mem::size_of::<ARRAY_DEBUG>()
                                                                                  as
                                                                                  libc::c_ulong).wrapping_mul(numArrays
                                                                                                                  as
                                                                                                                  libc::c_uint))
                                                                as
                                                                *mut ARRAY_DEBUG;
                                                        if (*psFinalProg).psArrayDebug.is_null()
                                                           {
                                                            scr_error(b"Out of memory\x00"
                                                                          as
                                                                          *const u8
                                                                          as
                                                                          *const libc::c_char
                                                                          as
                                                                          *mut libc::c_char);
                                                            current_block =
                                                                10563765182283539921;
                                                            break ;
                                                        }
                                                    } else {
                                                        (*psFinalProg).psArrayDebug
                                                            =
                                                            0 as
                                                                *mut ARRAY_DEBUG
                                                    }
                                                } else {
                                                    (*psFinalProg).psVarDebug
                                                        = 0 as *mut VAR_DEBUG;
                                                    (*psFinalProg).psArrayDebug
                                                        =
                                                        0 as *mut ARRAY_DEBUG
                                                }
                                                psCurr = psGlobalVars;
                                                while !psCurr.is_null() {
                                                    i =
                                                        (*psCurr).index as
                                                            SDWORD;
                                                    *(*psFinalProg).pGlobals.offset(i
                                                                                        as
                                                                                        isize)
                                                        = (*psCurr).type_0;
                                                    if genDebugInfo != 0 {
                                                        let ref mut fresh3 =
                                                            (*(*psFinalProg).psVarDebug.offset(i
                                                                                                   as
                                                                                                   isize)).pIdent;
                                                        *fresh3 =
                                                            memMallocRelease(strlen((*psCurr).pIdent).wrapping_add(1
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       libc::c_uint))
                                                                as
                                                                *mut STRING;
                                                        if (*(*psFinalProg).psVarDebug.offset(i
                                                                                                  as
                                                                                                  isize)).pIdent.is_null()
                                                           {
                                                            scr_error(b"Out of memory\x00"
                                                                          as
                                                                          *const u8
                                                                          as
                                                                          *const libc::c_char
                                                                          as
                                                                          *mut libc::c_char);
                                                            current_block =
                                                                10563765182283539921;
                                                            break 's_88 ;
                                                        } else {
                                                            strcpy((*(*psFinalProg).psVarDebug.offset(i
                                                                                                          as
                                                                                                          isize)).pIdent,
                                                                   (*psCurr).pIdent);
                                                            (*(*psFinalProg).psVarDebug.offset(i
                                                                                                   as
                                                                                                   isize)).storage
                                                                =
                                                                (*psCurr).storage
                                                        }
                                                    }
                                                    psCurr = (*psCurr).psNext
                                                }
                                                (*psFinalProg).arraySize =
                                                    totalArraySize as UDWORD;
                                                psCurr = psGlobalArrays;
                                                while !psCurr.is_null() {
                                                    i =
                                                        (*psCurr).index as
                                                            SDWORD;
                                                    (*(*psFinalProg).psArrayInfo.offset(i
                                                                                            as
                                                                                            isize)).type_0
                                                        =
                                                        (*psCurr).type_0 as
                                                            UBYTE;
                                                    (*(*psFinalProg).psArrayInfo.offset(i
                                                                                            as
                                                                                            isize)).dimensions
                                                        =
                                                        (*psCurr).dimensions
                                                            as UBYTE;
                                                    dimension =
                                                        0 as libc::c_int;
                                                    while dimension <
                                                              (*psCurr).dimensions
                                                          {
                                                        (*(*psFinalProg).psArrayInfo.offset(i
                                                                                                as
                                                                                                isize)).elements[dimension
                                                                                                                     as
                                                                                                                     usize]
                                                            =
                                                            (*psCurr).elements[dimension
                                                                                   as
                                                                                   usize]
                                                                as UBYTE;
                                                        dimension +=
                                                            1 as libc::c_int
                                                    }
                                                    if genDebugInfo != 0 {
                                                        let ref mut fresh4 =
                                                            (*(*psFinalProg).psArrayDebug.offset(i
                                                                                                     as
                                                                                                     isize)).pIdent;
                                                        *fresh4 =
                                                            memMallocRelease(strlen((*psCurr).pIdent).wrapping_add(1
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       libc::c_uint))
                                                                as
                                                                *mut STRING;
                                                        if (*(*psFinalProg).psArrayDebug.offset(i
                                                                                                    as
                                                                                                    isize)).pIdent.is_null()
                                                           {
                                                            scr_error(b"Out of memory\x00"
                                                                          as
                                                                          *const u8
                                                                          as
                                                                          *const libc::c_char
                                                                          as
                                                                          *mut libc::c_char);
                                                            current_block =
                                                                10563765182283539921;
                                                            break 's_88 ;
                                                        } else {
                                                            strcpy((*(*psFinalProg).psArrayDebug.offset(i
                                                                                                            as
                                                                                                            isize)).pIdent,
                                                                   (*psCurr).pIdent);
                                                            (*(*psFinalProg).psArrayDebug.offset(i
                                                                                                     as
                                                                                                     isize)).storage
                                                                =
                                                                (*psCurr).storage
                                                        }
                                                    }
                                                    psCurr = (*psCurr).psNext
                                                }
                                                base =
                                                    (*psFinalProg).numGlobals
                                                        as UDWORD;
                                                i = 0 as libc::c_int;
                                                while i < numArrays {
                                                    (*(*psFinalProg).psArrayInfo.offset(i
                                                                                            as
                                                                                            isize)).base
                                                        = base;
                                                    arraySize =
                                                        1 as libc::c_int;
                                                    dimension =
                                                        0 as libc::c_int;
                                                    while dimension <
                                                              (*(*psFinalProg).psArrayInfo.offset(i
                                                                                                      as
                                                                                                      isize)).dimensions
                                                                  as
                                                                  libc::c_int
                                                          {
                                                        arraySize *=
                                                            (*(*psFinalProg).psArrayInfo.offset(i
                                                                                                    as
                                                                                                    isize)).elements[dimension
                                                                                                                         as
                                                                                                                         usize]
                                                                as
                                                                libc::c_int;
                                                        dimension +=
                                                            1 as libc::c_int
                                                    }
                                                    base =
                                                        (base as
                                                             libc::c_uint).wrapping_add(arraySize
                                                                                            as
                                                                                            libc::c_uint)
                                                            as UDWORD as
                                                            UDWORD;
                                                    i += 1
                                                }
                                            }
                                        }
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            7 => {
                                /* Allocate the code block */
                                //Params + Opcode + event index
                                /* if any parameters declared */
                                /* Copy in the code for the parameters */
                                //PUT_BLOCK(ip, psPBlock);
                                current_block =
                                    9320480655893135347; //FREE_PBLOCK(psPBlock);
                            }
                            9 => {
                                memFreeRelease((*yyvsp.offset(0 as libc::c_int
                                                                  as
                                                                  isize)).vdecl
                                                   as *mut libc::c_void);
                                let ref mut fresh5 =
                                    (*yyvsp.offset(0 as libc::c_int as
                                                       isize)).vdecl;
                                *fresh5 = 0 as *mut VAR_DECL;
                                /* Store the instruction */
                                //Put event index
                                /* Add the debugging information */
                                current_block = 9320480655893135347;
                            }
                            10 => {
                                memFreeRelease((*yyvsp.offset(0 as libc::c_int
                                                                  as
                                                                  isize)).vdecl
                                                   as *mut libc::c_void);
                                let ref mut fresh6 =
                                    (*yyvsp.offset(0 as libc::c_int as
                                                       isize)).vdecl;
                                *fresh6 = 0 as *mut VAR_DECL;
                                current_block = 9320480655893135347;
                            }
                            11 => {
                                localVariableDef = 0 as libc::c_int;
                                yyval.vdecl =
                                    (*yyvsp.offset(-(1 as libc::c_int) as
                                                       isize)).vdecl;
                                /* Return the code block */
                                current_block = 9320480655893135347;
                            }
                            12 => {
                                psCurrVDecl =
                                    memMallocRelease(::std::mem::size_of::<VAR_DECL>()
                                                         as libc::c_ulong) as
                                        *mut VAR_DECL;
                                if psCurrVDecl.is_null() {
                                    scr_error(b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCurrVDecl).storage =
                                        (*yyvsp.offset(-(1 as libc::c_int) as
                                                           isize)).stype;
                                    (*psCurrVDecl).type_0 =
                                        (*yyvsp.offset(0 as libc::c_int as
                                                           isize)).tval;
                                    if (*yyvsp.offset(-(1 as libc::c_int) as
                                                          isize)).stype as
                                           libc::c_int ==
                                           ST_LOCAL as libc::c_int {
                                        localVariableDef = 1 as libc::c_int
                                    }
                                    yyval.vdecl = psCurrVDecl
                                }
                                current_block = 9320480655893135347;
                            }
                            13 => {
                                psCurrVDecl =
                                    memMallocRelease(::std::mem::size_of::<VAR_DECL>()
                                                         as libc::c_ulong) as
                                        *mut VAR_DECL;
                                if psCurrVDecl.is_null() {
                                    scr_error(b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCurrVDecl).storage =
                                        (*yyvsp.offset(-(1 as libc::c_int) as
                                                           isize)).stype;
                                    (*psCurrVDecl).type_0 = VAL_TRIGGER;
                                    yyval.vdecl = psCurrVDecl
                                }
                                current_block = 9320480655893135347;
                            }
                            14 => {
                                psCurrVDecl =
                                    memMallocRelease(::std::mem::size_of::<VAR_DECL>()
                                                         as libc::c_ulong) as
                                        *mut VAR_DECL;
                                if psCurrVDecl.is_null() {
                                    scr_error(b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCurrVDecl).storage =
                                        (*yyvsp.offset(-(1 as libc::c_int) as
                                                           isize)).stype;
                                    (*psCurrVDecl).type_0 = VAL_EVENT;
                                    yyval.vdecl = psCurrVDecl
                                }
                                current_block = 9320480655893135347;
                            }
                            15 => {
                                if (*yyvsp.offset(-(1 as libc::c_int) as
                                                      isize)).ival <=
                                       0 as libc::c_int ||
                                       (*yyvsp.offset(-(1 as libc::c_int) as
                                                          isize)).ival >=
                                           0xff as libc::c_int {
                                    scr_error(b"Invalid array size %d\x00" as
                                                  *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char,
                                              (*yyvsp.offset(-(1 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).ival);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    psCurrVIdentDecl =
                                        memMallocRelease(::std::mem::size_of::<VAR_IDENT_DECL>()
                                                             as libc::c_ulong)
                                            as *mut VAR_IDENT_DECL;
                                    if psCurrVIdentDecl.is_null() {
                                        scr_error(b"Out of memory\x00" as
                                                      *const u8 as
                                                      *const libc::c_char as
                                                      *mut libc::c_char);
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        if !(0 as *mut libc::c_void).is_null()
                                           {
                                            (*psCurrVIdentDecl).pIdent =
                                                memMallocRelease(strlen(0 as
                                                                            *const libc::c_char).wrapping_add(1
                                                                                                                  as
                                                                                                                  libc::c_int
                                                                                                                  as
                                                                                                                  libc::c_uint))
                                                    as *mut STRING;
                                            if (*psCurrVIdentDecl).pIdent.is_null()
                                               {
                                                scr_error(b"Out of memory\x00"
                                                              as *const u8 as
                                                              *const libc::c_char
                                                              as
                                                              *mut libc::c_char);
                                                current_block =
                                                    10563765182283539921;
                                                break ;
                                            } else {
                                                strcpy((*psCurrVIdentDecl).pIdent,
                                                       0 as
                                                           *const libc::c_char);
                                            }
                                        } else {
                                            (*psCurrVIdentDecl).pIdent =
                                                0 as *mut STRING
                                        }
                                        (*psCurrVIdentDecl).dimensions =
                                            1 as libc::c_int;
                                        (*psCurrVIdentDecl).elements[0 as
                                                                         libc::c_int
                                                                         as
                                                                         usize]
                                            =
                                            (*yyvsp.offset(-(1 as libc::c_int)
                                                               as
                                                               isize)).ival;
                                        yyval.videcl = psCurrVIdentDecl
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            16 => {
                                yyval.videcl =
                                    (*yyvsp.offset(0 as libc::c_int as
                                                       isize)).videcl;
                                /* Return the code block */
                                current_block = 9320480655893135347;
                            }
                            17 => {
                                //debug(LOG_SCRIPT, "'(' stringexp ')'");
					/* Just pass the code up the tree */
                                if (*(*yyvsp.offset(-(3 as libc::c_int) as
                                                        isize)).videcl).dimensions
                                       >= 4 as libc::c_int {
                                    scr_error(b"Too many dimensions for array\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else if (*yyvsp.offset(-(1 as libc::c_int)
                                                             as isize)).ival
                                              <= 0 as libc::c_int ||
                                              (*yyvsp.offset(-(1 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).ival
                                                  >= 0xff as libc::c_int {
                                    scr_error(b"Invalid array size %d\x00" as
                                                  *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char,
                                              (*yyvsp.offset(-(1 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).ival);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*(*yyvsp.offset(-(3 as libc::c_int) as
                                                         isize)).videcl).elements[(*(*yyvsp.offset(-(3
                                                                                                         as
                                                                                                         libc::c_int)
                                                                                                       as
                                                                                                       isize)).videcl).dimensions
                                                                                      as
                                                                                      usize]
                                        =
                                        (*yyvsp.offset(-(1 as libc::c_int) as
                                                           isize)).ival;
                                    let ref mut fresh7 =
                                        (*(*yyvsp.offset(-(3 as libc::c_int)
                                                             as
                                                             isize)).videcl).dimensions;
                                    *fresh7 += 1 as libc::c_int;
                                    yyval.videcl =
                                        (*yyvsp.offset(-(3 as libc::c_int) as
                                                           isize)).videcl
                                }
                                current_block = 9320480655893135347;
                            }
                            18 => {
                                psCurrVIdentDecl =
                                    memMallocRelease(::std::mem::size_of::<VAR_IDENT_DECL>()
                                                         as libc::c_ulong) as
                                        *mut VAR_IDENT_DECL;
                                if psCurrVIdentDecl.is_null() {
                                    scr_error(b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    if !(*yyvsp.offset(0 as libc::c_int as
                                                           isize)).sval.is_null()
                                       {
                                        (*psCurrVIdentDecl).pIdent =
                                            memMallocRelease(strlen((*yyvsp.offset(0
                                                                                       as
                                                                                       libc::c_int
                                                                                       as
                                                                                       isize)).sval).wrapping_add(1
                                                                                                                      as
                                                                                                                      libc::c_int
                                                                                                                      as
                                                                                                                      libc::c_uint))
                                                as *mut STRING;
                                        if (*psCurrVIdentDecl).pIdent.is_null()
                                           {
                                            scr_error(b"Out of memory\x00" as
                                                          *const u8 as
                                                          *const libc::c_char
                                                          as
                                                          *mut libc::c_char);
                                            current_block =
                                                10563765182283539921;
                                            break ;
                                        } else {
                                            strcpy((*psCurrVIdentDecl).pIdent,
                                                   (*yyvsp.offset(0 as
                                                                      libc::c_int
                                                                      as
                                                                      isize)).sval);
                                        }
                                    } else {
                                        (*psCurrVIdentDecl).pIdent =
                                            0 as *mut STRING
                                    }
                                    (*psCurrVIdentDecl).dimensions =
                                        0 as libc::c_int;
                                    yyval.videcl = psCurrVIdentDecl
                                }
                                current_block = 9320480655893135347;
                            }
                            19 => {
                                let ref mut fresh8 =
                                    (*(*yyvsp.offset(0 as libc::c_int as
                                                         isize)).videcl).pIdent;
                                *fresh8 =
                                    memMallocRelease(strlen((*yyvsp.offset(-(1
                                                                                 as
                                                                                 libc::c_int)
                                                                               as
                                                                               isize)).sval).wrapping_add(1
                                                                                                              as
                                                                                                              libc::c_int
                                                                                                              as
                                                                                                              libc::c_uint))
                                        as *mut STRING;
                                if (*(*yyvsp.offset(0 as libc::c_int as
                                                        isize)).videcl).pIdent.is_null()
                                   {
                                    scr_error(b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    strcpy((*(*yyvsp.offset(0 as libc::c_int
                                                                as
                                                                isize)).videcl).pIdent,
                                           (*yyvsp.offset(-(1 as libc::c_int)
                                                              as
                                                              isize)).sval);
                                    yyval.videcl =
                                        (*yyvsp.offset(0 as libc::c_int as
                                                           isize)).videcl
                                }
                                current_block = 9320480655893135347;
                            }
                            20 => {
                                if scriptAddVariable((*yyvsp.offset(-(1 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).vdecl,
                                                     (*yyvsp.offset(0 as
                                                                        libc::c_int
                                                                        as
                                                                        isize)).videcl)
                                       == 0 {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                memFreeRelease((*yyvsp.offset(0 as libc::c_int
                                                                  as
                                                                  isize)).videcl
                                                   as *mut libc::c_void);
                                let ref mut fresh9 =
                                    (*yyvsp.offset(0 as libc::c_int as
                                                       isize)).videcl;
                                *fresh9 = 0 as *mut VAR_IDENT_DECL;
                                yyval.vdecl =
                                    (*yyvsp.offset(-(1 as libc::c_int) as
                                                       isize)).vdecl;
                                //debug(LOG_SCRIPT, "STRING_VAR");
                                current_block = 9320480655893135347;
                            }
                            21 => {
                                if scriptAddVariable((*yyvsp.offset(-(2 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).vdecl,
                                                     (*yyvsp.offset(0 as
                                                                        libc::c_int
                                                                        as
                                                                        isize)).videcl)
                                       == 0 {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                memFreeRelease((*yyvsp.offset(0 as libc::c_int
                                                                  as
                                                                  isize)).videcl
                                                   as *mut libc::c_void);
                                let ref mut fresh10 =
                                    (*yyvsp.offset(0 as libc::c_int as
                                                       isize)).videcl;
                                *fresh10 = 0 as *mut VAR_IDENT_DECL;
                                yyval.vdecl =
                                    (*yyvsp.offset(-(2 as libc::c_int) as
                                                       isize)).vdecl;
                                /* Return the code block */
                                //debug(LOG_SCRIPT, "END STRING_VAR (%s)", $1->pIdent);
                                /* Return the code block */
                                current_block = 9320480655893135347;
                            }
                            25 => {
                                psCurrTDecl =
                                    memMallocRelease(::std::mem::size_of::<TRIGGER_DECL>()
                                                         as libc::c_ulong) as
                                        *mut TRIGGER_DECL;
                                if psCurrTDecl.is_null() {
                                    scr_error(b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCurrTDecl).type_0 = TR_CODE;
                                    (*psCurrTDecl).time =
                                        (*yyvsp.offset(0 as libc::c_int as
                                                           isize)).ival as
                                            UDWORD;
                                    if (*(*yyvsp.offset(-(2 as libc::c_int) as
                                                            isize)).cblock).size
                                           > 0 as libc::c_int as libc::c_uint
                                       {
                                        (*psCurrTDecl).pCode =
                                            memMallocRelease((*(*yyvsp.offset(-(2
                                                                                    as
                                                                                    libc::c_int)
                                                                                  as
                                                                                  isize)).cblock).size)
                                                as *mut UDWORD;
                                        if (*psCurrTDecl).pCode.is_null() {
                                            scr_error(b"Out of memory\x00" as
                                                          *const u8 as
                                                          *const libc::c_char
                                                          as
                                                          *mut libc::c_char);
                                            current_block =
                                                10563765182283539921;
                                            break ;
                                        } else {
                                            (*psCurrTDecl).size =
                                                (*(*yyvsp.offset(-(2 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).cblock).size
                                        }
                                    } else {
                                        (*psCurrTDecl).pCode =
                                            0 as *mut UDWORD;
                                        (*psCurrTDecl).size =
                                            0 as libc::c_int as UDWORD
                                    }
                                    ip = (*psCurrTDecl).pCode;
                                    memcpy(ip as *mut libc::c_void,
                                           (*(*yyvsp.offset(-(2 as
                                                                  libc::c_int)
                                                                as
                                                                isize)).cblock).pCode
                                               as *const libc::c_void,
                                           (*(*yyvsp.offset(-(2 as
                                                                  libc::c_int)
                                                                as
                                                                isize)).cblock).size);
                                    ip =
                                        (ip as
                                             *mut UBYTE).offset((*(*yyvsp.offset(-(2
                                                                                       as
                                                                                       libc::c_int)
                                                                                     as
                                                                                     isize)).cblock).size
                                                                    as isize)
                                            as *mut UDWORD;
                                    memFreeRelease((*(*yyvsp.offset(-(2 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).cblock).pCode
                                                       as *mut libc::c_void);
                                    let ref mut fresh11 =
                                        (*(*yyvsp.offset(-(2 as libc::c_int)
                                                             as
                                                             isize)).cblock).pCode;
                                    *fresh11 = 0 as *mut UDWORD;
                                    memFreeRelease((*yyvsp.offset(-(2 as
                                                                        libc::c_int)
                                                                      as
                                                                      isize)).cblock
                                                       as *mut libc::c_void);
                                    let ref mut fresh12 =
                                        (*yyvsp.offset(-(2 as libc::c_int) as
                                                           isize)).cblock;
                                    *fresh12 = 0 as *mut CODE_BLOCK;
                                    yyval.tdecl = psCurrTDecl
                                }
                                current_block = 9320480655893135347;
                            }
                            26 => {
                                /* DEBUG */
					//sprintf(msg,"[YACC]: PUT_DATA VAL_STRING, val: '%s'\n",yyvsp[0].sval);
					//debug(LOG_SCRIPT,"[YACC]: PUT_DATA VAL_STRING, val: '%s'",yyvsp[0].sval);
                                psCurrTDecl =
                                    memMallocRelease(::std::mem::size_of::<TRIGGER_DECL>()
                                                         as libc::c_ulong) as
                                        *mut TRIGGER_DECL;
                                if psCurrTDecl.is_null() {
                                    scr_error(b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCurrTDecl).type_0 = TR_WAIT;
                                    (*psCurrTDecl).time =
                                        (*yyvsp.offset(0 as libc::c_int as
                                                           isize)).ival as
                                            UDWORD;
                                    if 0 as libc::c_int > 0 as libc::c_int {
                                        (*psCurrTDecl).pCode =
                                            memMallocRelease(0 as libc::c_int
                                                                 as size_t) as
                                                *mut UDWORD;
                                        if (*psCurrTDecl).pCode.is_null() {
                                            scr_error(b"Out of memory\x00" as
                                                          *const u8 as
                                                          *const libc::c_char
                                                          as
                                                          *mut libc::c_char);
                                            current_block =
                                                10563765182283539921;
                                            break ;
                                        } else {
                                            (*psCurrTDecl).size =
                                                0 as libc::c_int as UDWORD
                                        }
                                    } else {
                                        (*psCurrTDecl).pCode =
                                            0 as *mut UDWORD;
                                        (*psCurrTDecl).size =
                                            0 as libc::c_int as UDWORD
                                    }
                                    yyval.tdecl = psCurrTDecl
                                }
                                current_block = 9320480655893135347;
                            }
                            27 => {
                                psCurrTDecl =
                                    memMallocRelease(::std::mem::size_of::<TRIGGER_DECL>()
                                                         as libc::c_ulong) as
                                        *mut TRIGGER_DECL;
                                if psCurrTDecl.is_null() {
                                    scr_error(b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCurrTDecl).type_0 = TR_EVERY;
                                    (*psCurrTDecl).time =
                                        (*yyvsp.offset(0 as libc::c_int as
                                                           isize)).ival as
                                            UDWORD;
                                    if 0 as libc::c_int > 0 as libc::c_int {
                                        (*psCurrTDecl).pCode =
                                            memMallocRelease(0 as libc::c_int
                                                                 as size_t) as
                                                *mut UDWORD;
                                        if (*psCurrTDecl).pCode.is_null() {
                                            scr_error(b"Out of memory\x00" as
                                                          *const u8 as
                                                          *const libc::c_char
                                                          as
                                                          *mut libc::c_char);
                                            current_block =
                                                10563765182283539921;
                                            break ;
                                        } else {
                                            (*psCurrTDecl).size =
                                                0 as libc::c_int as UDWORD
                                        }
                                    } else {
                                        (*psCurrTDecl).pCode =
                                            0 as *mut UDWORD;
                                        (*psCurrTDecl).size =
                                            0 as libc::c_int as UDWORD
                                    }
                                    yyval.tdecl = psCurrTDecl
                                }
                                current_block = 9320480655893135347;
                            }
                            28 => {
                                /* Return the code block */
                                psCurrTDecl =
                                    memMallocRelease(::std::mem::size_of::<TRIGGER_DECL>()
                                                         as libc::c_ulong) as
                                        *mut TRIGGER_DECL;
                                if psCurrTDecl.is_null() {
                                    scr_error(b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCurrTDecl).type_0 = TR_INIT;
                                    (*psCurrTDecl).time =
                                        0 as libc::c_int as UDWORD;
                                    if 0 as libc::c_int > 0 as libc::c_int {
                                        (*psCurrTDecl).pCode =
                                            memMallocRelease(0 as libc::c_int
                                                                 as size_t) as
                                                *mut UDWORD;
                                        if (*psCurrTDecl).pCode.is_null() {
                                            scr_error(b"Out of memory\x00" as
                                                          *const u8 as
                                                          *const libc::c_char
                                                          as
                                                          *mut libc::c_char);
                                            current_block =
                                                10563765182283539921;
                                            break ;
                                        } else {
                                            (*psCurrTDecl).size =
                                                0 as libc::c_int as UDWORD
                                        }
                                    } else {
                                        (*psCurrTDecl).pCode =
                                            0 as *mut UDWORD;
                                        (*psCurrTDecl).size =
                                            0 as libc::c_int as UDWORD
                                    }
                                    yyval.tdecl = psCurrTDecl
                                }
                                current_block = 9320480655893135347;
                            }
                            29 => {
                                if (*(*yyvsp.offset(0 as libc::c_int as
                                                        isize)).cbSymbol).numParams
                                       != 0 as libc::c_int as libc::c_uint {
                                    scr_error(b"Expected parameters for callback trigger\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    psCurrTDecl =
                                        memMallocRelease(::std::mem::size_of::<TRIGGER_DECL>()
                                                             as libc::c_ulong)
                                            as *mut TRIGGER_DECL;
                                    if psCurrTDecl.is_null() {
                                        scr_error(b"Out of memory\x00" as
                                                      *const u8 as
                                                      *const libc::c_char as
                                                      *mut libc::c_char);
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrTDecl).type_0 =
                                            (*(*yyvsp.offset(0 as libc::c_int
                                                                 as
                                                                 isize)).cbSymbol).type_0;
                                        (*psCurrTDecl).time =
                                            0 as libc::c_int as UDWORD;
                                        if 0 as libc::c_int > 0 as libc::c_int
                                           {
                                            (*psCurrTDecl).pCode =
                                                memMallocRelease(0 as
                                                                     libc::c_int
                                                                     as
                                                                     size_t)
                                                    as *mut UDWORD;
                                            if (*psCurrTDecl).pCode.is_null()
                                               {
                                                scr_error(b"Out of memory\x00"
                                                              as *const u8 as
                                                              *const libc::c_char
                                                              as
                                                              *mut libc::c_char);
                                                current_block =
                                                    10563765182283539921;
                                                break ;
                                            } else {
                                                (*psCurrTDecl).size =
                                                    0 as libc::c_int as UDWORD
                                            }
                                        } else {
                                            (*psCurrTDecl).pCode =
                                                0 as *mut UDWORD;
                                            (*psCurrTDecl).size =
                                                0 as libc::c_int as UDWORD
                                        }
                                        yyval.tdecl = psCurrTDecl
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            30 => {
                                codeRet =
                                    scriptCodeCallbackParams((*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cbSymbol,
                                                             (*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).pblock,
                                                             &mut psCurrTDecl);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.tdecl = psCurrTDecl;
                                    /* Return the code block */
                                    current_block = 9320480655893135347;
                                }
                            }
                            31 => {
                                let mut line: SDWORD = 0;
                                let mut pDummy: *mut STRING =
                                    0 as *mut STRING;
                                scriptGetErrorData(&mut line, &mut pDummy);
                                if scriptAddTrigger((*yyvsp.offset(-(4 as
                                                                         libc::c_int)
                                                                       as
                                                                       isize)).sval,
                                                    (*yyvsp.offset(-(2 as
                                                                         libc::c_int)
                                                                       as
                                                                       isize)).tdecl,
                                                    line as UDWORD) == 0 {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if !(*(*yyvsp.offset(-(2 as libc::c_int) as
                                                         isize)).tdecl).pCode.is_null()
                                   {
                                    memFreeRelease((*(*yyvsp.offset(-(2 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).tdecl).pCode
                                                       as *mut libc::c_void);
                                    let ref mut fresh13 =
                                        (*(*yyvsp.offset(-(2 as libc::c_int)
                                                             as
                                                             isize)).tdecl).pCode;
                                    *fresh13 = 0 as *mut UDWORD
                                }
                                memFreeRelease((*yyvsp.offset(-(2 as
                                                                    libc::c_int)
                                                                  as
                                                                  isize)).tdecl
                                                   as *mut libc::c_void);
                                let ref mut fresh14 =
                                    (*yyvsp.offset(-(2 as libc::c_int) as
                                                       isize)).tdecl;
                                *fresh14 = 0 as *mut TRIGGER_DECL;
                                /* Return the code block */
                                /* Copy the already generated bits of code into the code block */
                                /* Now put a negation operator into the code */
                                current_block = 9320480655893135347;
                            }
                            34 => {
                                let mut psEvent_0: *mut EVENT_SYMBOL =
                                    0 as *mut EVENT_SYMBOL;
                                if scriptDeclareEvent((*yyvsp.offset(0 as
                                                                         libc::c_int
                                                                         as
                                                                         isize)).sval,
                                                      &mut psEvent_0,
                                                      0 as libc::c_int) == 0 {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                psCurEvent = psEvent_0;
                                yyval.eSymbol = psEvent_0;
                                /* Return the code block */
                                /* Just pass the code up the tree */
                                /* Generate the code for the function call */
                                /* Return the code block */
                                current_block = 9320480655893135347;
                            }
                            35 => {
                                psCurEvent =
                                    (*yyvsp.offset(0 as libc::c_int as
                                                       isize)).eSymbol;
                                yyval.eSymbol =
                                    (*yyvsp.offset(0 as libc::c_int as
                                                       isize)).eSymbol;
                                current_block = 9320480655893135347;
                            }
                            42 => {
                                let mut psEvent_1: *mut EVENT_SYMBOL =
                                    0 as *mut EVENT_SYMBOL;
                                localVariableDef = 1 as libc::c_int;
                                if scriptDeclareEvent((*yyvsp.offset(0 as
                                                                         libc::c_int
                                                                         as
                                                                         isize)).sval,
                                                      &mut psEvent_1,
                                                      0 as libc::c_int) == 0 {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                (*psEvent_1).retType =
                                    (*yyvsp.offset(-(1 as libc::c_int) as
                                                       isize)).tval;
                                psCurEvent = psEvent_1;
                                (*psCurEvent).bFunction = 1 as libc::c_int;
                                yyval.eSymbol = psEvent_1;
                                /* make sure function has a return type */
                                /* check if right parameters were passed */
                                /* Allocate the code block */
                                //Params + Opcode + event index
                                current_block = 9320480655893135347;
                            }
                            43 => {
                                /* if any parameters declared */
                                psCurEvent =
                                    (*yyvsp.offset(0 as libc::c_int as
                                                       isize)).eSymbol;
                                if (*(*yyvsp.offset(0 as libc::c_int as
                                                        isize)).eSymbol).bFunction
                                       == 0 {
                                    debug(LOG_ERROR,
                                          b"\'%s\' was declared as event before and can\'t be redefined to function\x00"
                                              as *const u8 as
                                              *const libc::c_char,
                                          (*(*yyvsp.offset(0 as libc::c_int as
                                                               isize)).eSymbol).pIdent);
                                    scr_error(b"Wrong event definition\x00" as
                                                  *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    yyval.eSymbol =
                                        (*yyvsp.offset(0 as libc::c_int as
                                                           isize)).eSymbol
                                }
                                current_block = 9320480655893135347;
                            }
                            44 => {
                                yyval.integer_val =
                                    (*yyvsp.offset(-(1 as libc::c_int) as
                                                       isize)).tval as UDWORD;
                                /* Return the code block */
                                current_block = 9320480655893135347;
                            }
                            45 => {
                                yyval.integer_val =
                                    (*yyvsp.offset(-(1 as libc::c_int) as
                                                       isize)).tval as UDWORD;
                                /* Return the code block */
                                current_block = 9320480655893135347;
                            }
                            46 => {
                                yyval.integer_val =
                                    (*yyvsp.offset(-(1 as libc::c_int) as
                                                       isize)).tval as UDWORD;
                                /* Return the code block */
                                current_block = 9320480655893135347;
                            }
                            47 => {
                                yyval.integer_val =
                                    (*yyvsp.offset(-(1 as libc::c_int) as
                                                       isize)).tval as UDWORD;
                                /* Return the code block */
                                current_block = 9320480655893135347;
                            }
                            48 => {
                                yyval.integer_val =
                                    (*yyvsp.offset(-(1 as libc::c_int) as
                                                       isize)).tval as UDWORD;
                                /* Code to store the value on the stack */
                                current_block =
                                    9320480655893135347; /* Return the code block */
                            }
                            49 => {
                                yyval.integer_val =
                                    (*yyvsp.offset(-(1 as libc::c_int) as
                                                       isize)).tval as
                                        UDWORD; /* Return the code block */
                                current_block = 9320480655893135347;
                            }
                            50 => {
                                yyval.integer_val =
                                    (*yyvsp.offset(-(1 as libc::c_int) as
                                                       isize)).tval as UDWORD;
                                current_block = 9320480655893135347;
                            }
                            51 => {
                                if checkFuncParamType(0 as libc::c_int,
                                                      (*yyvsp.offset(0 as
                                                                         libc::c_int
                                                                         as
                                                                         isize)).integer_val
                                                          as SDWORD) == 0 {
                                    scr_error(b"Wrong event argument definition in \'%s\'\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char,
                                              (*psCurEvent).pIdent);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    yyval.integer_val =
                                        1 as libc::c_int as UDWORD
                                }
                                current_block = 9320480655893135347;
                            }
                            52 => {
                                if checkFuncParamType((*yyvsp.offset(-(2 as
                                                                           libc::c_int)
                                                                         as
                                                                         isize)).integer_val
                                                          as SDWORD,
                                                      (*yyvsp.offset(0 as
                                                                         libc::c_int
                                                                         as
                                                                         isize)).integer_val
                                                          as SDWORD) == 0 {
                                    scr_error(b"Wrong event argument definition\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    yyval.integer_val =
                                        (*yyvsp.offset(-(2 as libc::c_int) as
                                                           isize)).integer_val.wrapping_add(1
                                                                                                as
                                                                                                libc::c_int
                                                                                                as
                                                                                                libc::c_uint)
                                }
                                current_block = 9320480655893135347;
                            }
                            53 => {
                                psCurrVDecl =
                                    memMallocRelease(::std::mem::size_of::<VAR_DECL>()
                                                         as libc::c_ulong) as
                                        *mut VAR_DECL;
                                if psCurrVDecl.is_null() {
                                    scr_error(b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCurrVDecl).storage =
                                        ST_LOCAL as libc::c_int as
                                            STORAGE_TYPE;
                                    (*psCurrVDecl).type_0 =
                                        (*yyvsp.offset(-(1 as libc::c_int) as
                                                           isize)).tval;
                                    if scriptAddVariable(psCurrVDecl,
                                                         (*yyvsp.offset(0 as
                                                                            libc::c_int
                                                                            as
                                                                            isize)).videcl)
                                           == 0 {
                                        current_block = 10563765182283539921;
                                        break ;
                                    }
                                    memFreeRelease((*yyvsp.offset(0 as
                                                                      libc::c_int
                                                                      as
                                                                      isize)).videcl
                                                       as *mut libc::c_void);
                                    let ref mut fresh15 =
                                        (*yyvsp.offset(0 as libc::c_int as
                                                           isize)).videcl;
                                    *fresh15 = 0 as *mut VAR_IDENT_DECL;
                                    memFreeRelease(psCurrVDecl as
                                                       *mut libc::c_void);
                                    psCurrVDecl = 0 as *mut VAR_DECL;
                                    if psCurEvent.is_null() {
                                        debug(LOG_ERROR,
                                              b"argument_decl_head 0:  - psCurEvent == NULL\x00"
                                                  as *const u8 as
                                                  *const libc::c_char);
                                    }
                                    (*psCurEvent).numParams =
                                        (*psCurEvent).numParams.wrapping_add(1
                                                                                 as
                                                                                 libc::c_int
                                                                                 as
                                                                                 libc::c_uint);
                                    (*psCurEvent).aParams[0 as libc::c_int as
                                                              usize] =
                                        (*yyvsp.offset(-(1 as libc::c_int) as
                                                           isize)).tval
                                }
                                current_block = 9320480655893135347;
                            }
                            54 => {
                                psCurrVDecl =
                                    memMallocRelease(::std::mem::size_of::<VAR_DECL>()
                                                         as libc::c_ulong) as
                                        *mut VAR_DECL;
                                if psCurrVDecl.is_null() {
                                    scr_error(b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCurrVDecl).storage =
                                        ST_LOCAL as libc::c_int as
                                            STORAGE_TYPE;
                                    (*psCurrVDecl).type_0 =
                                        (*yyvsp.offset(-(1 as libc::c_int) as
                                                           isize)).tval;
                                    (*psCurEvent).aParams[(*psCurEvent).numParams
                                                              as usize] =
                                        (*yyvsp.offset(-(1 as libc::c_int) as
                                                           isize)).tval;
                                    if scriptAddVariable(psCurrVDecl,
                                                         (*yyvsp.offset(0 as
                                                                            libc::c_int
                                                                            as
                                                                            isize)).videcl)
                                           == 0 {
                                        current_block = 10563765182283539921;
                                        break ;
                                    }
                                    memFreeRelease((*yyvsp.offset(0 as
                                                                      libc::c_int
                                                                      as
                                                                      isize)).videcl
                                                       as *mut libc::c_void);
                                    let ref mut fresh16 =
                                        (*yyvsp.offset(0 as libc::c_int as
                                                           isize)).videcl;
                                    *fresh16 = 0 as *mut VAR_IDENT_DECL;
                                    memFreeRelease(psCurrVDecl as
                                                       *mut libc::c_void);
                                    psCurrVDecl = 0 as *mut VAR_DECL;
                                    if psCurEvent.is_null() {
                                        debug(LOG_ERROR,
                                              b"argument_decl_head 0:  - psCurEvent == NULL\x00"
                                                  as *const u8 as
                                                  *const libc::c_char);
                                    }
                                    (*psCurEvent).numParams =
                                        (*psCurEvent).numParams.wrapping_add(1
                                                                                 as
                                                                                 libc::c_int
                                                                                 as
                                                                                 libc::c_uint)
                                }
                                current_block = 9320480655893135347;
                            }
                            56 => {
                                localVariableDef = 0 as libc::c_int;
                                /* Return the code block */
                                current_block = 9320480655893135347;
                            }
                            57 => {
                                localVariableDef = 0 as libc::c_int;
                                if (*psCurEvent).bDeclared != 0 {
                                    scr_error(b"Wrong event definition: \nEvent %s\'s definition doesn\'t match with declaration\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char,
                                              (*psCurEvent).pIdent);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    yyval.eSymbol =
                                        (*yyvsp.offset(-(3 as libc::c_int) as
                                                           isize)).eSymbol
                                }
                                current_block = 9320480655893135347;
                            }
                            58 => {
                                localVariableDef = 0 as libc::c_int;
                                if (*(*yyvsp.offset(-(2 as libc::c_int) as
                                                        isize)).eSymbol).numParams
                                       > 0 as libc::c_int as libc::c_uint &&
                                       (*psCurEvent).bDeclared != 0 {
                                    scr_error(b"Wrong event definition: \nEvent %s\'s definition doesn\'t match with declaration\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char,
                                              (*psCurEvent).pIdent);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    yyval.eSymbol =
                                        (*yyvsp.offset(-(2 as libc::c_int) as
                                                           isize)).eSymbol
                                }
                                current_block = 9320480655893135347;
                            }
                            59 => {
                                (*psCurEvent).bDeclared = 1 as libc::c_int;
                                /* Code to store the value on the stack */
                                current_block = 9320480655893135347;
                            }
                            60 => {
                                localVariableDef = 0 as libc::c_int;
                                (*psCurEvent).bDeclared = 1 as libc::c_int;
                                /* Return the code block */
                                current_block = 9320480655893135347;
                            }
                            61 => {
                                if (*psCurEvent).bFunction != 0 {
                                    debug(LOG_ERROR,
                                          b"Event \'%s\' is declared as function and can\'t have a trigger assigned\x00"
                                              as *const u8 as
                                              *const libc::c_char,
                                          (*psCurEvent).pIdent);
                                    scr_error(b"Wrong event definition\x00" as
                                                  *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    if scriptDefineEvent((*yyvsp.offset(-(7 as
                                                                              libc::c_int)
                                                                            as
                                                                            isize)).eSymbol,
                                                         (*yyvsp.offset(-(1 as
                                                                              libc::c_int)
                                                                            as
                                                                            isize)).cblock,
                                                         (*(*yyvsp.offset(-(5
                                                                                as
                                                                                libc::c_int)
                                                                              as
                                                                              isize)).tSymbol).index
                                                             as SDWORD) == 0 {
                                        current_block = 10563765182283539921;
                                        break ;
                                    }
                                    psCurEvent = 0 as *mut EVENT_SYMBOL;
                                    if genDebugInfo != 0 {
                                        memFreeRelease((*(*yyvsp.offset(-(1 as
                                                                              libc::c_int)
                                                                            as
                                                                            isize)).cblock).psDebug
                                                           as
                                                           *mut libc::c_void);
                                        let ref mut fresh17 =
                                            (*(*yyvsp.offset(-(1 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).cblock).psDebug;
                                        *fresh17 = 0 as *mut SCRIPT_DEBUG
                                    }
                                    memFreeRelease((*(*yyvsp.offset(-(1 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).cblock).pCode
                                                       as *mut libc::c_void);
                                    let ref mut fresh18 =
                                        (*(*yyvsp.offset(-(1 as libc::c_int)
                                                             as
                                                             isize)).cblock).pCode;
                                    *fresh18 = 0 as *mut UDWORD;
                                    memFreeRelease((*yyvsp.offset(-(1 as
                                                                        libc::c_int)
                                                                      as
                                                                      isize)).cblock
                                                       as *mut libc::c_void);
                                    let ref mut fresh19 =
                                        (*yyvsp.offset(-(1 as libc::c_int) as
                                                           isize)).cblock;
                                    *fresh19 = 0 as *mut CODE_BLOCK
                                }
                                current_block = 9320480655893135347;
                            }
                            62 => {
                                let mut pDummy_0: *mut STRING =
                                    0 as *mut STRING;
                                if (*psCurEvent).bFunction != 0 {
                                    debug(LOG_ERROR,
                                          b"Event \'%s\' is declared as function and can\'t have a trigger assigned\x00"
                                              as *const u8 as
                                              *const libc::c_char,
                                          (*psCurEvent).pIdent);
                                    scr_error(b"Wrong event definition\x00" as
                                                  *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    scriptGetErrorData(&mut debugLine as
                                                           *mut UDWORD as
                                                           *mut SDWORD,
                                                       &mut pDummy_0);
                                }
                                current_block = 9320480655893135347;
                            }
                            63 => {
                                if scriptAddTrigger(b"\x00" as *const u8 as
                                                        *const libc::c_char as
                                                        *mut STRING,
                                                    (*yyvsp.offset(-(6 as
                                                                         libc::c_int)
                                                                       as
                                                                       isize)).tdecl,
                                                    debugLine) == 0 {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if !(*(*yyvsp.offset(-(6 as libc::c_int) as
                                                         isize)).tdecl).pCode.is_null()
                                   {
                                    memFreeRelease((*(*yyvsp.offset(-(6 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).tdecl).pCode
                                                       as *mut libc::c_void);
                                    let ref mut fresh20 =
                                        (*(*yyvsp.offset(-(6 as libc::c_int)
                                                             as
                                                             isize)).tdecl).pCode;
                                    *fresh20 = 0 as *mut UDWORD
                                }
                                memFreeRelease((*yyvsp.offset(-(6 as
                                                                    libc::c_int)
                                                                  as
                                                                  isize)).tdecl
                                                   as *mut libc::c_void);
                                let ref mut fresh21 =
                                    (*yyvsp.offset(-(6 as libc::c_int) as
                                                       isize)).tdecl;
                                *fresh21 = 0 as *mut TRIGGER_DECL;
                                if scriptDefineEvent((*yyvsp.offset(-(8 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).eSymbol,
                                                     (*yyvsp.offset(-(1 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).cblock,
                                                     numTriggers.wrapping_sub(1
                                                                                  as
                                                                                  libc::c_int
                                                                                  as
                                                                                  libc::c_uint)
                                                         as SDWORD) == 0 {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                psCurEvent = 0 as *mut EVENT_SYMBOL;
                                if genDebugInfo != 0 {
                                    memFreeRelease((*(*yyvsp.offset(-(1 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).cblock).psDebug
                                                       as *mut libc::c_void);
                                    let ref mut fresh22 =
                                        (*(*yyvsp.offset(-(1 as libc::c_int)
                                                             as
                                                             isize)).cblock).psDebug;
                                    *fresh22 = 0 as *mut SCRIPT_DEBUG
                                }
                                memFreeRelease((*(*yyvsp.offset(-(1 as
                                                                      libc::c_int)
                                                                    as
                                                                    isize)).cblock).pCode
                                                   as *mut libc::c_void);
                                let ref mut fresh23 =
                                    (*(*yyvsp.offset(-(1 as libc::c_int) as
                                                         isize)).cblock).pCode;
                                *fresh23 = 0 as *mut UDWORD;
                                memFreeRelease((*yyvsp.offset(-(1 as
                                                                    libc::c_int)
                                                                  as
                                                                  isize)).cblock
                                                   as *mut libc::c_void);
                                let ref mut fresh24 =
                                    (*yyvsp.offset(-(1 as libc::c_int) as
                                                       isize)).cblock;
                                *fresh24 = 0 as *mut CODE_BLOCK;
                                /* make sure function has a return type */
						/* if($1->retType != OBJ_VAR) */
                                /* check if right parameters were passed */
                                /* Allocate the code block */
                                //Params + Opcode + event index
                                current_block = 9320480655893135347;
                            }
                            64 => {
                                /* if any parameters declared */
                                if (*psCurEvent).bFunction != 0 {
                                    debug(LOG_ERROR,
                                          b"Event \'%s\' is declared as function and can\'t have a trigger assigned\x00"
                                              as *const u8 as
                                              *const libc::c_char,
                                          (*psCurEvent).pIdent);
                                    scr_error(b"Wrong event definition\x00" as
                                                  *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    if scriptDefineEvent((*yyvsp.offset(-(7 as
                                                                              libc::c_int)
                                                                            as
                                                                            isize)).eSymbol,
                                                         (*yyvsp.offset(-(1 as
                                                                              libc::c_int)
                                                                            as
                                                                            isize)).cblock,
                                                         -(1 as libc::c_int))
                                           == 0 {
                                        current_block = 10563765182283539921;
                                        break ;
                                    }
                                    psCurEvent = 0 as *mut EVENT_SYMBOL;
                                    if genDebugInfo != 0 {
                                        memFreeRelease((*(*yyvsp.offset(-(1 as
                                                                              libc::c_int)
                                                                            as
                                                                            isize)).cblock).psDebug
                                                           as
                                                           *mut libc::c_void);
                                        let ref mut fresh25 =
                                            (*(*yyvsp.offset(-(1 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).cblock).psDebug;
                                        *fresh25 = 0 as *mut SCRIPT_DEBUG
                                    }
                                    memFreeRelease((*(*yyvsp.offset(-(1 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).cblock).pCode
                                                       as *mut libc::c_void);
                                    let ref mut fresh26 =
                                        (*(*yyvsp.offset(-(1 as libc::c_int)
                                                             as
                                                             isize)).cblock).pCode;
                                    *fresh26 = 0 as *mut UDWORD;
                                    memFreeRelease((*yyvsp.offset(-(1 as
                                                                        libc::c_int)
                                                                      as
                                                                      isize)).cblock
                                                       as *mut libc::c_void);
                                    let ref mut fresh27 =
                                        (*yyvsp.offset(-(1 as libc::c_int) as
                                                           isize)).cblock;
                                    *fresh27 = 0 as *mut CODE_BLOCK
                                }
                                current_block = 9320480655893135347;
                            }
                            65 => {
                                /* Return the code block */
                                let mut line_0: UDWORD = 0;
                                let mut pDummy_1: *mut STRING =
                                    0 as *mut STRING;
                                psCurrBlock =
                                    memMallocRelease(::std::mem::size_of::<CODE_BLOCK>()
                                                         as libc::c_ulong) as
                                        *mut CODE_BLOCK;
                                if psCurrBlock.is_null() {
                                    debug(LOG_ERROR,
                                          b"Out of memory\x00" as *const u8 as
                                              *const libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCurrBlock).pCode =
                                        memMallocRelease((*(*yyvsp.offset(-(2
                                                                                as
                                                                                libc::c_int)
                                                                              as
                                                                              isize)).cblock).size.wrapping_add((*(*yyvsp.offset(-(1
                                                                                                                                       as
                                                                                                                                       libc::c_int)
                                                                                                                                     as
                                                                                                                                     isize)).cblock).size).wrapping_add(::std::mem::size_of::<OPCODE>()
                                                                                                                                                                            as
                                                                                                                                                                            libc::c_ulong).wrapping_add((::std::mem::size_of::<OPCODE>()
                                                                                                                                                                                                             as
                                                                                                                                                                                                             libc::c_ulong).wrapping_mul((*(*yyvsp.offset(-(5
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                libc::c_int)
                                                                                                                                                                                                                                                              as
                                                                                                                                                                                                                                                              isize)).eSymbol).numParams)))
                                            as *mut UDWORD;
                                    if (*psCurrBlock).pCode.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        memFreeRelease(psCurrBlock as
                                                           *mut libc::c_void);
                                        psCurrBlock = 0 as *mut CODE_BLOCK;
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrBlock).size =
                                            (*(*yyvsp.offset(-(2 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).cblock).size.wrapping_add((*(*yyvsp.offset(-(1
                                                                                                                          as
                                                                                                                          libc::c_int)
                                                                                                                        as
                                                                                                                        isize)).cblock).size).wrapping_add(::std::mem::size_of::<OPCODE>()
                                                                                                                                                               as
                                                                                                                                                               libc::c_ulong).wrapping_add((::std::mem::size_of::<OPCODE>()
                                                                                                                                                                                                as
                                                                                                                                                                                                libc::c_ulong).wrapping_mul((*(*yyvsp.offset(-(5
                                                                                                                                                                                                                                                   as
                                                                                                                                                                                                                                                   libc::c_int)
                                                                                                                                                                                                                                                 as
                                                                                                                                                                                                                                                 isize)).eSymbol).numParams));
                                        ip = (*psCurrBlock).pCode;
                                        popArguments(&mut ip,
                                                     (*(*yyvsp.offset(-(5 as
                                                                            libc::c_int)
                                                                          as
                                                                          isize)).eSymbol).numParams
                                                         as SDWORD);
                                        memcpy(ip as *mut libc::c_void,
                                               (*(*yyvsp.offset(-(2 as
                                                                      libc::c_int)
                                                                    as
                                                                    isize)).cblock).pCode
                                                   as *const libc::c_void,
                                               (*(*yyvsp.offset(-(2 as
                                                                      libc::c_int)
                                                                    as
                                                                    isize)).cblock).size);
                                        ip =
                                            (ip as
                                                 *mut UBYTE).offset((*(*yyvsp.offset(-(2
                                                                                           as
                                                                                           libc::c_int)
                                                                                         as
                                                                                         isize)).cblock).size
                                                                        as
                                                                        isize)
                                                as *mut UDWORD;
                                        memcpy(ip as *mut libc::c_void,
                                               (*(*yyvsp.offset(-(1 as
                                                                      libc::c_int)
                                                                    as
                                                                    isize)).cblock).pCode
                                                   as *const libc::c_void,
                                               (*(*yyvsp.offset(-(1 as
                                                                      libc::c_int)
                                                                    as
                                                                    isize)).cblock).size);
                                        ip =
                                            (ip as
                                                 *mut UBYTE).offset((*(*yyvsp.offset(-(1
                                                                                           as
                                                                                           libc::c_int)
                                                                                         as
                                                                                         isize)).cblock).size
                                                                        as
                                                                        isize)
                                                as *mut UDWORD;
                                        *ip =
                                            ((OP_EXIT as libc::c_int) <<
                                                 24 as libc::c_int) as UDWORD;
                                        ip =
                                            ip.offset(1 as libc::c_int as
                                                          isize);
                                        if genDebugInfo != 0 {
                                            (*psCurrBlock).psDebug =
                                                memMallocRelease((::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                      as
                                                                      libc::c_ulong).wrapping_mul((*(*yyvsp.offset(-(2
                                                                                                                         as
                                                                                                                         libc::c_int)
                                                                                                                       as
                                                                                                                       isize)).cblock).debugEntries))
                                                    as *mut SCRIPT_DEBUG;
                                            if (*psCurrBlock).psDebug.is_null()
                                               {
                                                scr_error(b"Out of memory\x00"
                                                              as *const u8 as
                                                              *const libc::c_char
                                                              as
                                                              *mut libc::c_char);
                                                current_block =
                                                    10563765182283539921;
                                                break ;
                                            } else {
                                                memset((*psCurrBlock).psDebug
                                                           as
                                                           *mut libc::c_void,
                                                       0 as libc::c_int,
                                                       (::std::mem::size_of::<SCRIPT_DEBUG>()
                                                            as
                                                            libc::c_ulong).wrapping_mul((*(*yyvsp.offset(-(2
                                                                                                               as
                                                                                                               libc::c_int)
                                                                                                             as
                                                                                                             isize)).cblock).debugEntries));
                                                (*psCurrBlock).debugEntries =
                                                    (*(*yyvsp.offset(-(2 as
                                                                           libc::c_int)
                                                                         as
                                                                         isize)).cblock).debugEntries
                                                        as UWORD as UDWORD
                                            }
                                        } else {
                                            (*psCurrBlock).psDebug =
                                                0 as *mut SCRIPT_DEBUG;
                                            (*psCurrBlock).debugEntries =
                                                0 as libc::c_int as UDWORD
                                        }
                                        if genDebugInfo != 0 {
                                            memcpy((*psCurrBlock).psDebug as
                                                       *mut libc::c_void,
                                                   (*(*yyvsp.offset(-(2 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).cblock).psDebug
                                                       as *const libc::c_void,
                                                   (::std::mem::size_of::<SCRIPT_DEBUG>()
                                                        as
                                                        libc::c_ulong).wrapping_mul((*(*yyvsp.offset(-(2
                                                                                                           as
                                                                                                           libc::c_int)
                                                                                                         as
                                                                                                         isize)).cblock).debugEntries));
                                            (*psCurrBlock).debugEntries =
                                                (*(*yyvsp.offset(-(2 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).cblock).debugEntries
                                        }
                                        if scriptDefineEvent((*yyvsp.offset(-(5
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).eSymbol,
                                                             psCurrBlock,
                                                             -(1 as
                                                                   libc::c_int))
                                               == 0 {
                                            current_block =
                                                10563765182283539921;
                                            break ;
                                        }
                                        if genDebugInfo != 0 {
                                            memFreeRelease((*(*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cblock).psDebug
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh28 =
                                                (*(*yyvsp.offset(-(2 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).cblock).psDebug;
                                            *fresh28 = 0 as *mut SCRIPT_DEBUG
                                        }
                                        memFreeRelease((*(*yyvsp.offset(-(2 as
                                                                              libc::c_int)
                                                                            as
                                                                            isize)).cblock).pCode
                                                           as
                                                           *mut libc::c_void);
                                        let ref mut fresh29 =
                                            (*(*yyvsp.offset(-(2 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).cblock).pCode;
                                        *fresh29 = 0 as *mut UDWORD;
                                        memFreeRelease((*yyvsp.offset(-(2 as
                                                                            libc::c_int)
                                                                          as
                                                                          isize)).cblock
                                                           as
                                                           *mut libc::c_void);
                                        let ref mut fresh30 =
                                            (*yyvsp.offset(-(2 as libc::c_int)
                                                               as
                                                               isize)).cblock;
                                        *fresh30 = 0 as *mut CODE_BLOCK;
                                        memFreeRelease((*(*yyvsp.offset(-(1 as
                                                                              libc::c_int)
                                                                            as
                                                                            isize)).cblock).pCode
                                                           as
                                                           *mut libc::c_void);
                                        let ref mut fresh31 =
                                            (*(*yyvsp.offset(-(1 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).cblock).pCode;
                                        *fresh31 = 0 as *mut UDWORD;
                                        memFreeRelease((*yyvsp.offset(-(1 as
                                                                            libc::c_int)
                                                                          as
                                                                          isize)).cblock
                                                           as
                                                           *mut libc::c_void);
                                        let ref mut fresh32 =
                                            (*yyvsp.offset(-(1 as libc::c_int)
                                                               as
                                                               isize)).cblock;
                                        *fresh32 = 0 as *mut CODE_BLOCK;
                                        psCurEvent = 0 as *mut EVENT_SYMBOL;
                                        if genDebugInfo != 0 {
                                            memFreeRelease((*psCurrBlock).psDebug
                                                               as
                                                               *mut libc::c_void);
                                            (*psCurrBlock).psDebug =
                                                0 as *mut SCRIPT_DEBUG
                                        }
                                        memFreeRelease((*psCurrBlock).pCode as
                                                           *mut libc::c_void);
                                        (*psCurrBlock).pCode =
                                            0 as *mut UDWORD;
                                        memFreeRelease(psCurrBlock as
                                                           *mut libc::c_void);
                                        psCurrBlock = 0 as *mut CODE_BLOCK
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            66 => {
                                if (*psCurEvent).bDeclared == 0 {
                                    debug(LOG_ERROR,
                                          b"Event %s\'s definition doesn\'t match with declaration.\x00"
                                              as *const u8 as
                                              *const libc::c_char,
                                          (*psCurEvent).pIdent);
                                    scr_error(b"Wrong event definition:\n event %s\'s definition doesn\'t match with declaration\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char,
                                              (*psCurEvent).pIdent);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else if (*yyvsp.offset(-(6 as libc::c_int)
                                                             as
                                                             isize)).integer_val
                                              != (*psCurEvent).numParams {
                                    scr_error(b"Wrong number of arguments in function definition (or declaration-definition argument type/names mismatch) \n in event: \'%s\'\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char,
                                              (*psCurEvent).pIdent);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    psCurrBlock =
                                        memMallocRelease(::std::mem::size_of::<CODE_BLOCK>()
                                                             as libc::c_ulong)
                                            as *mut CODE_BLOCK;
                                    if psCurrBlock.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrBlock).pCode =
                                            memMallocRelease((*(*yyvsp.offset(-(2
                                                                                    as
                                                                                    libc::c_int)
                                                                                  as
                                                                                  isize)).cblock).size.wrapping_add((*(*yyvsp.offset(-(1
                                                                                                                                           as
                                                                                                                                           libc::c_int)
                                                                                                                                         as
                                                                                                                                         isize)).cblock).size).wrapping_add(::std::mem::size_of::<OPCODE>()
                                                                                                                                                                                as
                                                                                                                                                                                libc::c_ulong).wrapping_add((::std::mem::size_of::<OPCODE>()
                                                                                                                                                                                                                 as
                                                                                                                                                                                                                 libc::c_ulong).wrapping_mul((*(*yyvsp.offset(-(8
                                                                                                                                                                                                                                                                    as
                                                                                                                                                                                                                                                                    libc::c_int)
                                                                                                                                                                                                                                                                  as
                                                                                                                                                                                                                                                                  isize)).eSymbol).numParams)))
                                                as *mut UDWORD;
                                        if (*psCurrBlock).pCode.is_null() {
                                            debug(LOG_ERROR,
                                                  b"Out of memory\x00" as
                                                      *const u8 as
                                                      *const libc::c_char);
                                            memFreeRelease(psCurrBlock as
                                                               *mut libc::c_void);
                                            psCurrBlock =
                                                0 as *mut CODE_BLOCK;
                                            current_block =
                                                10563765182283539921;
                                            break ;
                                        } else {
                                            (*psCurrBlock).size =
                                                (*(*yyvsp.offset(-(2 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).cblock).size.wrapping_add((*(*yyvsp.offset(-(1
                                                                                                                              as
                                                                                                                              libc::c_int)
                                                                                                                            as
                                                                                                                            isize)).cblock).size).wrapping_add(::std::mem::size_of::<OPCODE>()
                                                                                                                                                                   as
                                                                                                                                                                   libc::c_ulong).wrapping_add((::std::mem::size_of::<OPCODE>()
                                                                                                                                                                                                    as
                                                                                                                                                                                                    libc::c_ulong).wrapping_mul((*(*yyvsp.offset(-(8
                                                                                                                                                                                                                                                       as
                                                                                                                                                                                                                                                       libc::c_int)
                                                                                                                                                                                                                                                     as
                                                                                                                                                                                                                                                     isize)).eSymbol).numParams));
                                            ip = (*psCurrBlock).pCode;
                                            popArguments(&mut ip,
                                                         (*(*yyvsp.offset(-(8
                                                                                as
                                                                                libc::c_int)
                                                                              as
                                                                              isize)).eSymbol).numParams
                                                             as SDWORD);
                                            memcpy(ip as *mut libc::c_void,
                                                   (*(*yyvsp.offset(-(2 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).cblock).pCode
                                                       as *const libc::c_void,
                                                   (*(*yyvsp.offset(-(2 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).cblock).size);
                                            ip =
                                                (ip as
                                                     *mut UBYTE).offset((*(*yyvsp.offset(-(2
                                                                                               as
                                                                                               libc::c_int)
                                                                                             as
                                                                                             isize)).cblock).size
                                                                            as
                                                                            isize)
                                                    as *mut UDWORD;
                                            memcpy(ip as *mut libc::c_void,
                                                   (*(*yyvsp.offset(-(1 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).cblock).pCode
                                                       as *const libc::c_void,
                                                   (*(*yyvsp.offset(-(1 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).cblock).size);
                                            ip =
                                                (ip as
                                                     *mut UBYTE).offset((*(*yyvsp.offset(-(1
                                                                                               as
                                                                                               libc::c_int)
                                                                                             as
                                                                                             isize)).cblock).size
                                                                            as
                                                                            isize)
                                                    as *mut UDWORD;
                                            *ip =
                                                ((OP_EXIT as libc::c_int) <<
                                                     24 as libc::c_int) as
                                                    UDWORD;
                                            ip =
                                                ip.offset(1 as libc::c_int as
                                                              isize);
                                            if genDebugInfo != 0 {
                                                (*psCurrBlock).psDebug =
                                                    memMallocRelease((::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                          as
                                                                          libc::c_ulong).wrapping_mul((*(*yyvsp.offset(-(2
                                                                                                                             as
                                                                                                                             libc::c_int)
                                                                                                                           as
                                                                                                                           isize)).cblock).debugEntries))
                                                        as *mut SCRIPT_DEBUG;
                                                if (*psCurrBlock).psDebug.is_null()
                                                   {
                                                    scr_error(b"Out of memory\x00"
                                                                  as *const u8
                                                                  as
                                                                  *const libc::c_char
                                                                  as
                                                                  *mut libc::c_char);
                                                    current_block =
                                                        10563765182283539921;
                                                    break ;
                                                } else {
                                                    memset((*psCurrBlock).psDebug
                                                               as
                                                               *mut libc::c_void,
                                                           0 as libc::c_int,
                                                           (::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                as
                                                                libc::c_ulong).wrapping_mul((*(*yyvsp.offset(-(2
                                                                                                                   as
                                                                                                                   libc::c_int)
                                                                                                                 as
                                                                                                                 isize)).cblock).debugEntries));
                                                    (*psCurrBlock).debugEntries
                                                        =
                                                        (*(*yyvsp.offset(-(2
                                                                               as
                                                                               libc::c_int)
                                                                             as
                                                                             isize)).cblock).debugEntries
                                                            as UWORD as UDWORD
                                                }
                                            } else {
                                                (*psCurrBlock).psDebug =
                                                    0 as *mut SCRIPT_DEBUG;
                                                (*psCurrBlock).debugEntries =
                                                    0 as libc::c_int as UDWORD
                                            }
                                            if genDebugInfo != 0 {
                                                memcpy((*psCurrBlock).psDebug
                                                           as
                                                           *mut libc::c_void,
                                                       (*(*yyvsp.offset(-(2 as
                                                                              libc::c_int)
                                                                            as
                                                                            isize)).cblock).psDebug
                                                           as
                                                           *const libc::c_void,
                                                       (::std::mem::size_of::<SCRIPT_DEBUG>()
                                                            as
                                                            libc::c_ulong).wrapping_mul((*(*yyvsp.offset(-(2
                                                                                                               as
                                                                                                               libc::c_int)
                                                                                                             as
                                                                                                             isize)).cblock).debugEntries));
                                                (*psCurrBlock).debugEntries =
                                                    (*(*yyvsp.offset(-(2 as
                                                                           libc::c_int)
                                                                         as
                                                                         isize)).cblock).debugEntries
                                            }
                                            if scriptDefineEvent((*yyvsp.offset(-(8
                                                                                      as
                                                                                      libc::c_int)
                                                                                    as
                                                                                    isize)).eSymbol,
                                                                 psCurrBlock,
                                                                 -(1 as
                                                                       libc::c_int))
                                                   == 0 {
                                                current_block =
                                                    10563765182283539921;
                                                break ;
                                            }
                                            if genDebugInfo != 0 {
                                                memFreeRelease((*(*yyvsp.offset(-(2
                                                                                      as
                                                                                      libc::c_int)
                                                                                    as
                                                                                    isize)).cblock).psDebug
                                                                   as
                                                                   *mut libc::c_void);
                                                let ref mut fresh33 =
                                                    (*(*yyvsp.offset(-(2 as
                                                                           libc::c_int)
                                                                         as
                                                                         isize)).cblock).psDebug;
                                                *fresh33 =
                                                    0 as *mut SCRIPT_DEBUG
                                            }
                                            memFreeRelease((*(*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cblock).pCode
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh34 =
                                                (*(*yyvsp.offset(-(2 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).cblock).pCode;
                                            *fresh34 = 0 as *mut UDWORD;
                                            memFreeRelease((*yyvsp.offset(-(2
                                                                                as
                                                                                libc::c_int)
                                                                              as
                                                                              isize)).cblock
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh35 =
                                                (*yyvsp.offset(-(2 as
                                                                     libc::c_int)
                                                                   as
                                                                   isize)).cblock;
                                            *fresh35 = 0 as *mut CODE_BLOCK;
                                            memFreeRelease((*(*yyvsp.offset(-(1
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cblock).pCode
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh36 =
                                                (*(*yyvsp.offset(-(1 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).cblock).pCode;
                                            *fresh36 = 0 as *mut UDWORD;
                                            memFreeRelease((*yyvsp.offset(-(1
                                                                                as
                                                                                libc::c_int)
                                                                              as
                                                                              isize)).cblock
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh37 =
                                                (*yyvsp.offset(-(1 as
                                                                     libc::c_int)
                                                                   as
                                                                   isize)).cblock;
                                            *fresh37 = 0 as *mut CODE_BLOCK;
                                            psCurEvent =
                                                0 as *mut EVENT_SYMBOL
                                        }
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            69 => {
                                if psCurEvent.is_null() {
                                    scr_error(b"return statement outside of function\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else if (*psCurEvent).bFunction == 0 {
                                    scr_error(b"return statement inside of an event \'%s\'\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char,
                                              (*psCurEvent).pIdent);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else if (*psCurEvent).retType as
                                              libc::c_uint !=
                                              VAL_VOID as libc::c_int as
                                                  libc::c_uint {
                                    scr_error(b"wrong return statement syntax for a non-void function \'%s\'\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char,
                                              (*psCurEvent).pIdent);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    psCurrBlock =
                                        memMallocRelease(::std::mem::size_of::<CODE_BLOCK>()
                                                             as libc::c_ulong)
                                            as *mut CODE_BLOCK;
                                    if psCurrBlock.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrBlock).pCode =
                                            memMallocRelease(::std::mem::size_of::<OPCODE>()
                                                                 as
                                                                 libc::c_ulong)
                                                as *mut UDWORD;
                                        if (*psCurrBlock).pCode.is_null() {
                                            debug(LOG_ERROR,
                                                  b"Out of memory\x00" as
                                                      *const u8 as
                                                      *const libc::c_char);
                                            memFreeRelease(psCurrBlock as
                                                               *mut libc::c_void);
                                            psCurrBlock =
                                                0 as *mut CODE_BLOCK;
                                            current_block =
                                                10563765182283539921;
                                            break ;
                                        } else {
                                            (*psCurrBlock).size =
                                                ::std::mem::size_of::<OPCODE>()
                                                    as libc::c_ulong;
                                            ip = (*psCurrBlock).pCode;
                                            *ip =
                                                ((OP_EXIT as libc::c_int) <<
                                                     24 as libc::c_int) as
                                                    UDWORD;
                                            ip =
                                                ip.offset(1 as libc::c_int as
                                                              isize);
                                            (*psCurrBlock).type_0 = VAL_VOID;
                                            yyval.cblock = psCurrBlock
                                        }
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            70 => {
                                if psCurEvent.is_null() {
                                    debug(LOG_ERROR,
                                          b"return statement outside of function\x00"
                                              as *const u8 as
                                              *const libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else if (*psCurEvent).bFunction == 0 {
                                    debug(LOG_ERROR,
                                          b"return statement inside of an event \'%s\'\x00"
                                              as *const u8 as
                                              *const libc::c_char,
                                          (*psCurEvent).pIdent);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    if (*psCurEvent).retType as libc::c_uint
                                           !=
                                           (*(*yyvsp.offset(-(1 as
                                                                  libc::c_int)
                                                                as
                                                                isize)).cblock).type_0
                                               as libc::c_uint {
                                        if interpCheckEquiv((*psCurEvent).retType,
                                                            (*(*yyvsp.offset(-(1
                                                                                   as
                                                                                   libc::c_int)
                                                                                 as
                                                                                 isize)).cblock).type_0)
                                               == 0 {
                                            debug(LOG_ERROR,
                                                  b"return type mismatch\x00"
                                                      as *const u8 as
                                                      *const libc::c_char);
                                            debug(LOG_ERROR,
                                                  b"wrong return statement syntax for function \'%s\' (%d - %d)\x00"
                                                      as *const u8 as
                                                      *const libc::c_char,
                                                  (*psCurEvent).pIdent,
                                                  (*psCurEvent).retType as
                                                      libc::c_uint,
                                                  (*(*yyvsp.offset(-(1 as
                                                                         libc::c_int)
                                                                       as
                                                                       isize)).cblock).type_0
                                                      as libc::c_uint);
                                            current_block =
                                                10563765182283539921;
                                            break ;
                                        }
                                    }
                                    psCurrBlock =
                                        memMallocRelease(::std::mem::size_of::<CODE_BLOCK>()
                                                             as libc::c_ulong)
                                            as *mut CODE_BLOCK;
                                    if psCurrBlock.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrBlock).pCode =
                                            memMallocRelease((*(*yyvsp.offset(-(1
                                                                                    as
                                                                                    libc::c_int)
                                                                                  as
                                                                                  isize)).cblock).size.wrapping_add(::std::mem::size_of::<OPCODE>()
                                                                                                                        as
                                                                                                                        libc::c_ulong))
                                                as *mut UDWORD;
                                        if (*psCurrBlock).pCode.is_null() {
                                            debug(LOG_ERROR,
                                                  b"Out of memory\x00" as
                                                      *const u8 as
                                                      *const libc::c_char);
                                            memFreeRelease(psCurrBlock as
                                                               *mut libc::c_void);
                                            psCurrBlock =
                                                0 as *mut CODE_BLOCK;
                                            current_block =
                                                10563765182283539921;
                                            break ;
                                        } else {
                                            (*psCurrBlock).size =
                                                (*(*yyvsp.offset(-(1 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).cblock).size.wrapping_add(::std::mem::size_of::<OPCODE>()
                                                                                                           as
                                                                                                           libc::c_ulong);
                                            ip = (*psCurrBlock).pCode;
                                            memcpy(ip as *mut libc::c_void,
                                                   (*(*yyvsp.offset(-(1 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).cblock).pCode
                                                       as *const libc::c_void,
                                                   (*(*yyvsp.offset(-(1 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).cblock).size);
                                            ip =
                                                (ip as
                                                     *mut UBYTE).offset((*(*yyvsp.offset(-(1
                                                                                               as
                                                                                               libc::c_int)
                                                                                             as
                                                                                             isize)).cblock).size
                                                                            as
                                                                            isize)
                                                    as *mut UDWORD;
                                            *ip =
                                                ((OP_EXIT as libc::c_int) <<
                                                     24 as libc::c_int) as
                                                    UDWORD;
                                            ip =
                                                ip.offset(1 as libc::c_int as
                                                              isize);
                                            (*psCurrBlock).type_0 =
                                                (*(*yyvsp.offset(-(1 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).cblock).type_0;
                                            yyval.cblock = psCurrBlock
                                        }
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            71 => {
                                psCurrBlock =
                                    memMallocRelease(::std::mem::size_of::<CODE_BLOCK>()
                                                         as libc::c_ulong) as
                                        *mut CODE_BLOCK;
                                if psCurrBlock.is_null() {
                                    debug(LOG_ERROR,
                                          b"Out of memory\x00" as *const u8 as
                                              *const libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCurrBlock).pCode =
                                        memMallocRelease(1 as libc::c_int as
                                                             size_t) as
                                            *mut UDWORD;
                                    if (*psCurrBlock).pCode.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        memFreeRelease(psCurrBlock as
                                                           *mut libc::c_void);
                                        psCurrBlock = 0 as *mut CODE_BLOCK;
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrBlock).size =
                                            1 as libc::c_int as UDWORD;
                                        (*psCurrBlock).size =
                                            0 as libc::c_int as UDWORD;
                                        yyval.cblock = psCurrBlock
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            72 => {
                                /* Reset the temp local variable symbol table */
                                yyval.cblock =
                                    (*yyvsp.offset(0 as libc::c_int as
                                                       isize)).cblock;
                                current_block = 9320480655893135347;
                            }
                            73 => {
                                psCurrBlock =
                                    memMallocRelease(::std::mem::size_of::<CODE_BLOCK>()
                                                         as libc::c_ulong) as
                                        *mut CODE_BLOCK;
                                if psCurrBlock.is_null() {
                                    debug(LOG_ERROR,
                                          b"Out of memory\x00" as *const u8 as
                                              *const libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCurrBlock).pCode =
                                        memMallocRelease((*(*yyvsp.offset(-(1
                                                                                as
                                                                                libc::c_int)
                                                                              as
                                                                              isize)).cblock).size.wrapping_add((*(*yyvsp.offset(0
                                                                                                                                     as
                                                                                                                                     libc::c_int
                                                                                                                                     as
                                                                                                                                     isize)).cblock).size))
                                            as *mut UDWORD;
                                    if (*psCurrBlock).pCode.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        memFreeRelease(psCurrBlock as
                                                           *mut libc::c_void);
                                        psCurrBlock = 0 as *mut CODE_BLOCK;
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrBlock).size =
                                            (*(*yyvsp.offset(-(1 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).cblock).size.wrapping_add((*(*yyvsp.offset(0
                                                                                                                        as
                                                                                                                        libc::c_int
                                                                                                                        as
                                                                                                                        isize)).cblock).size);
                                        if genDebugInfo != 0 {
                                            (*psCurrBlock).psDebug =
                                                memMallocRelease((::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                      as
                                                                      libc::c_ulong).wrapping_mul((*(*yyvsp.offset(-(1
                                                                                                                         as
                                                                                                                         libc::c_int)
                                                                                                                       as
                                                                                                                       isize)).cblock).debugEntries.wrapping_add((*(*yyvsp.offset(0
                                                                                                                                                                                      as
                                                                                                                                                                                      libc::c_int
                                                                                                                                                                                      as
                                                                                                                                                                                      isize)).cblock).debugEntries)))
                                                    as *mut SCRIPT_DEBUG;
                                            if (*psCurrBlock).psDebug.is_null()
                                               {
                                                scr_error(b"Out of memory\x00"
                                                              as *const u8 as
                                                              *const libc::c_char
                                                              as
                                                              *mut libc::c_char);
                                                current_block =
                                                    10563765182283539921;
                                                break ;
                                            } else {
                                                memset((*psCurrBlock).psDebug
                                                           as
                                                           *mut libc::c_void,
                                                       0 as libc::c_int,
                                                       (::std::mem::size_of::<SCRIPT_DEBUG>()
                                                            as
                                                            libc::c_ulong).wrapping_mul((*(*yyvsp.offset(-(1
                                                                                                               as
                                                                                                               libc::c_int)
                                                                                                             as
                                                                                                             isize)).cblock).debugEntries.wrapping_add((*(*yyvsp.offset(0
                                                                                                                                                                            as
                                                                                                                                                                            libc::c_int
                                                                                                                                                                            as
                                                                                                                                                                            isize)).cblock).debugEntries)));
                                                (*psCurrBlock).debugEntries =
                                                    (*(*yyvsp.offset(-(1 as
                                                                           libc::c_int)
                                                                         as
                                                                         isize)).cblock).debugEntries.wrapping_add((*(*yyvsp.offset(0
                                                                                                                                        as
                                                                                                                                        libc::c_int
                                                                                                                                        as
                                                                                                                                        isize)).cblock).debugEntries)
                                                        as UWORD as UDWORD
                                            }
                                        } else {
                                            (*psCurrBlock).psDebug =
                                                0 as *mut SCRIPT_DEBUG;
                                            (*psCurrBlock).debugEntries =
                                                0 as libc::c_int as UDWORD
                                        }
                                        ip = (*psCurrBlock).pCode;
                                        memcpy(ip as *mut libc::c_void,
                                               (*(*yyvsp.offset(-(1 as
                                                                      libc::c_int)
                                                                    as
                                                                    isize)).cblock).pCode
                                                   as *const libc::c_void,
                                               (*(*yyvsp.offset(-(1 as
                                                                      libc::c_int)
                                                                    as
                                                                    isize)).cblock).size);
                                        ip =
                                            (ip as
                                                 *mut UBYTE).offset((*(*yyvsp.offset(-(1
                                                                                           as
                                                                                           libc::c_int)
                                                                                         as
                                                                                         isize)).cblock).size
                                                                        as
                                                                        isize)
                                                as *mut UDWORD;
                                        memcpy(ip as *mut libc::c_void,
                                               (*(*yyvsp.offset(0 as
                                                                    libc::c_int
                                                                    as
                                                                    isize)).cblock).pCode
                                                   as *const libc::c_void,
                                               (*(*yyvsp.offset(0 as
                                                                    libc::c_int
                                                                    as
                                                                    isize)).cblock).size);
                                        ip =
                                            (ip as
                                                 *mut UBYTE).offset((*(*yyvsp.offset(0
                                                                                         as
                                                                                         libc::c_int
                                                                                         as
                                                                                         isize)).cblock).size
                                                                        as
                                                                        isize)
                                                as *mut UDWORD;
                                        if genDebugInfo != 0 {
                                            memcpy((*psCurrBlock).psDebug as
                                                       *mut libc::c_void,
                                                   (*(*yyvsp.offset(-(1 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).cblock).psDebug
                                                       as *const libc::c_void,
                                                   (::std::mem::size_of::<SCRIPT_DEBUG>()
                                                        as
                                                        libc::c_ulong).wrapping_mul((*(*yyvsp.offset(-(1
                                                                                                           as
                                                                                                           libc::c_int)
                                                                                                         as
                                                                                                         isize)).cblock).debugEntries));
                                            (*psCurrBlock).debugEntries =
                                                (*(*yyvsp.offset(-(1 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).cblock).debugEntries
                                        }
                                        if genDebugInfo != 0 {
                                            _dbEntry =
                                                0 as libc::c_int as UDWORD;
                                            while _dbEntry <
                                                      (*(*yyvsp.offset(0 as
                                                                           libc::c_int
                                                                           as
                                                                           isize)).cblock).debugEntries
                                                  {
                                                _psCurr =
                                                    (*psCurrBlock).psDebug.offset((*psCurrBlock).debugEntries
                                                                                      as
                                                                                      isize).offset(_dbEntry
                                                                                                        as
                                                                                                        isize);
                                                (*_psCurr).line =
                                                    (*(*(*yyvsp.offset(0 as
                                                                           libc::c_int
                                                                           as
                                                                           isize)).cblock).psDebug.offset(_dbEntry
                                                                                                              as
                                                                                                              isize)).line;
                                                (*_psCurr).offset =
                                                    (*(*(*yyvsp.offset(0 as
                                                                           libc::c_int
                                                                           as
                                                                           isize)).cblock).psDebug.offset(_dbEntry
                                                                                                              as
                                                                                                              isize)).offset.wrapping_add((*(*yyvsp.offset(-(1
                                                                                                                                                                 as
                                                                                                                                                                 libc::c_int)
                                                                                                                                                               as
                                                                                                                                                               isize)).cblock).size.wrapping_div(::std::mem::size_of::<UDWORD>()
                                                                                                                                                                                                     as
                                                                                                                                                                                                     libc::c_ulong));
                                                _dbEntry =
                                                    _dbEntry.wrapping_add(1)
                                            }
                                            (*psCurrBlock).debugEntries =
                                                (*psCurrBlock).debugEntries.wrapping_add((*(*yyvsp.offset(0
                                                                                                              as
                                                                                                              libc::c_int
                                                                                                              as
                                                                                                              isize)).cblock).debugEntries)
                                                    as UWORD as UDWORD
                                        }
                                        if genDebugInfo != 0 {
                                            memFreeRelease((*(*yyvsp.offset(-(1
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cblock).psDebug
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh38 =
                                                (*(*yyvsp.offset(-(1 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).cblock).psDebug;
                                            *fresh38 = 0 as *mut SCRIPT_DEBUG
                                        }
                                        if genDebugInfo != 0 {
                                            memFreeRelease((*(*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).cblock).psDebug
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh39 =
                                                (*(*yyvsp.offset(0 as
                                                                     libc::c_int
                                                                     as
                                                                     isize)).cblock).psDebug;
                                            *fresh39 = 0 as *mut SCRIPT_DEBUG
                                        }
                                        memFreeRelease((*(*yyvsp.offset(-(1 as
                                                                              libc::c_int)
                                                                            as
                                                                            isize)).cblock).pCode
                                                           as
                                                           *mut libc::c_void);
                                        let ref mut fresh40 =
                                            (*(*yyvsp.offset(-(1 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).cblock).pCode;
                                        *fresh40 = 0 as *mut UDWORD;
                                        memFreeRelease((*yyvsp.offset(-(1 as
                                                                            libc::c_int)
                                                                          as
                                                                          isize)).cblock
                                                           as
                                                           *mut libc::c_void);
                                        let ref mut fresh41 =
                                            (*yyvsp.offset(-(1 as libc::c_int)
                                                               as
                                                               isize)).cblock;
                                        *fresh41 = 0 as *mut CODE_BLOCK;
                                        memFreeRelease((*(*yyvsp.offset(0 as
                                                                            libc::c_int
                                                                            as
                                                                            isize)).cblock).pCode
                                                           as
                                                           *mut libc::c_void);
                                        let ref mut fresh42 =
                                            (*(*yyvsp.offset(0 as libc::c_int
                                                                 as
                                                                 isize)).cblock).pCode;
                                        *fresh42 = 0 as *mut UDWORD;
                                        memFreeRelease((*yyvsp.offset(0 as
                                                                          libc::c_int
                                                                          as
                                                                          isize)).cblock
                                                           as
                                                           *mut libc::c_void);
                                        let ref mut fresh43 =
                                            (*yyvsp.offset(0 as libc::c_int as
                                                               isize)).cblock;
                                        *fresh43 = 0 as *mut CODE_BLOCK;
                                        yyval.cblock = psCurrBlock
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            74 => {
                                let mut line_1: UDWORD = 0;
                                let mut pDummy_2: *mut STRING =
                                    0 as *mut STRING;
                                if genDebugInfo != 0 {
                                    if genDebugInfo != 0 {
                                        let ref mut fresh44 =
                                            (*(*yyvsp.offset(-(1 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).cblock).psDebug;
                                        *fresh44 =
                                            memMallocRelease((::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                  as
                                                                  libc::c_ulong).wrapping_mul(1
                                                                                                  as
                                                                                                  libc::c_int
                                                                                                  as
                                                                                                  libc::c_uint))
                                                as *mut SCRIPT_DEBUG;
                                        if (*(*yyvsp.offset(-(1 as
                                                                  libc::c_int)
                                                                as
                                                                isize)).cblock).psDebug.is_null()
                                           {
                                            scr_error(b"Out of memory\x00" as
                                                          *const u8 as
                                                          *const libc::c_char
                                                          as
                                                          *mut libc::c_char);
                                            current_block =
                                                10563765182283539921;
                                            break ;
                                        } else {
                                            memset((*(*yyvsp.offset(-(1 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).cblock).psDebug
                                                       as *mut libc::c_void,
                                                   0 as libc::c_int,
                                                   (::std::mem::size_of::<SCRIPT_DEBUG>()
                                                        as
                                                        libc::c_ulong).wrapping_mul(1
                                                                                        as
                                                                                        libc::c_int
                                                                                        as
                                                                                        libc::c_uint));
                                            (*(*yyvsp.offset(-(1 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).cblock).debugEntries
                                                =
                                                1 as libc::c_int as UWORD as
                                                    UDWORD
                                        }
                                    } else {
                                        let ref mut fresh45 =
                                            (*(*yyvsp.offset(-(1 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).cblock).psDebug;
                                        *fresh45 = 0 as *mut SCRIPT_DEBUG;
                                        (*(*yyvsp.offset(-(1 as libc::c_int)
                                                             as
                                                             isize)).cblock).debugEntries
                                            = 0 as libc::c_int as UDWORD
                                    }
                                    (*(*(*yyvsp.offset(-(1 as libc::c_int) as
                                                           isize)).cblock).psDebug.offset(0
                                                                                              as
                                                                                              libc::c_int
                                                                                              as
                                                                                              isize)).offset
                                        = 0 as libc::c_int as UDWORD;
                                    scriptGetErrorData(&mut line_1 as
                                                           *mut UDWORD as
                                                           *mut SDWORD,
                                                       &mut pDummy_2);
                                    (*(*(*yyvsp.offset(-(1 as libc::c_int) as
                                                           isize)).cblock).psDebug.offset(0
                                                                                              as
                                                                                              libc::c_int
                                                                                              as
                                                                                              isize)).line
                                        = line_1
                                }
                                yyval.cblock =
                                    (*yyvsp.offset(-(1 as libc::c_int) as
                                                       isize)).cblock;
                                // Reset the event table
                                current_block = 9320480655893135347;
                            }
                            75 => {
                                /* Reset the function symbol table */
                                let mut line_2: UDWORD = 0;
                                let mut pDummy_3: *mut STRING =
                                    0 as *mut STRING;
                                if genDebugInfo != 0 {
                                    if genDebugInfo != 0 {
                                        let ref mut fresh46 =
                                            (*(*yyvsp.offset(-(1 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).cblock).psDebug;
                                        *fresh46 =
                                            memMallocRelease((::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                  as
                                                                  libc::c_ulong).wrapping_mul(1
                                                                                                  as
                                                                                                  libc::c_int
                                                                                                  as
                                                                                                  libc::c_uint))
                                                as *mut SCRIPT_DEBUG;
                                        if (*(*yyvsp.offset(-(1 as
                                                                  libc::c_int)
                                                                as
                                                                isize)).cblock).psDebug.is_null()
                                           {
                                            scr_error(b"Out of memory\x00" as
                                                          *const u8 as
                                                          *const libc::c_char
                                                          as
                                                          *mut libc::c_char);
                                            current_block =
                                                10563765182283539921;
                                            break ;
                                        } else {
                                            memset((*(*yyvsp.offset(-(1 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).cblock).psDebug
                                                       as *mut libc::c_void,
                                                   0 as libc::c_int,
                                                   (::std::mem::size_of::<SCRIPT_DEBUG>()
                                                        as
                                                        libc::c_ulong).wrapping_mul(1
                                                                                        as
                                                                                        libc::c_int
                                                                                        as
                                                                                        libc::c_uint));
                                            (*(*yyvsp.offset(-(1 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).cblock).debugEntries
                                                =
                                                1 as libc::c_int as UWORD as
                                                    UDWORD
                                        }
                                    } else {
                                        let ref mut fresh47 =
                                            (*(*yyvsp.offset(-(1 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).cblock).psDebug;
                                        *fresh47 = 0 as *mut SCRIPT_DEBUG;
                                        (*(*yyvsp.offset(-(1 as libc::c_int)
                                                             as
                                                             isize)).cblock).debugEntries
                                            = 0 as libc::c_int as UDWORD
                                    }
                                    (*(*(*yyvsp.offset(-(1 as libc::c_int) as
                                                           isize)).cblock).psDebug.offset(0
                                                                                              as
                                                                                              libc::c_int
                                                                                              as
                                                                                              isize)).offset
                                        = 0 as libc::c_int as UDWORD;
                                    scriptGetErrorData(&mut line_2 as
                                                           *mut UDWORD as
                                                           *mut SDWORD,
                                                       &mut pDummy_3);
                                    (*(*(*yyvsp.offset(-(1 as libc::c_int) as
                                                           isize)).cblock).psDebug.offset(0
                                                                                              as
                                                                                              libc::c_int
                                                                                              as
                                                                                              isize)).line
                                        = line_2
                                }
                                yyval.cblock =
                                    (*yyvsp.offset(-(1 as libc::c_int) as
                                                       isize)).cblock;
                                /* Compile a script program */
                                // Tell lex about the input buffer
                                current_block = 9320480655893135347;
                            }
                            76 => {
                                let mut line_3: UDWORD = 0;
                                let mut paramNumber: UDWORD = 0;
                                let mut pDummy_4: *mut STRING =
                                    0 as *mut STRING;
                                if (*(*yyvsp.offset(-(4 as libc::c_int) as
                                                        isize)).eSymbol).bFunction
                                       == 0 &&
                                       (*(*yyvsp.offset(-(2 as libc::c_int) as
                                                            isize)).pblock).numParams
                                           > 0 as libc::c_int as libc::c_uint
                                   {
                                    scr_error(b"Can\'t pass any parameters in an event call:\nEvent: \'%s\'\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char,
                                              (*(*yyvsp.offset(-(4 as
                                                                     libc::c_int)
                                                                   as
                                                                   isize)).eSymbol).pIdent);
                                    return CE_PARSE as libc::c_int
                                }
                                if (*(*yyvsp.offset(-(2 as libc::c_int) as
                                                        isize)).pblock).numParams
                                       !=
                                       (*(*yyvsp.offset(-(4 as libc::c_int) as
                                                            isize)).eSymbol).numParams
                                   {
                                    scr_error(b"Wrong number of arguments for function call: \'%s\'. Expected %d parameters instead of  %d.\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char,
                                              (*(*yyvsp.offset(-(4 as
                                                                     libc::c_int)
                                                                   as
                                                                   isize)).eSymbol).pIdent,
                                              (*(*yyvsp.offset(-(4 as
                                                                     libc::c_int)
                                                                   as
                                                                   isize)).eSymbol).numParams,
                                              (*(*yyvsp.offset(-(2 as
                                                                     libc::c_int)
                                                                   as
                                                                   isize)).pblock).numParams);
                                    return CE_PARSE as libc::c_int
                                }
                                paramNumber =
                                    checkFuncParamTypes((*yyvsp.offset(-(4 as
                                                                             libc::c_int)
                                                                           as
                                                                           isize)).eSymbol,
                                                        (*yyvsp.offset(-(2 as
                                                                             libc::c_int)
                                                                           as
                                                                           isize)).pblock);
                                if paramNumber >
                                       0 as libc::c_int as libc::c_uint {
                                    debug(LOG_ERROR,
                                          b"Parameter mismatch in function call: \'%s\'. Mismatch in parameter  %d.\x00"
                                              as *const u8 as
                                              *const libc::c_char,
                                          (*(*yyvsp.offset(-(4 as libc::c_int)
                                                               as
                                                               isize)).eSymbol).pIdent,
                                          paramNumber);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    psCurrBlock =
                                        memMallocRelease(::std::mem::size_of::<CODE_BLOCK>()
                                                             as libc::c_ulong)
                                            as *mut CODE_BLOCK;
                                    if psCurrBlock.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrBlock).pCode =
                                            memMallocRelease((*(*yyvsp.offset(-(2
                                                                                    as
                                                                                    libc::c_int)
                                                                                  as
                                                                                  isize)).pblock).size.wrapping_add(::std::mem::size_of::<OPCODE>()
                                                                                                                        as
                                                                                                                        libc::c_ulong).wrapping_add(::std::mem::size_of::<UDWORD>()
                                                                                                                                                        as
                                                                                                                                                        libc::c_ulong))
                                                as *mut UDWORD;
                                        if (*psCurrBlock).pCode.is_null() {
                                            debug(LOG_ERROR,
                                                  b"Out of memory\x00" as
                                                      *const u8 as
                                                      *const libc::c_char);
                                            memFreeRelease(psCurrBlock as
                                                               *mut libc::c_void);
                                            psCurrBlock =
                                                0 as *mut CODE_BLOCK;
                                            current_block =
                                                10563765182283539921;
                                            break ;
                                        } else {
                                            (*psCurrBlock).size =
                                                (*(*yyvsp.offset(-(2 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).pblock).size.wrapping_add(::std::mem::size_of::<OPCODE>()
                                                                                                           as
                                                                                                           libc::c_ulong).wrapping_add(::std::mem::size_of::<UDWORD>()
                                                                                                                                           as
                                                                                                                                           libc::c_ulong);
                                            if genDebugInfo != 0 {
                                                (*psCurrBlock).psDebug =
                                                    memMallocRelease((::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                          as
                                                                          libc::c_ulong).wrapping_mul(1
                                                                                                          as
                                                                                                          libc::c_int
                                                                                                          as
                                                                                                          libc::c_uint))
                                                        as *mut SCRIPT_DEBUG;
                                                if (*psCurrBlock).psDebug.is_null()
                                                   {
                                                    scr_error(b"Out of memory\x00"
                                                                  as *const u8
                                                                  as
                                                                  *const libc::c_char
                                                                  as
                                                                  *mut libc::c_char);
                                                    current_block =
                                                        10563765182283539921;
                                                    break ;
                                                } else {
                                                    memset((*psCurrBlock).psDebug
                                                               as
                                                               *mut libc::c_void,
                                                           0 as libc::c_int,
                                                           (::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                as
                                                                libc::c_ulong).wrapping_mul(1
                                                                                                as
                                                                                                libc::c_int
                                                                                                as
                                                                                                libc::c_uint));
                                                    (*psCurrBlock).debugEntries
                                                        =
                                                        1 as libc::c_int as
                                                            UWORD as UDWORD
                                                }
                                            } else {
                                                (*psCurrBlock).psDebug =
                                                    0 as *mut SCRIPT_DEBUG;
                                                (*psCurrBlock).debugEntries =
                                                    0 as libc::c_int as UDWORD
                                            }
                                            ip = (*psCurrBlock).pCode;
                                            if (*(*yyvsp.offset(-(2 as
                                                                      libc::c_int)
                                                                    as
                                                                    isize)).pblock).numParams
                                                   >
                                                   0 as libc::c_int as
                                                       libc::c_uint {
                                                memcpy(ip as
                                                           *mut libc::c_void,
                                                       (*(*yyvsp.offset(-(2 as
                                                                              libc::c_int)
                                                                            as
                                                                            isize)).pblock).pCode
                                                           as
                                                           *const libc::c_void,
                                                       (*(*yyvsp.offset(-(2 as
                                                                              libc::c_int)
                                                                            as
                                                                            isize)).pblock).size);
                                                ip =
                                                    (ip as
                                                         *mut UBYTE).offset((*(*yyvsp.offset(-(2
                                                                                                   as
                                                                                                   libc::c_int)
                                                                                                 as
                                                                                                 isize)).pblock).size
                                                                                as
                                                                                isize)
                                                        as *mut UDWORD;
                                                memFreeRelease((*(*yyvsp.offset(-(2
                                                                                      as
                                                                                      libc::c_int)
                                                                                    as
                                                                                    isize)).pblock).pCode
                                                                   as
                                                                   *mut libc::c_void);
                                                let ref mut fresh48 =
                                                    (*(*yyvsp.offset(-(2 as
                                                                           libc::c_int)
                                                                         as
                                                                         isize)).pblock).pCode;
                                                *fresh48 = 0 as *mut UDWORD;
                                                memFreeRelease((*(*yyvsp.offset(-(2
                                                                                      as
                                                                                      libc::c_int)
                                                                                    as
                                                                                    isize)).pblock).aParams
                                                                   as
                                                                   *mut libc::c_void);
                                                let ref mut fresh49 =
                                                    (*(*yyvsp.offset(-(2 as
                                                                           libc::c_int)
                                                                         as
                                                                         isize)).pblock).aParams;
                                                *fresh49 =
                                                    0 as *mut INTERP_TYPE;
                                                memFreeRelease((*yyvsp.offset(-(2
                                                                                    as
                                                                                    libc::c_int)
                                                                                  as
                                                                                  isize)).pblock
                                                                   as
                                                                   *mut libc::c_void);
                                                let ref mut fresh50 =
                                                    (*yyvsp.offset(-(2 as
                                                                         libc::c_int)
                                                                       as
                                                                       isize)).pblock;
                                                *fresh50 =
                                                    0 as *mut PARAM_BLOCK
                                            }
                                            *ip =
                                                ((OP_FUNC as libc::c_int) <<
                                                     24 as libc::c_int) as
                                                    UDWORD;
                                            ip =
                                                ip.offset(1 as libc::c_int as
                                                              isize);
                                            *ip =
                                                (*(*yyvsp.offset(-(4 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).eSymbol).index;
                                            ip =
                                                ip.offset(1 as libc::c_int as
                                                              isize);
                                            if genDebugInfo != 0 {
                                                (*(*psCurrBlock).psDebug.offset(0
                                                                                    as
                                                                                    libc::c_int
                                                                                    as
                                                                                    isize)).offset
                                                    =
                                                    0 as libc::c_int as
                                                        UDWORD;
                                                scriptGetErrorData(&mut line_3
                                                                       as
                                                                       *mut UDWORD
                                                                       as
                                                                       *mut SDWORD,
                                                                   &mut pDummy_4);
                                                (*(*psCurrBlock).psDebug.offset(0
                                                                                    as
                                                                                    libc::c_int
                                                                                    as
                                                                                    isize)).line
                                                    = line_3
                                            }
                                            yyval.cblock = psCurrBlock
                                        }
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            77 => {
                                let mut line_4: UDWORD = 0;
                                let mut pDummy_5: *mut STRING =
                                    0 as *mut STRING;
                                if (*(*yyvsp.offset(-(4 as libc::c_int) as
                                                        isize)).eSymbol).bFunction
                                       == 0 &&
                                       (*(*yyvsp.offset(-(2 as libc::c_int) as
                                                            isize)).pblock).numParams
                                           > 0 as libc::c_int as libc::c_uint
                                   {
                                    scr_error(b"Can\'t pass any parameters in an event call:\nEvent: \'%s\'\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char,
                                              (*(*yyvsp.offset(-(4 as
                                                                     libc::c_int)
                                                                   as
                                                                   isize)).eSymbol).pIdent);
                                    return CE_PARSE as libc::c_int
                                }
                                if (*(*yyvsp.offset(-(2 as libc::c_int) as
                                                        isize)).pblock).numParams
                                       !=
                                       (*(*yyvsp.offset(-(4 as libc::c_int) as
                                                            isize)).eSymbol).numParams
                                   {
                                    scr_error(b"Wrong number of arguments for function call: \'%s\'. Expected %d parameters instead of  %d.\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char,
                                              (*(*yyvsp.offset(-(4 as
                                                                     libc::c_int)
                                                                   as
                                                                   isize)).eSymbol).pIdent,
                                              (*(*yyvsp.offset(-(4 as
                                                                     libc::c_int)
                                                                   as
                                                                   isize)).eSymbol).numParams,
                                              (*(*yyvsp.offset(-(2 as
                                                                     libc::c_int)
                                                                   as
                                                                   isize)).pblock).numParams);
                                    return CE_PARSE as libc::c_int
                                }
                                psCurrBlock =
                                    memMallocRelease(::std::mem::size_of::<CODE_BLOCK>()
                                                         as libc::c_ulong) as
                                        *mut CODE_BLOCK;
                                if psCurrBlock.is_null() {
                                    debug(LOG_ERROR,
                                          b"Out of memory\x00" as *const u8 as
                                              *const libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCurrBlock).pCode =
                                        memMallocRelease((*(*yyvsp.offset(-(2
                                                                                as
                                                                                libc::c_int)
                                                                              as
                                                                              isize)).pblock).size.wrapping_add(::std::mem::size_of::<OPCODE>()
                                                                                                                    as
                                                                                                                    libc::c_ulong).wrapping_add(::std::mem::size_of::<UDWORD>()
                                                                                                                                                    as
                                                                                                                                                    libc::c_ulong))
                                            as *mut UDWORD;
                                    if (*psCurrBlock).pCode.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        memFreeRelease(psCurrBlock as
                                                           *mut libc::c_void);
                                        psCurrBlock = 0 as *mut CODE_BLOCK;
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrBlock).size =
                                            (*(*yyvsp.offset(-(2 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).pblock).size.wrapping_add(::std::mem::size_of::<OPCODE>()
                                                                                                       as
                                                                                                       libc::c_ulong).wrapping_add(::std::mem::size_of::<UDWORD>()
                                                                                                                                       as
                                                                                                                                       libc::c_ulong);
                                        if genDebugInfo != 0 {
                                            (*psCurrBlock).psDebug =
                                                memMallocRelease((::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                      as
                                                                      libc::c_ulong).wrapping_mul(1
                                                                                                      as
                                                                                                      libc::c_int
                                                                                                      as
                                                                                                      libc::c_uint))
                                                    as *mut SCRIPT_DEBUG;
                                            if (*psCurrBlock).psDebug.is_null()
                                               {
                                                scr_error(b"Out of memory\x00"
                                                              as *const u8 as
                                                              *const libc::c_char
                                                              as
                                                              *mut libc::c_char);
                                                current_block =
                                                    10563765182283539921;
                                                break ;
                                            } else {
                                                memset((*psCurrBlock).psDebug
                                                           as
                                                           *mut libc::c_void,
                                                       0 as libc::c_int,
                                                       (::std::mem::size_of::<SCRIPT_DEBUG>()
                                                            as
                                                            libc::c_ulong).wrapping_mul(1
                                                                                            as
                                                                                            libc::c_int
                                                                                            as
                                                                                            libc::c_uint));
                                                (*psCurrBlock).debugEntries =
                                                    1 as libc::c_int as UWORD
                                                        as UDWORD
                                            }
                                        } else {
                                            (*psCurrBlock).psDebug =
                                                0 as *mut SCRIPT_DEBUG;
                                            (*psCurrBlock).debugEntries =
                                                0 as libc::c_int as UDWORD
                                        }
                                        ip = (*psCurrBlock).pCode;
                                        if (*(*yyvsp.offset(-(2 as
                                                                  libc::c_int)
                                                                as
                                                                isize)).pblock).numParams
                                               >
                                               0 as libc::c_int as
                                                   libc::c_uint {
                                            memcpy(ip as *mut libc::c_void,
                                                   (*(*yyvsp.offset(-(2 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).pblock).pCode
                                                       as *const libc::c_void,
                                                   (*(*yyvsp.offset(-(2 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).pblock).size);
                                            ip =
                                                (ip as
                                                     *mut UBYTE).offset((*(*yyvsp.offset(-(2
                                                                                               as
                                                                                               libc::c_int)
                                                                                             as
                                                                                             isize)).pblock).size
                                                                            as
                                                                            isize)
                                                    as *mut UDWORD;
                                            memFreeRelease((*(*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).pblock).pCode
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh51 =
                                                (*(*yyvsp.offset(-(2 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).pblock).pCode;
                                            *fresh51 = 0 as *mut UDWORD;
                                            memFreeRelease((*(*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).pblock).aParams
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh52 =
                                                (*(*yyvsp.offset(-(2 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).pblock).aParams;
                                            *fresh52 = 0 as *mut INTERP_TYPE;
                                            memFreeRelease((*yyvsp.offset(-(2
                                                                                as
                                                                                libc::c_int)
                                                                              as
                                                                              isize)).pblock
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh53 =
                                                (*yyvsp.offset(-(2 as
                                                                     libc::c_int)
                                                                   as
                                                                   isize)).pblock;
                                            *fresh53 = 0 as *mut PARAM_BLOCK
                                        }
                                        *ip =
                                            ((OP_FUNC as libc::c_int) <<
                                                 24 as libc::c_int) as UDWORD;
                                        ip =
                                            ip.offset(1 as libc::c_int as
                                                          isize);
                                        *ip =
                                            (*(*yyvsp.offset(-(4 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).eSymbol).index;
                                        ip =
                                            ip.offset(1 as libc::c_int as
                                                          isize);
                                        if genDebugInfo != 0 {
                                            (*(*psCurrBlock).psDebug.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).offset
                                                = 0 as libc::c_int as UDWORD;
                                            scriptGetErrorData(&mut line_4 as
                                                                   *mut UDWORD
                                                                   as
                                                                   *mut SDWORD,
                                                               &mut pDummy_5);
                                            (*(*psCurrBlock).psDebug.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).line
                                                = line_4
                                        }
                                        yyval.cblock = psCurrBlock
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            78 => {
                                yyval.cblock =
                                    (*yyvsp.offset(0 as libc::c_int as
                                                       isize)).cblock;
                                /* Allocate the memory for the symbol structure */
                                current_block = 9320480655893135347;
                            }
                            79 => {
                                yyval.cblock =
                                    (*yyvsp.offset(0 as libc::c_int as
                                                       isize)).cblock;
                                //(STRING *)MALLOC(strlen(pIdent) + 1);
                                /*	if (psNew->pIdent == NULL)
	{
		scr_error("Out of memory");
		return FALSE;
	}*/
                                current_block = 9320480655893135347;
                            }
                            80 => {
                                let mut line_5: UDWORD = 0;
                                let mut pDummy_6: *mut STRING =
                                    0 as *mut STRING;
                                psCurrBlock =
                                    memMallocRelease(::std::mem::size_of::<CODE_BLOCK>()
                                                         as libc::c_ulong) as
                                        *mut CODE_BLOCK;
                                if psCurrBlock.is_null() {
                                    debug(LOG_ERROR,
                                          b"Out of memory\x00" as *const u8 as
                                              *const libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCurrBlock).pCode =
                                        memMallocRelease(::std::mem::size_of::<OPCODE>()
                                                             as libc::c_ulong)
                                            as *mut UDWORD;
                                    if (*psCurrBlock).pCode.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        memFreeRelease(psCurrBlock as
                                                           *mut libc::c_void);
                                        psCurrBlock = 0 as *mut CODE_BLOCK;
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrBlock).size =
                                            ::std::mem::size_of::<OPCODE>() as
                                                libc::c_ulong;
                                        if genDebugInfo != 0 {
                                            (*psCurrBlock).psDebug =
                                                memMallocRelease((::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                      as
                                                                      libc::c_ulong).wrapping_mul(1
                                                                                                      as
                                                                                                      libc::c_int
                                                                                                      as
                                                                                                      libc::c_uint))
                                                    as *mut SCRIPT_DEBUG;
                                            if (*psCurrBlock).psDebug.is_null()
                                               {
                                                scr_error(b"Out of memory\x00"
                                                              as *const u8 as
                                                              *const libc::c_char
                                                              as
                                                              *mut libc::c_char);
                                                current_block =
                                                    10563765182283539921;
                                                break ;
                                            } else {
                                                memset((*psCurrBlock).psDebug
                                                           as
                                                           *mut libc::c_void,
                                                       0 as libc::c_int,
                                                       (::std::mem::size_of::<SCRIPT_DEBUG>()
                                                            as
                                                            libc::c_ulong).wrapping_mul(1
                                                                                            as
                                                                                            libc::c_int
                                                                                            as
                                                                                            libc::c_uint));
                                                (*psCurrBlock).debugEntries =
                                                    1 as libc::c_int as UWORD
                                                        as UDWORD
                                            }
                                        } else {
                                            (*psCurrBlock).psDebug =
                                                0 as *mut SCRIPT_DEBUG;
                                            (*psCurrBlock).debugEntries =
                                                0 as libc::c_int as UDWORD
                                        }
                                        ip = (*psCurrBlock).pCode;
                                        *ip =
                                            ((OP_EXIT as libc::c_int) <<
                                                 24 as libc::c_int) as UDWORD;
                                        ip =
                                            ip.offset(1 as libc::c_int as
                                                          isize);
                                        if genDebugInfo != 0 {
                                            (*(*psCurrBlock).psDebug.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).offset
                                                = 0 as libc::c_int as UDWORD;
                                            scriptGetErrorData(&mut line_5 as
                                                                   *mut UDWORD
                                                                   as
                                                                   *mut SDWORD,
                                                               &mut pDummy_6);
                                            (*(*psCurrBlock).psDebug.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).line
                                                = line_5
                                        }
                                        yyval.cblock = psCurrBlock
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            81 => {
                                let mut line_6: UDWORD = 0;
                                let mut pDummy_7: *mut STRING =
                                    0 as *mut STRING;
                                if psCurEvent.is_null() {
                                    scr_error(b"\'return\' outside of function body\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else if (*psCurEvent).bFunction == 0 {
                                    debug(LOG_ERROR,
                                          b"\'return\' can only be used in functions, not in events, event: \'%s\'\x00"
                                              as *const u8 as
                                              *const libc::c_char,
                                          (*psCurEvent).pIdent);
                                    scr_error(b"\'return\' in event\x00" as
                                                  *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else if (*(*yyvsp.offset(0 as libc::c_int as
                                                               isize)).cblock).type_0
                                              as libc::c_uint !=
                                              (*psCurEvent).retType as
                                                  libc::c_uint {
                                    debug(LOG_ERROR,
                                          b"\'return\' type doesn\'t match with function return type, function: \'%s\' (%d / %d)\x00"
                                              as *const u8 as
                                              *const libc::c_char,
                                          (*psCurEvent).pIdent,
                                          (*(*yyvsp.offset(0 as libc::c_int as
                                                               isize)).cblock).type_0
                                              as libc::c_uint,
                                          (*psCurEvent).retType as
                                              libc::c_uint);
                                    scr_error(b"\'return\' type mismatch 0\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    psCurrBlock =
                                        memMallocRelease(::std::mem::size_of::<CODE_BLOCK>()
                                                             as libc::c_ulong)
                                            as *mut CODE_BLOCK;
                                    if psCurrBlock.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrBlock).pCode =
                                            memMallocRelease((*(*yyvsp.offset(0
                                                                                  as
                                                                                  libc::c_int
                                                                                  as
                                                                                  isize)).cblock).size.wrapping_add(::std::mem::size_of::<OPCODE>()
                                                                                                                        as
                                                                                                                        libc::c_ulong))
                                                as *mut UDWORD;
                                        if (*psCurrBlock).pCode.is_null() {
                                            debug(LOG_ERROR,
                                                  b"Out of memory\x00" as
                                                      *const u8 as
                                                      *const libc::c_char);
                                            memFreeRelease(psCurrBlock as
                                                               *mut libc::c_void);
                                            psCurrBlock =
                                                0 as *mut CODE_BLOCK;
                                            current_block =
                                                10563765182283539921;
                                            break ;
                                        } else {
                                            (*psCurrBlock).size =
                                                (*(*yyvsp.offset(0 as
                                                                     libc::c_int
                                                                     as
                                                                     isize)).cblock).size.wrapping_add(::std::mem::size_of::<OPCODE>()
                                                                                                           as
                                                                                                           libc::c_ulong);
                                            if genDebugInfo != 0 {
                                                (*psCurrBlock).psDebug =
                                                    memMallocRelease((::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                          as
                                                                          libc::c_ulong).wrapping_mul(1
                                                                                                          as
                                                                                                          libc::c_int
                                                                                                          as
                                                                                                          libc::c_uint))
                                                        as *mut SCRIPT_DEBUG;
                                                if (*psCurrBlock).psDebug.is_null()
                                                   {
                                                    scr_error(b"Out of memory\x00"
                                                                  as *const u8
                                                                  as
                                                                  *const libc::c_char
                                                                  as
                                                                  *mut libc::c_char);
                                                    current_block =
                                                        10563765182283539921;
                                                    break ;
                                                } else {
                                                    memset((*psCurrBlock).psDebug
                                                               as
                                                               *mut libc::c_void,
                                                           0 as libc::c_int,
                                                           (::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                as
                                                                libc::c_ulong).wrapping_mul(1
                                                                                                as
                                                                                                libc::c_int
                                                                                                as
                                                                                                libc::c_uint));
                                                    (*psCurrBlock).debugEntries
                                                        =
                                                        1 as libc::c_int as
                                                            UWORD as UDWORD
                                                }
                                            } else {
                                                (*psCurrBlock).psDebug =
                                                    0 as *mut SCRIPT_DEBUG;
                                                (*psCurrBlock).debugEntries =
                                                    0 as libc::c_int as UDWORD
                                            }
                                            ip = (*psCurrBlock).pCode;
                                            memcpy(ip as *mut libc::c_void,
                                                   (*(*yyvsp.offset(0 as
                                                                        libc::c_int
                                                                        as
                                                                        isize)).cblock).pCode
                                                       as *const libc::c_void,
                                                   (*(*yyvsp.offset(0 as
                                                                        libc::c_int
                                                                        as
                                                                        isize)).cblock).size);
                                            ip =
                                                (ip as
                                                     *mut UBYTE).offset((*(*yyvsp.offset(0
                                                                                             as
                                                                                             libc::c_int
                                                                                             as
                                                                                             isize)).cblock).size
                                                                            as
                                                                            isize)
                                                    as *mut UDWORD;
                                            *ip =
                                                ((OP_EXIT as libc::c_int) <<
                                                     24 as libc::c_int) as
                                                    UDWORD;
                                            ip =
                                                ip.offset(1 as libc::c_int as
                                                              isize);
                                            memFreeRelease((*(*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).cblock).pCode
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh54 =
                                                (*(*yyvsp.offset(0 as
                                                                     libc::c_int
                                                                     as
                                                                     isize)).cblock).pCode;
                                            *fresh54 = 0 as *mut UDWORD;
                                            memFreeRelease((*yyvsp.offset(0 as
                                                                              libc::c_int
                                                                              as
                                                                              isize)).cblock
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh55 =
                                                (*yyvsp.offset(0 as
                                                                   libc::c_int
                                                                   as
                                                                   isize)).cblock;
                                            *fresh55 = 0 as *mut CODE_BLOCK;
                                            if genDebugInfo != 0 {
                                                (*(*psCurrBlock).psDebug.offset(0
                                                                                    as
                                                                                    libc::c_int
                                                                                    as
                                                                                    isize)).offset
                                                    =
                                                    0 as libc::c_int as
                                                        UDWORD;
                                                scriptGetErrorData(&mut line_6
                                                                       as
                                                                       *mut UDWORD
                                                                       as
                                                                       *mut SDWORD,
                                                                   &mut pDummy_7);
                                                (*(*psCurrBlock).psDebug.offset(0
                                                                                    as
                                                                                    libc::c_int
                                                                                    as
                                                                                    isize)).line
                                                    = line_6
                                            }
                                            yyval.cblock = psCurrBlock
                                        }
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            82 => {
                                let mut line_7: UDWORD = 0;
                                let mut pDummy_8: *mut STRING =
                                    0 as *mut STRING;
                                if (*yyvsp.offset(-(2 as libc::c_int) as
                                                      isize)).ival <
                                       0 as libc::c_int {
                                    scr_error(b"Invalid pause time\x00" as
                                                  *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    psCurrBlock =
                                        memMallocRelease(::std::mem::size_of::<CODE_BLOCK>()
                                                             as libc::c_ulong)
                                            as *mut CODE_BLOCK;
                                    if psCurrBlock.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrBlock).pCode =
                                            memMallocRelease(::std::mem::size_of::<OPCODE>()
                                                                 as
                                                                 libc::c_ulong)
                                                as *mut UDWORD;
                                        if (*psCurrBlock).pCode.is_null() {
                                            debug(LOG_ERROR,
                                                  b"Out of memory\x00" as
                                                      *const u8 as
                                                      *const libc::c_char);
                                            memFreeRelease(psCurrBlock as
                                                               *mut libc::c_void);
                                            psCurrBlock =
                                                0 as *mut CODE_BLOCK;
                                            current_block =
                                                10563765182283539921;
                                            break ;
                                        } else {
                                            (*psCurrBlock).size =
                                                ::std::mem::size_of::<OPCODE>()
                                                    as libc::c_ulong;
                                            if genDebugInfo != 0 {
                                                (*psCurrBlock).psDebug =
                                                    memMallocRelease((::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                          as
                                                                          libc::c_ulong).wrapping_mul(1
                                                                                                          as
                                                                                                          libc::c_int
                                                                                                          as
                                                                                                          libc::c_uint))
                                                        as *mut SCRIPT_DEBUG;
                                                if (*psCurrBlock).psDebug.is_null()
                                                   {
                                                    scr_error(b"Out of memory\x00"
                                                                  as *const u8
                                                                  as
                                                                  *const libc::c_char
                                                                  as
                                                                  *mut libc::c_char);
                                                    current_block =
                                                        10563765182283539921;
                                                    break ;
                                                } else {
                                                    memset((*psCurrBlock).psDebug
                                                               as
                                                               *mut libc::c_void,
                                                           0 as libc::c_int,
                                                           (::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                as
                                                                libc::c_ulong).wrapping_mul(1
                                                                                                as
                                                                                                libc::c_int
                                                                                                as
                                                                                                libc::c_uint));
                                                    (*psCurrBlock).debugEntries
                                                        =
                                                        1 as libc::c_int as
                                                            UWORD as UDWORD
                                                }
                                            } else {
                                                (*psCurrBlock).psDebug =
                                                    0 as *mut SCRIPT_DEBUG;
                                                (*psCurrBlock).debugEntries =
                                                    0 as libc::c_int as UDWORD
                                            }
                                            ip = (*psCurrBlock).pCode;
                                            *ip =
                                                (*yyvsp.offset(-(2 as
                                                                     libc::c_int)
                                                                   as
                                                                   isize)).ival
                                                    as UDWORD &
                                                    0xffffff as libc::c_int as
                                                        libc::c_uint;
                                            *ip =
                                                (OP_PAUSE as libc::c_int as
                                                     UDWORD) <<
                                                    24 as libc::c_int | *ip;
                                            ip =
                                                ip.offset(1 as libc::c_int as
                                                              isize);
                                            if genDebugInfo != 0 {
                                                (*(*psCurrBlock).psDebug.offset(0
                                                                                    as
                                                                                    libc::c_int
                                                                                    as
                                                                                    isize)).offset
                                                    =
                                                    0 as libc::c_int as
                                                        UDWORD;
                                                scriptGetErrorData(&mut line_7
                                                                       as
                                                                       *mut UDWORD
                                                                       as
                                                                       *mut SDWORD,
                                                                   &mut pDummy_8);
                                                (*(*psCurrBlock).psDebug.offset(0
                                                                                    as
                                                                                    libc::c_int
                                                                                    as
                                                                                    isize)).line
                                                    = line_7
                                            }
                                            yyval.cblock = psCurrBlock
                                        }
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            83 => {
                                (*(*yyvsp.offset(0 as libc::c_int as
                                                     isize)).cblock).type_0 =
                                    VAL_INT;
                                yyval.cblock =
                                    (*yyvsp.offset(0 as libc::c_int as
                                                       isize)).cblock;
                                //debug(LOG_SCRIPT, "scriptLookUpVariable: extern");
                                //debug(LOG_SCRIPT, "scriptLookUpVariable 2");
                                current_block = 9320480655893135347;
                            }
                            84 => {
                                /* See if the symbol is in the local variable list */
                                (*(*yyvsp.offset(0 as libc::c_int as
                                                     isize)).cblock).type_0 =
                                    VAL_STRING;
                                yyval.cblock =
                                    (*yyvsp.offset(0 as libc::c_int as
                                                       isize)).cblock;
                                //debug(LOG_SCRIPT, "scriptLookUpVariable: local");
                                current_block = 9320480655893135347;
                            }
                            85 => {
                                //debug(LOG_SCRIPT, "scriptLookUpVariable 3");
                                (*(*yyvsp.offset(0 as libc::c_int as
                                                     isize)).cblock).type_0 =
                                    VAL_BOOL;
                                yyval.cblock =
                                    (*yyvsp.offset(0 as libc::c_int as
                                                       isize)).cblock;
                                /* check local vars if we are inside of an event */
                                current_block =
                                    9320480655893135347; //any vars stored for this event
                            }
                            86 => {
                                yyval.cblock =
                                    (*yyvsp.offset(0 as libc::c_int as
                                                       isize)).cblock;
                                //debug(LOG_SCRIPT, "now checking event %s; index = %d\n", psCurEvent->pIdent, psCurEvent->index);
                                current_block = 9320480655893135347;
                            }
                            87 => {
                                codeRet =
                                    scriptCodeAssignment((*yyvsp.offset(-(2 as
                                                                              libc::c_int)
                                                                            as
                                                                            isize)).vSymbol,
                                                         (*yyvsp.offset(0 as
                                                                            libc::c_int
                                                                            as
                                                                            isize)).cblock,
                                                         &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    //debug(LOG_SCRIPT, "start comparing, num local vars=%d, at line %d\n", numEventLocalVars[i], line);
				//debug(LOG_SCRIPT, "current var=%s\n", psCurr->pIdent);
				//debug(LOG_SCRIPT, "passed string=%s\n", pIdent);
                                    //debug(LOG_SCRIPT, "comparing %s with %s \n", psCurr->pIdent, pIdent);
                                    //debug(LOG_SCRIPT, "4");
					//debug(LOG_SCRIPT, "scriptLookUpVariable - local var found, type=%d\n", psCurr->type);
                                    current_block = 9320480655893135347;
                                }
                            }
                            88 => {
                                codeRet =
                                    scriptCodeAssignment((*yyvsp.offset(-(2 as
                                                                              libc::c_int)
                                                                            as
                                                                            isize)).vSymbol,
                                                         (*yyvsp.offset(0 as
                                                                            libc::c_int
                                                                            as
                                                                            isize)).cblock,
                                                         &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    //debug(LOG_SCRIPT, "scriptLookUpVariable 4");
                                    /* See if the symbol is in the global variable list.
	 * This is not checked for when local variables are being defined.
	 * This allows local variables to have the same name as global ones.
	 */
                                    current_block = 9320480655893135347;
                                }
                            }
                            89 => {
                                codeRet =
                                    scriptCodeAssignment((*yyvsp.offset(-(2 as
                                                                              libc::c_int)
                                                                            as
                                                                            isize)).vSymbol,
                                                         (*yyvsp.offset(0 as
                                                                            libc::c_int
                                                                            as
                                                                            isize)).cblock,
                                                         &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            90 => {
                                if interpCheckEquiv((*(*yyvsp.offset(-(2 as
                                                                           libc::c_int)
                                                                         as
                                                                         isize)).vSymbol).type_0,
                                                    (*(*yyvsp.offset(0 as
                                                                         libc::c_int
                                                                         as
                                                                         isize)).cblock).type_0)
                                       == 0 {
                                    scr_error(b"User type mismatch for assignment (%d - %d) 4\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char,
                                              (*(*yyvsp.offset(-(2 as
                                                                     libc::c_int)
                                                                   as
                                                                   isize)).vSymbol).type_0
                                                  as libc::c_uint,
                                              (*(*yyvsp.offset(0 as
                                                                   libc::c_int
                                                                   as
                                                                   isize)).cblock).type_0
                                                  as libc::c_uint);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    codeRet =
                                        scriptCodeAssignment((*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).vSymbol,
                                                             (*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).cblock,
                                                             &mut psCurrBlock);
                                    if codeRet as libc::c_uint ==
                                           CE_MEMORY as libc::c_int as
                                               libc::c_uint {
                                        current_block = 10563765182283539921;
                                        break ;
                                    }
                                    if codeRet as libc::c_uint ==
                                           CE_PARSE as libc::c_int as
                                               libc::c_uint {
                                        current_block = 15438562788955825517;
                                    } else {
                                        yyval.cblock = psCurrBlock;
                                        /* Failed to find the variable */
                                        //debug(LOG_SCRIPT, "END scriptLookUpVariable");
                                        current_block = 9320480655893135347;
                                    }
                                }
                            }
                            91 => {
                                /* Add a new trigger symbol */
                                if interpCheckEquiv((*(*yyvsp.offset(-(2 as
                                                                           libc::c_int)
                                                                         as
                                                                         isize)).vSymbol).type_0,
                                                    (*(*yyvsp.offset(0 as
                                                                         libc::c_int
                                                                         as
                                                                         isize)).cblock).type_0)
                                       == 0 {
                                    scr_error(b"User type mismatch for assignment (%d - %d) 3\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char,
                                              (*(*yyvsp.offset(-(2 as
                                                                     libc::c_int)
                                                                   as
                                                                   isize)).vSymbol).type_0
                                                  as libc::c_uint,
                                              (*(*yyvsp.offset(0 as
                                                                   libc::c_int
                                                                   as
                                                                   isize)).cblock).type_0
                                                  as libc::c_uint);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    codeRet =
                                        scriptCodeAssignment((*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).vSymbol,
                                                             (*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).cblock,
                                                             &mut psCurrBlock);
                                    if codeRet as libc::c_uint ==
                                           CE_MEMORY as libc::c_int as
                                               libc::c_uint {
                                        current_block = 10563765182283539921;
                                        break ;
                                    }
                                    if codeRet as libc::c_uint ==
                                           CE_PARSE as libc::c_int as
                                               libc::c_uint {
                                        current_block = 15438562788955825517;
                                    } else {
                                        yyval.cblock = psCurrBlock;
                                        // Allocate the trigger
                                        current_block = 9320480655893135347;
                                    }
                                }
                            }
                            92 => {
                                codeRet =
                                    scriptCodeObjAssignment((*yyvsp.offset(-(2
                                                                                 as
                                                                                 libc::c_int)
                                                                               as
                                                                               isize)).objVarBlock,
                                                            (*yyvsp.offset(0
                                                                               as
                                                                               libc::c_int
                                                                               as
                                                                               isize)).cblock,
                                                            &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            93 => {
                                codeRet =
                                    scriptCodeObjAssignment((*yyvsp.offset(-(2
                                                                                 as
                                                                                 libc::c_int)
                                                                               as
                                                                               isize)).objVarBlock,
                                                            (*yyvsp.offset(0
                                                                               as
                                                                               libc::c_int
                                                                               as
                                                                               isize)).cblock,
                                                            &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    // Add debug info
                                    current_block = 9320480655893135347;
                                }
                            }
                            94 => {
                                if interpCheckEquiv((*(*(*yyvsp.offset(-(2 as
                                                                             libc::c_int)
                                                                           as
                                                                           isize)).objVarBlock).psObjVar).type_0,
                                                    (*(*yyvsp.offset(0 as
                                                                         libc::c_int
                                                                         as
                                                                         isize)).cblock).type_0)
                                       == 0 {
                                    scr_error(b"User type mismatch for assignment (%d - %d) 2\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char,
                                              (*(*(*yyvsp.offset(-(2 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).objVarBlock).psObjVar).type_0
                                                  as libc::c_uint,
                                              (*(*yyvsp.offset(0 as
                                                                   libc::c_int
                                                                   as
                                                                   isize)).cblock).type_0
                                                  as libc::c_uint);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    codeRet =
                                        scriptCodeObjAssignment((*yyvsp.offset(-(2
                                                                                     as
                                                                                     libc::c_int)
                                                                                   as
                                                                                   isize)).objVarBlock,
                                                                (*yyvsp.offset(0
                                                                                   as
                                                                                   libc::c_int
                                                                                   as
                                                                                   isize)).cblock,
                                                                &mut psCurrBlock);
                                    if codeRet as libc::c_uint ==
                                           CE_MEMORY as libc::c_int as
                                               libc::c_uint {
                                        current_block = 10563765182283539921;
                                        break ;
                                    }
                                    if codeRet as libc::c_uint ==
                                           CE_PARSE as libc::c_int as
                                               libc::c_uint {
                                        current_block = 15438562788955825517;
                                    } else {
                                        yyval.cblock = psCurrBlock;
                                        // Store the trigger
                                        current_block = 9320480655893135347;
                                    }
                                }
                            }
                            95 => {
                                if interpCheckEquiv((*(*(*yyvsp.offset(-(2 as
                                                                             libc::c_int)
                                                                           as
                                                                           isize)).objVarBlock).psObjVar).type_0,
                                                    (*(*yyvsp.offset(0 as
                                                                         libc::c_int
                                                                         as
                                                                         isize)).cblock).type_0)
                                       == 0 {
                                    scr_error(b"User type mismatch for assignment (%d - %d) 1\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char,
                                              (*(*(*yyvsp.offset(-(2 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).objVarBlock).psObjVar).type_0
                                                  as libc::c_uint,
                                              (*(*yyvsp.offset(0 as
                                                                   libc::c_int
                                                                   as
                                                                   isize)).cblock).type_0
                                                  as libc::c_uint);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    codeRet =
                                        scriptCodeObjAssignment((*yyvsp.offset(-(2
                                                                                     as
                                                                                     libc::c_int)
                                                                                   as
                                                                                   isize)).objVarBlock,
                                                                (*yyvsp.offset(0
                                                                                   as
                                                                                   libc::c_int
                                                                                   as
                                                                                   isize)).cblock,
                                                                &mut psCurrBlock);
                                    if codeRet as libc::c_uint ==
                                           CE_MEMORY as libc::c_int as
                                               libc::c_uint {
                                        current_block = 10563765182283539921;
                                        break ;
                                    }
                                    if codeRet as libc::c_uint ==
                                           CE_PARSE as libc::c_int as
                                               libc::c_uint {
                                        current_block = 15438562788955825517;
                                    } else {
                                        yyval.cblock = psCurrBlock;
                                        /* Lookup a trigger symbol */
                                        current_block = 9320480655893135347;
                                    }
                                }
                            }
                            96 => {
                                codeRet =
                                    scriptCodeArrayAssignment((*yyvsp.offset(-(2
                                                                                   as
                                                                                   libc::c_int)
                                                                                 as
                                                                                 isize)).arrayBlock,
                                                              (*yyvsp.offset(0
                                                                                 as
                                                                                 libc::c_int
                                                                                 as
                                                                                 isize)).cblock,
                                                              &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    //debug(LOG_SCRIPT, "scriptLookUpTrigger");
                                    //debug(LOG_SCRIPT, "scriptLookUpTrigger: found");
                                    current_block = 9320480655893135347;
                                }
                            }
                            97 => {
                                codeRet =
                                    scriptCodeArrayAssignment((*yyvsp.offset(-(2
                                                                                   as
                                                                                   libc::c_int)
                                                                                 as
                                                                                 isize)).arrayBlock,
                                                              (*yyvsp.offset(0
                                                                                 as
                                                                                 libc::c_int
                                                                                 as
                                                                                 isize)).cblock,
                                                              &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    //debug(LOG_SCRIPT, "END scriptLookUpTrigger");
                                    /* Lookup a callback trigger symbol */
                                    current_block = 9320480655893135347;
                                }
                            }
                            98 => {
                                if interpCheckEquiv((*(*(*yyvsp.offset(-(2 as
                                                                             libc::c_int)
                                                                           as
                                                                           isize)).arrayBlock).psArrayVar).type_0,
                                                    (*(*yyvsp.offset(0 as
                                                                         libc::c_int
                                                                         as
                                                                         isize)).cblock).type_0)
                                       == 0 {
                                    scr_error(b"User type mismatch for assignment (%d - %d) 0\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char,
                                              (*(*(*yyvsp.offset(-(2 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).arrayBlock).psArrayVar).type_0
                                                  as libc::c_uint,
                                              (*(*yyvsp.offset(0 as
                                                                   libc::c_int
                                                                   as
                                                                   isize)).cblock).type_0
                                                  as libc::c_uint);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    codeRet =
                                        scriptCodeArrayAssignment((*yyvsp.offset(-(2
                                                                                       as
                                                                                       libc::c_int)
                                                                                     as
                                                                                     isize)).arrayBlock,
                                                                  (*yyvsp.offset(0
                                                                                     as
                                                                                     libc::c_int
                                                                                     as
                                                                                     isize)).cblock,
                                                                  &mut psCurrBlock);
                                    if codeRet as libc::c_uint ==
                                           CE_MEMORY as libc::c_int as
                                               libc::c_uint {
                                        current_block = 10563765182283539921;
                                        break ;
                                    }
                                    if codeRet as libc::c_uint ==
                                           CE_PARSE as libc::c_int as
                                               libc::c_uint {
                                        current_block = 15438562788955825517;
                                    } else {
                                        yyval.cblock = psCurrBlock;
                                        //debug(LOG_SCRIPT, "scriptLookUpCallback");
                                        //debug(LOG_SCRIPT, "scriptLookUpCallback: found");
                                        current_block = 9320480655893135347;
                                    }
                                }
                            }
                            99 => {
                                if interpCheckEquiv((*(*(*yyvsp.offset(-(2 as
                                                                             libc::c_int)
                                                                           as
                                                                           isize)).arrayBlock).psArrayVar).type_0,
                                                    (*(*yyvsp.offset(0 as
                                                                         libc::c_int
                                                                         as
                                                                         isize)).cblock).type_0)
                                       == 0 {
                                    scr_error(b"User type mismatch for assignment\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    codeRet =
                                        scriptCodeArrayAssignment((*yyvsp.offset(-(2
                                                                                       as
                                                                                       libc::c_int)
                                                                                     as
                                                                                     isize)).arrayBlock,
                                                                  (*yyvsp.offset(0
                                                                                     as
                                                                                     libc::c_int
                                                                                     as
                                                                                     isize)).cblock,
                                                                  &mut psCurrBlock);
                                    if codeRet as libc::c_uint ==
                                           CE_MEMORY as libc::c_int as
                                               libc::c_uint {
                                        current_block = 10563765182283539921;
                                        break ;
                                    }
                                    if codeRet as libc::c_uint ==
                                           CE_PARSE as libc::c_int as
                                               libc::c_uint {
                                        current_block = 15438562788955825517;
                                    } else {
                                        yyval.cblock = psCurrBlock;
                                        //debug(LOG_SCRIPT, "END scriptLookUpCallback: found");
                                        /* Add a new event symbol */
                                        // Allocate the event
                                        current_block = 9320480655893135347;
                                    }
                                }
                            }
                            100 => {
                                codeRet =
                                    scriptCodeFunction((*yyvsp.offset(-(3 as
                                                                            libc::c_int)
                                                                          as
                                                                          isize)).fSymbol,
                                                       (*yyvsp.offset(-(1 as
                                                                            libc::c_int)
                                                                          as
                                                                          isize)).pblock,
                                                       0 as libc::c_int,
                                                       &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            101 => {
                                /* remember how many params this event has */
                                codeRet =
                                    scriptCodeFunction((*yyvsp.offset(-(3 as
                                                                            libc::c_int)
                                                                          as
                                                                          isize)).fSymbol,
                                                       (*yyvsp.offset(-(1 as
                                                                            libc::c_int)
                                                                          as
                                                                          isize)).pblock,
                                                       0 as libc::c_int,
                                                       &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    /* functions can return a value */
                                    // Add the event to the list
                                    current_block = 9320480655893135347;
                                }
                            }
                            102 => {
                                codeRet =
                                    scriptCodeFunction((*yyvsp.offset(-(3 as
                                                                            libc::c_int)
                                                                          as
                                                                          isize)).fSymbol,
                                                       (*yyvsp.offset(-(1 as
                                                                            libc::c_int)
                                                                          as
                                                                          isize)).pblock,
                                                       0 as libc::c_int,
                                                       &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    // Add the code to a defined event
                                    current_block = 9320480655893135347;
                                }
                            }
                            103 => {
                                codeRet =
                                    scriptCodeFunction((*yyvsp.offset(-(3 as
                                                                            libc::c_int)
                                                                          as
                                                                          isize)).fSymbol,
                                                       (*yyvsp.offset(-(1 as
                                                                            libc::c_int)
                                                                          as
                                                                          isize)).pblock,
                                                       0 as libc::c_int,
                                                       &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    // events with arguments can't have a trigger assigned
                                    // Store the event code
                                    current_block = 9320480655893135347;
                                }
                            }
                            104 => {
                                codeRet =
                                    scriptCodeFunction((*yyvsp.offset(-(3 as
                                                                            libc::c_int)
                                                                          as
                                                                          isize)).fSymbol,
                                                       (*yyvsp.offset(-(1 as
                                                                            libc::c_int)
                                                                          as
                                                                          isize)).pblock,
                                                       0 as libc::c_int,
                                                       &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    // Add debug info
                                    current_block = 9320480655893135347;
                                }
                            }
                            105 => {
                                psCurrPBlock =
                                    memMallocRelease(::std::mem::size_of::<PARAM_BLOCK>()
                                                         as libc::c_ulong) as
                                        *mut PARAM_BLOCK;
                                if psCurrPBlock.is_null() {
                                    debug(LOG_ERROR,
                                          b"Out of memory\x00" as *const u8 as
                                              *const libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCurrPBlock).pCode =
                                        memMallocRelease(::std::mem::size_of::<UDWORD>()
                                                             as libc::c_ulong)
                                            as *mut UDWORD;
                                    if (*psCurrPBlock).pCode.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        memFreeRelease(psCurrPBlock as
                                                           *mut libc::c_void);
                                        psCurrPBlock = 0 as *mut PARAM_BLOCK;
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrPBlock).aParams =
                                            memMallocRelease((::std::mem::size_of::<INTERP_TYPE>()
                                                                  as
                                                                  libc::c_ulong).wrapping_mul(1
                                                                                                  as
                                                                                                  libc::c_int
                                                                                                  as
                                                                                                  libc::c_uint))
                                                as *mut INTERP_TYPE;
                                        if (*psCurrPBlock).aParams.is_null() {
                                            debug(LOG_ERROR,
                                                  b"Out of memory\x00" as
                                                      *const u8 as
                                                      *const libc::c_char);
                                            memFreeRelease((*psCurrPBlock).pCode
                                                               as
                                                               *mut libc::c_void);
                                            (*psCurrPBlock).pCode =
                                                0 as *mut UDWORD;
                                            memFreeRelease(psCurrPBlock as
                                                               *mut libc::c_void);
                                            psCurrPBlock =
                                                0 as *mut PARAM_BLOCK;
                                            current_block =
                                                10563765182283539921;
                                            break ;
                                        } else {
                                            (*psCurrPBlock).size =
                                                ::std::mem::size_of::<UDWORD>()
                                                    as libc::c_ulong;
                                            (*psCurrPBlock).numParams =
                                                1 as libc::c_int as UDWORD;
                                            (*psCurrPBlock).size =
                                                0 as libc::c_int as UDWORD;
                                            (*psCurrPBlock).numParams =
                                                0 as libc::c_int as UDWORD;
                                            yyval.pblock = psCurrPBlock
                                        }
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            106 => {
                                yyval.pblock =
                                    (*yyvsp.offset(0 as libc::c_int as
                                                       isize)).pblock;
                                //debug(LOG_SCRIPT, "before define event");
                                /* store local vars */
                                current_block = 9320480655893135347;
                            }
                            107 => {
                                psCurrPBlock =
                                    memMallocRelease(::std::mem::size_of::<PARAM_BLOCK>()
                                                         as libc::c_ulong) as
                                        *mut PARAM_BLOCK;
                                if psCurrPBlock.is_null() {
                                    debug(LOG_ERROR,
                                          b"Out of memory\x00" as *const u8 as
                                              *const libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCurrPBlock).pCode =
                                        memMallocRelease((*(*yyvsp.offset(-(2
                                                                                as
                                                                                libc::c_int)
                                                                              as
                                                                              isize)).pblock).size.wrapping_add((*(*yyvsp.offset(0
                                                                                                                                     as
                                                                                                                                     libc::c_int
                                                                                                                                     as
                                                                                                                                     isize)).pblock).size))
                                            as *mut UDWORD;
                                    if (*psCurrPBlock).pCode.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        memFreeRelease(psCurrPBlock as
                                                           *mut libc::c_void);
                                        psCurrPBlock = 0 as *mut PARAM_BLOCK;
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrPBlock).aParams =
                                            memMallocRelease((::std::mem::size_of::<INTERP_TYPE>()
                                                                  as
                                                                  libc::c_ulong).wrapping_mul((*(*yyvsp.offset(-(2
                                                                                                                     as
                                                                                                                     libc::c_int)
                                                                                                                   as
                                                                                                                   isize)).pblock).numParams.wrapping_add((*(*yyvsp.offset(0
                                                                                                                                                                               as
                                                                                                                                                                               libc::c_int
                                                                                                                                                                               as
                                                                                                                                                                               isize)).pblock).numParams)))
                                                as *mut INTERP_TYPE;
                                        if (*psCurrPBlock).aParams.is_null() {
                                            debug(LOG_ERROR,
                                                  b"Out of memory\x00" as
                                                      *const u8 as
                                                      *const libc::c_char);
                                            memFreeRelease((*psCurrPBlock).pCode
                                                               as
                                                               *mut libc::c_void);
                                            (*psCurrPBlock).pCode =
                                                0 as *mut UDWORD;
                                            memFreeRelease(psCurrPBlock as
                                                               *mut libc::c_void);
                                            psCurrPBlock =
                                                0 as *mut PARAM_BLOCK;
                                            current_block =
                                                10563765182283539921;
                                            break ;
                                        } else {
                                            (*psCurrPBlock).size =
                                                (*(*yyvsp.offset(-(2 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).pblock).size.wrapping_add((*(*yyvsp.offset(0
                                                                                                                            as
                                                                                                                            libc::c_int
                                                                                                                            as
                                                                                                                            isize)).pblock).size);
                                            (*psCurrPBlock).numParams =
                                                (*(*yyvsp.offset(-(2 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).pblock).numParams.wrapping_add((*(*yyvsp.offset(0
                                                                                                                                 as
                                                                                                                                 libc::c_int
                                                                                                                                 as
                                                                                                                                 isize)).pblock).numParams);
                                            ip = (*psCurrPBlock).pCode;
                                            memcpy(ip as *mut libc::c_void,
                                                   (*(*yyvsp.offset(-(2 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).pblock).pCode
                                                       as *const libc::c_void,
                                                   (*(*yyvsp.offset(-(2 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).pblock).size);
                                            ip =
                                                (ip as
                                                     *mut UBYTE).offset((*(*yyvsp.offset(-(2
                                                                                               as
                                                                                               libc::c_int)
                                                                                             as
                                                                                             isize)).pblock).size
                                                                            as
                                                                            isize)
                                                    as *mut UDWORD;
                                            memcpy(ip as *mut libc::c_void,
                                                   (*(*yyvsp.offset(0 as
                                                                        libc::c_int
                                                                        as
                                                                        isize)).pblock).pCode
                                                       as *const libc::c_void,
                                                   (*(*yyvsp.offset(0 as
                                                                        libc::c_int
                                                                        as
                                                                        isize)).pblock).size);
                                            ip =
                                                (ip as
                                                     *mut UBYTE).offset((*(*yyvsp.offset(0
                                                                                             as
                                                                                             libc::c_int
                                                                                             as
                                                                                             isize)).pblock).size
                                                                            as
                                                                            isize)
                                                    as *mut UDWORD;
                                            memcpy((*psCurrPBlock).aParams as
                                                       *mut libc::c_void,
                                                   (*(*yyvsp.offset(-(2 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).pblock).aParams
                                                       as *const libc::c_void,
                                                   (*(*yyvsp.offset(-(2 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).pblock).numParams.wrapping_mul(::std::mem::size_of::<INTERP_TYPE>()
                                                                                                                   as
                                                                                                                   libc::c_ulong));
                                            memcpy((*psCurrPBlock).aParams.offset((*(*yyvsp.offset(-(2
                                                                                                         as
                                                                                                         libc::c_int)
                                                                                                       as
                                                                                                       isize)).pblock).numParams
                                                                                      as
                                                                                      isize)
                                                       as *mut libc::c_void,
                                                   (*(*yyvsp.offset(0 as
                                                                        libc::c_int
                                                                        as
                                                                        isize)).pblock).aParams
                                                       as *const libc::c_void,
                                                   (*(*yyvsp.offset(0 as
                                                                        libc::c_int
                                                                        as
                                                                        isize)).pblock).numParams.wrapping_mul(::std::mem::size_of::<INTERP_TYPE>()
                                                                                                                   as
                                                                                                                   libc::c_ulong));
                                            memFreeRelease((*(*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).pblock).pCode
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh56 =
                                                (*(*yyvsp.offset(-(2 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).pblock).pCode;
                                            *fresh56 = 0 as *mut UDWORD;
                                            memFreeRelease((*(*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).pblock).aParams
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh57 =
                                                (*(*yyvsp.offset(-(2 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).pblock).aParams;
                                            *fresh57 = 0 as *mut INTERP_TYPE;
                                            memFreeRelease((*yyvsp.offset(-(2
                                                                                as
                                                                                libc::c_int)
                                                                              as
                                                                              isize)).pblock
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh58 =
                                                (*yyvsp.offset(-(2 as
                                                                     libc::c_int)
                                                                   as
                                                                   isize)).pblock;
                                            *fresh58 = 0 as *mut PARAM_BLOCK;
                                            memFreeRelease((*(*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).pblock).pCode
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh59 =
                                                (*(*yyvsp.offset(0 as
                                                                     libc::c_int
                                                                     as
                                                                     isize)).pblock).pCode;
                                            *fresh59 = 0 as *mut UDWORD;
                                            memFreeRelease((*(*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).pblock).aParams
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh60 =
                                                (*(*yyvsp.offset(0 as
                                                                     libc::c_int
                                                                     as
                                                                     isize)).pblock).aParams;
                                            *fresh60 = 0 as *mut INTERP_TYPE;
                                            memFreeRelease((*yyvsp.offset(0 as
                                                                              libc::c_int
                                                                              as
                                                                              isize)).pblock
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh61 =
                                                (*yyvsp.offset(0 as
                                                                   libc::c_int
                                                                   as
                                                                   isize)).pblock;
                                            *fresh61 = 0 as *mut PARAM_BLOCK;
                                            yyval.pblock = psCurrPBlock
                                        }
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            108 => {
                                codeRet =
                                    scriptCodeParameter((*yyvsp.offset(0 as
                                                                           libc::c_int
                                                                           as
                                                                           isize)).cblock,
                                                        VAL_INT,
                                                        &mut psCurrPBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.pblock = psCurrPBlock;
                                    //debug(LOG_SCRIPT, "END scriptLookUpConstant");
                                    current_block = 9320480655893135347;
                                }
                            }
                            109 => {
                                codeRet =
                                    scriptCodeParameter((*yyvsp.offset(0 as
                                                                           libc::c_int
                                                                           as
                                                                           isize)).cblock,
                                                        VAL_BOOL,
                                                        &mut psCurrPBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.pblock = psCurrPBlock;
                                    /* Look up a function symbol */
                                    //debug(LOG_SCRIPT, "scriptLookUpFunction");
                                    /* See if the function is defined as an instinct function */
                                    current_block = 9320480655893135347;
                                }
                            }
                            110 => {
                                codeRet =
                                    scriptCodeParameter((*yyvsp.offset(0 as
                                                                           libc::c_int
                                                                           as
                                                                           isize)).cblock,
                                                        VAL_STRING,
                                                        &mut psCurrPBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.pblock = psCurrPBlock;
                                    /* See if the function is defined as a script function */
                                    current_block = 9320480655893135347;
                                }
                            }
                            111 => {
                                codeRet =
                                    scriptCodeParameter((*yyvsp.offset(0 as
                                                                           libc::c_int
                                                                           as
                                                                           isize)).cblock,
                                                        (*(*yyvsp.offset(0 as
                                                                             libc::c_int
                                                                             as
                                                                             isize)).cblock).type_0,
                                                        &mut psCurrPBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.pblock = psCurrPBlock;
                                    /* Failed to find the indentifier */
                                    //debug(LOG_SCRIPT, "END scriptLookUpFunction");
                                    current_block = 9320480655893135347;
                                }
                            }
                            112 => {
                                codeRet =
                                    scriptCodeParameter((*yyvsp.offset(0 as
                                                                           libc::c_int
                                                                           as
                                                                           isize)).cblock,
                                                        (*(*yyvsp.offset(0 as
                                                                             libc::c_int
                                                                             as
                                                                             isize)).cblock).type_0,
                                                        &mut psCurrPBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.pblock = psCurrPBlock;
                                    /* Look up a function symbol defined in script */
                                    //debug(LOG_SCRIPT, "scriptLookUpCustomFunction");
                                    /* See if the function is defined as a script function */
                                    /* event defined as function */
                                    current_block = 9320480655893135347;
                                }
                            }
                            113 => {
                                yyval.pblock =
                                    (*yyvsp.offset(0 as libc::c_int as
                                                       isize)).pblock;
                                //debug(LOG_SCRIPT, "scriptLookUpCustomFunction: %s is a custom function", pIdent);
                                current_block = 9320480655893135347;
                            }
                            114 => {
                                /* Failed to find the indentifier */
                                codeRet =
                                    scriptCodeVarRef((*yyvsp.offset(0 as
                                                                        libc::c_int
                                                                        as
                                                                        isize)).vSymbol,
                                                     &mut psCurrPBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.pblock = psCurrPBlock;
                                    //debug(LOG_SCRIPT, "END scriptLookUpCustomFunction");
                                    /* Set the type table */
                                    current_block = 9320480655893135347;
                                }
                            }
                            115 => {
                                codeRet =
                                    scriptCodeVarRef((*yyvsp.offset(0 as
                                                                        libc::c_int
                                                                        as
                                                                        isize)).vSymbol,
                                                     &mut psCurrPBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.pblock = psCurrPBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            116 => {
                                codeRet =
                                    scriptCodeVarRef((*yyvsp.offset(0 as
                                                                        libc::c_int
                                                                        as
                                                                        isize)).vSymbol,
                                                     &mut psCurrPBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.pblock = psCurrPBlock;
                                    /* Set the function table */
                                    /* Set the object variable table */
                                    current_block = 9320480655893135347;
                                }
                            }
                            117 => {
                                codeRet =
                                    scriptCodeVarRef((*yyvsp.offset(0 as
                                                                        libc::c_int
                                                                        as
                                                                        isize)).vSymbol,
                                                     &mut psCurrPBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.pblock = psCurrPBlock;
                                    /* Set the external variable table */
                                    /* Set the constant table */
                                    current_block = 9320480655893135347;
                                }
                            }
                            118 => {
                                codeRet =
                                    scriptCodeVarRef((*yyvsp.offset(0 as
                                                                        libc::c_int
                                                                        as
                                                                        isize)).vSymbol,
                                                     &mut psCurrPBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.pblock = psCurrPBlock;
                                    /* Set the callback table */
                                    current_block = 9320480655893135347;
                                }
                            }
                            119 => {
                                codeRet =
                                    scriptCodeConditional((*yyvsp.offset(0 as
                                                                             libc::c_int
                                                                             as
                                                                             isize)).condBlock,
                                                          &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            120 => {
                                psCondBlock =
                                    memMallocRelease(::std::mem::size_of::<COND_BLOCK>()
                                                         as libc::c_ulong) as
                                        *mut COND_BLOCK;
                                if psCondBlock.is_null() {
                                    debug(LOG_ERROR,
                                          b"Out of memory\x00" as *const u8 as
                                              *const libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCondBlock).aOffsets =
                                        memMallocRelease((::std::mem::size_of::<SDWORD>()
                                                              as
                                                              libc::c_ulong).wrapping_mul((*(*yyvsp.offset(-(2
                                                                                                                 as
                                                                                                                 libc::c_int)
                                                                                                               as
                                                                                                               isize)).condBlock).numOffsets.wrapping_add((*(*yyvsp.offset(0
                                                                                                                                                                               as
                                                                                                                                                                               libc::c_int
                                                                                                                                                                               as
                                                                                                                                                                               isize)).condBlock).numOffsets)))
                                            as *mut UDWORD;
                                    if (*psCondBlock).aOffsets.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCondBlock).pCode =
                                            memMallocRelease((*(*yyvsp.offset(-(2
                                                                                    as
                                                                                    libc::c_int)
                                                                                  as
                                                                                  isize)).condBlock).size.wrapping_add((*(*yyvsp.offset(0
                                                                                                                                            as
                                                                                                                                            libc::c_int
                                                                                                                                            as
                                                                                                                                            isize)).condBlock).size))
                                                as *mut UDWORD;
                                        if (*psCondBlock).pCode.is_null() {
                                            debug(LOG_ERROR,
                                                  b"Out of memory\x00" as
                                                      *const u8 as
                                                      *const libc::c_char);
                                            current_block =
                                                10563765182283539921;
                                            break ;
                                        } else {
                                            (*psCondBlock).size =
                                                (*(*yyvsp.offset(-(2 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).condBlock).size.wrapping_add((*(*yyvsp.offset(0
                                                                                                                               as
                                                                                                                               libc::c_int
                                                                                                                               as
                                                                                                                               isize)).condBlock).size);
                                            (*psCondBlock).numOffsets =
                                                (*(*yyvsp.offset(-(2 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).condBlock).numOffsets.wrapping_add((*(*yyvsp.offset(0
                                                                                                                                     as
                                                                                                                                     libc::c_int
                                                                                                                                     as
                                                                                                                                     isize)).condBlock).numOffsets);
                                            if genDebugInfo != 0 {
                                                (*psCondBlock).psDebug =
                                                    memMallocRelease((::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                          as
                                                                          libc::c_ulong).wrapping_mul((*(*yyvsp.offset(-(2
                                                                                                                             as
                                                                                                                             libc::c_int)
                                                                                                                           as
                                                                                                                           isize)).condBlock).debugEntries.wrapping_add((*(*yyvsp.offset(0
                                                                                                                                                                                             as
                                                                                                                                                                                             libc::c_int
                                                                                                                                                                                             as
                                                                                                                                                                                             isize)).condBlock).debugEntries)))
                                                        as *mut SCRIPT_DEBUG;
                                                if (*psCondBlock).psDebug.is_null()
                                                   {
                                                    scr_error(b"Out of memory\x00"
                                                                  as *const u8
                                                                  as
                                                                  *const libc::c_char
                                                                  as
                                                                  *mut libc::c_char);
                                                    current_block =
                                                        10563765182283539921;
                                                    break ;
                                                } else {
                                                    memset((*psCondBlock).psDebug
                                                               as
                                                               *mut libc::c_void,
                                                           0 as libc::c_int,
                                                           (::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                as
                                                                libc::c_ulong).wrapping_mul((*(*yyvsp.offset(-(2
                                                                                                                   as
                                                                                                                   libc::c_int)
                                                                                                                 as
                                                                                                                 isize)).condBlock).debugEntries.wrapping_add((*(*yyvsp.offset(0
                                                                                                                                                                                   as
                                                                                                                                                                                   libc::c_int
                                                                                                                                                                                   as
                                                                                                                                                                                   isize)).condBlock).debugEntries)));
                                                    (*psCondBlock).debugEntries
                                                        =
                                                        (*(*yyvsp.offset(-(2
                                                                               as
                                                                               libc::c_int)
                                                                             as
                                                                             isize)).condBlock).debugEntries.wrapping_add((*(*yyvsp.offset(0
                                                                                                                                               as
                                                                                                                                               libc::c_int
                                                                                                                                               as
                                                                                                                                               isize)).condBlock).debugEntries)
                                                            as UWORD as UDWORD
                                                }
                                            } else {
                                                (*psCondBlock).psDebug =
                                                    0 as *mut SCRIPT_DEBUG;
                                                (*psCondBlock).debugEntries =
                                                    0 as libc::c_int as UDWORD
                                            }
                                            ip = (*psCondBlock).pCode;
                                            memcpy(ip as *mut libc::c_void,
                                                   (*(*yyvsp.offset(-(2 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).condBlock).pCode
                                                       as *const libc::c_void,
                                                   (*(*yyvsp.offset(-(2 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).condBlock).size);
                                            ip =
                                                (ip as
                                                     *mut UBYTE).offset((*(*yyvsp.offset(-(2
                                                                                               as
                                                                                               libc::c_int)
                                                                                             as
                                                                                             isize)).condBlock).size
                                                                            as
                                                                            isize)
                                                    as *mut UDWORD;
                                            memcpy(ip as *mut libc::c_void,
                                                   (*(*yyvsp.offset(0 as
                                                                        libc::c_int
                                                                        as
                                                                        isize)).condBlock).pCode
                                                       as *const libc::c_void,
                                                   (*(*yyvsp.offset(0 as
                                                                        libc::c_int
                                                                        as
                                                                        isize)).condBlock).size);
                                            ip =
                                                (ip as
                                                     *mut UBYTE).offset((*(*yyvsp.offset(0
                                                                                             as
                                                                                             libc::c_int
                                                                                             as
                                                                                             isize)).condBlock).size
                                                                            as
                                                                            isize)
                                                    as *mut UDWORD;
                                            memcpy((*psCondBlock).aOffsets as
                                                       *mut libc::c_void,
                                                   (*(*yyvsp.offset(-(2 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).condBlock).aOffsets
                                                       as *const libc::c_void,
                                                   (*(*yyvsp.offset(-(2 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).condBlock).numOffsets.wrapping_mul(::std::mem::size_of::<SDWORD>()
                                                                                                                       as
                                                                                                                       libc::c_ulong));
                                            (*psCondBlock).numOffsets =
                                                (*(*yyvsp.offset(-(2 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).condBlock).numOffsets;
                                            if genDebugInfo != 0 {
                                                memcpy((*psCondBlock).psDebug
                                                           as
                                                           *mut libc::c_void,
                                                       (*(*yyvsp.offset(-(2 as
                                                                              libc::c_int)
                                                                            as
                                                                            isize)).condBlock).psDebug
                                                           as
                                                           *const libc::c_void,
                                                       (::std::mem::size_of::<SCRIPT_DEBUG>()
                                                            as
                                                            libc::c_ulong).wrapping_mul((*(*yyvsp.offset(-(2
                                                                                                               as
                                                                                                               libc::c_int)
                                                                                                             as
                                                                                                             isize)).condBlock).debugEntries));
                                                (*psCondBlock).debugEntries =
                                                    (*(*yyvsp.offset(-(2 as
                                                                           libc::c_int)
                                                                         as
                                                                         isize)).condBlock).debugEntries
                                            }
                                            if genDebugInfo != 0 {
                                                _dbEntry =
                                                    0 as libc::c_int as
                                                        UDWORD;
                                                while _dbEntry <
                                                          (*(*yyvsp.offset(0
                                                                               as
                                                                               libc::c_int
                                                                               as
                                                                               isize)).condBlock).debugEntries
                                                      {
                                                    _psCurr =
                                                        (*psCondBlock).psDebug.offset((*psCondBlock).debugEntries
                                                                                          as
                                                                                          isize).offset(_dbEntry
                                                                                                            as
                                                                                                            isize);
                                                    (*_psCurr).line =
                                                        (*(*(*yyvsp.offset(0
                                                                               as
                                                                               libc::c_int
                                                                               as
                                                                               isize)).condBlock).psDebug.offset(_dbEntry
                                                                                                                     as
                                                                                                                     isize)).line;
                                                    (*_psCurr).offset =
                                                        (*(*(*yyvsp.offset(0
                                                                               as
                                                                               libc::c_int
                                                                               as
                                                                               isize)).condBlock).psDebug.offset(_dbEntry
                                                                                                                     as
                                                                                                                     isize)).offset.wrapping_add((*(*yyvsp.offset(-(2
                                                                                                                                                                        as
                                                                                                                                                                        libc::c_int)
                                                                                                                                                                      as
                                                                                                                                                                      isize)).condBlock).size.wrapping_div(::std::mem::size_of::<UDWORD>()
                                                                                                                                                                                                               as
                                                                                                                                                                                                               libc::c_ulong));
                                                    _dbEntry =
                                                        _dbEntry.wrapping_add(1)
                                                }
                                                (*psCondBlock).debugEntries =
                                                    (*psCondBlock).debugEntries.wrapping_add((*(*yyvsp.offset(0
                                                                                                                  as
                                                                                                                  libc::c_int
                                                                                                                  as
                                                                                                                  isize)).condBlock).debugEntries)
                                                        as UWORD as UDWORD
                                            }
                                            if genDebugInfo != 0 {
                                                memFreeRelease((*(*yyvsp.offset(-(2
                                                                                      as
                                                                                      libc::c_int)
                                                                                    as
                                                                                    isize)).condBlock).psDebug
                                                                   as
                                                                   *mut libc::c_void);
                                                let ref mut fresh62 =
                                                    (*(*yyvsp.offset(-(2 as
                                                                           libc::c_int)
                                                                         as
                                                                         isize)).condBlock).psDebug;
                                                *fresh62 =
                                                    0 as *mut SCRIPT_DEBUG
                                            }
                                            if genDebugInfo != 0 {
                                                memFreeRelease((*(*yyvsp.offset(0
                                                                                    as
                                                                                    libc::c_int
                                                                                    as
                                                                                    isize)).condBlock).psDebug
                                                                   as
                                                                   *mut libc::c_void);
                                                let ref mut fresh63 =
                                                    (*(*yyvsp.offset(0 as
                                                                         libc::c_int
                                                                         as
                                                                         isize)).condBlock).psDebug;
                                                *fresh63 =
                                                    0 as *mut SCRIPT_DEBUG
                                            }
                                            memFreeRelease((*(*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).condBlock).aOffsets
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh64 =
                                                (*(*yyvsp.offset(-(2 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).condBlock).aOffsets;
                                            *fresh64 = 0 as *mut UDWORD;
                                            memFreeRelease((*(*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).condBlock).pCode
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh65 =
                                                (*(*yyvsp.offset(-(2 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).condBlock).pCode;
                                            *fresh65 = 0 as *mut UDWORD;
                                            memFreeRelease((*yyvsp.offset(-(2
                                                                                as
                                                                                libc::c_int)
                                                                              as
                                                                              isize)).condBlock
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh66 =
                                                (*yyvsp.offset(-(2 as
                                                                     libc::c_int)
                                                                   as
                                                                   isize)).condBlock;
                                            *fresh66 = 0 as *mut COND_BLOCK;
                                            memFreeRelease((*(*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).condBlock).aOffsets
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh67 =
                                                (*(*yyvsp.offset(0 as
                                                                     libc::c_int
                                                                     as
                                                                     isize)).condBlock).aOffsets;
                                            *fresh67 = 0 as *mut UDWORD;
                                            memFreeRelease((*(*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).condBlock).pCode
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh68 =
                                                (*(*yyvsp.offset(0 as
                                                                     libc::c_int
                                                                     as
                                                                     isize)).condBlock).pCode;
                                            *fresh68 = 0 as *mut UDWORD;
                                            memFreeRelease((*yyvsp.offset(0 as
                                                                              libc::c_int
                                                                              as
                                                                              isize)).condBlock
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh69 =
                                                (*yyvsp.offset(0 as
                                                                   libc::c_int
                                                                   as
                                                                   isize)).condBlock;
                                            *fresh69 = 0 as *mut COND_BLOCK;
                                            codeRet =
                                                scriptCodeConditional(psCondBlock,
                                                                      &mut psCurrBlock);
                                            if codeRet as libc::c_uint ==
                                                   CE_MEMORY as libc::c_int as
                                                       libc::c_uint {
                                                current_block =
                                                    10563765182283539921;
                                                break ;
                                            }
                                            if codeRet as libc::c_uint ==
                                                   CE_PARSE as libc::c_int as
                                                       libc::c_uint {
                                                current_block =
                                                    15438562788955825517;
                                            } else {
                                                yyval.cblock = psCurrBlock;
                                                current_block =
                                                    9320480655893135347;
                                            }
                                        }
                                    }
                                }
                            }
                            121 => {
                                yyval.condBlock =
                                    (*yyvsp.offset(0 as libc::c_int as
                                                       isize)).condBlock;
                                current_block = 9320480655893135347;
                            }
                            122 => {
                                psCondBlock =
                                    memMallocRelease(::std::mem::size_of::<COND_BLOCK>()
                                                         as libc::c_ulong) as
                                        *mut COND_BLOCK;
                                if psCondBlock.is_null() {
                                    debug(LOG_ERROR,
                                          b"Out of memory\x00" as *const u8 as
                                              *const libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCondBlock).aOffsets =
                                        memMallocRelease((::std::mem::size_of::<SDWORD>()
                                                              as
                                                              libc::c_ulong).wrapping_mul((*(*yyvsp.offset(-(2
                                                                                                                 as
                                                                                                                 libc::c_int)
                                                                                                               as
                                                                                                               isize)).condBlock).numOffsets.wrapping_add((*(*yyvsp.offset(0
                                                                                                                                                                               as
                                                                                                                                                                               libc::c_int
                                                                                                                                                                               as
                                                                                                                                                                               isize)).condBlock).numOffsets)))
                                            as *mut UDWORD;
                                    if (*psCondBlock).aOffsets.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCondBlock).pCode =
                                            memMallocRelease((*(*yyvsp.offset(-(2
                                                                                    as
                                                                                    libc::c_int)
                                                                                  as
                                                                                  isize)).condBlock).size.wrapping_add((*(*yyvsp.offset(0
                                                                                                                                            as
                                                                                                                                            libc::c_int
                                                                                                                                            as
                                                                                                                                            isize)).condBlock).size))
                                                as *mut UDWORD;
                                        if (*psCondBlock).pCode.is_null() {
                                            debug(LOG_ERROR,
                                                  b"Out of memory\x00" as
                                                      *const u8 as
                                                      *const libc::c_char);
                                            current_block =
                                                10563765182283539921;
                                            break ;
                                        } else {
                                            (*psCondBlock).size =
                                                (*(*yyvsp.offset(-(2 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).condBlock).size.wrapping_add((*(*yyvsp.offset(0
                                                                                                                               as
                                                                                                                               libc::c_int
                                                                                                                               as
                                                                                                                               isize)).condBlock).size);
                                            (*psCondBlock).numOffsets =
                                                (*(*yyvsp.offset(-(2 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).condBlock).numOffsets.wrapping_add((*(*yyvsp.offset(0
                                                                                                                                     as
                                                                                                                                     libc::c_int
                                                                                                                                     as
                                                                                                                                     isize)).condBlock).numOffsets);
                                            if genDebugInfo != 0 {
                                                (*psCondBlock).psDebug =
                                                    memMallocRelease((::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                          as
                                                                          libc::c_ulong).wrapping_mul((*(*yyvsp.offset(-(2
                                                                                                                             as
                                                                                                                             libc::c_int)
                                                                                                                           as
                                                                                                                           isize)).condBlock).debugEntries.wrapping_add((*(*yyvsp.offset(0
                                                                                                                                                                                             as
                                                                                                                                                                                             libc::c_int
                                                                                                                                                                                             as
                                                                                                                                                                                             isize)).condBlock).debugEntries)))
                                                        as *mut SCRIPT_DEBUG;
                                                if (*psCondBlock).psDebug.is_null()
                                                   {
                                                    scr_error(b"Out of memory\x00"
                                                                  as *const u8
                                                                  as
                                                                  *const libc::c_char
                                                                  as
                                                                  *mut libc::c_char);
                                                    current_block =
                                                        10563765182283539921;
                                                    break ;
                                                } else {
                                                    memset((*psCondBlock).psDebug
                                                               as
                                                               *mut libc::c_void,
                                                           0 as libc::c_int,
                                                           (::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                as
                                                                libc::c_ulong).wrapping_mul((*(*yyvsp.offset(-(2
                                                                                                                   as
                                                                                                                   libc::c_int)
                                                                                                                 as
                                                                                                                 isize)).condBlock).debugEntries.wrapping_add((*(*yyvsp.offset(0
                                                                                                                                                                                   as
                                                                                                                                                                                   libc::c_int
                                                                                                                                                                                   as
                                                                                                                                                                                   isize)).condBlock).debugEntries)));
                                                    (*psCondBlock).debugEntries
                                                        =
                                                        (*(*yyvsp.offset(-(2
                                                                               as
                                                                               libc::c_int)
                                                                             as
                                                                             isize)).condBlock).debugEntries.wrapping_add((*(*yyvsp.offset(0
                                                                                                                                               as
                                                                                                                                               libc::c_int
                                                                                                                                               as
                                                                                                                                               isize)).condBlock).debugEntries)
                                                            as UWORD as UDWORD
                                                }
                                            } else {
                                                (*psCondBlock).psDebug =
                                                    0 as *mut SCRIPT_DEBUG;
                                                (*psCondBlock).debugEntries =
                                                    0 as libc::c_int as UDWORD
                                            }
                                            ip = (*psCondBlock).pCode;
                                            memcpy(ip as *mut libc::c_void,
                                                   (*(*yyvsp.offset(-(2 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).condBlock).pCode
                                                       as *const libc::c_void,
                                                   (*(*yyvsp.offset(-(2 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).condBlock).size);
                                            ip =
                                                (ip as
                                                     *mut UBYTE).offset((*(*yyvsp.offset(-(2
                                                                                               as
                                                                                               libc::c_int)
                                                                                             as
                                                                                             isize)).condBlock).size
                                                                            as
                                                                            isize)
                                                    as *mut UDWORD;
                                            memcpy(ip as *mut libc::c_void,
                                                   (*(*yyvsp.offset(0 as
                                                                        libc::c_int
                                                                        as
                                                                        isize)).condBlock).pCode
                                                       as *const libc::c_void,
                                                   (*(*yyvsp.offset(0 as
                                                                        libc::c_int
                                                                        as
                                                                        isize)).condBlock).size);
                                            ip =
                                                (ip as
                                                     *mut UBYTE).offset((*(*yyvsp.offset(0
                                                                                             as
                                                                                             libc::c_int
                                                                                             as
                                                                                             isize)).condBlock).size
                                                                            as
                                                                            isize)
                                                    as *mut UDWORD;
                                            memcpy((*psCondBlock).aOffsets as
                                                       *mut libc::c_void,
                                                   (*(*yyvsp.offset(-(2 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).condBlock).aOffsets
                                                       as *const libc::c_void,
                                                   (*(*yyvsp.offset(-(2 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).condBlock).numOffsets.wrapping_mul(::std::mem::size_of::<SDWORD>()
                                                                                                                       as
                                                                                                                       libc::c_ulong));
                                            *(*psCondBlock).aOffsets.offset((*(*yyvsp.offset(-(2
                                                                                                   as
                                                                                                   libc::c_int)
                                                                                                 as
                                                                                                 isize)).condBlock).numOffsets
                                                                                as
                                                                                isize)
                                                =
                                                (*(*(*yyvsp.offset(0 as
                                                                       libc::c_int
                                                                       as
                                                                       isize)).condBlock).aOffsets.offset(0
                                                                                                              as
                                                                                                              libc::c_int
                                                                                                              as
                                                                                                              isize)).wrapping_add((*(*yyvsp.offset(-(2
                                                                                                                                                          as
                                                                                                                                                          libc::c_int)
                                                                                                                                                        as
                                                                                                                                                        isize)).condBlock).size.wrapping_div(::std::mem::size_of::<UDWORD>()
                                                                                                                                                                                                 as
                                                                                                                                                                                                 libc::c_ulong));
                                            (*psCondBlock).numOffsets =
                                                (*(*yyvsp.offset(-(2 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).condBlock).numOffsets.wrapping_add(1
                                                                                                                    as
                                                                                                                    libc::c_int
                                                                                                                    as
                                                                                                                    libc::c_uint);
                                            if genDebugInfo != 0 {
                                                memcpy((*psCondBlock).psDebug
                                                           as
                                                           *mut libc::c_void,
                                                       (*(*yyvsp.offset(-(2 as
                                                                              libc::c_int)
                                                                            as
                                                                            isize)).condBlock).psDebug
                                                           as
                                                           *const libc::c_void,
                                                       (::std::mem::size_of::<SCRIPT_DEBUG>()
                                                            as
                                                            libc::c_ulong).wrapping_mul((*(*yyvsp.offset(-(2
                                                                                                               as
                                                                                                               libc::c_int)
                                                                                                             as
                                                                                                             isize)).condBlock).debugEntries));
                                                (*psCondBlock).debugEntries =
                                                    (*(*yyvsp.offset(-(2 as
                                                                           libc::c_int)
                                                                         as
                                                                         isize)).condBlock).debugEntries
                                            }
                                            if genDebugInfo != 0 {
                                                _dbEntry =
                                                    0 as libc::c_int as
                                                        UDWORD;
                                                while _dbEntry <
                                                          (*(*yyvsp.offset(0
                                                                               as
                                                                               libc::c_int
                                                                               as
                                                                               isize)).condBlock).debugEntries
                                                      {
                                                    _psCurr =
                                                        (*psCondBlock).psDebug.offset((*psCondBlock).debugEntries
                                                                                          as
                                                                                          isize).offset(_dbEntry
                                                                                                            as
                                                                                                            isize);
                                                    (*_psCurr).line =
                                                        (*(*(*yyvsp.offset(0
                                                                               as
                                                                               libc::c_int
                                                                               as
                                                                               isize)).condBlock).psDebug.offset(_dbEntry
                                                                                                                     as
                                                                                                                     isize)).line;
                                                    (*_psCurr).offset =
                                                        (*(*(*yyvsp.offset(0
                                                                               as
                                                                               libc::c_int
                                                                               as
                                                                               isize)).condBlock).psDebug.offset(_dbEntry
                                                                                                                     as
                                                                                                                     isize)).offset.wrapping_add((*(*yyvsp.offset(-(2
                                                                                                                                                                        as
                                                                                                                                                                        libc::c_int)
                                                                                                                                                                      as
                                                                                                                                                                      isize)).condBlock).size.wrapping_div(::std::mem::size_of::<UDWORD>()
                                                                                                                                                                                                               as
                                                                                                                                                                                                               libc::c_ulong));
                                                    _dbEntry =
                                                        _dbEntry.wrapping_add(1)
                                                }
                                                (*psCondBlock).debugEntries =
                                                    (*psCondBlock).debugEntries.wrapping_add((*(*yyvsp.offset(0
                                                                                                                  as
                                                                                                                  libc::c_int
                                                                                                                  as
                                                                                                                  isize)).condBlock).debugEntries)
                                                        as UWORD as UDWORD
                                            }
                                            if genDebugInfo != 0 {
                                                memFreeRelease((*(*yyvsp.offset(-(2
                                                                                      as
                                                                                      libc::c_int)
                                                                                    as
                                                                                    isize)).condBlock).psDebug
                                                                   as
                                                                   *mut libc::c_void);
                                                let ref mut fresh70 =
                                                    (*(*yyvsp.offset(-(2 as
                                                                           libc::c_int)
                                                                         as
                                                                         isize)).condBlock).psDebug;
                                                *fresh70 =
                                                    0 as *mut SCRIPT_DEBUG
                                            }
                                            if genDebugInfo != 0 {
                                                memFreeRelease((*(*yyvsp.offset(0
                                                                                    as
                                                                                    libc::c_int
                                                                                    as
                                                                                    isize)).condBlock).psDebug
                                                                   as
                                                                   *mut libc::c_void);
                                                let ref mut fresh71 =
                                                    (*(*yyvsp.offset(0 as
                                                                         libc::c_int
                                                                         as
                                                                         isize)).condBlock).psDebug;
                                                *fresh71 =
                                                    0 as *mut SCRIPT_DEBUG
                                            }
                                            memFreeRelease((*(*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).condBlock).aOffsets
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh72 =
                                                (*(*yyvsp.offset(-(2 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).condBlock).aOffsets;
                                            *fresh72 = 0 as *mut UDWORD;
                                            memFreeRelease((*(*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).condBlock).pCode
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh73 =
                                                (*(*yyvsp.offset(-(2 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).condBlock).pCode;
                                            *fresh73 = 0 as *mut UDWORD;
                                            memFreeRelease((*yyvsp.offset(-(2
                                                                                as
                                                                                libc::c_int)
                                                                              as
                                                                              isize)).condBlock
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh74 =
                                                (*yyvsp.offset(-(2 as
                                                                     libc::c_int)
                                                                   as
                                                                   isize)).condBlock;
                                            *fresh74 = 0 as *mut COND_BLOCK;
                                            memFreeRelease((*(*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).condBlock).aOffsets
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh75 =
                                                (*(*yyvsp.offset(0 as
                                                                     libc::c_int
                                                                     as
                                                                     isize)).condBlock).aOffsets;
                                            *fresh75 = 0 as *mut UDWORD;
                                            memFreeRelease((*(*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).condBlock).pCode
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh76 =
                                                (*(*yyvsp.offset(0 as
                                                                     libc::c_int
                                                                     as
                                                                     isize)).condBlock).pCode;
                                            *fresh76 = 0 as *mut UDWORD;
                                            memFreeRelease((*yyvsp.offset(0 as
                                                                              libc::c_int
                                                                              as
                                                                              isize)).condBlock
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh77 =
                                                (*yyvsp.offset(0 as
                                                                   libc::c_int
                                                                   as
                                                                   isize)).condBlock;
                                            *fresh77 = 0 as *mut COND_BLOCK;
                                            yyval.condBlock = psCondBlock
                                        }
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            123 => {
                                psCondBlock =
                                    memMallocRelease(::std::mem::size_of::<COND_BLOCK>()
                                                         as libc::c_ulong) as
                                        *mut COND_BLOCK;
                                if psCondBlock.is_null() {
                                    debug(LOG_ERROR,
                                          b"Out of memory\x00" as *const u8 as
                                              *const libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCondBlock).aOffsets =
                                        memMallocRelease((::std::mem::size_of::<SDWORD>()
                                                              as
                                                              libc::c_ulong).wrapping_mul(1
                                                                                              as
                                                                                              libc::c_int
                                                                                              as
                                                                                              libc::c_uint))
                                            as *mut UDWORD;
                                    if (*psCondBlock).aOffsets.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCondBlock).pCode =
                                            memMallocRelease((*(*yyvsp.offset(-(1
                                                                                    as
                                                                                    libc::c_int)
                                                                                  as
                                                                                  isize)).cblock).size)
                                                as *mut UDWORD;
                                        if (*psCondBlock).pCode.is_null() {
                                            debug(LOG_ERROR,
                                                  b"Out of memory\x00" as
                                                      *const u8 as
                                                      *const libc::c_char);
                                            current_block =
                                                10563765182283539921;
                                            break ;
                                        } else {
                                            (*psCondBlock).size =
                                                (*(*yyvsp.offset(-(1 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).cblock).size;
                                            (*psCondBlock).numOffsets =
                                                1 as libc::c_int as UDWORD;
                                            if genDebugInfo != 0 {
                                                (*psCondBlock).psDebug =
                                                    memMallocRelease((::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                          as
                                                                          libc::c_ulong).wrapping_mul((*(*yyvsp.offset(-(1
                                                                                                                             as
                                                                                                                             libc::c_int)
                                                                                                                           as
                                                                                                                           isize)).cblock).debugEntries))
                                                        as *mut SCRIPT_DEBUG;
                                                if (*psCondBlock).psDebug.is_null()
                                                   {
                                                    scr_error(b"Out of memory\x00"
                                                                  as *const u8
                                                                  as
                                                                  *const libc::c_char
                                                                  as
                                                                  *mut libc::c_char);
                                                    current_block =
                                                        10563765182283539921;
                                                    break ;
                                                } else {
                                                    memset((*psCondBlock).psDebug
                                                               as
                                                               *mut libc::c_void,
                                                           0 as libc::c_int,
                                                           (::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                as
                                                                libc::c_ulong).wrapping_mul((*(*yyvsp.offset(-(1
                                                                                                                   as
                                                                                                                   libc::c_int)
                                                                                                                 as
                                                                                                                 isize)).cblock).debugEntries));
                                                    (*psCondBlock).debugEntries
                                                        =
                                                        (*(*yyvsp.offset(-(1
                                                                               as
                                                                               libc::c_int)
                                                                             as
                                                                             isize)).cblock).debugEntries
                                                            as UWORD as UDWORD
                                                }
                                            } else {
                                                (*psCondBlock).psDebug =
                                                    0 as *mut SCRIPT_DEBUG;
                                                (*psCondBlock).debugEntries =
                                                    0 as libc::c_int as UDWORD
                                            }
                                            ip = (*psCondBlock).pCode;
                                            if genDebugInfo != 0 {
                                                memcpy((*psCondBlock).psDebug
                                                           as
                                                           *mut libc::c_void,
                                                       (*(*yyvsp.offset(-(1 as
                                                                              libc::c_int)
                                                                            as
                                                                            isize)).cblock).psDebug
                                                           as
                                                           *const libc::c_void,
                                                       (::std::mem::size_of::<SCRIPT_DEBUG>()
                                                            as
                                                            libc::c_ulong).wrapping_mul((*(*yyvsp.offset(-(1
                                                                                                               as
                                                                                                               libc::c_int)
                                                                                                             as
                                                                                                             isize)).cblock).debugEntries));
                                                (*psCondBlock).debugEntries =
                                                    (*(*yyvsp.offset(-(1 as
                                                                           libc::c_int)
                                                                         as
                                                                         isize)).cblock).debugEntries
                                            }
                                            memcpy(ip as *mut libc::c_void,
                                                   (*(*yyvsp.offset(-(1 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).cblock).pCode
                                                       as *const libc::c_void,
                                                   (*(*yyvsp.offset(-(1 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).cblock).size);
                                            ip =
                                                (ip as
                                                     *mut UBYTE).offset((*(*yyvsp.offset(-(1
                                                                                               as
                                                                                               libc::c_int)
                                                                                             as
                                                                                             isize)).cblock).size
                                                                            as
                                                                            isize)
                                                    as *mut UDWORD;
                                            if genDebugInfo != 0 {
                                                memFreeRelease((*(*yyvsp.offset(-(1
                                                                                      as
                                                                                      libc::c_int)
                                                                                    as
                                                                                    isize)).cblock).psDebug
                                                                   as
                                                                   *mut libc::c_void);
                                                let ref mut fresh78 =
                                                    (*(*yyvsp.offset(-(1 as
                                                                           libc::c_int)
                                                                         as
                                                                         isize)).cblock).psDebug;
                                                *fresh78 =
                                                    0 as *mut SCRIPT_DEBUG
                                            }
                                            memFreeRelease((*(*yyvsp.offset(-(1
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cblock).pCode
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh79 =
                                                (*(*yyvsp.offset(-(1 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).cblock).pCode;
                                            *fresh79 = 0 as *mut UDWORD;
                                            memFreeRelease((*yyvsp.offset(-(1
                                                                                as
                                                                                libc::c_int)
                                                                              as
                                                                              isize)).cblock
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh80 =
                                                (*yyvsp.offset(-(1 as
                                                                     libc::c_int)
                                                                   as
                                                                   isize)).cblock;
                                            *fresh80 = 0 as *mut CODE_BLOCK;
                                            yyval.condBlock = psCondBlock
                                        }
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            124 => {
                                let mut pDummy_9: *mut STRING =
                                    0 as *mut STRING;
                                scriptGetErrorData(&mut debugLine as
                                                       *mut UDWORD as
                                                       *mut SDWORD,
                                                   &mut pDummy_9);
                                current_block = 9320480655893135347;
                            }
                            125 => {
                                psCondBlock =
                                    memMallocRelease(::std::mem::size_of::<COND_BLOCK>()
                                                         as libc::c_ulong) as
                                        *mut COND_BLOCK;
                                if psCondBlock.is_null() {
                                    debug(LOG_ERROR,
                                          b"Out of memory\x00" as *const u8 as
                                              *const libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCondBlock).aOffsets =
                                        memMallocRelease((::std::mem::size_of::<SDWORD>()
                                                              as
                                                              libc::c_ulong).wrapping_mul(1
                                                                                              as
                                                                                              libc::c_int
                                                                                              as
                                                                                              libc::c_uint))
                                            as *mut UDWORD;
                                    if (*psCondBlock).aOffsets.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCondBlock).pCode =
                                            memMallocRelease((*(*yyvsp.offset(-(5
                                                                                    as
                                                                                    libc::c_int)
                                                                                  as
                                                                                  isize)).cblock).size.wrapping_add((*(*yyvsp.offset(-(1
                                                                                                                                           as
                                                                                                                                           libc::c_int)
                                                                                                                                         as
                                                                                                                                         isize)).cblock).size).wrapping_add((::std::mem::size_of::<OPCODE>()
                                                                                                                                                                                 as
                                                                                                                                                                                 libc::c_ulong).wrapping_mul(2
                                                                                                                                                                                                                 as
                                                                                                                                                                                                                 libc::c_int
                                                                                                                                                                                                                 as
                                                                                                                                                                                                                 libc::c_uint)))
                                                as *mut UDWORD;
                                        if (*psCondBlock).pCode.is_null() {
                                            debug(LOG_ERROR,
                                                  b"Out of memory\x00" as
                                                      *const u8 as
                                                      *const libc::c_char);
                                            current_block =
                                                10563765182283539921;
                                            break ;
                                        } else {
                                            (*psCondBlock).size =
                                                (*(*yyvsp.offset(-(5 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).cblock).size.wrapping_add((*(*yyvsp.offset(-(1
                                                                                                                              as
                                                                                                                              libc::c_int)
                                                                                                                            as
                                                                                                                            isize)).cblock).size).wrapping_add((::std::mem::size_of::<OPCODE>()
                                                                                                                                                                    as
                                                                                                                                                                    libc::c_ulong).wrapping_mul(2
                                                                                                                                                                                                    as
                                                                                                                                                                                                    libc::c_int
                                                                                                                                                                                                    as
                                                                                                                                                                                                    libc::c_uint));
                                            (*psCondBlock).numOffsets =
                                                1 as libc::c_int as UDWORD;
                                            if genDebugInfo != 0 {
                                                (*psCondBlock).psDebug =
                                                    memMallocRelease((::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                          as
                                                                          libc::c_ulong).wrapping_mul((*(*yyvsp.offset(-(1
                                                                                                                             as
                                                                                                                             libc::c_int)
                                                                                                                           as
                                                                                                                           isize)).cblock).debugEntries.wrapping_add(1
                                                                                                                                                                         as
                                                                                                                                                                         libc::c_int
                                                                                                                                                                         as
                                                                                                                                                                         libc::c_uint)))
                                                        as *mut SCRIPT_DEBUG;
                                                if (*psCondBlock).psDebug.is_null()
                                                   {
                                                    scr_error(b"Out of memory\x00"
                                                                  as *const u8
                                                                  as
                                                                  *const libc::c_char
                                                                  as
                                                                  *mut libc::c_char);
                                                    current_block =
                                                        10563765182283539921;
                                                    break ;
                                                } else {
                                                    memset((*psCondBlock).psDebug
                                                               as
                                                               *mut libc::c_void,
                                                           0 as libc::c_int,
                                                           (::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                as
                                                                libc::c_ulong).wrapping_mul((*(*yyvsp.offset(-(1
                                                                                                                   as
                                                                                                                   libc::c_int)
                                                                                                                 as
                                                                                                                 isize)).cblock).debugEntries.wrapping_add(1
                                                                                                                                                               as
                                                                                                                                                               libc::c_int
                                                                                                                                                               as
                                                                                                                                                               libc::c_uint)));
                                                    (*psCondBlock).debugEntries
                                                        =
                                                        (*(*yyvsp.offset(-(1
                                                                               as
                                                                               libc::c_int)
                                                                             as
                                                                             isize)).cblock).debugEntries.wrapping_add(1
                                                                                                                           as
                                                                                                                           libc::c_int
                                                                                                                           as
                                                                                                                           libc::c_uint)
                                                            as UWORD as UDWORD
                                                }
                                            } else {
                                                (*psCondBlock).psDebug =
                                                    0 as *mut SCRIPT_DEBUG;
                                                (*psCondBlock).debugEntries =
                                                    0 as libc::c_int as UDWORD
                                            }
                                            ip = (*psCondBlock).pCode;
                                            memcpy(ip as *mut libc::c_void,
                                                   (*(*yyvsp.offset(-(5 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).cblock).pCode
                                                       as *const libc::c_void,
                                                   (*(*yyvsp.offset(-(5 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).cblock).size);
                                            ip =
                                                (ip as
                                                     *mut UBYTE).offset((*(*yyvsp.offset(-(5
                                                                                               as
                                                                                               libc::c_int)
                                                                                             as
                                                                                             isize)).cblock).size
                                                                            as
                                                                            isize)
                                                    as *mut UDWORD;
                                            memFreeRelease((*(*yyvsp.offset(-(5
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cblock).pCode
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh81 =
                                                (*(*yyvsp.offset(-(5 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).cblock).pCode;
                                            *fresh81 = 0 as *mut UDWORD;
                                            memFreeRelease((*yyvsp.offset(-(5
                                                                                as
                                                                                libc::c_int)
                                                                              as
                                                                              isize)).cblock
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh82 =
                                                (*yyvsp.offset(-(5 as
                                                                     libc::c_int)
                                                                   as
                                                                   isize)).cblock;
                                            *fresh82 = 0 as *mut CODE_BLOCK;
                                            *ip =
                                                (*(*yyvsp.offset(-(1 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).cblock).size.wrapping_div(::std::mem::size_of::<UDWORD>()
                                                                                                           as
                                                                                                           libc::c_ulong).wrapping_add(2
                                                                                                                                           as
                                                                                                                                           libc::c_int
                                                                                                                                           as
                                                                                                                                           libc::c_uint)
                                                    &
                                                    0xffffff as libc::c_int as
                                                        libc::c_uint;
                                            *ip =
                                                (OP_JUMPFALSE as libc::c_int
                                                     as UDWORD) <<
                                                    24 as libc::c_int | *ip;
                                            ip =
                                                ip.offset(1 as libc::c_int as
                                                              isize);
                                            if genDebugInfo != 0 {
                                                (*psCondBlock).debugEntries =
                                                    1 as libc::c_int as
                                                        UDWORD;
                                                (*(*psCondBlock).psDebug).line
                                                    = debugLine;
                                                (*(*psCondBlock).psDebug).offset
                                                    =
                                                    0 as libc::c_int as
                                                        UDWORD;
                                                if genDebugInfo != 0 {
                                                    _dbEntry =
                                                        0 as libc::c_int as
                                                            UDWORD;
                                                    while _dbEntry <
                                                              (*(*yyvsp.offset(-(1
                                                                                     as
                                                                                     libc::c_int)
                                                                                   as
                                                                                   isize)).cblock).debugEntries
                                                          {
                                                        _psCurr =
                                                            (*psCondBlock).psDebug.offset((*psCondBlock).debugEntries
                                                                                              as
                                                                                              isize).offset(_dbEntry
                                                                                                                as
                                                                                                                isize);
                                                        (*_psCurr).line =
                                                            (*(*(*yyvsp.offset(-(1
                                                                                     as
                                                                                     libc::c_int)
                                                                                   as
                                                                                   isize)).cblock).psDebug.offset(_dbEntry
                                                                                                                      as
                                                                                                                      isize)).line;
                                                        (*_psCurr).offset =
                                                            (*(*(*yyvsp.offset(-(1
                                                                                     as
                                                                                     libc::c_int)
                                                                                   as
                                                                                   isize)).cblock).psDebug.offset(_dbEntry
                                                                                                                      as
                                                                                                                      isize)).offset.wrapping_add(ip.wrapping_offset_from((*psCondBlock).pCode)
                                                                                                                                                      as
                                                                                                                                                      libc::c_int
                                                                                                                                                      as
                                                                                                                                                      libc::c_uint);
                                                        _dbEntry =
                                                            _dbEntry.wrapping_add(1)
                                                    }
                                                    (*psCondBlock).debugEntries
                                                        =
                                                        (*psCondBlock).debugEntries.wrapping_add((*(*yyvsp.offset(-(1
                                                                                                                        as
                                                                                                                        libc::c_int)
                                                                                                                      as
                                                                                                                      isize)).cblock).debugEntries)
                                                            as UWORD as UDWORD
                                                }
                                            }
                                            memcpy(ip as *mut libc::c_void,
                                                   (*(*yyvsp.offset(-(1 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).cblock).pCode
                                                       as *const libc::c_void,
                                                   (*(*yyvsp.offset(-(1 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).cblock).size);
                                            ip =
                                                (ip as
                                                     *mut UBYTE).offset((*(*yyvsp.offset(-(1
                                                                                               as
                                                                                               libc::c_int)
                                                                                             as
                                                                                             isize)).cblock).size
                                                                            as
                                                                            isize)
                                                    as *mut UDWORD;
                                            if genDebugInfo != 0 {
                                                memFreeRelease((*(*yyvsp.offset(-(1
                                                                                      as
                                                                                      libc::c_int)
                                                                                    as
                                                                                    isize)).cblock).psDebug
                                                                   as
                                                                   *mut libc::c_void);
                                                let ref mut fresh83 =
                                                    (*(*yyvsp.offset(-(1 as
                                                                           libc::c_int)
                                                                         as
                                                                         isize)).cblock).psDebug;
                                                *fresh83 =
                                                    0 as *mut SCRIPT_DEBUG
                                            }
                                            memFreeRelease((*(*yyvsp.offset(-(1
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cblock).pCode
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh84 =
                                                (*(*yyvsp.offset(-(1 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).cblock).pCode;
                                            *fresh84 = 0 as *mut UDWORD;
                                            memFreeRelease((*yyvsp.offset(-(1
                                                                                as
                                                                                libc::c_int)
                                                                              as
                                                                              isize)).cblock
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh85 =
                                                (*yyvsp.offset(-(1 as
                                                                     libc::c_int)
                                                                   as
                                                                   isize)).cblock;
                                            *fresh85 = 0 as *mut CODE_BLOCK;
                                            *(*psCondBlock).aOffsets.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)
                                                =
                                                ip.wrapping_offset_from((*psCondBlock).pCode)
                                                    as libc::c_int as UDWORD;
                                            *ip =
                                                0 as libc::c_int as UDWORD &
                                                    0xffffff as libc::c_int as
                                                        libc::c_uint;
                                            *ip =
                                                (OP_JUMP as libc::c_int as
                                                     UDWORD) <<
                                                    24 as libc::c_int | *ip;
                                            ip =
                                                ip.offset(1 as libc::c_int as
                                                              isize);
                                            yyval.condBlock = psCondBlock
                                        }
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            126 => {
                                let mut pDummy_10: *mut STRING =
                                    0 as *mut STRING;
                                scriptGetErrorData(&mut debugLine as
                                                       *mut UDWORD as
                                                       *mut SDWORD,
                                                   &mut pDummy_10);
                                current_block = 9320480655893135347;
                            }
                            127 => {
                                psCurrBlock =
                                    memMallocRelease(::std::mem::size_of::<CODE_BLOCK>()
                                                         as libc::c_ulong) as
                                        *mut CODE_BLOCK;
                                if psCurrBlock.is_null() {
                                    debug(LOG_ERROR,
                                          b"Out of memory\x00" as *const u8 as
                                              *const libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCurrBlock).pCode =
                                        memMallocRelease((*(*yyvsp.offset(-(5
                                                                                as
                                                                                libc::c_int)
                                                                              as
                                                                              isize)).cblock).size.wrapping_add((*(*yyvsp.offset(-(1
                                                                                                                                       as
                                                                                                                                       libc::c_int)
                                                                                                                                     as
                                                                                                                                     isize)).cblock).size).wrapping_add((::std::mem::size_of::<OPCODE>()
                                                                                                                                                                             as
                                                                                                                                                                             libc::c_ulong).wrapping_mul(2
                                                                                                                                                                                                             as
                                                                                                                                                                                                             libc::c_int
                                                                                                                                                                                                             as
                                                                                                                                                                                                             libc::c_uint)))
                                            as *mut UDWORD;
                                    if (*psCurrBlock).pCode.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        memFreeRelease(psCurrBlock as
                                                           *mut libc::c_void);
                                        psCurrBlock = 0 as *mut CODE_BLOCK;
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrBlock).size =
                                            (*(*yyvsp.offset(-(5 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).cblock).size.wrapping_add((*(*yyvsp.offset(-(1
                                                                                                                          as
                                                                                                                          libc::c_int)
                                                                                                                        as
                                                                                                                        isize)).cblock).size).wrapping_add((::std::mem::size_of::<OPCODE>()
                                                                                                                                                                as
                                                                                                                                                                libc::c_ulong).wrapping_mul(2
                                                                                                                                                                                                as
                                                                                                                                                                                                libc::c_int
                                                                                                                                                                                                as
                                                                                                                                                                                                libc::c_uint));
                                        if genDebugInfo != 0 {
                                            (*psCurrBlock).psDebug =
                                                memMallocRelease((::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                      as
                                                                      libc::c_ulong).wrapping_mul((*(*yyvsp.offset(-(1
                                                                                                                         as
                                                                                                                         libc::c_int)
                                                                                                                       as
                                                                                                                       isize)).cblock).debugEntries.wrapping_add(1
                                                                                                                                                                     as
                                                                                                                                                                     libc::c_int
                                                                                                                                                                     as
                                                                                                                                                                     libc::c_uint)))
                                                    as *mut SCRIPT_DEBUG;
                                            if (*psCurrBlock).psDebug.is_null()
                                               {
                                                scr_error(b"Out of memory\x00"
                                                              as *const u8 as
                                                              *const libc::c_char
                                                              as
                                                              *mut libc::c_char);
                                                current_block =
                                                    10563765182283539921;
                                                break ;
                                            } else {
                                                memset((*psCurrBlock).psDebug
                                                           as
                                                           *mut libc::c_void,
                                                       0 as libc::c_int,
                                                       (::std::mem::size_of::<SCRIPT_DEBUG>()
                                                            as
                                                            libc::c_ulong).wrapping_mul((*(*yyvsp.offset(-(1
                                                                                                               as
                                                                                                               libc::c_int)
                                                                                                             as
                                                                                                             isize)).cblock).debugEntries.wrapping_add(1
                                                                                                                                                           as
                                                                                                                                                           libc::c_int
                                                                                                                                                           as
                                                                                                                                                           libc::c_uint)));
                                                (*psCurrBlock).debugEntries =
                                                    (*(*yyvsp.offset(-(1 as
                                                                           libc::c_int)
                                                                         as
                                                                         isize)).cblock).debugEntries.wrapping_add(1
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       libc::c_uint)
                                                        as UWORD as UDWORD
                                            }
                                        } else {
                                            (*psCurrBlock).psDebug =
                                                0 as *mut SCRIPT_DEBUG;
                                            (*psCurrBlock).debugEntries =
                                                0 as libc::c_int as UDWORD
                                        }
                                        ip = (*psCurrBlock).pCode;
                                        memcpy(ip as *mut libc::c_void,
                                               (*(*yyvsp.offset(-(5 as
                                                                      libc::c_int)
                                                                    as
                                                                    isize)).cblock).pCode
                                                   as *const libc::c_void,
                                               (*(*yyvsp.offset(-(5 as
                                                                      libc::c_int)
                                                                    as
                                                                    isize)).cblock).size);
                                        ip =
                                            (ip as
                                                 *mut UBYTE).offset((*(*yyvsp.offset(-(5
                                                                                           as
                                                                                           libc::c_int)
                                                                                         as
                                                                                         isize)).cblock).size
                                                                        as
                                                                        isize)
                                                as *mut UDWORD;
                                        memFreeRelease((*(*yyvsp.offset(-(5 as
                                                                              libc::c_int)
                                                                            as
                                                                            isize)).cblock).pCode
                                                           as
                                                           *mut libc::c_void);
                                        let ref mut fresh86 =
                                            (*(*yyvsp.offset(-(5 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).cblock).pCode;
                                        *fresh86 = 0 as *mut UDWORD;
                                        memFreeRelease((*yyvsp.offset(-(5 as
                                                                            libc::c_int)
                                                                          as
                                                                          isize)).cblock
                                                           as
                                                           *mut libc::c_void);
                                        let ref mut fresh87 =
                                            (*yyvsp.offset(-(5 as libc::c_int)
                                                               as
                                                               isize)).cblock;
                                        *fresh87 = 0 as *mut CODE_BLOCK;
                                        *ip =
                                            (*(*yyvsp.offset(-(1 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).cblock).size.wrapping_div(::std::mem::size_of::<UDWORD>()
                                                                                                       as
                                                                                                       libc::c_ulong).wrapping_add(2
                                                                                                                                       as
                                                                                                                                       libc::c_int
                                                                                                                                       as
                                                                                                                                       libc::c_uint)
                                                &
                                                0xffffff as libc::c_int as
                                                    libc::c_uint;
                                        *ip =
                                            (OP_JUMPFALSE as libc::c_int as
                                                 UDWORD) << 24 as libc::c_int
                                                | *ip;
                                        ip =
                                            ip.offset(1 as libc::c_int as
                                                          isize);
                                        if genDebugInfo != 0 {
                                            (*psCurrBlock).debugEntries =
                                                1 as libc::c_int as UDWORD;
                                            (*(*psCurrBlock).psDebug).line =
                                                debugLine;
                                            (*(*psCurrBlock).psDebug).offset =
                                                0 as libc::c_int as UDWORD;
                                            if genDebugInfo != 0 {
                                                _dbEntry =
                                                    0 as libc::c_int as
                                                        UDWORD;
                                                while _dbEntry <
                                                          (*(*yyvsp.offset(-(1
                                                                                 as
                                                                                 libc::c_int)
                                                                               as
                                                                               isize)).cblock).debugEntries
                                                      {
                                                    _psCurr =
                                                        (*psCurrBlock).psDebug.offset((*psCurrBlock).debugEntries
                                                                                          as
                                                                                          isize).offset(_dbEntry
                                                                                                            as
                                                                                                            isize);
                                                    (*_psCurr).line =
                                                        (*(*(*yyvsp.offset(-(1
                                                                                 as
                                                                                 libc::c_int)
                                                                               as
                                                                               isize)).cblock).psDebug.offset(_dbEntry
                                                                                                                  as
                                                                                                                  isize)).line;
                                                    (*_psCurr).offset =
                                                        (*(*(*yyvsp.offset(-(1
                                                                                 as
                                                                                 libc::c_int)
                                                                               as
                                                                               isize)).cblock).psDebug.offset(_dbEntry
                                                                                                                  as
                                                                                                                  isize)).offset.wrapping_add(ip.wrapping_offset_from((*psCurrBlock).pCode)
                                                                                                                                                  as
                                                                                                                                                  libc::c_int
                                                                                                                                                  as
                                                                                                                                                  libc::c_uint);
                                                    _dbEntry =
                                                        _dbEntry.wrapping_add(1)
                                                }
                                                (*psCurrBlock).debugEntries =
                                                    (*psCurrBlock).debugEntries.wrapping_add((*(*yyvsp.offset(-(1
                                                                                                                    as
                                                                                                                    libc::c_int)
                                                                                                                  as
                                                                                                                  isize)).cblock).debugEntries)
                                                        as UWORD as UDWORD
                                            }
                                        }
                                        memcpy(ip as *mut libc::c_void,
                                               (*(*yyvsp.offset(-(1 as
                                                                      libc::c_int)
                                                                    as
                                                                    isize)).cblock).pCode
                                                   as *const libc::c_void,
                                               (*(*yyvsp.offset(-(1 as
                                                                      libc::c_int)
                                                                    as
                                                                    isize)).cblock).size);
                                        ip =
                                            (ip as
                                                 *mut UBYTE).offset((*(*yyvsp.offset(-(1
                                                                                           as
                                                                                           libc::c_int)
                                                                                         as
                                                                                         isize)).cblock).size
                                                                        as
                                                                        isize)
                                                as *mut UDWORD;
                                        if genDebugInfo != 0 {
                                            memFreeRelease((*(*yyvsp.offset(-(1
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cblock).psDebug
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh88 =
                                                (*(*yyvsp.offset(-(1 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).cblock).psDebug;
                                            *fresh88 = 0 as *mut SCRIPT_DEBUG
                                        }
                                        memFreeRelease((*(*yyvsp.offset(-(1 as
                                                                              libc::c_int)
                                                                            as
                                                                            isize)).cblock).pCode
                                                           as
                                                           *mut libc::c_void);
                                        let ref mut fresh89 =
                                            (*(*yyvsp.offset(-(1 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).cblock).pCode;
                                        *fresh89 = 0 as *mut UDWORD;
                                        memFreeRelease((*yyvsp.offset(-(1 as
                                                                            libc::c_int)
                                                                          as
                                                                          isize)).cblock
                                                           as
                                                           *mut libc::c_void);
                                        let ref mut fresh90 =
                                            (*yyvsp.offset(-(1 as libc::c_int)
                                                               as
                                                               isize)).cblock;
                                        *fresh90 = 0 as *mut CODE_BLOCK;
                                        *ip =
                                            (-((*psCurrBlock).size.wrapping_div(::std::mem::size_of::<UDWORD>()
                                                                                    as
                                                                                    libc::c_ulong)
                                                   as SWORD as libc::c_int) +
                                                 1 as libc::c_int) as SWORD as
                                                UDWORD &
                                                0xffffff as libc::c_int as
                                                    libc::c_uint;
                                        *ip =
                                            (OP_JUMP as libc::c_int as UDWORD)
                                                << 24 as libc::c_int | *ip;
                                        ip =
                                            ip.offset(1 as libc::c_int as
                                                          isize);
                                        yyval.cblock = psCurrBlock
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            128 => {
                                codeRet =
                                    scriptCodeBinaryOperator((*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cblock,
                                                             (*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).cblock,
                                                             OP_ADD,
                                                             &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            129 => {
                                codeRet =
                                    scriptCodeBinaryOperator((*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cblock,
                                                             (*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).cblock,
                                                             OP_SUB,
                                                             &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            130 => {
                                codeRet =
                                    scriptCodeBinaryOperator((*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cblock,
                                                             (*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).cblock,
                                                             OP_MUL,
                                                             &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            131 => {
                                codeRet =
                                    scriptCodeBinaryOperator((*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cblock,
                                                             (*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).cblock,
                                                             OP_DIV,
                                                             &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            132 => {
                                psCurrBlock =
                                    memMallocRelease(::std::mem::size_of::<CODE_BLOCK>()
                                                         as libc::c_ulong) as
                                        *mut CODE_BLOCK;
                                if psCurrBlock.is_null() {
                                    debug(LOG_ERROR,
                                          b"Out of memory\x00" as *const u8 as
                                              *const libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCurrBlock).pCode =
                                        memMallocRelease((*(*yyvsp.offset(0 as
                                                                              libc::c_int
                                                                              as
                                                                              isize)).cblock).size.wrapping_add(::std::mem::size_of::<OPCODE>()
                                                                                                                    as
                                                                                                                    libc::c_ulong))
                                            as *mut UDWORD;
                                    if (*psCurrBlock).pCode.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        memFreeRelease(psCurrBlock as
                                                           *mut libc::c_void);
                                        psCurrBlock = 0 as *mut CODE_BLOCK;
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrBlock).size =
                                            (*(*yyvsp.offset(0 as libc::c_int
                                                                 as
                                                                 isize)).cblock).size.wrapping_add(::std::mem::size_of::<OPCODE>()
                                                                                                       as
                                                                                                       libc::c_ulong);
                                        ip = (*psCurrBlock).pCode;
                                        memcpy(ip as *mut libc::c_void,
                                               (*(*yyvsp.offset(0 as
                                                                    libc::c_int
                                                                    as
                                                                    isize)).cblock).pCode
                                                   as *const libc::c_void,
                                               (*(*yyvsp.offset(0 as
                                                                    libc::c_int
                                                                    as
                                                                    isize)).cblock).size);
                                        ip =
                                            (ip as
                                                 *mut UBYTE).offset((*(*yyvsp.offset(0
                                                                                         as
                                                                                         libc::c_int
                                                                                         as
                                                                                         isize)).cblock).size
                                                                        as
                                                                        isize)
                                                as *mut UDWORD;
                                        *ip =
                                            OP_NEG as libc::c_int as UDWORD &
                                                0xffffff as libc::c_int as
                                                    libc::c_uint;
                                        *ip =
                                            (OP_UNARYOP as libc::c_int as
                                                 UDWORD) << 24 as libc::c_int
                                                | *ip;
                                        ip =
                                            ip.offset(1 as libc::c_int as
                                                          isize);
                                        memFreeRelease((*(*yyvsp.offset(0 as
                                                                            libc::c_int
                                                                            as
                                                                            isize)).cblock).pCode
                                                           as
                                                           *mut libc::c_void);
                                        let ref mut fresh91 =
                                            (*(*yyvsp.offset(0 as libc::c_int
                                                                 as
                                                                 isize)).cblock).pCode;
                                        *fresh91 = 0 as *mut UDWORD;
                                        memFreeRelease((*yyvsp.offset(0 as
                                                                          libc::c_int
                                                                          as
                                                                          isize)).cblock
                                                           as
                                                           *mut libc::c_void);
                                        let ref mut fresh92 =
                                            (*yyvsp.offset(0 as libc::c_int as
                                                               isize)).cblock;
                                        *fresh92 = 0 as *mut CODE_BLOCK;
                                        yyval.cblock = psCurrBlock
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            133 => {
                                yyval.cblock =
                                    (*yyvsp.offset(-(1 as libc::c_int) as
                                                       isize)).cblock;
                                current_block = 9320480655893135347;
                            }
                            134 => {
                                codeRet =
                                    scriptCodeFunction((*yyvsp.offset(-(3 as
                                                                            libc::c_int)
                                                                          as
                                                                          isize)).fSymbol,
                                                       (*yyvsp.offset(-(1 as
                                                                            libc::c_int)
                                                                          as
                                                                          isize)).pblock,
                                                       1 as libc::c_int,
                                                       &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            135 => {
                                let mut line_8: UDWORD = 0;
                                let mut paramNumber_0: UDWORD = 0;
                                let mut pDummy_11: *mut STRING =
                                    0 as *mut STRING;
                                if (*(*yyvsp.offset(-(1 as libc::c_int) as
                                                        isize)).pblock).numParams
                                       !=
                                       (*(*yyvsp.offset(-(3 as libc::c_int) as
                                                            isize)).eSymbol).numParams
                                   {
                                    debug(LOG_ERROR,
                                          b"Wrong number of arguments for function call: \'%s\'. Expected %d parameters instead of  %d.\x00"
                                              as *const u8 as
                                              *const libc::c_char,
                                          (*(*yyvsp.offset(-(3 as libc::c_int)
                                                               as
                                                               isize)).eSymbol).pIdent,
                                          (*(*yyvsp.offset(-(3 as libc::c_int)
                                                               as
                                                               isize)).eSymbol).numParams,
                                          (*(*yyvsp.offset(-(1 as libc::c_int)
                                                               as
                                                               isize)).pblock).numParams);
                                    scr_error(b"Wrong number of arguments in function call\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    return CE_PARSE as libc::c_int
                                }
                                if (*(*yyvsp.offset(-(3 as libc::c_int) as
                                                        isize)).eSymbol).bFunction
                                       == 0 {
                                    debug(LOG_ERROR,
                                          b"\'%s\' is not a function\x00" as
                                              *const u8 as
                                              *const libc::c_char,
                                          (*(*yyvsp.offset(-(3 as libc::c_int)
                                                               as
                                                               isize)).eSymbol).pIdent);
                                    scr_error(b"Can\'t cann an event\x00" as
                                                  *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    return CE_PARSE as libc::c_int
                                }
                                if (*(*yyvsp.offset(-(3 as libc::c_int) as
                                                        isize)).eSymbol).retType
                                       as libc::c_uint !=
                                       VAL_INT as libc::c_int as libc::c_uint
                                   {
                                    debug(LOG_ERROR,
                                          b"\'%s\' does not return an integer value\x00"
                                              as *const u8 as
                                              *const libc::c_char,
                                          (*(*yyvsp.offset(-(3 as libc::c_int)
                                                               as
                                                               isize)).eSymbol).pIdent);
                                    scr_error(b"assignment type conflict\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    return CE_PARSE as libc::c_int
                                }
                                paramNumber_0 =
                                    checkFuncParamTypes((*yyvsp.offset(-(3 as
                                                                             libc::c_int)
                                                                           as
                                                                           isize)).eSymbol,
                                                        (*yyvsp.offset(-(1 as
                                                                             libc::c_int)
                                                                           as
                                                                           isize)).pblock);
                                if paramNumber_0 >
                                       0 as libc::c_int as libc::c_uint {
                                    debug(LOG_ERROR,
                                          b"Parameter mismatch in function call: \'%s\'. Mismatch in parameter  %d.\x00"
                                              as *const u8 as
                                              *const libc::c_char,
                                          (*(*yyvsp.offset(-(3 as libc::c_int)
                                                               as
                                                               isize)).eSymbol).pIdent,
                                          paramNumber_0);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    psCurrBlock =
                                        memMallocRelease(::std::mem::size_of::<CODE_BLOCK>()
                                                             as libc::c_ulong)
                                            as *mut CODE_BLOCK;
                                    if psCurrBlock.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrBlock).pCode =
                                            memMallocRelease((*(*yyvsp.offset(-(1
                                                                                    as
                                                                                    libc::c_int)
                                                                                  as
                                                                                  isize)).pblock).size.wrapping_add(::std::mem::size_of::<OPCODE>()
                                                                                                                        as
                                                                                                                        libc::c_ulong).wrapping_add(::std::mem::size_of::<UDWORD>()
                                                                                                                                                        as
                                                                                                                                                        libc::c_ulong))
                                                as *mut UDWORD;
                                        if (*psCurrBlock).pCode.is_null() {
                                            debug(LOG_ERROR,
                                                  b"Out of memory\x00" as
                                                      *const u8 as
                                                      *const libc::c_char);
                                            memFreeRelease(psCurrBlock as
                                                               *mut libc::c_void);
                                            psCurrBlock =
                                                0 as *mut CODE_BLOCK;
                                            current_block =
                                                10563765182283539921;
                                            break ;
                                        } else {
                                            (*psCurrBlock).size =
                                                (*(*yyvsp.offset(-(1 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).pblock).size.wrapping_add(::std::mem::size_of::<OPCODE>()
                                                                                                           as
                                                                                                           libc::c_ulong).wrapping_add(::std::mem::size_of::<UDWORD>()
                                                                                                                                           as
                                                                                                                                           libc::c_ulong);
                                            if genDebugInfo != 0 {
                                                (*psCurrBlock).psDebug =
                                                    memMallocRelease((::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                          as
                                                                          libc::c_ulong).wrapping_mul(1
                                                                                                          as
                                                                                                          libc::c_int
                                                                                                          as
                                                                                                          libc::c_uint))
                                                        as *mut SCRIPT_DEBUG;
                                                if (*psCurrBlock).psDebug.is_null()
                                                   {
                                                    scr_error(b"Out of memory\x00"
                                                                  as *const u8
                                                                  as
                                                                  *const libc::c_char
                                                                  as
                                                                  *mut libc::c_char);
                                                    current_block =
                                                        10563765182283539921;
                                                    break ;
                                                } else {
                                                    memset((*psCurrBlock).psDebug
                                                               as
                                                               *mut libc::c_void,
                                                           0 as libc::c_int,
                                                           (::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                as
                                                                libc::c_ulong).wrapping_mul(1
                                                                                                as
                                                                                                libc::c_int
                                                                                                as
                                                                                                libc::c_uint));
                                                    (*psCurrBlock).debugEntries
                                                        =
                                                        1 as libc::c_int as
                                                            UWORD as UDWORD
                                                }
                                            } else {
                                                (*psCurrBlock).psDebug =
                                                    0 as *mut SCRIPT_DEBUG;
                                                (*psCurrBlock).debugEntries =
                                                    0 as libc::c_int as UDWORD
                                            }
                                            ip = (*psCurrBlock).pCode;
                                            if (*(*yyvsp.offset(-(1 as
                                                                      libc::c_int)
                                                                    as
                                                                    isize)).pblock).numParams
                                                   >
                                                   0 as libc::c_int as
                                                       libc::c_uint {
                                                memcpy(ip as
                                                           *mut libc::c_void,
                                                       (*(*yyvsp.offset(-(1 as
                                                                              libc::c_int)
                                                                            as
                                                                            isize)).pblock).pCode
                                                           as
                                                           *const libc::c_void,
                                                       (*(*yyvsp.offset(-(1 as
                                                                              libc::c_int)
                                                                            as
                                                                            isize)).pblock).size);
                                                ip =
                                                    (ip as
                                                         *mut UBYTE).offset((*(*yyvsp.offset(-(1
                                                                                                   as
                                                                                                   libc::c_int)
                                                                                                 as
                                                                                                 isize)).pblock).size
                                                                                as
                                                                                isize)
                                                        as *mut UDWORD;
                                                memFreeRelease((*(*yyvsp.offset(-(1
                                                                                      as
                                                                                      libc::c_int)
                                                                                    as
                                                                                    isize)).pblock).pCode
                                                                   as
                                                                   *mut libc::c_void);
                                                let ref mut fresh93 =
                                                    (*(*yyvsp.offset(-(1 as
                                                                           libc::c_int)
                                                                         as
                                                                         isize)).pblock).pCode;
                                                *fresh93 = 0 as *mut UDWORD;
                                                memFreeRelease((*(*yyvsp.offset(-(1
                                                                                      as
                                                                                      libc::c_int)
                                                                                    as
                                                                                    isize)).pblock).aParams
                                                                   as
                                                                   *mut libc::c_void);
                                                let ref mut fresh94 =
                                                    (*(*yyvsp.offset(-(1 as
                                                                           libc::c_int)
                                                                         as
                                                                         isize)).pblock).aParams;
                                                *fresh94 =
                                                    0 as *mut INTERP_TYPE;
                                                memFreeRelease((*yyvsp.offset(-(1
                                                                                    as
                                                                                    libc::c_int)
                                                                                  as
                                                                                  isize)).pblock
                                                                   as
                                                                   *mut libc::c_void);
                                                let ref mut fresh95 =
                                                    (*yyvsp.offset(-(1 as
                                                                         libc::c_int)
                                                                       as
                                                                       isize)).pblock;
                                                *fresh95 =
                                                    0 as *mut PARAM_BLOCK
                                            }
                                            *ip =
                                                ((OP_FUNC as libc::c_int) <<
                                                     24 as libc::c_int) as
                                                    UDWORD;
                                            ip =
                                                ip.offset(1 as libc::c_int as
                                                              isize);
                                            *ip =
                                                (*(*yyvsp.offset(-(3 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).eSymbol).index;
                                            ip =
                                                ip.offset(1 as libc::c_int as
                                                              isize);
                                            if genDebugInfo != 0 {
                                                (*(*psCurrBlock).psDebug.offset(0
                                                                                    as
                                                                                    libc::c_int
                                                                                    as
                                                                                    isize)).offset
                                                    =
                                                    0 as libc::c_int as
                                                        UDWORD;
                                                scriptGetErrorData(&mut line_8
                                                                       as
                                                                       *mut UDWORD
                                                                       as
                                                                       *mut SDWORD,
                                                                   &mut pDummy_11);
                                                (*(*psCurrBlock).psDebug.offset(0
                                                                                    as
                                                                                    libc::c_int
                                                                                    as
                                                                                    isize)).line
                                                    = line_8
                                            }
                                            yyval.cblock = psCurrBlock
                                        }
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            136 => {
                                codeRet =
                                    scriptCodeVarGet((*yyvsp.offset(0 as
                                                                        libc::c_int
                                                                        as
                                                                        isize)).vSymbol,
                                                     &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            137 => {
                                codeRet =
                                    scriptCodeConstant((*yyvsp.offset(0 as
                                                                          libc::c_int
                                                                          as
                                                                          isize)).cSymbol,
                                                       &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            138 => {
                                codeRet =
                                    scriptCodeObjGet((*yyvsp.offset(0 as
                                                                        libc::c_int
                                                                        as
                                                                        isize)).objVarBlock,
                                                     &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            139 => {
                                codeRet =
                                    scriptCodeArrayGet((*yyvsp.offset(0 as
                                                                          libc::c_int
                                                                          as
                                                                          isize)).arrayBlock,
                                                       &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            140 => {
                                psCurrBlock =
                                    memMallocRelease(::std::mem::size_of::<CODE_BLOCK>()
                                                         as libc::c_ulong) as
                                        *mut CODE_BLOCK;
                                if psCurrBlock.is_null() {
                                    debug(LOG_ERROR,
                                          b"Out of memory\x00" as *const u8 as
                                              *const libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCurrBlock).pCode =
                                        memMallocRelease((::std::mem::size_of::<OPCODE>()
                                                              as
                                                              libc::c_ulong).wrapping_add(::std::mem::size_of::<UDWORD>()
                                                                                              as
                                                                                              libc::c_ulong))
                                            as *mut UDWORD;
                                    if (*psCurrBlock).pCode.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        memFreeRelease(psCurrBlock as
                                                           *mut libc::c_void);
                                        psCurrBlock = 0 as *mut CODE_BLOCK;
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrBlock).size =
                                            (::std::mem::size_of::<OPCODE>()
                                                 as
                                                 libc::c_ulong).wrapping_add(::std::mem::size_of::<UDWORD>()
                                                                                 as
                                                                                 libc::c_ulong);
                                        ip = (*psCurrBlock).pCode;
                                        *ip =
                                            VAL_INT as libc::c_int as UDWORD &
                                                0xffffff as libc::c_int as
                                                    libc::c_uint;
                                        *ip =
                                            (OP_PUSH as libc::c_int as UDWORD)
                                                << 24 as libc::c_int | *ip;
                                        ip =
                                            ip.offset(1 as libc::c_int as
                                                          isize);
                                        *ip =
                                            (*yyvsp.offset(0 as libc::c_int as
                                                               isize)).ival as
                                                UDWORD;
                                        ip =
                                            ip.offset(1 as libc::c_int as
                                                          isize);
                                        yyval.cblock = psCurrBlock
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            141 => {
                                codeRet =
                                    scriptCodeBinaryOperator((*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cblock,
                                                             (*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).cblock,
                                                             OP_CANC,
                                                             &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            142 => {
                                codeRet =
                                    scriptCodeBinaryOperator((*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cblock,
                                                             (*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).cblock,
                                                             OP_CANC,
                                                             &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            143 => {
                                codeRet =
                                    scriptCodeBinaryOperator((*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cblock,
                                                             (*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).cblock,
                                                             OP_CANC,
                                                             &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            144 => {
                                yyval.cblock =
                                    (*yyvsp.offset(-(1 as libc::c_int) as
                                                       isize)).cblock;
                                current_block = 9320480655893135347;
                            }
                            145 => {
                                let mut line_9: UDWORD = 0;
                                let mut pDummy_12: *mut STRING =
                                    0 as *mut STRING;
                                if (*(*yyvsp.offset(-(1 as libc::c_int) as
                                                        isize)).pblock).numParams
                                       !=
                                       (*(*yyvsp.offset(-(3 as libc::c_int) as
                                                            isize)).eSymbol).numParams
                                   {
                                    debug(LOG_ERROR,
                                          b"Wrong number of arguments for function call: \'%s\'. Expected %d parameters instead of  %d.\x00"
                                              as *const u8 as
                                              *const libc::c_char,
                                          (*(*yyvsp.offset(-(3 as libc::c_int)
                                                               as
                                                               isize)).eSymbol).pIdent,
                                          (*(*yyvsp.offset(-(3 as libc::c_int)
                                                               as
                                                               isize)).eSymbol).numParams,
                                          (*(*yyvsp.offset(-(1 as libc::c_int)
                                                               as
                                                               isize)).pblock).numParams);
                                    scr_error(b"Wrong number of arguments in function call\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    return CE_PARSE as libc::c_int
                                }
                                if (*(*yyvsp.offset(-(3 as libc::c_int) as
                                                        isize)).eSymbol).bFunction
                                       == 0 {
                                    debug(LOG_ERROR,
                                          b"\'%s\' is not a function\x00" as
                                              *const u8 as
                                              *const libc::c_char,
                                          (*(*yyvsp.offset(-(3 as libc::c_int)
                                                               as
                                                               isize)).eSymbol).pIdent);
                                    scr_error(b"Can\'t cann an event\x00" as
                                                  *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    return CE_PARSE as libc::c_int
                                }
                                if (*(*yyvsp.offset(-(3 as libc::c_int) as
                                                        isize)).eSymbol).retType
                                       as libc::c_uint !=
                                       VAL_STRING as libc::c_int as
                                           libc::c_uint {
                                    debug(LOG_ERROR,
                                          b"\'%s\' does not return a string value\x00"
                                              as *const u8 as
                                              *const libc::c_char,
                                          (*(*yyvsp.offset(-(3 as libc::c_int)
                                                               as
                                                               isize)).eSymbol).pIdent);
                                    scr_error(b"assignment type conflict\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    return CE_PARSE as libc::c_int
                                }
                                psCurrBlock =
                                    memMallocRelease(::std::mem::size_of::<CODE_BLOCK>()
                                                         as libc::c_ulong) as
                                        *mut CODE_BLOCK;
                                if psCurrBlock.is_null() {
                                    debug(LOG_ERROR,
                                          b"Out of memory\x00" as *const u8 as
                                              *const libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCurrBlock).pCode =
                                        memMallocRelease((*(*yyvsp.offset(-(1
                                                                                as
                                                                                libc::c_int)
                                                                              as
                                                                              isize)).pblock).size.wrapping_add(::std::mem::size_of::<OPCODE>()
                                                                                                                    as
                                                                                                                    libc::c_ulong).wrapping_add(::std::mem::size_of::<UDWORD>()
                                                                                                                                                    as
                                                                                                                                                    libc::c_ulong))
                                            as *mut UDWORD;
                                    if (*psCurrBlock).pCode.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        memFreeRelease(psCurrBlock as
                                                           *mut libc::c_void);
                                        psCurrBlock = 0 as *mut CODE_BLOCK;
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrBlock).size =
                                            (*(*yyvsp.offset(-(1 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).pblock).size.wrapping_add(::std::mem::size_of::<OPCODE>()
                                                                                                       as
                                                                                                       libc::c_ulong).wrapping_add(::std::mem::size_of::<UDWORD>()
                                                                                                                                       as
                                                                                                                                       libc::c_ulong);
                                        if genDebugInfo != 0 {
                                            (*psCurrBlock).psDebug =
                                                memMallocRelease((::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                      as
                                                                      libc::c_ulong).wrapping_mul(1
                                                                                                      as
                                                                                                      libc::c_int
                                                                                                      as
                                                                                                      libc::c_uint))
                                                    as *mut SCRIPT_DEBUG;
                                            if (*psCurrBlock).psDebug.is_null()
                                               {
                                                scr_error(b"Out of memory\x00"
                                                              as *const u8 as
                                                              *const libc::c_char
                                                              as
                                                              *mut libc::c_char);
                                                current_block =
                                                    10563765182283539921;
                                                break ;
                                            } else {
                                                memset((*psCurrBlock).psDebug
                                                           as
                                                           *mut libc::c_void,
                                                       0 as libc::c_int,
                                                       (::std::mem::size_of::<SCRIPT_DEBUG>()
                                                            as
                                                            libc::c_ulong).wrapping_mul(1
                                                                                            as
                                                                                            libc::c_int
                                                                                            as
                                                                                            libc::c_uint));
                                                (*psCurrBlock).debugEntries =
                                                    1 as libc::c_int as UWORD
                                                        as UDWORD
                                            }
                                        } else {
                                            (*psCurrBlock).psDebug =
                                                0 as *mut SCRIPT_DEBUG;
                                            (*psCurrBlock).debugEntries =
                                                0 as libc::c_int as UDWORD
                                        }
                                        ip = (*psCurrBlock).pCode;
                                        if (*(*yyvsp.offset(-(1 as
                                                                  libc::c_int)
                                                                as
                                                                isize)).pblock).numParams
                                               >
                                               0 as libc::c_int as
                                                   libc::c_uint {
                                            memcpy(ip as *mut libc::c_void,
                                                   (*(*yyvsp.offset(-(1 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).pblock).pCode
                                                       as *const libc::c_void,
                                                   (*(*yyvsp.offset(-(1 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)).pblock).size);
                                            ip =
                                                (ip as
                                                     *mut UBYTE).offset((*(*yyvsp.offset(-(1
                                                                                               as
                                                                                               libc::c_int)
                                                                                             as
                                                                                             isize)).pblock).size
                                                                            as
                                                                            isize)
                                                    as *mut UDWORD;
                                            memFreeRelease((*(*yyvsp.offset(-(1
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).pblock).pCode
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh96 =
                                                (*(*yyvsp.offset(-(1 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).pblock).pCode;
                                            *fresh96 = 0 as *mut UDWORD;
                                            memFreeRelease((*(*yyvsp.offset(-(1
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).pblock).aParams
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh97 =
                                                (*(*yyvsp.offset(-(1 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).pblock).aParams;
                                            *fresh97 = 0 as *mut INTERP_TYPE;
                                            memFreeRelease((*yyvsp.offset(-(1
                                                                                as
                                                                                libc::c_int)
                                                                              as
                                                                              isize)).pblock
                                                               as
                                                               *mut libc::c_void);
                                            let ref mut fresh98 =
                                                (*yyvsp.offset(-(1 as
                                                                     libc::c_int)
                                                                   as
                                                                   isize)).pblock;
                                            *fresh98 = 0 as *mut PARAM_BLOCK
                                        }
                                        *ip =
                                            ((OP_FUNC as libc::c_int) <<
                                                 24 as libc::c_int) as UDWORD;
                                        ip =
                                            ip.offset(1 as libc::c_int as
                                                          isize);
                                        *ip =
                                            (*(*yyvsp.offset(-(3 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).eSymbol).index;
                                        ip =
                                            ip.offset(1 as libc::c_int as
                                                          isize);
                                        if genDebugInfo != 0 {
                                            (*(*psCurrBlock).psDebug.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).offset
                                                = 0 as libc::c_int as UDWORD;
                                            scriptGetErrorData(&mut line_9 as
                                                                   *mut UDWORD
                                                                   as
                                                                   *mut SDWORD,
                                                               &mut pDummy_12);
                                            (*(*psCurrBlock).psDebug.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).line
                                                = line_9
                                        }
                                        yyval.cblock = psCurrBlock
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            146 => {
                                codeRet =
                                    scriptCodeVarGet((*yyvsp.offset(0 as
                                                                        libc::c_int
                                                                        as
                                                                        isize)).vSymbol,
                                                     &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            147 => {
                                codeRet =
                                    scriptCodeVarGet((*yyvsp.offset(0 as
                                                                        libc::c_int
                                                                        as
                                                                        isize)).vSymbol,
                                                     &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            148 => {
                                psCurrBlock =
                                    memMallocRelease(::std::mem::size_of::<CODE_BLOCK>()
                                                         as libc::c_ulong) as
                                        *mut CODE_BLOCK;
                                if psCurrBlock.is_null() {
                                    debug(LOG_ERROR,
                                          b"Out of memory\x00" as *const u8 as
                                              *const libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCurrBlock).pCode =
                                        memMallocRelease((::std::mem::size_of::<OPCODE>()
                                                              as
                                                              libc::c_ulong).wrapping_add(::std::mem::size_of::<UDWORD>()
                                                                                              as
                                                                                              libc::c_ulong))
                                            as *mut UDWORD;
                                    if (*psCurrBlock).pCode.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        memFreeRelease(psCurrBlock as
                                                           *mut libc::c_void);
                                        psCurrBlock = 0 as *mut CODE_BLOCK;
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrBlock).size =
                                            (::std::mem::size_of::<OPCODE>()
                                                 as
                                                 libc::c_ulong).wrapping_add(::std::mem::size_of::<UDWORD>()
                                                                                 as
                                                                                 libc::c_ulong);
                                        ip = (*psCurrBlock).pCode;
                                        *ip =
                                            VAL_STRING as libc::c_int as
                                                UDWORD &
                                                0xffffff as libc::c_int as
                                                    libc::c_uint;
                                        *ip =
                                            (OP_PUSH as libc::c_int as UDWORD)
                                                << 24 as libc::c_int | *ip;
                                        ip =
                                            ip.offset(1 as libc::c_int as
                                                          isize);
                                        *ip =
                                            STRSTACK[CURSTACKSTR as
                                                         usize].as_mut_ptr()
                                                as UDWORD;
                                        ip =
                                            ip.offset(1 as libc::c_int as
                                                          isize);
                                        yyval.cblock = psCurrBlock;
                                        *STRSTACK[CURSTACKSTR as
                                                      usize].as_mut_ptr() =
                                            memMallocRelease(255 as
                                                                 libc::c_int
                                                                 as size_t) as
                                                libc::c_char;
                                        widgCopyString(STRSTACK[CURSTACKSTR as
                                                                    usize].as_mut_ptr(),
                                                       (*yyvsp.offset(0 as
                                                                          libc::c_int
                                                                          as
                                                                          isize)).sval);
                                        CURSTACKSTR =
                                            CURSTACKSTR.wrapping_add(1 as
                                                                         libc::c_int
                                                                         as
                                                                         libc::c_uint)
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            149 => {
                                psCurrBlock =
                                    memMallocRelease(::std::mem::size_of::<CODE_BLOCK>()
                                                         as libc::c_ulong) as
                                        *mut CODE_BLOCK;
                                if psCurrBlock.is_null() {
                                    debug(LOG_ERROR,
                                          b"Out of memory\x00" as *const u8 as
                                              *const libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCurrBlock).pCode =
                                        memMallocRelease((::std::mem::size_of::<OPCODE>()
                                                              as
                                                              libc::c_ulong).wrapping_add(::std::mem::size_of::<UDWORD>()
                                                                                              as
                                                                                              libc::c_ulong))
                                            as *mut UDWORD;
                                    if (*psCurrBlock).pCode.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        memFreeRelease(psCurrBlock as
                                                           *mut libc::c_void);
                                        psCurrBlock = 0 as *mut CODE_BLOCK;
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrBlock).size =
                                            (::std::mem::size_of::<OPCODE>()
                                                 as
                                                 libc::c_ulong).wrapping_add(::std::mem::size_of::<UDWORD>()
                                                                                 as
                                                                                 libc::c_ulong);
                                        ip = (*psCurrBlock).pCode;
                                        *ip =
                                            VAL_INT as libc::c_int as UDWORD &
                                                0xffffff as libc::c_int as
                                                    libc::c_uint;
                                        *ip =
                                            (OP_PUSH as libc::c_int as UDWORD)
                                                << 24 as libc::c_int | *ip;
                                        ip =
                                            ip.offset(1 as libc::c_int as
                                                          isize);
                                        *ip =
                                            (*yyvsp.offset(0 as libc::c_int as
                                                               isize)).ival as
                                                UDWORD;
                                        ip =
                                            ip.offset(1 as libc::c_int as
                                                          isize);
                                        yyval.cblock = psCurrBlock
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            150 => {
                                codeRet =
                                    scriptCodeBinaryOperator((*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cblock,
                                                             (*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).cblock,
                                                             OP_AND,
                                                             &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            151 => {
                                codeRet =
                                    scriptCodeBinaryOperator((*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cblock,
                                                             (*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).cblock,
                                                             OP_OR,
                                                             &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            152 => {
                                codeRet =
                                    scriptCodeBinaryOperator((*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cblock,
                                                             (*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).cblock,
                                                             OP_EQUAL,
                                                             &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            153 => {
                                codeRet =
                                    scriptCodeBinaryOperator((*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cblock,
                                                             (*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).cblock,
                                                             OP_NOTEQUAL,
                                                             &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            154 => {
                                psCurrBlock =
                                    memMallocRelease(::std::mem::size_of::<CODE_BLOCK>()
                                                         as libc::c_ulong) as
                                        *mut CODE_BLOCK;
                                if psCurrBlock.is_null() {
                                    debug(LOG_ERROR,
                                          b"Out of memory\x00" as *const u8 as
                                              *const libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCurrBlock).pCode =
                                        memMallocRelease((*(*yyvsp.offset(0 as
                                                                              libc::c_int
                                                                              as
                                                                              isize)).cblock).size.wrapping_add(::std::mem::size_of::<OPCODE>()
                                                                                                                    as
                                                                                                                    libc::c_ulong))
                                            as *mut UDWORD;
                                    if (*psCurrBlock).pCode.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        memFreeRelease(psCurrBlock as
                                                           *mut libc::c_void);
                                        psCurrBlock = 0 as *mut CODE_BLOCK;
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrBlock).size =
                                            (*(*yyvsp.offset(0 as libc::c_int
                                                                 as
                                                                 isize)).cblock).size.wrapping_add(::std::mem::size_of::<OPCODE>()
                                                                                                       as
                                                                                                       libc::c_ulong);
                                        ip = (*psCurrBlock).pCode;
                                        memcpy(ip as *mut libc::c_void,
                                               (*(*yyvsp.offset(0 as
                                                                    libc::c_int
                                                                    as
                                                                    isize)).cblock).pCode
                                                   as *const libc::c_void,
                                               (*(*yyvsp.offset(0 as
                                                                    libc::c_int
                                                                    as
                                                                    isize)).cblock).size);
                                        ip =
                                            (ip as
                                                 *mut UBYTE).offset((*(*yyvsp.offset(0
                                                                                         as
                                                                                         libc::c_int
                                                                                         as
                                                                                         isize)).cblock).size
                                                                        as
                                                                        isize)
                                                as *mut UDWORD;
                                        *ip =
                                            OP_NOT as libc::c_int as UDWORD &
                                                0xffffff as libc::c_int as
                                                    libc::c_uint;
                                        *ip =
                                            (OP_UNARYOP as libc::c_int as
                                                 UDWORD) << 24 as libc::c_int
                                                | *ip;
                                        ip =
                                            ip.offset(1 as libc::c_int as
                                                          isize);
                                        memFreeRelease((*(*yyvsp.offset(0 as
                                                                            libc::c_int
                                                                            as
                                                                            isize)).cblock).pCode
                                                           as
                                                           *mut libc::c_void);
                                        let ref mut fresh99 =
                                            (*(*yyvsp.offset(0 as libc::c_int
                                                                 as
                                                                 isize)).cblock).pCode;
                                        *fresh99 = 0 as *mut UDWORD;
                                        memFreeRelease((*yyvsp.offset(0 as
                                                                          libc::c_int
                                                                          as
                                                                          isize)).cblock
                                                           as
                                                           *mut libc::c_void);
                                        let ref mut fresh100 =
                                            (*yyvsp.offset(0 as libc::c_int as
                                                               isize)).cblock;
                                        *fresh100 = 0 as *mut CODE_BLOCK;
                                        yyval.cblock = psCurrBlock
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            155 => {
                                yyval.cblock =
                                    (*yyvsp.offset(-(1 as libc::c_int) as
                                                       isize)).cblock;
                                current_block = 9320480655893135347;
                            }
                            156 => {
                                codeRet =
                                    scriptCodeFunction((*yyvsp.offset(-(3 as
                                                                            libc::c_int)
                                                                          as
                                                                          isize)).fSymbol,
                                                       (*yyvsp.offset(-(1 as
                                                                            libc::c_int)
                                                                          as
                                                                          isize)).pblock,
                                                       1 as libc::c_int,
                                                       &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            157 => {
                                let mut line_10: UDWORD = 0;
                                let mut paramNumber_1: UDWORD = 0;
                                let mut pDummy_13: *mut STRING =
                                    0 as *mut STRING;
                                if (*(*yyvsp.offset(-(1 as libc::c_int) as
                                                        isize)).pblock).numParams
                                       !=
                                       (*(*yyvsp.offset(-(3 as libc::c_int) as
                                                            isize)).eSymbol).numParams
                                   {
                                    debug(LOG_ERROR,
                                          b"Wrong number of arguments for function call: \'%s\'. Expected %d parameters instead of  %d.\x00"
                                              as *const u8 as
                                              *const libc::c_char,
                                          (*(*yyvsp.offset(-(3 as libc::c_int)
                                                               as
                                                               isize)).eSymbol).pIdent,
                                          (*(*yyvsp.offset(-(3 as libc::c_int)
                                                               as
                                                               isize)).eSymbol).numParams,
                                          (*(*yyvsp.offset(-(1 as libc::c_int)
                                                               as
                                                               isize)).pblock).numParams);
                                    scr_error(b"Wrong number of arguments in function call\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    return CE_PARSE as libc::c_int
                                }
                                if (*(*yyvsp.offset(-(3 as libc::c_int) as
                                                        isize)).eSymbol).bFunction
                                       == 0 {
                                    debug(LOG_ERROR,
                                          b"\'%s\' is not a function\x00" as
                                              *const u8 as
                                              *const libc::c_char,
                                          (*(*yyvsp.offset(-(3 as libc::c_int)
                                                               as
                                                               isize)).eSymbol).pIdent);
                                    scr_error(b"Can\'t cann an event\x00" as
                                                  *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    return CE_PARSE as libc::c_int
                                }
                                if (*(*yyvsp.offset(-(3 as libc::c_int) as
                                                        isize)).eSymbol).retType
                                       as libc::c_uint !=
                                       VAL_BOOL as libc::c_int as libc::c_uint
                                   {
                                    debug(LOG_ERROR,
                                          b"\'%s\' does not return a boolean value\x00"
                                              as *const u8 as
                                              *const libc::c_char,
                                          (*(*yyvsp.offset(-(3 as libc::c_int)
                                                               as
                                                               isize)).eSymbol).pIdent);
                                    scr_error(b"assignment type conflict\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    return CE_PARSE as libc::c_int
                                }
                                paramNumber_1 =
                                    checkFuncParamTypes((*yyvsp.offset(-(3 as
                                                                             libc::c_int)
                                                                           as
                                                                           isize)).eSymbol,
                                                        (*yyvsp.offset(-(1 as
                                                                             libc::c_int)
                                                                           as
                                                                           isize)).pblock);
                                if paramNumber_1 >
                                       0 as libc::c_int as libc::c_uint {
                                    debug(LOG_ERROR,
                                          b"Parameter mismatch in function call: \'%s\'. Mismatch in parameter  %d.\x00"
                                              as *const u8 as
                                              *const libc::c_char,
                                          (*(*yyvsp.offset(-(3 as libc::c_int)
                                                               as
                                                               isize)).eSymbol).pIdent,
                                          paramNumber_1);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    psCurrBlock =
                                        memMallocRelease(::std::mem::size_of::<CODE_BLOCK>()
                                                             as libc::c_ulong)
                                            as *mut CODE_BLOCK;
                                    if psCurrBlock.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrBlock).pCode =
                                            memMallocRelease((*(*yyvsp.offset(-(1
                                                                                    as
                                                                                    libc::c_int)
                                                                                  as
                                                                                  isize)).pblock).size.wrapping_add(::std::mem::size_of::<OPCODE>()
                                                                                                                        as
                                                                                                                        libc::c_ulong).wrapping_add(::std::mem::size_of::<UDWORD>()
                                                                                                                                                        as
                                                                                                                                                        libc::c_ulong))
                                                as *mut UDWORD;
                                        if (*psCurrBlock).pCode.is_null() {
                                            debug(LOG_ERROR,
                                                  b"Out of memory\x00" as
                                                      *const u8 as
                                                      *const libc::c_char);
                                            memFreeRelease(psCurrBlock as
                                                               *mut libc::c_void);
                                            psCurrBlock =
                                                0 as *mut CODE_BLOCK;
                                            current_block =
                                                10563765182283539921;
                                            break ;
                                        } else {
                                            (*psCurrBlock).size =
                                                (*(*yyvsp.offset(-(1 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).pblock).size.wrapping_add(::std::mem::size_of::<OPCODE>()
                                                                                                           as
                                                                                                           libc::c_ulong).wrapping_add(::std::mem::size_of::<UDWORD>()
                                                                                                                                           as
                                                                                                                                           libc::c_ulong);
                                            if genDebugInfo != 0 {
                                                (*psCurrBlock).psDebug =
                                                    memMallocRelease((::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                          as
                                                                          libc::c_ulong).wrapping_mul(1
                                                                                                          as
                                                                                                          libc::c_int
                                                                                                          as
                                                                                                          libc::c_uint))
                                                        as *mut SCRIPT_DEBUG;
                                                if (*psCurrBlock).psDebug.is_null()
                                                   {
                                                    scr_error(b"Out of memory\x00"
                                                                  as *const u8
                                                                  as
                                                                  *const libc::c_char
                                                                  as
                                                                  *mut libc::c_char);
                                                    current_block =
                                                        10563765182283539921;
                                                    break ;
                                                } else {
                                                    memset((*psCurrBlock).psDebug
                                                               as
                                                               *mut libc::c_void,
                                                           0 as libc::c_int,
                                                           (::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                as
                                                                libc::c_ulong).wrapping_mul(1
                                                                                                as
                                                                                                libc::c_int
                                                                                                as
                                                                                                libc::c_uint));
                                                    (*psCurrBlock).debugEntries
                                                        =
                                                        1 as libc::c_int as
                                                            UWORD as UDWORD
                                                }
                                            } else {
                                                (*psCurrBlock).psDebug =
                                                    0 as *mut SCRIPT_DEBUG;
                                                (*psCurrBlock).debugEntries =
                                                    0 as libc::c_int as UDWORD
                                            }
                                            ip = (*psCurrBlock).pCode;
                                            if (*(*yyvsp.offset(-(1 as
                                                                      libc::c_int)
                                                                    as
                                                                    isize)).pblock).numParams
                                                   >
                                                   0 as libc::c_int as
                                                       libc::c_uint {
                                                memcpy(ip as
                                                           *mut libc::c_void,
                                                       (*(*yyvsp.offset(-(1 as
                                                                              libc::c_int)
                                                                            as
                                                                            isize)).pblock).pCode
                                                           as
                                                           *const libc::c_void,
                                                       (*(*yyvsp.offset(-(1 as
                                                                              libc::c_int)
                                                                            as
                                                                            isize)).pblock).size);
                                                ip =
                                                    (ip as
                                                         *mut UBYTE).offset((*(*yyvsp.offset(-(1
                                                                                                   as
                                                                                                   libc::c_int)
                                                                                                 as
                                                                                                 isize)).pblock).size
                                                                                as
                                                                                isize)
                                                        as *mut UDWORD;
                                                memFreeRelease((*(*yyvsp.offset(-(1
                                                                                      as
                                                                                      libc::c_int)
                                                                                    as
                                                                                    isize)).pblock).pCode
                                                                   as
                                                                   *mut libc::c_void);
                                                let ref mut fresh101 =
                                                    (*(*yyvsp.offset(-(1 as
                                                                           libc::c_int)
                                                                         as
                                                                         isize)).pblock).pCode;
                                                *fresh101 = 0 as *mut UDWORD;
                                                memFreeRelease((*(*yyvsp.offset(-(1
                                                                                      as
                                                                                      libc::c_int)
                                                                                    as
                                                                                    isize)).pblock).aParams
                                                                   as
                                                                   *mut libc::c_void);
                                                let ref mut fresh102 =
                                                    (*(*yyvsp.offset(-(1 as
                                                                           libc::c_int)
                                                                         as
                                                                         isize)).pblock).aParams;
                                                *fresh102 =
                                                    0 as *mut INTERP_TYPE;
                                                memFreeRelease((*yyvsp.offset(-(1
                                                                                    as
                                                                                    libc::c_int)
                                                                                  as
                                                                                  isize)).pblock
                                                                   as
                                                                   *mut libc::c_void);
                                                let ref mut fresh103 =
                                                    (*yyvsp.offset(-(1 as
                                                                         libc::c_int)
                                                                       as
                                                                       isize)).pblock;
                                                *fresh103 =
                                                    0 as *mut PARAM_BLOCK
                                            }
                                            *ip =
                                                ((OP_FUNC as libc::c_int) <<
                                                     24 as libc::c_int) as
                                                    UDWORD;
                                            ip =
                                                ip.offset(1 as libc::c_int as
                                                              isize);
                                            *ip =
                                                (*(*yyvsp.offset(-(3 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).eSymbol).index;
                                            ip =
                                                ip.offset(1 as libc::c_int as
                                                              isize);
                                            if genDebugInfo != 0 {
                                                (*(*psCurrBlock).psDebug.offset(0
                                                                                    as
                                                                                    libc::c_int
                                                                                    as
                                                                                    isize)).offset
                                                    =
                                                    0 as libc::c_int as
                                                        UDWORD;
                                                scriptGetErrorData(&mut line_10
                                                                       as
                                                                       *mut UDWORD
                                                                       as
                                                                       *mut SDWORD,
                                                                   &mut pDummy_13);
                                                (*(*psCurrBlock).psDebug.offset(0
                                                                                    as
                                                                                    libc::c_int
                                                                                    as
                                                                                    isize)).line
                                                    = line_10
                                            }
                                            yyval.cblock = psCurrBlock
                                        }
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            158 => {
                                codeRet =
                                    scriptCodeVarGet((*yyvsp.offset(0 as
                                                                        libc::c_int
                                                                        as
                                                                        isize)).vSymbol,
                                                     &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            159 => {
                                codeRet =
                                    scriptCodeConstant((*yyvsp.offset(0 as
                                                                          libc::c_int
                                                                          as
                                                                          isize)).cSymbol,
                                                       &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            160 => {
                                codeRet =
                                    scriptCodeObjGet((*yyvsp.offset(0 as
                                                                        libc::c_int
                                                                        as
                                                                        isize)).objVarBlock,
                                                     &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            161 => {
                                codeRet =
                                    scriptCodeArrayGet((*yyvsp.offset(0 as
                                                                          libc::c_int
                                                                          as
                                                                          isize)).arrayBlock,
                                                       &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            162 => {
                                psCurrBlock =
                                    memMallocRelease(::std::mem::size_of::<CODE_BLOCK>()
                                                         as libc::c_ulong) as
                                        *mut CODE_BLOCK;
                                if psCurrBlock.is_null() {
                                    debug(LOG_ERROR,
                                          b"Out of memory\x00" as *const u8 as
                                              *const libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCurrBlock).pCode =
                                        memMallocRelease((::std::mem::size_of::<OPCODE>()
                                                              as
                                                              libc::c_ulong).wrapping_add(::std::mem::size_of::<UDWORD>()
                                                                                              as
                                                                                              libc::c_ulong))
                                            as *mut UDWORD;
                                    if (*psCurrBlock).pCode.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        memFreeRelease(psCurrBlock as
                                                           *mut libc::c_void);
                                        psCurrBlock = 0 as *mut CODE_BLOCK;
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrBlock).size =
                                            (::std::mem::size_of::<OPCODE>()
                                                 as
                                                 libc::c_ulong).wrapping_add(::std::mem::size_of::<UDWORD>()
                                                                                 as
                                                                                 libc::c_ulong);
                                        ip = (*psCurrBlock).pCode;
                                        *ip =
                                            VAL_BOOL as libc::c_int as UDWORD
                                                &
                                                0xffffff as libc::c_int as
                                                    libc::c_uint;
                                        *ip =
                                            (OP_PUSH as libc::c_int as UDWORD)
                                                << 24 as libc::c_int | *ip;
                                        ip =
                                            ip.offset(1 as libc::c_int as
                                                          isize);
                                        *ip =
                                            (*yyvsp.offset(0 as libc::c_int as
                                                               isize)).bval as
                                                UDWORD;
                                        ip =
                                            ip.offset(1 as libc::c_int as
                                                          isize);
                                        yyval.cblock = psCurrBlock
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            163 => {
                                codeRet =
                                    scriptCodeBinaryOperator((*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cblock,
                                                             (*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).cblock,
                                                             OP_EQUAL,
                                                             &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            164 => {
                                if interpCheckEquiv((*(*yyvsp.offset(-(2 as
                                                                           libc::c_int)
                                                                         as
                                                                         isize)).cblock).type_0,
                                                    (*(*yyvsp.offset(0 as
                                                                         libc::c_int
                                                                         as
                                                                         isize)).cblock).type_0)
                                       == 0 {
                                    scr_error(b"Type mismatch for equality\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    codeRet =
                                        scriptCodeBinaryOperator((*yyvsp.offset(-(2
                                                                                      as
                                                                                      libc::c_int)
                                                                                    as
                                                                                    isize)).cblock,
                                                                 (*yyvsp.offset(0
                                                                                    as
                                                                                    libc::c_int
                                                                                    as
                                                                                    isize)).cblock,
                                                                 OP_EQUAL,
                                                                 &mut psCurrBlock);
                                    if codeRet as libc::c_uint ==
                                           CE_MEMORY as libc::c_int as
                                               libc::c_uint {
                                        current_block = 10563765182283539921;
                                        break ;
                                    }
                                    if codeRet as libc::c_uint ==
                                           CE_PARSE as libc::c_int as
                                               libc::c_uint {
                                        current_block = 15438562788955825517;
                                    } else {
                                        yyval.cblock = psCurrBlock;
                                        current_block = 9320480655893135347;
                                    }
                                }
                            }
                            165 => {
                                if interpCheckEquiv((*(*yyvsp.offset(-(2 as
                                                                           libc::c_int)
                                                                         as
                                                                         isize)).cblock).type_0,
                                                    (*(*yyvsp.offset(0 as
                                                                         libc::c_int
                                                                         as
                                                                         isize)).cblock).type_0)
                                       == 0 {
                                    scr_error(b"Type mismatch for equality\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    codeRet =
                                        scriptCodeBinaryOperator((*yyvsp.offset(-(2
                                                                                      as
                                                                                      libc::c_int)
                                                                                    as
                                                                                    isize)).cblock,
                                                                 (*yyvsp.offset(0
                                                                                    as
                                                                                    libc::c_int
                                                                                    as
                                                                                    isize)).cblock,
                                                                 OP_EQUAL,
                                                                 &mut psCurrBlock);
                                    if codeRet as libc::c_uint ==
                                           CE_MEMORY as libc::c_int as
                                               libc::c_uint {
                                        current_block = 10563765182283539921;
                                        break ;
                                    }
                                    if codeRet as libc::c_uint ==
                                           CE_PARSE as libc::c_int as
                                               libc::c_uint {
                                        current_block = 15438562788955825517;
                                    } else {
                                        yyval.cblock = psCurrBlock;
                                        current_block = 9320480655893135347;
                                    }
                                }
                            }
                            166 => {
                                codeRet =
                                    scriptCodeBinaryOperator((*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cblock,
                                                             (*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).cblock,
                                                             OP_NOTEQUAL,
                                                             &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            167 => {
                                if interpCheckEquiv((*(*yyvsp.offset(-(2 as
                                                                           libc::c_int)
                                                                         as
                                                                         isize)).cblock).type_0,
                                                    (*(*yyvsp.offset(0 as
                                                                         libc::c_int
                                                                         as
                                                                         isize)).cblock).type_0)
                                       == 0 {
                                    scr_error(b"Type mismatch for inequality\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    codeRet =
                                        scriptCodeBinaryOperator((*yyvsp.offset(-(2
                                                                                      as
                                                                                      libc::c_int)
                                                                                    as
                                                                                    isize)).cblock,
                                                                 (*yyvsp.offset(0
                                                                                    as
                                                                                    libc::c_int
                                                                                    as
                                                                                    isize)).cblock,
                                                                 OP_NOTEQUAL,
                                                                 &mut psCurrBlock);
                                    if codeRet as libc::c_uint ==
                                           CE_MEMORY as libc::c_int as
                                               libc::c_uint {
                                        current_block = 10563765182283539921;
                                        break ;
                                    }
                                    if codeRet as libc::c_uint ==
                                           CE_PARSE as libc::c_int as
                                               libc::c_uint {
                                        current_block = 15438562788955825517;
                                    } else {
                                        yyval.cblock = psCurrBlock;
                                        current_block = 9320480655893135347;
                                    }
                                }
                            }
                            168 => {
                                if interpCheckEquiv((*(*yyvsp.offset(-(2 as
                                                                           libc::c_int)
                                                                         as
                                                                         isize)).cblock).type_0,
                                                    (*(*yyvsp.offset(0 as
                                                                         libc::c_int
                                                                         as
                                                                         isize)).cblock).type_0)
                                       == 0 {
                                    scr_error(b"Type mismatch for inequality\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    codeRet =
                                        scriptCodeBinaryOperator((*yyvsp.offset(-(2
                                                                                      as
                                                                                      libc::c_int)
                                                                                    as
                                                                                    isize)).cblock,
                                                                 (*yyvsp.offset(0
                                                                                    as
                                                                                    libc::c_int
                                                                                    as
                                                                                    isize)).cblock,
                                                                 OP_NOTEQUAL,
                                                                 &mut psCurrBlock);
                                    if codeRet as libc::c_uint ==
                                           CE_MEMORY as libc::c_int as
                                               libc::c_uint {
                                        current_block = 10563765182283539921;
                                        break ;
                                    }
                                    if codeRet as libc::c_uint ==
                                           CE_PARSE as libc::c_int as
                                               libc::c_uint {
                                        current_block = 15438562788955825517;
                                    } else {
                                        yyval.cblock = psCurrBlock;
                                        current_block = 9320480655893135347;
                                    }
                                }
                            }
                            169 => {
                                codeRet =
                                    scriptCodeBinaryOperator((*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cblock,
                                                             (*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).cblock,
                                                             OP_LESSEQUAL,
                                                             &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            170 => {
                                codeRet =
                                    scriptCodeBinaryOperator((*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cblock,
                                                             (*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).cblock,
                                                             OP_GREATEREQUAL,
                                                             &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            171 => {
                                codeRet =
                                    scriptCodeBinaryOperator((*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cblock,
                                                             (*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).cblock,
                                                             OP_GREATER,
                                                             &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            172 => {
                                codeRet =
                                    scriptCodeBinaryOperator((*yyvsp.offset(-(2
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cblock,
                                                             (*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).cblock,
                                                             OP_LESS,
                                                             &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            173 => {
                                codeRet =
                                    scriptCodeVarGet((*yyvsp.offset(0 as
                                                                        libc::c_int
                                                                        as
                                                                        isize)).vSymbol,
                                                     &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            174 => {
                                codeRet =
                                    scriptCodeConstant((*yyvsp.offset(0 as
                                                                          libc::c_int
                                                                          as
                                                                          isize)).cSymbol,
                                                       &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            175 => {
                                codeRet =
                                    scriptCodeObjGet((*yyvsp.offset(0 as
                                                                        libc::c_int
                                                                        as
                                                                        isize)).objVarBlock,
                                                     &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            176 => {
                                codeRet =
                                    scriptCodeArrayGet((*yyvsp.offset(0 as
                                                                          libc::c_int
                                                                          as
                                                                          isize)).arrayBlock,
                                                       &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            177 => {
                                codeRet =
                                    scriptCodeFunction((*yyvsp.offset(-(3 as
                                                                            libc::c_int)
                                                                          as
                                                                          isize)).fSymbol,
                                                       (*yyvsp.offset(-(1 as
                                                                            libc::c_int)
                                                                          as
                                                                          isize)).pblock,
                                                       1 as libc::c_int,
                                                       &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            178 => {
                                psCurrBlock =
                                    memMallocRelease(::std::mem::size_of::<CODE_BLOCK>()
                                                         as libc::c_ulong) as
                                        *mut CODE_BLOCK;
                                if psCurrBlock.is_null() {
                                    debug(LOG_ERROR,
                                          b"Out of memory\x00" as *const u8 as
                                              *const libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCurrBlock).pCode =
                                        memMallocRelease((::std::mem::size_of::<OPCODE>()
                                                              as
                                                              libc::c_ulong).wrapping_add(::std::mem::size_of::<UDWORD>()
                                                                                              as
                                                                                              libc::c_ulong))
                                            as *mut UDWORD;
                                    if (*psCurrBlock).pCode.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        memFreeRelease(psCurrBlock as
                                                           *mut libc::c_void);
                                        psCurrBlock = 0 as *mut CODE_BLOCK;
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrBlock).size =
                                            (::std::mem::size_of::<OPCODE>()
                                                 as
                                                 libc::c_ulong).wrapping_add(::std::mem::size_of::<UDWORD>()
                                                                                 as
                                                                                 libc::c_ulong);
                                        ip = (*psCurrBlock).pCode;
                                        *ip =
                                            VAL_TRIGGER as libc::c_int as
                                                UDWORD &
                                                0xffffff as libc::c_int as
                                                    libc::c_uint;
                                        *ip =
                                            (OP_PUSH as libc::c_int as UDWORD)
                                                << 24 as libc::c_int | *ip;
                                        ip =
                                            ip.offset(1 as libc::c_int as
                                                          isize);
                                        *ip =
                                            (*(*yyvsp.offset(0 as libc::c_int
                                                                 as
                                                                 isize)).tSymbol).index;
                                        ip =
                                            ip.offset(1 as libc::c_int as
                                                          isize);
                                        (*psCurrBlock).type_0 = VAL_TRIGGER;
                                        yyval.cblock = psCurrBlock
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            179 => {
                                psCurrBlock =
                                    memMallocRelease(::std::mem::size_of::<CODE_BLOCK>()
                                                         as libc::c_ulong) as
                                        *mut CODE_BLOCK;
                                if psCurrBlock.is_null() {
                                    debug(LOG_ERROR,
                                          b"Out of memory\x00" as *const u8 as
                                              *const libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCurrBlock).pCode =
                                        memMallocRelease((::std::mem::size_of::<OPCODE>()
                                                              as
                                                              libc::c_ulong).wrapping_add(::std::mem::size_of::<UDWORD>()
                                                                                              as
                                                                                              libc::c_ulong))
                                            as *mut UDWORD;
                                    if (*psCurrBlock).pCode.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        memFreeRelease(psCurrBlock as
                                                           *mut libc::c_void);
                                        psCurrBlock = 0 as *mut CODE_BLOCK;
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrBlock).size =
                                            (::std::mem::size_of::<OPCODE>()
                                                 as
                                                 libc::c_ulong).wrapping_add(::std::mem::size_of::<UDWORD>()
                                                                                 as
                                                                                 libc::c_ulong);
                                        ip = (*psCurrBlock).pCode;
                                        *ip =
                                            VAL_TRIGGER as libc::c_int as
                                                UDWORD &
                                                0xffffff as libc::c_int as
                                                    libc::c_uint;
                                        *ip =
                                            (OP_PUSH as libc::c_int as UDWORD)
                                                << 24 as libc::c_int | *ip;
                                        ip =
                                            ip.offset(1 as libc::c_int as
                                                          isize);
                                        *ip = -(1 as libc::c_int) as UDWORD;
                                        ip =
                                            ip.offset(1 as libc::c_int as
                                                          isize);
                                        (*psCurrBlock).type_0 = VAL_TRIGGER;
                                        yyval.cblock = psCurrBlock
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            180 => {
                                psCurrBlock =
                                    memMallocRelease(::std::mem::size_of::<CODE_BLOCK>()
                                                         as libc::c_ulong) as
                                        *mut CODE_BLOCK;
                                if psCurrBlock.is_null() {
                                    debug(LOG_ERROR,
                                          b"Out of memory\x00" as *const u8 as
                                              *const libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCurrBlock).pCode =
                                        memMallocRelease((::std::mem::size_of::<OPCODE>()
                                                              as
                                                              libc::c_ulong).wrapping_add(::std::mem::size_of::<UDWORD>()
                                                                                              as
                                                                                              libc::c_ulong))
                                            as *mut UDWORD;
                                    if (*psCurrBlock).pCode.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        memFreeRelease(psCurrBlock as
                                                           *mut libc::c_void);
                                        psCurrBlock = 0 as *mut CODE_BLOCK;
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrBlock).size =
                                            (::std::mem::size_of::<OPCODE>()
                                                 as
                                                 libc::c_ulong).wrapping_add(::std::mem::size_of::<UDWORD>()
                                                                                 as
                                                                                 libc::c_ulong);
                                        ip = (*psCurrBlock).pCode;
                                        *ip =
                                            VAL_EVENT as libc::c_int as UDWORD
                                                &
                                                0xffffff as libc::c_int as
                                                    libc::c_uint;
                                        *ip =
                                            (OP_PUSH as libc::c_int as UDWORD)
                                                << 24 as libc::c_int | *ip;
                                        ip =
                                            ip.offset(1 as libc::c_int as
                                                          isize);
                                        *ip =
                                            (*(*yyvsp.offset(0 as libc::c_int
                                                                 as
                                                                 isize)).eSymbol).index;
                                        ip =
                                            ip.offset(1 as libc::c_int as
                                                          isize);
                                        (*psCurrBlock).type_0 = VAL_EVENT;
                                        yyval.cblock = psCurrBlock
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            181 => {
                                codeRet =
                                    scriptCodeVarGet((*yyvsp.offset(0 as
                                                                        libc::c_int
                                                                        as
                                                                        isize)).vSymbol,
                                                     &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            182 => {
                                codeRet =
                                    scriptCodeConstant((*yyvsp.offset(0 as
                                                                          libc::c_int
                                                                          as
                                                                          isize)).cSymbol,
                                                       &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            183 => {
                                codeRet =
                                    scriptCodeFunction((*yyvsp.offset(-(3 as
                                                                            libc::c_int)
                                                                          as
                                                                          isize)).fSymbol,
                                                       (*yyvsp.offset(-(1 as
                                                                            libc::c_int)
                                                                          as
                                                                          isize)).pblock,
                                                       1 as libc::c_int,
                                                       &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            184 => {
                                let mut line_11: UDWORD = 0;
                                let mut paramNumber_2: UDWORD = 0;
                                let mut pDummy_14: *mut STRING =
                                    0 as *mut STRING;
                                if (*(*yyvsp.offset(-(1 as libc::c_int) as
                                                        isize)).pblock).numParams
                                       !=
                                       (*(*yyvsp.offset(-(3 as libc::c_int) as
                                                            isize)).eSymbol).numParams
                                   {
                                    debug(LOG_ERROR,
                                          b"Wrong number of arguments for function call: \'%s\'. Expected %d parameters instead of  %d.\x00"
                                              as *const u8 as
                                              *const libc::c_char,
                                          (*(*yyvsp.offset(-(3 as libc::c_int)
                                                               as
                                                               isize)).eSymbol).pIdent,
                                          (*(*yyvsp.offset(-(3 as libc::c_int)
                                                               as
                                                               isize)).eSymbol).numParams,
                                          (*(*yyvsp.offset(-(1 as libc::c_int)
                                                               as
                                                               isize)).pblock).numParams);
                                    scr_error(b"Wrong number of arguments in function call\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    return CE_PARSE as libc::c_int
                                }
                                if (*(*yyvsp.offset(-(3 as libc::c_int) as
                                                        isize)).eSymbol).bFunction
                                       == 0 {
                                    debug(LOG_ERROR,
                                          b"\'%s\' is not a function\x00" as
                                              *const u8 as
                                              *const libc::c_char,
                                          (*(*yyvsp.offset(-(3 as libc::c_int)
                                                               as
                                                               isize)).eSymbol).pIdent);
                                    scr_error(b"Can\'t cann an event\x00" as
                                                  *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    return CE_PARSE as libc::c_int
                                }
                                if (*asScrTypeTab.offset(((*(*yyvsp.offset(-(3
                                                                                 as
                                                                                 libc::c_int)
                                                                               as
                                                                               isize)).eSymbol).retType
                                                              as
                                                              libc::c_uint).wrapping_sub(VAL_USERTYPESTART
                                                                                             as
                                                                                             libc::c_int
                                                                                             as
                                                                                             libc::c_uint)
                                                             as
                                                             isize)).accessType
                                       as libc::c_int !=
                                       AT_OBJECT as libc::c_int {
                                    scr_error(b"\'%s\' does not return an object value (%d )\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char,
                                              (*(*yyvsp.offset(-(3 as
                                                                     libc::c_int)
                                                                   as
                                                                   isize)).eSymbol).pIdent,
                                              (*(*yyvsp.offset(-(3 as
                                                                     libc::c_int)
                                                                   as
                                                                   isize)).eSymbol).retType
                                                  as libc::c_uint);
                                    return CE_PARSE as libc::c_int
                                }
                                paramNumber_2 =
                                    checkFuncParamTypes((*yyvsp.offset(-(3 as
                                                                             libc::c_int)
                                                                           as
                                                                           isize)).eSymbol,
                                                        (*yyvsp.offset(-(1 as
                                                                             libc::c_int)
                                                                           as
                                                                           isize)).pblock);
                                if paramNumber_2 >
                                       0 as libc::c_int as libc::c_uint {
                                    debug(LOG_ERROR,
                                          b"Parameter mismatch in function call: \'%s\'. Mismatch in parameter  %d.\x00"
                                              as *const u8 as
                                              *const libc::c_char,
                                          (*(*yyvsp.offset(-(3 as libc::c_int)
                                                               as
                                                               isize)).eSymbol).pIdent,
                                          paramNumber_2);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    psCurrBlock =
                                        memMallocRelease(::std::mem::size_of::<CODE_BLOCK>()
                                                             as libc::c_ulong)
                                            as *mut CODE_BLOCK;
                                    if psCurrBlock.is_null() {
                                        debug(LOG_ERROR,
                                              b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrBlock).pCode =
                                            memMallocRelease((*(*yyvsp.offset(-(1
                                                                                    as
                                                                                    libc::c_int)
                                                                                  as
                                                                                  isize)).pblock).size.wrapping_add(::std::mem::size_of::<OPCODE>()
                                                                                                                        as
                                                                                                                        libc::c_ulong).wrapping_add(::std::mem::size_of::<UDWORD>()
                                                                                                                                                        as
                                                                                                                                                        libc::c_ulong))
                                                as *mut UDWORD;
                                        if (*psCurrBlock).pCode.is_null() {
                                            debug(LOG_ERROR,
                                                  b"Out of memory\x00" as
                                                      *const u8 as
                                                      *const libc::c_char);
                                            memFreeRelease(psCurrBlock as
                                                               *mut libc::c_void);
                                            psCurrBlock =
                                                0 as *mut CODE_BLOCK;
                                            current_block =
                                                10563765182283539921;
                                            break ;
                                        } else {
                                            (*psCurrBlock).size =
                                                (*(*yyvsp.offset(-(1 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).pblock).size.wrapping_add(::std::mem::size_of::<OPCODE>()
                                                                                                           as
                                                                                                           libc::c_ulong).wrapping_add(::std::mem::size_of::<UDWORD>()
                                                                                                                                           as
                                                                                                                                           libc::c_ulong);
                                            if genDebugInfo != 0 {
                                                (*psCurrBlock).psDebug =
                                                    memMallocRelease((::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                          as
                                                                          libc::c_ulong).wrapping_mul(1
                                                                                                          as
                                                                                                          libc::c_int
                                                                                                          as
                                                                                                          libc::c_uint))
                                                        as *mut SCRIPT_DEBUG;
                                                if (*psCurrBlock).psDebug.is_null()
                                                   {
                                                    scr_error(b"Out of memory\x00"
                                                                  as *const u8
                                                                  as
                                                                  *const libc::c_char
                                                                  as
                                                                  *mut libc::c_char);
                                                    current_block =
                                                        10563765182283539921;
                                                    break ;
                                                } else {
                                                    memset((*psCurrBlock).psDebug
                                                               as
                                                               *mut libc::c_void,
                                                           0 as libc::c_int,
                                                           (::std::mem::size_of::<SCRIPT_DEBUG>()
                                                                as
                                                                libc::c_ulong).wrapping_mul(1
                                                                                                as
                                                                                                libc::c_int
                                                                                                as
                                                                                                libc::c_uint));
                                                    (*psCurrBlock).debugEntries
                                                        =
                                                        1 as libc::c_int as
                                                            UWORD as UDWORD
                                                }
                                            } else {
                                                (*psCurrBlock).psDebug =
                                                    0 as *mut SCRIPT_DEBUG;
                                                (*psCurrBlock).debugEntries =
                                                    0 as libc::c_int as UDWORD
                                            }
                                            ip = (*psCurrBlock).pCode;
                                            if (*(*yyvsp.offset(-(1 as
                                                                      libc::c_int)
                                                                    as
                                                                    isize)).pblock).numParams
                                                   >
                                                   0 as libc::c_int as
                                                       libc::c_uint {
                                                memcpy(ip as
                                                           *mut libc::c_void,
                                                       (*(*yyvsp.offset(-(1 as
                                                                              libc::c_int)
                                                                            as
                                                                            isize)).pblock).pCode
                                                           as
                                                           *const libc::c_void,
                                                       (*(*yyvsp.offset(-(1 as
                                                                              libc::c_int)
                                                                            as
                                                                            isize)).pblock).size);
                                                ip =
                                                    (ip as
                                                         *mut UBYTE).offset((*(*yyvsp.offset(-(1
                                                                                                   as
                                                                                                   libc::c_int)
                                                                                                 as
                                                                                                 isize)).pblock).size
                                                                                as
                                                                                isize)
                                                        as *mut UDWORD;
                                                memFreeRelease((*(*yyvsp.offset(-(1
                                                                                      as
                                                                                      libc::c_int)
                                                                                    as
                                                                                    isize)).pblock).pCode
                                                                   as
                                                                   *mut libc::c_void);
                                                let ref mut fresh104 =
                                                    (*(*yyvsp.offset(-(1 as
                                                                           libc::c_int)
                                                                         as
                                                                         isize)).pblock).pCode;
                                                *fresh104 = 0 as *mut UDWORD;
                                                memFreeRelease((*(*yyvsp.offset(-(1
                                                                                      as
                                                                                      libc::c_int)
                                                                                    as
                                                                                    isize)).pblock).aParams
                                                                   as
                                                                   *mut libc::c_void);
                                                let ref mut fresh105 =
                                                    (*(*yyvsp.offset(-(1 as
                                                                           libc::c_int)
                                                                         as
                                                                         isize)).pblock).aParams;
                                                *fresh105 =
                                                    0 as *mut INTERP_TYPE;
                                                memFreeRelease((*yyvsp.offset(-(1
                                                                                    as
                                                                                    libc::c_int)
                                                                                  as
                                                                                  isize)).pblock
                                                                   as
                                                                   *mut libc::c_void);
                                                let ref mut fresh106 =
                                                    (*yyvsp.offset(-(1 as
                                                                         libc::c_int)
                                                                       as
                                                                       isize)).pblock;
                                                *fresh106 =
                                                    0 as *mut PARAM_BLOCK
                                            }
                                            *ip =
                                                ((OP_FUNC as libc::c_int) <<
                                                     24 as libc::c_int) as
                                                    UDWORD;
                                            ip =
                                                ip.offset(1 as libc::c_int as
                                                              isize);
                                            *ip =
                                                (*(*yyvsp.offset(-(3 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).eSymbol).index;
                                            ip =
                                                ip.offset(1 as libc::c_int as
                                                              isize);
                                            if genDebugInfo != 0 {
                                                (*(*psCurrBlock).psDebug.offset(0
                                                                                    as
                                                                                    libc::c_int
                                                                                    as
                                                                                    isize)).offset
                                                    =
                                                    0 as libc::c_int as
                                                        UDWORD;
                                                scriptGetErrorData(&mut line_11
                                                                       as
                                                                       *mut UDWORD
                                                                       as
                                                                       *mut SDWORD,
                                                                   &mut pDummy_14);
                                                (*(*psCurrBlock).psDebug.offset(0
                                                                                    as
                                                                                    libc::c_int
                                                                                    as
                                                                                    isize)).line
                                                    = line_11
                                            }
                                            (*psCurrBlock).type_0 =
                                                (*(*yyvsp.offset(-(3 as
                                                                       libc::c_int)
                                                                     as
                                                                     isize)).eSymbol).retType;
                                            yyval.cblock = psCurrBlock
                                        }
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            185 => {
                                codeRet =
                                    scriptCodeObjGet((*yyvsp.offset(0 as
                                                                        libc::c_int
                                                                        as
                                                                        isize)).objVarBlock,
                                                     &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            186 => {
                                codeRet =
                                    scriptCodeArrayGet((*yyvsp.offset(0 as
                                                                          libc::c_int
                                                                          as
                                                                          isize)).arrayBlock,
                                                       &mut psCurrBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.cblock = psCurrBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            187 => {
                                objVarContext =
                                    (*(*yyvsp.offset(-(1 as libc::c_int) as
                                                         isize)).cblock).type_0;
                                current_block = 9320480655893135347;
                            }
                            188 => {
                                codeRet =
                                    scriptCodeObjectVariable((*yyvsp.offset(-(1
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cblock,
                                                             (*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).vSymbol,
                                                             &mut psObjVarBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    objVarContext = VAL_BOOL;
                                    yyval.objVarBlock = psObjVarBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            189 => {
                                codeRet =
                                    scriptCodeObjectVariable((*yyvsp.offset(-(1
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cblock,
                                                             (*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).vSymbol,
                                                             &mut psObjVarBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    objVarContext = VAL_BOOL;
                                    yyval.objVarBlock = psObjVarBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            190 => {
                                codeRet =
                                    scriptCodeObjectVariable((*yyvsp.offset(-(1
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cblock,
                                                             (*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).vSymbol,
                                                             &mut psObjVarBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    objVarContext = VAL_BOOL;
                                    yyval.objVarBlock = psObjVarBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            191 => {
                                codeRet =
                                    scriptCodeObjectVariable((*yyvsp.offset(-(1
                                                                                  as
                                                                                  libc::c_int)
                                                                                as
                                                                                isize)).cblock,
                                                             (*yyvsp.offset(0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                isize)).vSymbol,
                                                             &mut psObjVarBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    objVarContext = VAL_BOOL;
                                    yyval.objVarBlock = psObjVarBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            192 => {
                                psCurrArrayBlock =
                                    memMallocRelease(::std::mem::size_of::<ARRAY_BLOCK>()
                                                         as libc::c_ulong) as
                                        *mut ARRAY_BLOCK;
                                if psCurrArrayBlock.is_null() {
                                    scr_error(b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCurrArrayBlock).pCode =
                                        memMallocRelease((*(*yyvsp.offset(-(1
                                                                                as
                                                                                libc::c_int)
                                                                              as
                                                                              isize)).cblock).size)
                                            as *mut UDWORD;
                                    if (*psCurrArrayBlock).pCode.is_null() {
                                        scr_error(b"Out of memory\x00" as
                                                      *const u8 as
                                                      *const libc::c_char as
                                                      *mut libc::c_char);
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrArrayBlock).size =
                                            (*(*yyvsp.offset(-(1 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).cblock).size;
                                        (*psCurrArrayBlock).dimensions =
                                            1 as libc::c_int;
                                        (*psCurrArrayBlock).psArrayVar =
                                            0 as *mut VAR_SYMBOL;
                                        ip = (*psCurrArrayBlock).pCode;
                                        memcpy(ip as *mut libc::c_void,
                                               (*(*yyvsp.offset(-(1 as
                                                                      libc::c_int)
                                                                    as
                                                                    isize)).cblock).pCode
                                                   as *const libc::c_void,
                                               (*(*yyvsp.offset(-(1 as
                                                                      libc::c_int)
                                                                    as
                                                                    isize)).cblock).size);
                                        ip =
                                            (ip as
                                                 *mut UBYTE).offset((*(*yyvsp.offset(-(1
                                                                                           as
                                                                                           libc::c_int)
                                                                                         as
                                                                                         isize)).cblock).size
                                                                        as
                                                                        isize)
                                                as *mut UDWORD;
                                        memFreeRelease((*(*yyvsp.offset(-(1 as
                                                                              libc::c_int)
                                                                            as
                                                                            isize)).cblock).pCode
                                                           as
                                                           *mut libc::c_void);
                                        let ref mut fresh107 =
                                            (*(*yyvsp.offset(-(1 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).cblock).pCode;
                                        *fresh107 = 0 as *mut UDWORD;
                                        memFreeRelease((*yyvsp.offset(-(1 as
                                                                            libc::c_int)
                                                                          as
                                                                          isize)).cblock
                                                           as
                                                           *mut libc::c_void);
                                        let ref mut fresh108 =
                                            (*yyvsp.offset(-(1 as libc::c_int)
                                                               as
                                                               isize)).cblock;
                                        *fresh108 = 0 as *mut CODE_BLOCK;
                                        yyval.arrayBlock = psCurrArrayBlock
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            193 => {
                                yyval.arrayBlock =
                                    (*yyvsp.offset(0 as libc::c_int as
                                                       isize)).arrayBlock;
                                current_block = 9320480655893135347;
                            }
                            194 => {
                                psCurrArrayBlock =
                                    memMallocRelease(::std::mem::size_of::<ARRAY_BLOCK>()
                                                         as libc::c_ulong) as
                                        *mut ARRAY_BLOCK;
                                if psCurrArrayBlock.is_null() {
                                    scr_error(b"Out of memory\x00" as
                                                  *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char);
                                    current_block = 10563765182283539921;
                                    break ;
                                } else {
                                    (*psCurrArrayBlock).pCode =
                                        memMallocRelease((*(*yyvsp.offset(-(3
                                                                                as
                                                                                libc::c_int)
                                                                              as
                                                                              isize)).arrayBlock).size.wrapping_add((*(*yyvsp.offset(-(1
                                                                                                                                           as
                                                                                                                                           libc::c_int)
                                                                                                                                         as
                                                                                                                                         isize)).cblock).size))
                                            as *mut UDWORD;
                                    if (*psCurrArrayBlock).pCode.is_null() {
                                        scr_error(b"Out of memory\x00" as
                                                      *const u8 as
                                                      *const libc::c_char as
                                                      *mut libc::c_char);
                                        current_block = 10563765182283539921;
                                        break ;
                                    } else {
                                        (*psCurrArrayBlock).size =
                                            (*(*yyvsp.offset(-(3 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).arrayBlock).size.wrapping_add((*(*yyvsp.offset(-(1
                                                                                                                              as
                                                                                                                              libc::c_int)
                                                                                                                            as
                                                                                                                            isize)).cblock).size);
                                        (*psCurrArrayBlock).dimensions =
                                            1 as libc::c_int;
                                        (*psCurrArrayBlock).psArrayVar =
                                            0 as *mut VAR_SYMBOL;
                                        ip = (*psCurrArrayBlock).pCode;
                                        (*psCurrArrayBlock).dimensions =
                                            (*(*yyvsp.offset(-(3 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).arrayBlock).dimensions
                                                + 1 as libc::c_int;
                                        memcpy(ip as *mut libc::c_void,
                                               (*(*yyvsp.offset(-(3 as
                                                                      libc::c_int)
                                                                    as
                                                                    isize)).arrayBlock).pCode
                                                   as *const libc::c_void,
                                               (*(*yyvsp.offset(-(3 as
                                                                      libc::c_int)
                                                                    as
                                                                    isize)).arrayBlock).size);
                                        ip =
                                            (ip as
                                                 *mut UBYTE).offset((*(*yyvsp.offset(-(3
                                                                                           as
                                                                                           libc::c_int)
                                                                                         as
                                                                                         isize)).arrayBlock).size
                                                                        as
                                                                        isize)
                                                as *mut UDWORD;
                                        memcpy(ip as *mut libc::c_void,
                                               (*(*yyvsp.offset(-(1 as
                                                                      libc::c_int)
                                                                    as
                                                                    isize)).cblock).pCode
                                                   as *const libc::c_void,
                                               (*(*yyvsp.offset(-(1 as
                                                                      libc::c_int)
                                                                    as
                                                                    isize)).cblock).size);
                                        ip =
                                            (ip as
                                                 *mut UBYTE).offset((*(*yyvsp.offset(-(1
                                                                                           as
                                                                                           libc::c_int)
                                                                                         as
                                                                                         isize)).cblock).size
                                                                        as
                                                                        isize)
                                                as *mut UDWORD;
                                        memFreeRelease((*(*yyvsp.offset(-(3 as
                                                                              libc::c_int)
                                                                            as
                                                                            isize)).arrayBlock).pCode
                                                           as
                                                           *mut libc::c_void);
                                        let ref mut fresh109 =
                                            (*(*yyvsp.offset(-(3 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).arrayBlock).pCode;
                                        *fresh109 = 0 as *mut UDWORD;
                                        memFreeRelease((*yyvsp.offset(-(3 as
                                                                            libc::c_int)
                                                                          as
                                                                          isize)).arrayBlock
                                                           as
                                                           *mut libc::c_void);
                                        let ref mut fresh110 =
                                            (*yyvsp.offset(-(3 as libc::c_int)
                                                               as
                                                               isize)).arrayBlock;
                                        *fresh110 = 0 as *mut ARRAY_BLOCK;
                                        memFreeRelease((*(*yyvsp.offset(-(1 as
                                                                              libc::c_int)
                                                                            as
                                                                            isize)).cblock).pCode
                                                           as
                                                           *mut libc::c_void);
                                        let ref mut fresh111 =
                                            (*(*yyvsp.offset(-(1 as
                                                                   libc::c_int)
                                                                 as
                                                                 isize)).cblock).pCode;
                                        *fresh111 = 0 as *mut UDWORD;
                                        memFreeRelease((*yyvsp.offset(-(1 as
                                                                            libc::c_int)
                                                                          as
                                                                          isize)).cblock
                                                           as
                                                           *mut libc::c_void);
                                        let ref mut fresh112 =
                                            (*yyvsp.offset(-(1 as libc::c_int)
                                                               as
                                                               isize)).cblock;
                                        *fresh112 = 0 as *mut CODE_BLOCK;
                                        yyval.arrayBlock = psCurrArrayBlock
                                    }
                                }
                                current_block = 9320480655893135347;
                            }
                            195 => {
                                codeRet =
                                    scriptCodeArrayVariable((*yyvsp.offset(0
                                                                               as
                                                                               libc::c_int
                                                                               as
                                                                               isize)).arrayBlock,
                                                            (*yyvsp.offset(-(1
                                                                                 as
                                                                                 libc::c_int)
                                                                               as
                                                                               isize)).vSymbol,
                                                            &mut psCurrArrayBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.arrayBlock = psCurrArrayBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            196 => {
                                codeRet =
                                    scriptCodeArrayVariable((*yyvsp.offset(0
                                                                               as
                                                                               libc::c_int
                                                                               as
                                                                               isize)).arrayBlock,
                                                            (*yyvsp.offset(-(1
                                                                                 as
                                                                                 libc::c_int)
                                                                               as
                                                                               isize)).vSymbol,
                                                            &mut psCurrArrayBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.arrayBlock = psCurrArrayBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            197 => {
                                codeRet =
                                    scriptCodeArrayVariable((*yyvsp.offset(0
                                                                               as
                                                                               libc::c_int
                                                                               as
                                                                               isize)).arrayBlock,
                                                            (*yyvsp.offset(-(1
                                                                                 as
                                                                                 libc::c_int)
                                                                               as
                                                                               isize)).vSymbol,
                                                            &mut psCurrArrayBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.arrayBlock = psCurrArrayBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            198 => {
                                codeRet =
                                    scriptCodeArrayVariable((*yyvsp.offset(0
                                                                               as
                                                                               libc::c_int
                                                                               as
                                                                               isize)).arrayBlock,
                                                            (*yyvsp.offset(-(1
                                                                                 as
                                                                                 libc::c_int)
                                                                               as
                                                                               isize)).vSymbol,
                                                            &mut psCurrArrayBlock);
                                if codeRet as libc::c_uint ==
                                       CE_MEMORY as libc::c_int as
                                           libc::c_uint {
                                    current_block = 10563765182283539921;
                                    break ;
                                }
                                if codeRet as libc::c_uint ==
                                       CE_PARSE as libc::c_int as libc::c_uint
                                   {
                                    current_block = 15438562788955825517;
                                } else {
                                    yyval.arrayBlock = psCurrArrayBlock;
                                    current_block = 9320480655893135347;
                                }
                            }
                            _ => { current_block = 9320480655893135347; }
                        }
                        match current_block {
                            9320480655893135347 =>
                            /* User semantic actions sometimes alter yychar, and that requires
     that yytoken be updated with the new translation.  We take the
     approach of translating immediately before every use of yytoken.
     One alternative is translating here after every semantic action,
     but that translation would be missed if the semantic action invokes
     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
     incorrect destructor might then be invoked immediately.  In the
     case of YYERROR or YYBACKUP, subsequent parser actions might lead
     to an incorrect destructor call or verbose syntax error message
     before the lookahead is translated.  */
                            {
                                yyvsp = yyvsp.offset(-(yylen as isize));
                                yyssp = yyssp.offset(-(yylen as isize));
                                yylen = 0 as libc::c_int;
                                yyvsp = yyvsp.offset(1);
                                *yyvsp = yyval;
                                /* Now 'shift' the result of the reduction.  Determine what state
     that goes to, based on the state we popped back to and the rule
     number reduced by.  */
                                let yylhs: libc::c_int =
                                    yyr1[yyn as usize] as libc::c_int -
                                        82 as libc::c_int;
                                let yyi: libc::c_int =
                                    yypgoto[yylhs as usize] as libc::c_int +
                                        *yyssp as libc::c_int;
                                yystate =
                                    if 0 as libc::c_int <= yyi &&
                                           yyi <= 1493 as libc::c_int &&
                                           yycheck[yyi as usize] as
                                               libc::c_int ==
                                               *yyssp as libc::c_int {
                                        yytable[yyi as usize] as libc::c_int
                                    } else {
                                        yydefgoto[yylhs as usize] as
                                            libc::c_int
                                    };
                                current_block = 8100955437375066155;
                            }
                            _ =>
                            /* Pacify compilers when the user code never invokes YYERROR and the
     label yyerrorlab therefore never appears in user code.  */
                            /* Do not reclaim the symbols of the rule whose action triggered
     this YYERROR.  */
                            {
                                yyvsp = yyvsp.offset(-(yylen as isize));
                                yyssp = yyssp.offset(-(yylen as isize));
                                yylen = 0 as libc::c_int;
                                yystate = *yyssp as yy_state_fast_t;
                                current_block = 15689129494514526393;
                            }
                        }
                    }
                    _ => { }
                }
                match current_block {
                    15689129494514526393 =>
                    /*-------------------------------------------------------------.
| yyerrlab1 -- common code for both syntax error and YYERROR.  |
`-------------------------------------------------------------*/
                    {
                        yyerrstatus =
                            3 as
                                libc::c_int; /* Each real token shifted decrements this.  */
                        loop  {
                            yyn = yypact[yystate as usize] as libc::c_int;
                            if !(yyn == -(317 as libc::c_int)) {
                                yyn += 1 as libc::c_int;
                                if 0 as libc::c_int <= yyn &&
                                       yyn <= 1493 as libc::c_int &&
                                       yycheck[yyn as usize] as libc::c_int ==
                                           1 as libc::c_int {
                                    yyn =
                                        yytable[yyn as usize] as libc::c_int;
                                    if (0 as libc::c_int) < yyn { break ; }
                                }
                            }
                            /* Pop the current state because it cannot handle the error token.  */
                            if yyssp == yyss {
                                current_block = 10563765182283539921;
                                break 's_88 ;
                            }
                            yydestruct(b"Error: popping\x00" as *const u8 as
                                           *const libc::c_char,
                                       yystos[yystate as usize] as
                                           libc::c_int, yyvsp);
                            yyvsp =
                                yyvsp.offset(-(1 as libc::c_int as isize));
                            yyssp =
                                yyssp.offset(-(1 as libc::c_int as isize));
                            yystate = *yyssp as yy_state_fast_t
                        }
                        yyvsp = yyvsp.offset(1);
                        *yyvsp = scr_lval;
                        /* Shift the error token.  */
                        yystate = yyn
                    }
                    _ => { }
                }
                /*------------------------------------------------------------.
| yynewstate -- push a new state, which is found in yystate.  |
`------------------------------------------------------------*/
                /* Copy in the code for the parameters */
                /* In all cases, when you get here, the value and location stacks
     have just been pushed.  So pushing a state here evens the stacks.  */
                /* Copy the parameter types */
                yyssp = yyssp.offset(1)
            }
        }
    match current_block {
        14131958400073952123 =>
        /*-------------------------------------------------.
| yyexhaustedlab -- memory exhaustion comes here.  |
`-------------------------------------------------*/
        {
            scr_error(b"memory exhausted\x00" as *const u8 as
                          *const libc::c_char as *mut libc::c_char);
            yyresult = 2 as libc::c_int
        }
        10563765182283539921 =>
        /*-----------------------------------.
| yyabortlab -- YYABORT comes here.  |
`-----------------------------------*/
        {
            yyresult = 1 as libc::c_int
        }
        _ => { }
    }
    /* Fall through.  */
    /*-----------------------------------------------------.
| yyreturn -- parsing is finished, return the result.  |
`-----------------------------------------------------*/
    if scr_char != -(2 as libc::c_int) {
        /* Make sure we have latest lookahead translation.  See comments at
         user semantic actions for why this is necessary.  */
        yytoken =
            if 0 as libc::c_int <= scr_char && scr_char <= 321 as libc::c_int
               {
                yytranslate[scr_char as usize] as libc::c_int
            } else { 2 as libc::c_int };
        yydestruct(b"Cleanup: discarding lookahead\x00" as *const u8 as
                       *const libc::c_char, yytoken, &mut scr_lval);
    }
    /* Do not reclaim the symbols of the rule whose action triggered
     this YYABORT or YYACCEPT.  */
    yyvsp = yyvsp.offset(-(yylen as isize));
    yyssp = yyssp.offset(-(yylen as isize));
    while yyssp != yyss {
        yydestruct(b"Cleanup: popping\x00" as *const u8 as
                       *const libc::c_char,
                   yystos[*yyssp as libc::c_int as usize] as libc::c_int,
                   yyvsp);
        yyvsp = yyvsp.offset(-(1 as libc::c_int as isize));
        yyssp = yyssp.offset(-(1 as libc::c_int as isize))
    }
    if yyss != yyssa.as_mut_ptr() { free(yyss as *mut libc::c_void); }
    return yyresult;
}
unsafe extern "C" fn scriptResetTables() {
    let mut psCurr: *mut VAR_SYMBOL = 0 as *mut VAR_SYMBOL;
    let mut psNext: *mut VAR_SYMBOL = 0 as *mut VAR_SYMBOL;
    let mut psTCurr: *mut TRIGGER_SYMBOL = 0 as *mut TRIGGER_SYMBOL;
    let mut psTNext: *mut TRIGGER_SYMBOL = 0 as *mut TRIGGER_SYMBOL;
    let mut psECurr: *mut EVENT_SYMBOL = 0 as *mut EVENT_SYMBOL;
    let mut psENext: *mut EVENT_SYMBOL = 0 as *mut EVENT_SYMBOL;
    let mut psFCurr: *mut FUNC_SYMBOL = 0 as *mut FUNC_SYMBOL;
    let mut psFNext: *mut FUNC_SYMBOL = 0 as *mut FUNC_SYMBOL;
    let mut i: SDWORD = 0;
    localVariableDef = 0 as libc::c_int;
    psCurr = psGlobalVars;
    while !psCurr.is_null() {
        psNext = (*psCurr).psNext;
        memFreeRelease((*psCurr).pIdent as *mut libc::c_void);
        (*psCurr).pIdent = 0 as *mut STRING;
        memFreeRelease(psCurr as *mut libc::c_void);
        psCurr = 0 as *mut VAR_SYMBOL;
        psCurr = psNext
    }
    psGlobalVars = 0 as *mut VAR_SYMBOL;
    psCurEvent = 0 as *mut EVENT_SYMBOL;
    i = 0 as libc::c_int;
    while i < 1200 as libc::c_int {
        numEventLocalVars[i as usize] = 0 as libc::c_int as UDWORD;
        psCurr = psLocalVarsB[i as usize];
        while !psCurr.is_null() {
            psNext = (*psCurr).psNext;
            memFreeRelease((*psCurr).pIdent as *mut libc::c_void);
            (*psCurr).pIdent = 0 as *mut STRING;
            memFreeRelease(psCurr as *mut libc::c_void);
            psCurr = 0 as *mut VAR_SYMBOL;
            psCurr = psNext
        }
        psLocalVarsB[i as usize] = 0 as *mut VAR_SYMBOL;
        i += 1
    }
    psCurr = psLocalVarsTemp;
    while !psCurr.is_null() {
        psNext = (*psCurr).psNext;
        memFreeRelease((*psCurr).pIdent as *mut libc::c_void);
        (*psCurr).pIdent = 0 as *mut STRING;
        memFreeRelease(psCurr as *mut libc::c_void);
        psCurr = 0 as *mut VAR_SYMBOL;
        psCurr = psNext
    }
    psLocalVarsTemp = 0 as *mut VAR_SYMBOL;
    psCurr = psGlobalArrays;
    while !psCurr.is_null() {
        psNext = (*psCurr).psNext;
        memFreeRelease((*psCurr).pIdent as *mut libc::c_void);
        (*psCurr).pIdent = 0 as *mut STRING;
        memFreeRelease(psCurr as *mut libc::c_void);
        psCurr = 0 as *mut VAR_SYMBOL;
        psCurr = psNext
    }
    psGlobalArrays = 0 as *mut VAR_SYMBOL;
    psTCurr = psTriggers;
    while !psTCurr.is_null() {
        psTNext = (*psTCurr).psNext;
        if !(*psTCurr).psDebug.is_null() {
            memFreeRelease((*psTCurr).psDebug as *mut libc::c_void);
            (*psTCurr).psDebug = 0 as *mut SCRIPT_DEBUG
        }
        if !(*psTCurr).pCode.is_null() {
            memFreeRelease((*psTCurr).pCode as *mut libc::c_void);
            (*psTCurr).pCode = 0 as *mut UDWORD
        }
        memFreeRelease((*psTCurr).pIdent as *mut libc::c_void);
        (*psTCurr).pIdent = 0 as *mut STRING;
        memFreeRelease(psTCurr as *mut libc::c_void);
        psTCurr = 0 as *mut TRIGGER_SYMBOL;
        psTCurr = psTNext
    }
    psTriggers = 0 as *mut TRIGGER_SYMBOL;
    numTriggers = 0 as libc::c_int as UDWORD;
    psECurr = psEvents;
    while !psECurr.is_null() {
        psENext = (*psECurr).psNext;
        if !(*psECurr).psDebug.is_null() {
            memFreeRelease((*psECurr).psDebug as *mut libc::c_void);
            (*psECurr).psDebug = 0 as *mut SCRIPT_DEBUG
        }
        memFreeRelease((*psECurr).pIdent as *mut libc::c_void);
        (*psECurr).pIdent = 0 as *mut STRING;
        memFreeRelease((*psECurr).pCode as *mut libc::c_void);
        (*psECurr).pCode = 0 as *mut UDWORD;
        memFreeRelease(psECurr as *mut libc::c_void);
        psECurr = 0 as *mut EVENT_SYMBOL;
        psECurr = psENext
    }
    psEvents = 0 as *mut EVENT_SYMBOL;
    numEvents = 0 as libc::c_int as UDWORD;
    psFCurr = psFunctions;
    while !psFCurr.is_null() {
        psFNext = (*psFCurr).psNext;
        if genDebugInfo != 0 {
            memFreeRelease((*psFCurr).psDebug as *mut libc::c_void);
            (*psFCurr).psDebug = 0 as *mut SCRIPT_DEBUG
        }
        memFreeRelease((*psFCurr).pIdent as *mut libc::c_void);
        (*psFCurr).pIdent = 0 as *mut STRING;
        memFreeRelease((*psFCurr).pCode as *mut libc::c_void);
        (*psFCurr).pCode = 0 as *mut UDWORD;
        memFreeRelease(psFCurr as *mut libc::c_void);
        psFCurr = 0 as *mut FUNC_SYMBOL;
        psFCurr = psFNext
    }
    psFunctions = 0 as *mut FUNC_SYMBOL;
}
/* **********************************************************************************
 *
 * Compiler functions
 */
/* Compile a script program */
#[no_mangle]
pub unsafe extern "C" fn scriptCompile(mut pData: *mut libc::c_char,
                                       mut fileSize: UDWORD,
                                       mut ppsProg: *mut *mut SCRIPT_CODE,
                                       mut debugType: SCR_DEBUGTYPE) -> BOOL {
    scriptSetInputBuffer(pData, fileSize);
    scriptResetTables();
    psFinalProg = 0 as *mut SCRIPT_CODE;
    if debugType as libc::c_uint ==
           SCR_DEBUGINFO as libc::c_int as libc::c_uint {
        genDebugInfo = 1 as libc::c_int
    } else { genDebugInfo = 0 as libc::c_int }
    if scr_parse() != 0 as libc::c_int { return 0 as libc::c_int }
    scriptResetTables();
    *ppsProg = psFinalProg;
    return 1 as libc::c_int;
}
/* Give an error message */
#[no_mangle]
pub unsafe extern "C" fn scr_error(mut pMessage: *mut libc::c_char,
                                   mut args: ...) {
    let mut line: libc::c_int = 0;
    let mut text: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut args_0: va_list = 0 as *mut libc::c_char;
    let mut aBuff: [STRING; 1024] = [0; 1024];
    args_0 = args.clone();
    vsprintf(aBuff.as_mut_ptr(), pMessage, args_0);
    scriptGetErrorData(&mut line, &mut text);
    debug(LOG_ERROR,
          b"script parse error:\n\'%s\' at %s:%d\nToken: %d, Text: \'%s\'\n\x00"
              as *const u8 as *const libc::c_char, aBuff.as_mut_ptr(),
          GetLastResourceFilename(), line, scr_char, text);
    abort();
}
/* Look up a type symbol */
#[no_mangle]
pub unsafe extern "C" fn scriptLookUpType(mut pIdent: *mut STRING,
                                          mut pType: *mut INTERP_TYPE)
 -> BOOL {
    let mut i: UDWORD = 0;
    if !asScrTypeTab.is_null() {
        i = 0 as libc::c_int as UDWORD;
        while (*asScrTypeTab.offset(i as isize)).typeID as libc::c_int !=
                  0 as libc::c_int {
            if strcmp((*asScrTypeTab.offset(i as isize)).pIdent, pIdent) ==
                   0 as libc::c_int {
                *pType =
                    (*asScrTypeTab.offset(i as isize)).typeID as INTERP_TYPE;
                return 1 as libc::c_int
            }
            i = i.wrapping_add(1)
        }
    }
    return 0 as libc::c_int;
}
/* Reset the local variable symbol table */
#[no_mangle]
pub unsafe extern "C" fn scriptClearLocalVariables() {
    let mut psCurr: *mut VAR_SYMBOL = 0 as *mut VAR_SYMBOL;
    let mut psNext: *mut VAR_SYMBOL = 0 as *mut VAR_SYMBOL;
    psCurr = psLocalVars;
    while !psCurr.is_null() {
        psNext = (*psCurr).psNext;
        memFreeRelease((*psCurr).pIdent as *mut libc::c_void);
        (*psCurr).pIdent = 0 as *mut STRING;
        memFreeRelease(psCurr as *mut libc::c_void);
        psCurr = 0 as *mut VAR_SYMBOL;
        psCurr = psNext
    };
}
#[no_mangle]
pub unsafe extern "C" fn popArguments(mut ip_temp: *mut *mut UDWORD,
                                      mut numParams: SDWORD) -> BOOL {
    let mut i: SDWORD = 0;
    i = numParams - 1 as libc::c_int;
    while i >= 0 as libc::c_int {
        **ip_temp = i as UDWORD & 0xffffff as libc::c_int as libc::c_uint;
        **ip_temp =
            (OP_POPLOCAL as libc::c_int as UDWORD) << 24 as libc::c_int |
                **ip_temp;
        *ip_temp = (*ip_temp).offset(1 as libc::c_int as isize);
        i -= 1
    }
    return 1 as libc::c_int;
}
/* Add a new variable symbol */
#[no_mangle]
pub unsafe extern "C" fn scriptAddVariable(mut psStorage: *mut VAR_DECL,
                                           mut psVarIdent:
                                               *mut VAR_IDENT_DECL) -> BOOL {
    let mut psNew: *mut VAR_SYMBOL = 0 as *mut VAR_SYMBOL;
    let mut i: SDWORD = 0;
    let mut ppsVarSym: *mut *mut VAR_SYMBOL = 0 as *mut *mut VAR_SYMBOL;
    if (*psStorage).storage as libc::c_int == ST_LOCAL as libc::c_int {
        if scriptLookUpVariable((*psVarIdent).pIdent,
                                &mut ppsVarSym as *mut *mut *mut VAR_SYMBOL as
                                    *mut *mut VAR_SYMBOL) != 0 {
            debug(LOG_ERROR,
                  b"var found\x00" as *const u8 as *const libc::c_char);
            debug(LOG_ERROR,
                  b"var=%s, index=%d of %d\x00" as *const u8 as
                      *const libc::c_char, (*psVarIdent).pIdent,
                  (**ppsVarSym).index, (*psCurEvent).numParams);
        }
    }
    psNew =
        memMallocRelease(::std::mem::size_of::<VAR_SYMBOL>() as libc::c_ulong)
            as *mut VAR_SYMBOL;
    if psNew.is_null() {
        scr_error(b"Out of memory\x00" as *const u8 as *const libc::c_char as
                      *mut libc::c_char);
        return 0 as libc::c_int
    }
    (*psNew).pIdent = (*psVarIdent).pIdent;
    (*psNew).type_0 = (*psStorage).type_0;
    (*psNew).storage = (*psStorage).storage;
    (*psNew).dimensions = (*psVarIdent).dimensions;
    i = 0 as libc::c_int;
    while i < (*psNew).dimensions {
        (*psNew).elements[i as usize] = (*psVarIdent).elements[i as usize];
        i += 1
    }
    if (*psNew).dimensions == 0 as libc::c_int {
        if (*psStorage).storage as libc::c_int != ST_LOCAL as libc::c_int {
            if psGlobalVars.is_null() {
                (*psNew).index = 0 as libc::c_int as UDWORD
            } else {
                (*psNew).index =
                    (*psGlobalVars).index.wrapping_add(1 as libc::c_int as
                                                           libc::c_uint)
            }
            (*psNew).psNext = psGlobalVars;
            psGlobalVars = psNew
        } else {
            if psCurEvent.is_null() {
                debug(LOG_ERROR,
                      b"Can\'t declare local variables before defining an event\x00"
                          as *const u8 as *const libc::c_char);
            }
            if psLocalVarsB[(*psCurEvent).index as usize].is_null() {
                (*psNew).index = 0 as libc::c_int as UDWORD
            } else {
                (*psNew).index =
                    (*psLocalVarsB[(*psCurEvent).index as
                                       usize]).index.wrapping_add(1 as
                                                                      libc::c_int
                                                                      as
                                                                      libc::c_uint)
            }
            numEventLocalVars[(*psCurEvent).index as usize] =
                numEventLocalVars[(*psCurEvent).index as
                                      usize].wrapping_add(1 as libc::c_int as
                                                              libc::c_uint);
            (*psNew).psNext = psLocalVarsB[(*psCurEvent).index as usize];
            psLocalVarsB[(*psCurEvent).index as usize] = psNew
        }
    } else {
        if psGlobalArrays.is_null() {
            (*psNew).index = 0 as libc::c_int as UDWORD
        } else {
            (*psNew).index =
                (*psGlobalArrays).index.wrapping_add(1 as libc::c_int as
                                                         libc::c_uint)
        }
        (*psNew).psNext = psGlobalArrays;
        psGlobalArrays = psNew
    }
    return 1 as libc::c_int;
}
/* Look up a variable symbol */
#[no_mangle]
pub unsafe extern "C" fn scriptLookUpVariable(mut pIdent: *mut STRING,
                                              mut ppsSym:
                                                  *mut *mut VAR_SYMBOL)
 -> BOOL {
    let mut psCurr: *mut VAR_SYMBOL = 0 as *mut VAR_SYMBOL;
    let mut i: UDWORD = 0;
    if !asScrObjectVarTab.is_null() &&
           objVarContext as libc::c_uint != 0 as libc::c_int as libc::c_uint {
        psCurr = asScrObjectVarTab;
        while !(*psCurr).pIdent.is_null() {
            if interpCheckEquiv((*psCurr).objType, objVarContext) != 0 &&
                   strcmp((*psCurr).pIdent, pIdent) == 0 as libc::c_int {
                *ppsSym = psCurr;
                return 1 as libc::c_int
            }
            psCurr = psCurr.offset(1)
        }
    }
    if !asScrExternalTab.is_null() {
        psCurr = asScrExternalTab;
        while !(*psCurr).pIdent.is_null() {
            if strcmp((*psCurr).pIdent, pIdent) == 0 as libc::c_int {
                *ppsSym = psCurr;
                return 1 as libc::c_int
            }
            psCurr = psCurr.offset(1)
        }
    }
    psCurr = psLocalVars;
    while !psCurr.is_null() {
        if strcmp((*psCurr).pIdent, pIdent) == 0 as libc::c_int {
            *ppsSym = psCurr;
            return 1 as libc::c_int
        }
        psCurr = (*psCurr).psNext
    }
    if !psCurEvent.is_null() {
        if (*psCurEvent).index >= 1200 as libc::c_int as libc::c_uint {
            debug(LOG_ERROR,
                  b"psCurEvent->index (%d) >= maxEventsLocalVars\x00" as
                      *const u8 as *const libc::c_char, (*psCurEvent).index);
        }
        i = (*psCurEvent).index;
        if !psLocalVarsB[i as usize].is_null() {
            let mut line: libc::c_int = 0;
            let mut text: *mut libc::c_char = 0 as *mut libc::c_char;
            scriptGetErrorData(&mut line, &mut text);
            psCurr = psLocalVarsB[i as usize];
            while !psCurr.is_null() {
                if (*psCurr).pIdent.is_null() {
                    debug(LOG_ERROR,
                          b"psCurr->pIdent == NULL\x00" as *const u8 as
                              *const libc::c_char);
                    debug(LOG_ERROR,
                          b"psCurr->index = %d\x00" as *const u8 as
                              *const libc::c_char, (*psCurr).index);
                }
                if strcmp((*psCurr).pIdent, pIdent) == 0 as libc::c_int {
                    *ppsSym = psCurr;
                    return 1 as libc::c_int
                }
                psCurr = (*psCurr).psNext
            }
        }
    }
    if localVariableDef == 0 {
        psCurr = psGlobalVars;
        while !psCurr.is_null() {
            if strcmp((*psCurr).pIdent, pIdent) == 0 as libc::c_int {
                *ppsSym = psCurr;
                return 1 as libc::c_int
            }
            psCurr = (*psCurr).psNext
        }
        psCurr = psGlobalArrays;
        while !psCurr.is_null() {
            if strcmp((*psCurr).pIdent, pIdent) == 0 as libc::c_int {
                *ppsSym = psCurr;
                return 1 as libc::c_int
            }
            psCurr = (*psCurr).psNext
        }
    }
    *ppsSym = 0 as *mut VAR_SYMBOL;
    return 0 as libc::c_int;
}
/* Add a new trigger symbol */
#[no_mangle]
pub unsafe extern "C" fn scriptAddTrigger(mut pIdent: *mut STRING,
                                          mut psDecl: *mut TRIGGER_DECL,
                                          mut line: UDWORD) -> BOOL {
    let mut psTrigger: *mut TRIGGER_SYMBOL = 0 as *mut TRIGGER_SYMBOL;
    let mut psCurr: *mut TRIGGER_SYMBOL = 0 as *mut TRIGGER_SYMBOL;
    let mut psPrev: *mut TRIGGER_SYMBOL = 0 as *mut TRIGGER_SYMBOL;
    psTrigger =
        memMallocRelease(::std::mem::size_of::<TRIGGER_SYMBOL>() as
                             libc::c_ulong) as *mut TRIGGER_SYMBOL;
    if psTrigger.is_null() {
        scr_error(b"Out of memory\x00" as *const u8 as *const libc::c_char as
                      *mut libc::c_char);
        return 0 as libc::c_int
    }
    (*psTrigger).pIdent =
        memMallocRelease(strlen(pIdent).wrapping_add(1 as libc::c_int as
                                                         libc::c_uint)) as
            *mut STRING;
    if (*psTrigger).pIdent.is_null() {
        scr_error(b"Out of memory\x00" as *const u8 as *const libc::c_char as
                      *mut libc::c_char);
        return 0 as libc::c_int
    }
    strcpy((*psTrigger).pIdent, pIdent);
    if (*psDecl).size > 0 as libc::c_int as libc::c_uint {
        (*psTrigger).pCode = memMallocRelease((*psDecl).size) as *mut UDWORD;
        if (*psTrigger).pCode.is_null() {
            scr_error(b"Out of memory\x00" as *const u8 as *const libc::c_char
                          as *mut libc::c_char);
            return 0 as libc::c_int
        }
        memcpy((*psTrigger).pCode as *mut libc::c_void,
               (*psDecl).pCode as *const libc::c_void, (*psDecl).size);
    } else { (*psTrigger).pCode = 0 as *mut UDWORD }
    (*psTrigger).size = (*psDecl).size;
    (*psTrigger).type_0 = (*psDecl).type_0;
    (*psTrigger).time = (*psDecl).time;
    let fresh113 = numTriggers;
    numTriggers = numTriggers.wrapping_add(1);
    (*psTrigger).index = fresh113;
    (*psTrigger).psNext = 0 as *mut _trigger_symbol;
    if genDebugInfo != 0 {
        (*psTrigger).psDebug =
            memMallocRelease(::std::mem::size_of::<SCRIPT_DEBUG>() as
                                 libc::c_ulong) as *mut SCRIPT_DEBUG;
        (*(*psTrigger).psDebug.offset(0 as libc::c_int as isize)).offset =
            0 as libc::c_int as UDWORD;
        (*(*psTrigger).psDebug.offset(0 as libc::c_int as isize)).line = line;
        (*psTrigger).debugEntries = 1 as libc::c_int as UDWORD
    } else {
        (*psTrigger).debugEntries = 0 as libc::c_int as UDWORD;
        (*psTrigger).psDebug = 0 as *mut SCRIPT_DEBUG
    }
    psPrev = 0 as *mut TRIGGER_SYMBOL;
    psCurr = psTriggers;
    while !psCurr.is_null() { psPrev = psCurr; psCurr = (*psCurr).psNext }
    if !psPrev.is_null() {
        (*psPrev).psNext = psTrigger
    } else { psTriggers = psTrigger }
    return 1 as libc::c_int;
}
/* Lookup a trigger symbol */
#[no_mangle]
pub unsafe extern "C" fn scriptLookUpTrigger(mut pIdent: *mut STRING,
                                             mut ppsTrigger:
                                                 *mut *mut TRIGGER_SYMBOL)
 -> BOOL {
    let mut psCurr: *mut TRIGGER_SYMBOL = 0 as *mut TRIGGER_SYMBOL;
    psCurr = psTriggers;
    while !psCurr.is_null() {
        if strcmp(pIdent, (*psCurr).pIdent) == 0 as libc::c_int {
            *ppsTrigger = psCurr;
            return 1 as libc::c_int
        }
        psCurr = (*psCurr).psNext
    }
    return 0 as libc::c_int;
}
/* Lookup a callback trigger symbol */
#[no_mangle]
pub unsafe extern "C" fn scriptLookUpCallback(mut pIdent: *mut STRING,
                                              mut ppsCallback:
                                                  *mut *mut CALLBACK_SYMBOL)
 -> BOOL {
    let mut psCurr: *mut CALLBACK_SYMBOL = 0 as *mut CALLBACK_SYMBOL;
    if asScrCallbackTab.is_null() { return 0 as libc::c_int }
    psCurr = asScrCallbackTab;
    while (*psCurr).type_0 as libc::c_uint != 0 as libc::c_int as libc::c_uint
          {
        if strcmp(pIdent, (*psCurr).pIdent) == 0 as libc::c_int {
            *ppsCallback = psCurr;
            return 1 as libc::c_int
        }
        psCurr = psCurr.offset(1 as libc::c_int as isize)
    }
    return 0 as libc::c_int;
}
/* Add a new event symbol */
#[no_mangle]
pub unsafe extern "C" fn scriptDeclareEvent(mut pIdent: *mut STRING,
                                            mut ppsEvent:
                                                *mut *mut EVENT_SYMBOL,
                                            mut numArgs: SDWORD) -> BOOL {
    let mut psEvent: *mut EVENT_SYMBOL = 0 as *mut EVENT_SYMBOL;
    let mut psCurr: *mut EVENT_SYMBOL = 0 as *mut EVENT_SYMBOL;
    let mut psPrev: *mut EVENT_SYMBOL = 0 as *mut EVENT_SYMBOL;
    psEvent =
        memMallocRelease(::std::mem::size_of::<EVENT_SYMBOL>() as
                             libc::c_ulong) as *mut EVENT_SYMBOL;
    if psEvent.is_null() {
        scr_error(b"Out of memory\x00" as *const u8 as *const libc::c_char as
                      *mut libc::c_char);
        return 0 as libc::c_int
    }
    (*psEvent).pIdent =
        memMallocRelease(strlen(pIdent).wrapping_add(1 as libc::c_int as
                                                         libc::c_uint)) as
            *mut STRING;
    if (*psEvent).pIdent.is_null() {
        scr_error(b"Out of memory\x00" as *const u8 as *const libc::c_char as
                      *mut libc::c_char);
        return 0 as libc::c_int
    }
    strcpy((*psEvent).pIdent, pIdent);
    (*psEvent).pCode = 0 as *mut UDWORD;
    (*psEvent).size = 0 as libc::c_int as UDWORD;
    (*psEvent).psDebug = 0 as *mut SCRIPT_DEBUG;
    (*psEvent).debugEntries = 0 as libc::c_int as UDWORD;
    let fresh114 = numEvents;
    numEvents = numEvents.wrapping_add(1);
    (*psEvent).index = fresh114;
    (*psEvent).psNext = 0 as *mut _event_symbol;
    (*psEvent).numParams = numArgs as UDWORD;
    (*psEvent).bFunction = 0 as libc::c_int;
    (*psEvent).bDeclared = 0 as libc::c_int;
    (*psEvent).retType = VAL_VOID;
    psPrev = 0 as *mut EVENT_SYMBOL;
    psCurr = psEvents;
    while !psCurr.is_null() { psPrev = psCurr; psCurr = (*psCurr).psNext }
    if !psPrev.is_null() {
        (*psPrev).psNext = psEvent
    } else { psEvents = psEvent }
    *ppsEvent = psEvent;
    return 1 as libc::c_int;
}
// Add the code to a defined event
#[no_mangle]
pub unsafe extern "C" fn scriptDefineEvent(mut psEvent: *mut EVENT_SYMBOL,
                                           mut psCode: *mut CODE_BLOCK,
                                           mut trigger: SDWORD) -> BOOL {
    let mut psCurr: *mut VAR_SYMBOL = 0 as *mut VAR_SYMBOL;
    let mut psNext: *mut VAR_SYMBOL = 0 as *mut VAR_SYMBOL;
    if (*psCode).size == 0 as libc::c_int as libc::c_uint {
        debug(LOG_ERROR,
              b"Event \'%s\' is empty, please add atleast 1 statement\x00" as
                  *const u8 as *const libc::c_char, (*psEvent).pIdent);
    }
    if (*psEvent).numParams > 0 as libc::c_int as libc::c_uint &&
           trigger >= 0 as libc::c_int {
        debug(LOG_ERROR,
              b"Events with parameters can\'t have a trigger assigned, event: \'%s\' \x00"
                  as *const u8 as *const libc::c_char, (*psEvent).pIdent);
    }
    (*psEvent).pCode = memMallocRelease((*psCode).size) as *mut UDWORD;
    if (*psEvent).pCode.is_null() {
        scr_error(b"Out of memory\x00" as *const u8 as *const libc::c_char as
                      *mut libc::c_char);
        return 0 as libc::c_int
    }
    memcpy((*psEvent).pCode as *mut libc::c_void,
           (*psCode).pCode as *const libc::c_void, (*psCode).size);
    (*psEvent).size = (*psCode).size;
    (*psEvent).trigger = trigger;
    if genDebugInfo != 0 {
        (*psEvent).psDebug =
            memMallocRelease((::std::mem::size_of::<SCRIPT_DEBUG>() as
                                  libc::c_ulong).wrapping_mul((*psCode).debugEntries))
                as *mut SCRIPT_DEBUG;
        if (*psEvent).psDebug.is_null() {
            scr_error(b"Out of memory\x00" as *const u8 as *const libc::c_char
                          as *mut libc::c_char);
            return 0 as libc::c_int
        }
        memcpy((*psEvent).psDebug as *mut libc::c_void,
               (*psCode).psDebug as *const libc::c_void,
               (::std::mem::size_of::<SCRIPT_DEBUG>() as
                    libc::c_ulong).wrapping_mul((*psCode).debugEntries));
        (*psEvent).debugEntries = (*psCode).debugEntries
    } else {
        (*psEvent).debugEntries = 0 as libc::c_int as UDWORD;
        (*psEvent).psDebug = 0 as *mut SCRIPT_DEBUG
    }
    if (*psEvent).index >= 1200 as libc::c_int as libc::c_uint {
        debug(LOG_ERROR,
              b"scriptDefineEvent - psEvent->index >= maxEventsLocalVars\x00"
                  as *const u8 as *const libc::c_char);
    }
    return 1 as libc::c_int;
}
/* Lookup an event symbol */
#[no_mangle]
pub unsafe extern "C" fn scriptLookUpEvent(mut pIdent: *mut STRING,
                                           mut ppsEvent:
                                               *mut *mut EVENT_SYMBOL)
 -> BOOL {
    let mut psCurr: *mut EVENT_SYMBOL = 0 as *mut EVENT_SYMBOL;
    psCurr = psEvents;
    while !psCurr.is_null() {
        if strcmp(pIdent, (*psCurr).pIdent) == 0 as libc::c_int {
            *ppsEvent = psCurr;
            return 1 as libc::c_int
        }
        psCurr = (*psCurr).psNext
    }
    return 0 as libc::c_int;
}
/* Look up a constant variable symbol */
#[no_mangle]
pub unsafe extern "C" fn scriptLookUpConstant(mut pIdent: *mut STRING,
                                              mut ppsSym:
                                                  *mut *mut CONST_SYMBOL)
 -> BOOL {
    let mut psCurr: *mut CONST_SYMBOL = 0 as *mut CONST_SYMBOL;
    if !asScrConstantTab.is_null() {
        psCurr = asScrConstantTab;
        while (*psCurr).type_0 as libc::c_uint !=
                  VAL_VOID as libc::c_int as libc::c_uint {
            if strcmp((*psCurr).pIdent, pIdent) == 0 as libc::c_int {
                *ppsSym = psCurr;
                return 1 as libc::c_int
            }
            psCurr = psCurr.offset(1)
        }
    }
    return 0 as libc::c_int;
}
// The code block
/* Look up a function symbol */
#[no_mangle]
pub unsafe extern "C" fn scriptLookUpFunction(mut pIdent: *mut STRING,
                                              mut ppsSym:
                                                  *mut *mut FUNC_SYMBOL)
 -> BOOL {
    let mut i: UDWORD = 0;
    let mut psCurr: *mut FUNC_SYMBOL = 0 as *mut FUNC_SYMBOL;
    if !asScrInstinctTab.is_null() {
        i = 0 as libc::c_int as UDWORD;
        while (*asScrInstinctTab.offset(i as isize)).pFunc.is_some() {
            if strcmp((*asScrInstinctTab.offset(i as isize)).pIdent, pIdent)
                   == 0 as libc::c_int {
                *ppsSym = asScrInstinctTab.offset(i as isize);
                return 1 as libc::c_int
            }
            i = i.wrapping_add(1)
        }
    }
    psCurr = psFunctions;
    while !psCurr.is_null() {
        if strcmp((*psCurr).pIdent, pIdent) == 0 as libc::c_int {
            *ppsSym = psCurr;
            return 1 as libc::c_int
        }
        psCurr = (*psCurr).psNext
    }
    *ppsSym = 0 as *mut FUNC_SYMBOL;
    return 0 as libc::c_int;
}
/* Look up an in-script custom function symbol */
#[no_mangle]
pub unsafe extern "C" fn scriptLookUpCustomFunction(mut pIdent: *mut STRING,
                                                    mut ppsSym:
                                                        *mut *mut EVENT_SYMBOL)
 -> BOOL {
    let mut i: UDWORD = 0;
    let mut psCurr: *mut EVENT_SYMBOL = 0 as *mut EVENT_SYMBOL;
    psCurr = psEvents;
    while !psCurr.is_null() {
        if (*psCurr).bFunction != 0 {
            if strcmp((*psCurr).pIdent, pIdent) == 0 as libc::c_int {
                *ppsSym = psCurr;
                return 1 as libc::c_int
            }
        }
        psCurr = (*psCurr).psNext
    }
    *ppsSym = 0 as *mut EVENT_SYMBOL;
    return 0 as libc::c_int;
}
/* **********************************************************************************
 *
 * Compiler setup functions
 */
/* Set the type table */
#[no_mangle]
pub unsafe extern "C" fn scriptSetTypeTab(mut psTypeTab: *mut TYPE_SYMBOL) {
    asScrTypeTab = psTypeTab;
}
/* Set the function table */
#[no_mangle]
pub unsafe extern "C" fn scriptSetFuncTab(mut psFuncTab: *mut FUNC_SYMBOL) {
    asScrInstinctTab = psFuncTab;
}
/* Set the object variable table */
#[no_mangle]
pub unsafe extern "C" fn scriptSetObjectTab(mut psObjTab: *mut VAR_SYMBOL) {
    asScrObjectVarTab = psObjTab;
}
/* Set the external variable table */
#[no_mangle]
pub unsafe extern "C" fn scriptSetExternalTab(mut psExtTab: *mut VAR_SYMBOL) {
    asScrExternalTab = psExtTab;
}
/* Set the constant table */
#[no_mangle]
pub unsafe extern "C" fn scriptSetConstTab(mut psConstTab:
                                               *mut CONST_SYMBOL) {
    asScrConstantTab = psConstTab;
}
/* Set the callback table */
#[no_mangle]
pub unsafe extern "C" fn scriptSetCallbackTab(mut psCallTab:
                                                  *mut CALLBACK_SYMBOL) {
    asScrCallbackTab = psCallTab;
}
