use ::libc;
extern "C" {
    /* Directory management stuff ... */
    /* *
 * \fn int PHYSFS_mkdir(const char *dirName)
 * \brief Create a directory.
 *
 * This is specified in platform-independent notation in relation to the
 *  write dir. All missing parent directories are also created if they
 *  don't exist.
 *
 * So if you've got the write dir set to "C:\mygame\writedir" and call
 *  PHYSFS_mkdir("downloads/maps") then the directories
 *  "C:\mygame\writedir\downloads" and "C:\mygame\writedir\downloads\maps"
 *  will be created if possible. If the creation of "maps" fails after we
 *  have successfully created "downloads", then the function leaves the
 *  created directory behind and reports failure.
 *
 *   \param dirName New dir to create.
 *  \return nonzero on success, zero on error. Use
 *          PHYSFS_getLastErrorCode() to obtain the specific error.
 *
 * \sa PHYSFS_delete
 */
    #[no_mangle]
    fn PHYSFS_mkdir(dirName: *const libc::c_char) -> libc::c_int;
    /* Abort execution and generate a core-dump.  */
    #[no_mangle]
    fn abort() -> !;
    /* Set a block heap to use for all memory allocation rather than standard malloc/free */
    #[no_mangle]
    fn memSetBlockHeap(psHeap: *mut _block_heap);
    /* Get the current block heap */
    #[no_mangle]
    fn memGetBlockHeap() -> *mut _block_heap;
    #[no_mangle]
    fn memMallocRelease(Size: size_t) -> *mut libc::c_void;
    #[no_mangle]
    fn memFreeRelease(pMemToFree: *mut libc::c_void);
    /* Allocate an object from a heap
 * Returns a pointer to the object if successful
 */
    #[no_mangle]
    fn heapAlloc(psHeap: *mut OBJ_HEAP, ppObject: *mut *mut libc::c_void)
     -> BOOL;
    /* Return an object to the heap */
    #[no_mangle]
    fn heapFree(psHeap: *mut OBJ_HEAP, pObject: *mut libc::c_void) -> BOOL;
    /* Check the header files have been included from frame.h if they
 * are used outside of the framework library.
 */
    /* ***************************************************************************************
 *
 * Basic debugging macro's
 *
 */
    /*
 *
 * ASSERT
 *
 * Rewritten version of assert that allows a printf format text string to be passed
 * to ASSERT along with the condition.
 *
 * Arguments:	ASSERT( condition, "Format string with variables: %d, %d", var1, var2 );
 */
    /* ***************************************************************************************
 *
 * Conditional debugging macro's that can be selectively turned on or off on a file
 * by file basis.
 *
 * Modified to not output nothing under no conditions
 *
 */
    /* **
 ***
 ***  New debug logging output interface below. Heavily inspired
 ***  by similar code in Freeciv. Parts ripped directly.
 ***
 ***/
    /* Want to use GCC's __attribute__ keyword to check variadic
 * parameters to printf-like functions, without upsetting other
 * compilers: put any required defines magic here.
 * If other compilers have something equivalent, could also
 * work that out here.   Should this use configure stuff somehow?
 * --dwp
 */
    /* Must match code_part_names in debug.c */
    /* special: sets all to on */
    /* special; on by default */
    /* if too verbose for anything but dedicated debugging... */
    /* _must_ be last! */
    // / Function which does the output
    // / Setup function
    // / Cleaning function
    // / Used to pass data to the above functions. Eg a filename or handle.
    /* *
 * Call once to initialize the debug logging system.
 *
 * Doesn't register any callbacks!
 */
    /* *
 * Shutdown the debug system and remove all output callbacks
 */
    /* *
 * Register a callback to be called on every call to debug()
 *
 * \param	callback	Function which does the output
 * \param	init		Initializer function which does all setup for the callback (optional, may be NULL)
 * \param	exit		Cleanup function called when unregistering the callback (optional, may be NULL)
 * \param	data		Data to be passed to all three functions (optional, may be NULL)
 */
    /* *
 * Toggle debug output for part associated with str
 *
 * \param	str	Codepart in textformat
 */
    /* *
 * Output printf style format str with additional arguments.
 *
 * Only outputs if debugging of part was formerly enabled with debug_enable_switch.
 *
 * \param	part	Code part to associate with this message
 * \param	str		printf style formatstring
 */
    #[no_mangle]
    fn debug(part: code_part, str: *const libc::c_char, _: ...);
    // -----------------------------------------------------------------------------------------
    #[no_mangle]
    fn unix_path(path: *const libc::c_char) -> *mut libc::c_char;
    #[no_mangle]
    fn strlen(_: *const libc::c_char) -> libc::c_uint;
    #[no_mangle]
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    #[no_mangle]
    fn strcat(_: *mut libc::c_char, _: *const libc::c_char)
     -> *mut libc::c_char;
    #[no_mangle]
    fn strncpy(_: *mut libc::c_char, _: *const libc::c_char, _: libc::c_uint)
     -> *mut libc::c_char;
    #[no_mangle]
    fn strcpy(_: *mut libc::c_char, _: *const libc::c_char)
     -> *mut libc::c_char;
    #[no_mangle]
    fn memset(_: *mut libc::c_void, _: libc::c_int, _: libc::c_uint)
     -> *mut libc::c_void;
    #[no_mangle]
    fn memcpy(_: *mut libc::c_void, _: *const libc::c_void, _: libc::c_uint)
     -> *mut libc::c_void;
    /* Return the ID number for an ID string */
    #[no_mangle]
    fn strresGetIDNum(psRes: *mut STR_RES, pIDStr: *mut STRING,
                      pIDNum: *mut UDWORD) -> BOOL;
    /* Get the string from an ID number */
    #[no_mangle]
    fn strresGetString(psRes: *mut STR_RES, id: UDWORD) -> *mut STRING;
    #[no_mangle]
    fn blockSuspendUsage();
    #[no_mangle]
    fn blockUnsuspendUsage();
    // The size of this buffer
    /* Save the data in the buffer into the given file */
    #[no_mangle]
    fn saveFile(pFileName: *const libc::c_char,
                pFileData: *const libc::c_char, fileSize: UDWORD) -> BOOL;
    // load a file from disk into a fixed memory buffer
    #[no_mangle]
    fn loadFileToBuffer(pFileName: *mut libc::c_char,
                        pFileBuffer: *mut libc::c_char, bufferSize: UDWORD,
                        pSize: *mut UDWORD) -> BOOL;
    // as above but returns quietly if no file found
    #[no_mangle]
    fn loadFileToBufferNoError(pFileName: *mut libc::c_char,
                               pFileBuffer: *mut libc::c_char,
                               bufferSize: UDWORD, pSize: *mut UDWORD)
     -> BOOL;
    #[no_mangle]
    static mut colours: [uint8; 0];
    //fog available
    #[no_mangle]
    fn pie_EnableFog(val: BOOL);
    #[no_mangle]
    fn pie_GetFogEnabled() -> BOOL;
    #[no_mangle]
    fn pie_SetFogColour(colour: UDWORD);
    #[no_mangle]
    fn pie_GetFogColour() -> UDWORD;
    //resets the event timer - updateTime
    #[no_mangle]
    fn eventTimeReset(initTime: UDWORD);
    /*
 * EvntSave.h
 *
 * Save the state of the event system.
 *
 */
    // Save the state of the event system
    #[no_mangle]
    fn eventSaveState(version: SDWORD, ppBuffer: *mut *mut libc::c_char,
                      pFileSize: *mut UDWORD) -> BOOL;
    // Load the state of the event system
    #[no_mangle]
    fn eventLoadState(pBuffer: *mut libc::c_char, fileSize: UDWORD,
                      bHashed: BOOL) -> BOOL;
    /*
 * GTime.h
 *
 * Interface to the game clock.
 *
 */
    /* The number of ticks per second for the game clock */
    // The maximum time for one frame (stops the clock running away when debugging)
// changed to /6 by ajl. if this needs to go back to ticks/10 then tell me. 
    /* The current time in the game world */
    #[no_mangle]
    static mut gameTime: UDWORD;
    /* Call this to stop the game timer */
    #[no_mangle]
    fn gameTimeStop();
    /* Call this to restart the game timer after a call to gameTimeStop */
    #[no_mangle]
    fn gameTimeStart();
    /*Call this to reset the game timer*/
    #[no_mangle]
    fn gameTimeReset(time: UDWORD);
    //storage
    #[no_mangle]
    static mut apsDroidTemplates: [*mut DROID_TEMPLATE; 8];
    #[no_mangle]
    static mut aDroidExperience: [[UWORD; 32]; 8];
    //extern BOOL loadDroidPrograms(car *pProgramData, UDWORD bufferSize);
    /*initialise the template build and power points */
    #[no_mangle]
    fn initTemplatePoints();
    /*Builds an instance of a Structure - the x/y passed in are in world coords.*/
    #[no_mangle]
    fn buildDroid(pTemplate: *mut DROID_TEMPLATE, x: UDWORD, y: UDWORD,
                  player: UDWORD, onMission: BOOL) -> *mut DROID;
    /* Calculate the points required to build the template */
    #[no_mangle]
    fn calcTemplateBuild(psTemplate: *mut DROID_TEMPLATE) -> UDWORD;
    /* Calculate the points required to build the droid */
//UDWORD calcDroidBuild(DROID *psDroid);
    /* Calculate the power points required to build/maintain the droid */
    #[no_mangle]
    fn calcTemplatePower(psTemplate: *mut DROID_TEMPLATE) -> UDWORD;
    //free the storage for the droid templates
    #[no_mangle]
    fn droidTemplateShutDown() -> BOOL;
    /*getTemplateFromMultiPlayerID gets template for unique ID  searching all lists */
    #[no_mangle]
    fn getTemplateFromMultiPlayerID(multiPlayerID: UDWORD)
     -> *mut DROID_TEMPLATE;
    /* uwCycles=0 for infinite looping */
    #[no_mangle]
    fn animObj_Add(pParentObj: *mut libc::c_void, iAnimID: libc::c_int,
                   udwStartDelay: UDWORD, uwCycles: UWORD)
     -> *mut ANIM_OBJECT;
    #[no_mangle]
    fn audio_PlayObjStaticTrack(psObj: *mut libc::c_void, iTrack: libc::c_int)
     -> BOOL;
    #[no_mangle]
    fn audio_StopAll();
    /*calculates the electronic resistance of a droid based on its experience level*/
    #[no_mangle]
    fn droidResistance(psDroid: *mut DROID) -> SWORD;
    /*calculate the power cost to repair a droid*/
    #[no_mangle]
    fn powerReqForDroidRepair(psDroid: *mut DROID) -> UWORD;
    /*returns TRUE if droid type is one of the Cyborg types*/
    #[no_mangle]
    fn cyborgDroid(psDroid: *mut DROID) -> BOOL;
    /*
 * Structure.h
 *
 * Definitions for the structures.
 *
 */
    // how long to wait between CALL_STRUCT_ATTACKED's - plus how long to flash on radar for
    // This should really be logarithmic
    /* explosion data for when a structure is blown up - used by features as well*/
    //production loop max
    //10
    /*This should correspond to the structLimits! */
    //used to flag when the Factory is ready to start building
    //distance that VTOLs can be away from the reArm pad
    #[no_mangle]
    static mut factoryModuleIMDs: [[*mut iIMDShape; 2]; 2];
    #[no_mangle]
    static mut researchModuleIMDs: [*mut iIMDShape; 4];
    #[no_mangle]
    static mut asProductionRun: [[[PRODUCTION_RUN; 20]; 5]; 3];
    //stores which player the production list has been set up for
    #[no_mangle]
    static mut productionPlayer: SBYTE;
    //holder for all StructureStats
    #[no_mangle]
    static mut asStructureStats: *mut STRUCTURE_STATS;
    #[no_mangle]
    static mut numStructureStats: UDWORD;
    #[no_mangle]
    static mut asStructLimits: [*mut STRUCTURE_LIMITS; 8];
    //holds the upgrades attained through research for structure stats
    #[no_mangle]
    static mut asStructureUpgrade: [STRUCTURE_UPGRADE; 8];
    #[no_mangle]
    static mut asWallDefenceUpgrade: [WALLDEFENCE_UPGRADE; 8];
    //holds the upgrades for the functionality of structures through research
    #[no_mangle]
    static mut asResearchUpgrade: [RESEARCH_UPGRADE; 8];
    #[no_mangle]
    static mut asPowerUpgrade: [POWER_UPGRADE; 8];
    #[no_mangle]
    static mut asRepairFacUpgrade: [REPAIR_FACILITY_UPGRADE; 8];
    #[no_mangle]
    static mut asProductionUpgrade: [[PRODUCTION_UPGRADE; 3]; 8];
    #[no_mangle]
    static mut asReArmUpgrade: [REARM_UPGRADE; 8];
    // Set the tile no draw flags for a structure
    #[no_mangle]
    fn setStructTileDraw(psStruct: *mut STRUCTURE);
    //builds a specified structure at a given location
    #[no_mangle]
    fn buildStructure(pStructureType: *mut STRUCTURE_STATS, x: UDWORD,
                      y: UDWORD, player: UDWORD, FromSave: BOOL)
     -> *mut STRUCTURE;
    //initialise the structure limits structure
    #[no_mangle]
    fn initStructLimits();
    /* set the current number of structures of each type built */
    #[no_mangle]
    fn setCurrentStructQuantity(displayError: BOOL);
    /* get a stat inc based on the name */
    #[no_mangle]
    fn getStructStatFromName(pName: *mut STRING) -> SDWORD;
    /*initialises the flag before a new data set is loaded up*/
    #[no_mangle]
    fn initFactoryNumFlag();
    //called at start of missions
    #[no_mangle]
    fn resetFactoryNumFlag();
    /*this is called whenever a structure has finished building*/
    #[no_mangle]
    fn buildingComplete(psBuilding: *mut STRUCTURE);
    // these functions are used in game.c inplace of  building complete
    #[no_mangle]
    fn checkForResExtractors(psPowerGen: *mut STRUCTURE);
    #[no_mangle]
    fn checkForPowerGen(psPowerGen: *mut STRUCTURE);
    // Set the command droid that factory production should go to
//struct _command_droid;
    #[no_mangle]
    fn assignFactoryCommandDroid(psStruct: *mut STRUCTURE,
                                 psCommander: *mut _droid);
    /*for a given structure, return a pointer to its module stat */
    #[no_mangle]
    fn getModuleStat(psStruct: *mut STRUCTURE) -> *mut STRUCTURE_STATS;
    /*Access functions for the upgradeable stats of a structure*/
    #[no_mangle]
    fn structureBody(psStruct: *mut STRUCTURE) -> UDWORD;
    //check that delivery points haven't been put down in invalid location
    #[no_mangle]
    fn checkDeliveryPoints(version: UDWORD);
    /*This function is called after a game is loaded so that any resource extractors 
that are active are initialised for when to start*/
    #[no_mangle]
    fn checkResExtractorsActive();
    // La!
    #[no_mangle]
    fn IsStatExpansionModule(psStats: *mut STRUCTURE_STATS) -> BOOL;
    /*
 * Feature.h
 *
 * Definitions for the feature structures.
 *
 */
    //they're just not there anymore!!!!! Ye ha!
    /* The statistics for the features */
    #[no_mangle]
    static mut asFeatureStats: *mut FEATURE_STATS;
    #[no_mangle]
    static mut numFeatureStats: UDWORD;
    // Set the tile no draw flags for a structure
    #[no_mangle]
    fn setFeatTileDraw(psFeat: *mut FEATURE);
    /* Create a feature on the map */
    #[no_mangle]
    fn buildFeature(psStats: *mut FEATURE_STATS, x: UDWORD, y: UDWORD,
                    FromSave: BOOL) -> *mut FEATURE;
    // the memory heap for templates
    #[no_mangle]
    static mut psTemplateHeap: *mut OBJ_HEAP;
    /* The lists of objects allocated */
    #[no_mangle]
    static mut apsDroidLists: [*mut DROID; 8];
    #[no_mangle]
    static mut apsStructLists: [*mut STRUCTURE; 8];
    #[no_mangle]
    static mut apsFeatureLists: [*mut FEATURE; 8];
    #[no_mangle]
    static mut apsFlagPosLists: [*mut FLAG_POSITION; 8];
    /* add the droid to the Droid Lists */
    #[no_mangle]
    fn addDroid(psDroidToAdd: *mut DROID, pList: *mut *mut DROID);
    /* Remove all droids */
    #[no_mangle]
    fn freeAllDroids();
    /* Remove all structures */
    #[no_mangle]
    fn freeAllStructs();
    /* Remove all features */
    #[no_mangle]
    fn freeAllFeatures();
    /* Create a new Flag Position */
    #[no_mangle]
    fn createFlagPosition(ppsNew: *mut *mut FLAG_POSITION, player: UDWORD)
     -> BOOL;
    /* add the Flag Position to the Flag Position Lists */
    #[no_mangle]
    fn addFlagPosition(psFlagPosToAdd: *mut FLAG_POSITION);
    // free all flag positions
    #[no_mangle]
    fn freeAllFlagPositions();
    // Find a base object from it's id
    #[no_mangle]
    fn getBaseObjFromId(id: UDWORD) -> *mut BASE_OBJECT;
    #[no_mangle]
    fn checkValidId(id: UDWORD) -> BOOL;
    #[no_mangle]
    fn getRepairIdFromFlag(psFlag: *mut FLAG_POSITION) -> UDWORD;
    /*
 * AI.h
 *
 * Definitions for the AI system structures
 *
 */
    // states of alliance between players
    // for setting values only.
    //alliance possibilities for games.
    //#define GROUP_WINS		2
    // alliances
    #[no_mangle]
    static mut alliances: [[UBYTE; 8]; 8];
    /* update body and turret to local slope */
    #[no_mangle]
    fn updateDroidOrientation(psDroid: *mut DROID);
    #[no_mangle]
    static mut asBodyStats: *mut BODY_STATS;
    #[no_mangle]
    static mut asBrainStats: *mut BRAIN_STATS;
    #[no_mangle]
    static mut asPropulsionStats: *mut PROPULSION_STATS;
    #[no_mangle]
    static mut asSensorStats: *mut SENSOR_STATS;
    #[no_mangle]
    static mut asECMStats: *mut ECM_STATS;
    #[no_mangle]
    static mut asRepairStats: *mut REPAIR_STATS;
    #[no_mangle]
    static mut asWeaponStats: *mut WEAPON_STATS;
    #[no_mangle]
    static mut asConstructStats: *mut CONSTRUCT_STATS;
    #[no_mangle]
    static mut asWeaponUpgrade: [[WEAPON_UPGRADE; 17]; 8];
    #[no_mangle]
    static mut asSensorUpgrade: [SENSOR_UPGRADE; 8];
    #[no_mangle]
    static mut asECMUpgrade: [ECM_UPGRADE; 8];
    #[no_mangle]
    static mut asRepairUpgrade: [REPAIR_UPGRADE; 8];
    #[no_mangle]
    static mut asBodyUpgrade: [[BODY_UPGRADE; 2]; 8];
    #[no_mangle]
    static mut numBodyStats: UDWORD;
    #[no_mangle]
    static mut numBrainStats: UDWORD;
    #[no_mangle]
    static mut numPropulsionStats: UDWORD;
    #[no_mangle]
    static mut numSensorStats: UDWORD;
    #[no_mangle]
    static mut numECMStats: UDWORD;
    #[no_mangle]
    static mut numRepairStats: UDWORD;
    #[no_mangle]
    static mut numProgramStats: UDWORD;
    #[no_mangle]
    static mut numWeaponStats: UDWORD;
    #[no_mangle]
    static mut numConstructStats: UDWORD;
    #[no_mangle]
    static mut apCompLists: [[*mut UBYTE; 9]; 8];
    #[no_mangle]
    static mut apStructTypeLists: [*mut UBYTE; 8];
    //get the component Inc for a stat based on the name
    #[no_mangle]
    fn getCompFromName(compType: UDWORD, pName: *mut STRING) -> SDWORD;
    // Pass in a stat and get its name
    #[no_mangle]
    fn getStatName(pStat: *mut libc::c_void) -> *mut STRING;
    /*goes thru' the list passed in reversing the order so the first entry becomes 
the last and the last entry becomes the first!*/
    #[no_mangle]
    fn reverseObjectList(ppsList: *mut *mut BASE_OBJECT);
    #[no_mangle]
    static mut terrainTypes: [UBYTE; 255];
    #[no_mangle]
    static mut mapWidth: UDWORD;
    #[no_mangle]
    static mut mapHeight: UDWORD;
    #[no_mangle]
    static mut psMapTiles: *mut MAPTILE;
    /* Load the map data */
    #[no_mangle]
    fn mapLoad(pFileData: *mut libc::c_char, fileSize: UDWORD) -> BOOL;
    /* Save the map data */
    #[no_mangle]
    fn mapSave(ppFileData: *mut *mut libc::c_char, pFileSize: *mut UDWORD)
     -> BOOL;
    /* The map tiles generated by map calc line */
    #[no_mangle]
    static mut aMapLinePoints: *mut TILE_COORD;
    /* Return height of x,y */
//extern SDWORD map_Height(UDWORD x, UDWORD y);
    #[no_mangle]
    fn map_Height(x: UDWORD, y: UDWORD) -> SWORD;
    #[no_mangle]
    fn readVisibilityData(pFileData: *mut libc::c_char, fileSize: UDWORD)
     -> BOOL;
    #[no_mangle]
    fn writeVisibilityData(pFileName: *mut STRING) -> BOOL;
    //scroll min and max values
    #[no_mangle]
    static mut scrollMinX: SDWORD;
    #[no_mangle]
    static mut scrollMaxX: SDWORD;
    #[no_mangle]
    static mut scrollMinY: SDWORD;
    #[no_mangle]
    static mut scrollMaxY: SDWORD;
    /* The store for the research stats */
    #[no_mangle]
    static mut asResearch: *mut RESEARCH;
    #[no_mangle]
    static mut numResearch: UDWORD;
    //List of pointers to arrays of PLAYER_RESEARCH[numResearch] for each player
    #[no_mangle]
    static mut asPlayerResList: [*mut PLAYER_RESEARCH; 8];
    /* Default level of sensor, repair and ECM */
    #[no_mangle]
    static mut aDefaultSensor: [UDWORD; 8];
    #[no_mangle]
    static mut aDefaultECM: [UDWORD; 8];
    #[no_mangle]
    static mut aDefaultRepair: [UDWORD; 8];
    /* process the results of a completed research topic */
    #[no_mangle]
    fn researchResult(researchIndex: UDWORD, player: UBYTE, bDisplay: BOOL);
    #[no_mangle]
    fn enableSelfRepair(player: UBYTE);
    /*clear the playerPower */
    #[no_mangle]
    fn clearPlayerPower();
    #[no_mangle]
    static mut asPower: [*mut PLAYER_POWER; 8];
    //flag used to check for power calculations to be done or not
    #[no_mangle]
    static mut powerCalculated: BOOL;
    /* Reset the player AI after a load game */
    #[no_mangle]
    fn playerReset();
    #[no_mangle]
    static mut selectedPlayer: UDWORD;
    #[no_mangle]
    fn proj_FreeAllProjectiles();
    // true when interface is up and should be run.
    //the name of the save game to load from the front end
    #[no_mangle]
    static mut saveGameName: [STRING; 256];
    /* The string resource object */
    #[no_mangle]
    static mut psStringRes: *mut STR_RES;
    /*
 * Message.h
 *
 * Functions for the messages shown in the Intelligence Map View
 */
    /* The lists of messages allocated */
    #[no_mangle]
    static mut apsMessages: [*mut MESSAGE; 8];
    /* The list of proximity displays allocated */
    #[no_mangle]
    static mut apsProxDisp: [*mut PROXIMITY_DISPLAY; 8];
    /*Add a messgae to the list */
    #[no_mangle]
    fn addMessage(msgType: UDWORD, proxPos: BOOL, player: UDWORD)
     -> *mut MESSAGE;
    /* Remove all Messages*/
    #[no_mangle]
    fn freeMessages();
    /* removes all the proximity displays */
    #[no_mangle]
    fn releaseAllProxDisp();
    /*get the view data that contains the text message pointer passed in */
    #[no_mangle]
    fn getViewData(pTextMsg: *mut STRING) -> *mut VIEWDATA;
    #[no_mangle]
    fn intCheckResearchButton();
    #[no_mangle]
    fn stopReticuleButtonFlash(buttonID: UDWORD);
    #[no_mangle]
    static mut displayBufferSize: UDWORD;
    #[no_mangle]
    static mut DisplayBuffer: *mut libc::c_char;
    #[no_mangle]
    fn setDesiredPitch(pitch: SDWORD);
    #[no_mangle]
    fn setViewAngle(angle: SDWORD);
    #[no_mangle]
    fn disp3d_setView(newView: *mut iView);
    #[no_mangle]
    fn disp3d_getView(newView: *mut iView);
    #[no_mangle]
    fn getWaterTileNum() -> UDWORD;
    #[no_mangle]
    fn setUnderwaterTile(num: UDWORD);
    #[no_mangle]
    fn getRubbleTileNum() -> UDWORD;
    #[no_mangle]
    fn setRubbleTile(num: UDWORD);
    #[no_mangle]
    fn readFXData(pFileData: *mut libc::c_char, fileSize: UDWORD) -> BOOL;
    #[no_mangle]
    fn writeFXData(pFileName: *mut STRING) -> BOOL;
    // the block heap for the campaign map
    #[no_mangle]
    static mut psMapHeap: *mut BLOCK_HEAP;
    // the block heap for the pre WRF data
    #[no_mangle]
    static mut psMissionHeap: *mut BLOCK_HEAP;
    #[no_mangle]
    static mut mission: MISSION;
    #[no_mangle]
    static mut offWorldKeepLists: BOOL;
    #[no_mangle]
    static mut apsLimboDroids: [*mut DROID; 8];
    // return positions for vtols
    #[no_mangle]
    static mut asVTOLReturnPos: [POINT; 8];
    /*on the PC - sets the countdown played flag*/
    #[no_mangle]
    fn setMissionCountDown();
    // initialise the mission stuff for a save game
    #[no_mangle]
    fn startMissionSave(missionType: SDWORD) -> BOOL;
    //this causes the new mission data to be loaded up
    #[no_mangle]
    fn launchMission();
    #[no_mangle]
    fn missionIsOffworld() -> BOOL;
    //returns TRUE if the mission is a Limbo Expand mission
    #[no_mangle]
    fn missionLimboExpand() -> BOOL;
    #[no_mangle]
    fn swapMissionPointers();
    //access functions for bPlayCountDown flag
    #[no_mangle]
    fn setPlayCountDown(set: UBYTE);
    #[no_mangle]
    fn getPlayCountDown() -> BOOL;
    #[no_mangle]
    fn getLandingZone(i: SDWORD) -> *mut LANDING_ZONE;
    //
// orderdef.h 
//
// order releated structures.
    // data for barbarians retreating
    // position to retreat to
    // number of units below which might run
    // %health value below which to turn and run - FOR GROUPS ONLY
    // basic chance to run
    //UDWORD			x,y;
	//UDWORD			x2,y2;
    #[no_mangle]
    static mut asRunData: [RUN_DATA; 8];
    #[no_mangle]
    fn orderDroid(psDroid: *mut DROID, order: DROID_ORDER);
    #[no_mangle]
    fn getCampaignNumber() -> UDWORD;
    /*
 * Group.h
 *
 * Link droids together into a group for AI etc.
 *
 */
    // standard group
    // command droid group
    // transporter group
    // list of droids in the group
    // the command droid of a command group
    // where the group should retreat to
    // initialise the group system
    // shutdown the group system
    // create a new group
    #[no_mangle]
    fn grpCreate(ppsGroup: *mut *mut DROID_GROUP) -> BOOL;
    #[no_mangle]
    fn getDroidsToSafetyFlag() -> BOOL;
    #[no_mangle]
    fn missionGetReinforcementTime() -> UDWORD;
    #[no_mangle]
    fn clearMissionWidgets();
    #[no_mangle]
    fn resetMissionWidgets();
    #[no_mangle]
    fn setNoGoArea(x1: UBYTE, y1: UBYTE, x2: UBYTE, y2: UBYTE, area: UBYTE);
    #[no_mangle]
    fn grpJoin(psGroup: *mut DROID_GROUP, psDroid: *mut DROID);
    #[no_mangle]
    fn missionSetReinforcementTime(iTime: UDWORD);
    #[no_mangle]
    fn setDroidsToSafetyFlag(set: BOOL);
    #[no_mangle]
    fn readScoreData(pFileData: *mut libc::c_char, fileSize: UDWORD) -> BOOL;
    #[no_mangle]
    fn writeScoreData(pFileName: *mut STRING) -> BOOL;
    #[no_mangle]
    fn reverseTemplateList(ppsList: *mut *mut DROID_TEMPLATE);
    #[no_mangle]
    static mut fogStatus: UDWORD;
    #[no_mangle]
    fn setPlayerColour(player: UDWORD, col: UDWORD) -> BOOL;
    #[no_mangle]
    fn getPlayerColour(pl: UDWORD) -> UBYTE;
    #[no_mangle]
    fn SetRadarZoom(ZoomLevel: UWORD);
    #[no_mangle]
    fn GetRadarZoom() -> UDWORD;
    // add a droid to a command group
    #[no_mangle]
    fn cmdDroidAddDroid(psCommander: *mut DROID, psDroid: *mut DROID);
    // return the current target designator for a player
    #[no_mangle]
    fn cmdDroidGetDesignator(player: UDWORD) -> *mut DROID;
    // set the current target designator for a player
    #[no_mangle]
    fn cmdDroidSetDesignator(psDroid: *mut DROID);
    // note that commander experience should be increased
    #[no_mangle]
    fn cmdDroidMultiExpBoost(bDoit: BOOL);
    // Create a new formation
    #[no_mangle]
    fn formationNew(ppsFormation: *mut *mut FORMATION, type_0: FORMATION_TYPE,
                    x: SDWORD, y: SDWORD, dir: SDWORD) -> BOOL;
    // Try and find a formation near to a location
    #[no_mangle]
    fn formationFind(ppsFormation: *mut *mut FORMATION, x: SDWORD, y: SDWORD)
     -> BOOL;
    // Associate a unit with a formation
    #[no_mangle]
    fn formationJoin(psFormation: *mut FORMATION, psObj: *mut BASE_OBJECT);
    #[no_mangle]
    fn war_GetFog() -> BOOL;
    // ////////////////////////////////////////////////////////////////////////////
// Game Options and stats. 
    #[no_mangle]
    static mut game: MULTIPLAYERGAME;
    // the game description.
    #[no_mangle]
    static mut bMultiPlayer: BOOL;
    // true when more than 1 player.
    #[no_mangle]
    static mut player2dpid: [DWORD; 8];
    #[no_mangle]
    fn getPlayerName(player: UDWORD) -> *mut STRING;
    //send AI message
    #[no_mangle]
    fn turnOffMultiMsg(bDoit: BOOL) -> BOOL;
    // ////////////////////////////////////////////////////////////////////////
// variables
    #[no_mangle]
    static mut NetPlay: NETPLAY;
    // the global case
    //#define DEFAULT_LEVEL	"CAM_2A"
    #[no_mangle]
    static mut pLevelName: [libc::c_char; 257];
    // load up the data for a level
    #[no_mangle]
    fn levLoadData(pName: *mut STRING, pSaveName: *mut STRING,
                   saveType: SDWORD) -> BOOL;
    // find the level dataset
    #[no_mangle]
    fn levFindDataSet(pName: *mut STRING, ppsDataSet: *mut *mut LEVEL_DATASET)
     -> BOOL;
    #[no_mangle]
    fn getTileStructure(x: UDWORD, y: UDWORD) -> *mut STRUCTURE;
    /*
 * ScriptExtern.h
 *
 * All game variable access functions for the scripts
 *
 */
    // current game level
    #[no_mangle]
    static mut scrGameLevel: SDWORD;
    // whether any additional special case victory/failure conditions have been met
    #[no_mangle]
    static mut bExtraVictoryFlag: BOOL;
    #[no_mangle]
    static mut bExtraFailFlag: BOOL;
    #[no_mangle]
    static mut bTrackTransporter: BOOL;
    // to disk 
    #[no_mangle]
    fn loadMultiStats(sPlayerName: *mut STRING, playerStats: *mut PLAYERSTATS)
     -> BOOL;
    // get from net
    #[no_mangle]
    fn setMultiStats(playerDPID: DWORD, plStats: PLAYERSTATS, bLocal: BOOL)
     -> BOOL;
    #[no_mangle]
    fn setPlayerHasLost(val: BOOL);
    #[no_mangle]
    fn testPlayerHasLost() -> BOOL;
    #[no_mangle]
    fn testPlayerHasWon() -> BOOL;
    #[no_mangle]
    fn setPlayerHasWon(val: BOOL);
    #[no_mangle]
    fn setScriptWinLoseVideo(val: UBYTE);
    /* **************************************************************************/
/*
 *	Local Variables
 */
/* **************************************************************************/
    #[no_mangle]
    static mut objID: UDWORD;
}
pub type size_t = libc::c_uint;
pub type UBYTE = libc::c_uchar;
pub type SBYTE = libc::c_schar;
pub type STRING = libc::c_char;
pub type UWORD = libc::c_ushort;
pub type SWORD = libc::c_short;
pub type UDWORD = libc::c_uint;
pub type SDWORD = libc::c_int;
pub type BOOL = libc::c_int;
pub type CHAR = libc::c_char;
pub type DWORD = libc::c_int;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct POINT {
    pub x: libc::c_int,
    pub y: libc::c_int,
}
/* !WIN32 */
pub type DPID = libc::c_int;
pub type code_part = libc::c_uint;
pub const LOG_LAST: code_part = 12;
pub const LOG_SCRIPT: code_part = 11;
pub const LOG_NEVER: code_part = 10;
pub const LOG_ERROR: code_part = 9;
pub const LOG_MEMORY: code_part = 8;
pub const LOG_NET: code_part = 7;
pub const LOG_TEXTURE: code_part = 6;
pub const LOG_3D: code_part = 5;
pub const LOG_WZ: code_part = 4;
pub const LOG_VIDEO: code_part = 3;
pub const LOG_SOUND: code_part = 2;
pub const LOG_MAIN: code_part = 1;
pub const LOG_ALL: code_part = 0;
/*
 * Block.h
 *
 * Routines to allocate memory from one large block.
 * Any memory allocated is only available to be reallocated after
 * the whole block has been reset.
 */
// control whether the debugging block malloc is used
/* *********************************************************************************/
/*                    type definitions                                            */
// size of block
// pointer to the start of the free memory section
// pointer to the base of the memory block
// The start of the last allocated block (so that it can be freed by blkSpecialFree
/* Parse the res file */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _block_heap {
    pub init: SDWORD,
    pub ext: SDWORD,
    pub psBlocks: *mut BLOCK_HEAP_MEM,
    pub psNext: *mut _block_heap,
}
pub type BLOCK_HEAP_MEM = _block_heap_mem;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _block_heap_mem {
    pub size: SDWORD,
    pub pFree: *mut UBYTE,
    pub pMem: *mut UBYTE,
    pub pLastAllocated: *mut UBYTE,
    pub psNext: *mut _block_heap_mem,
}
/*
 * Heap.h
 *
 * Interface to the heap memory routines.
 *
 * Overhead of using the heap is :
 *			24 bytes for the initial block
 *           4 bytes for the extension blocks
 *
 */
/* Include Mem.h to get the DEBUG_MALLOC #define - this controls whether
  * normal or debugging memory management is used.
  */
/* structure used to store the list of free heap objects */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _free_object {
    pub psNext: *mut _free_object,
}
pub type FREE_OBJECT = _free_object;
/* structure used to store the extra space allocated for the heap */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _heap_extension {
    pub pMemory: *mut UBYTE,
    pub psNext: *mut _heap_extension,
}
pub type HEAP_EXTENSION = _heap_extension;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _obj_heap {
    pub objSize: UDWORD,
    pub initAlloc: UDWORD,
    pub extAlloc: UDWORD,
    pub psBlkHeap: *mut _block_heap,
    pub psFree: *mut FREE_OBJECT,
    pub pMemory: *mut UBYTE,
    pub psExt: *mut HEAP_EXTENSION,
}
pub type OBJ_HEAP = _obj_heap;
// Extension memory for the heap
/*
 * Treap.h
 *
 * A balanced binary tree implementation
 *
 * Overhead for using the treap is -
 *		Overhead for the heap used by the treap :
 *                  24 bytes + 4 bytes per extension
 *      12 bytes for the root
 *      20 bytes per node
 */
/* Turn on and off the treap debugging */
/* Function type for the object compare
 * return -1 for less
 *         1 for more
 *         0 for equal
 */
pub type TREAP_CMP
    =
    Option<unsafe extern "C" fn(_: UDWORD, _: UDWORD) -> SDWORD>;
/* The basic elements in the treap node.
 * These are done as macros so that the memory system
 * can use parts of the treap system.
 */
/* The key to sort the node on */
/* Treap priority */
/* The object stored in the treap */
/* The sub trees */
/* The debug info */
/* file the node was created in */
/* line the node was created at */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _treap_node {
    pub key: UDWORD,
    pub priority: UDWORD,
    pub pObj: *mut libc::c_void,
    pub psLeft: *mut _treap_node,
    pub psRight: *mut _treap_node,
}
pub type TREAP_NODE = _treap_node;
/* Treap data structure */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _treap {
    pub cmp: TREAP_CMP,
    pub psNodes: *mut OBJ_HEAP,
    pub psRoot: *mut TREAP_NODE,
}
pub type TREAP = _treap;
// root of the tree
// Routines to provide simple maths functions that work on both PSX & PC
// Use the type "FRACT" instead of FLOAT
//  - This is defined as a float on PC and a 20.12 fixed point number on PSX
//
//  Use:-
//		MAKEFRACT(int);  to convert from a SDWORD to a FRACT
//		MAKEINT(fract);	to convert the other way
//		FRACTmul(fract,fract); to multiply two fract numbers
//		FRACTdiv(fract,fract); to divide two numbers
//		SQRT(fract);		to get square root of a fract (returns a fract)
//      iSQRT(int);			to get a square root of an integer (returns an UDWORD)
//      FRACTCONST(constA,constB);	; Generates a constant of (constA/constB)
//                         e.g. to define 0.5 use FRACTCONST(1,2)
//                              to define 0.114 use FRACTCONT(114,1000)
//
// Also PERCENT(int,int);	// returns a int value 0->100 of the percentage of the first param over the second
//
// This file used to be in the deliverance src directory. But Jeremy quite correctly
// pointed out to me that it should be library based not deliverance based, and hence
// has now been moved to the lib\framework directory
//
// If you are reading this file from the deliverance source directory, please delete it now
// To multiply a FRACT by a integer just use the normal operator 
//   e.g.   FractValue2=FractValue*Interger;
//
// save is true of divide
/* Check the header files have been included from frame.h if they
 * are used outside of the framework library.
 */
pub type FRACT = libc::c_float;
/*
 * StrRes.h
 *
 * String resource interface functions
 *
 */
/* A string block */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _str_block {
    pub apStrings: *mut *mut STRING,
    pub idStart: UDWORD,
    pub idEnd: UDWORD,
    pub psNext: *mut _str_block,
}
pub type STR_BLOCK = _str_block;
/* A String Resource */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _str_res {
    pub psIDTreap: *mut TREAP,
    pub psStrings: *mut STR_BLOCK,
    pub init: UDWORD,
    pub ext: UDWORD,
    pub nextID: UDWORD,
}
pub type STR_RES = _str_res;
pub type BLOCK_HEAP = _block_heap;
pub type int32 = libc::c_int;
pub type uint8 = libc::c_uchar;
pub type uint16 = libc::c_ushort;
pub type uint32 = libc::c_uint;
pub type iBitmap = uint8;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct iSprite {
    pub width: libc::c_uint,
    pub height: libc::c_uint,
    pub bmp: *mut iBitmap,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct iVector {
    pub x: int32,
    pub y: int32,
    pub z: int32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct iVertex {
    pub x: int32,
    pub y: int32,
    pub z: int32,
    pub u: int32,
    pub v: int32,
    pub g: uint8,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct iView {
    pub p: iVector,
    pub r: iVector,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct iTexAnim {
    pub nFrames: libc::c_int,
    pub playbackRate: libc::c_int,
    pub textureWidth: libc::c_int,
    pub textureHeight: libc::c_int,
}
// The next free ID
//*************************************************************************
//
// imd structures
//
//*************************************************************************
pub type BSPPOLYID = uint16;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PLANE {
    pub a: FRACT,
    pub b: FRACT,
    pub c: FRACT,
    pub d: FRACT,
    pub vP: iVector,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct BSPTREENODE {
    pub link: [*mut BSPTREENODE; 2],
    pub Plane: PLANE,
    pub TriSameDir: BSPPOLYID,
    pub TriOppoDir: BSPPOLYID,
}
pub type PSBSPTREENODE = *mut BSPTREENODE;
pub type VERTEXID = libc::c_int;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct iIMDPoly {
    pub flags: uint32,
    pub zcentre: int32,
    pub npnts: libc::c_int,
    pub normal: iVector,
    pub pindex: *mut VERTEXID,
    pub vrt: *mut iVertex,
    pub pTexAnim: *mut iTexAnim,
    pub BSP_NextPoly: BSPPOLYID,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct iIMDShape {
    pub flags: uint32,
    pub texpage: int32,
    pub oradius: int32,
    pub sradius: int32,
    pub radius: int32,
    pub visRadius: int32,
    pub xmin: int32,
    pub xmax: int32,
    pub ymin: int32,
    pub ymax: int32,
    pub zmin: int32,
    pub zmax: int32,
    pub ocen: iVector,
    pub numFrames: UWORD,
    pub animInterval: UWORD,
    pub npoints: libc::c_int,
    pub npolys: libc::c_int,
    pub nconnectors: libc::c_int,
    pub points: *mut iVector,
    pub polys: *mut iIMDPoly,
    pub connectors: *mut iVector,
    pub ntexanims: libc::c_int,
    pub texanims: *mut *mut iTexAnim,
    pub next: *mut iIMDShape,
    pub BSPNode: PSBSPTREENODE,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _base_object {
    pub type_0: OBJECT_TYPE,
    pub id: UDWORD,
    pub x: UWORD,
    pub y: UWORD,
    pub z: UWORD,
    pub direction: UWORD,
    pub pitch: SWORD,
    pub roll: SWORD,
    pub psNext: *mut _base_object,
    pub sDisplay: SCREEN_DISP_DATA,
    pub player: UBYTE,
    pub group: UBYTE,
    pub selected: UBYTE,
    pub cluster: UBYTE,
    pub visible: [UBYTE; 8],
    pub died: UDWORD,
    pub lastEmission: UDWORD,
    pub inFire: BOOL,
    pub burnStart: UDWORD,
    pub burnDamage: UDWORD,
}
// points to first polygon in the BSP tree entry ... BSP_NextPoly in the iIMDPoly structure will point to the next entry
// id of the first polygon in the list ... or BSPPOLYID_TERMINATE for none
// id of the first polygon in the list ... or BSPPOLYID_TERMINATE for none
// only needed when generating the tree
/*
 * DisplayDef.h
 *
 * Definitions of the display structures
 *
 */
// ffs am
//#define BOUNDARY_X		(DISP_WIDTH/20)	   // proportional to resolution - Alex M
//#define	BOUNDARY_Y		(DISP_WIDTH/16)
//#define	BOUNDARY_X		(24)
//#define	BOUNDARY_Y		(24)
pub type SCREEN_DISP_DATA = _screen_disp_data;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _screen_disp_data {
    pub imd: *mut iIMDShape,
    pub frameNumber: UDWORD,
    pub screenX: UDWORD,
    pub screenY: UDWORD,
    pub screenR: UDWORD,
}
pub type OBJECT_TYPE = _object_type;
pub type _object_type = libc::c_uint;
pub const OBJ_TARGET: _object_type = 4;
pub const OBJ_BULLET: _object_type = 3;
pub const OBJ_FEATURE: _object_type = 2;
pub const OBJ_STRUCTURE: _object_type = 1;
pub const OBJ_DROID: _object_type = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _base_stats {
    pub ref_0: UDWORD,
    pub pName: *mut STRING,
}
pub type BASE_STATS = _base_stats;
pub type _component_type = libc::c_uint;
pub const COMP_NUMCOMPONENTS: _component_type = 9;
pub const COMP_WEAPON: _component_type = 8;
pub const COMP_CONSTRUCT: _component_type = 7;
pub const COMP_SENSOR: _component_type = 6;
pub const COMP_ECM: _component_type = 5;
pub const COMP_REPAIRUNIT: _component_type = 4;
pub const COMP_PROPULSION: _component_type = 3;
pub const COMP_BRAIN: _component_type = 2;
pub const COMP_BODY: _component_type = 1;
pub const COMP_UNKNOWN: _component_type = 0;
pub type _tech_level = libc::c_uint;
pub const MAX_TECH_LEVELS: _tech_level = 6;
pub const TECH_LEVEL_ALL: _tech_level = 5;
pub const TECH_LEVEL_TWO_THREE: _tech_level = 4;
pub const TECH_LEVEL_ONE_TWO: _tech_level = 3;
pub const TECH_LEVEL_THREE: _tech_level = 2;
pub const TECH_LEVEL_TWO: _tech_level = 1;
pub const TECH_LEVEL_ONE: _tech_level = 0;
pub type TECH_LEVEL = _tech_level;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _comp_base_stats {
    pub ref_0: UDWORD,
    pub pName: *mut STRING,
    pub techLevel: TECH_LEVEL,
    pub buildPower: UDWORD,
    pub buildPoints: UDWORD,
    pub weight: UDWORD,
    pub hitPoints: UDWORD,
    pub systemPoints: UDWORD,
    pub body: UDWORD,
    pub design: BOOL,
    pub pIMD: *mut iIMDShape,
}
pub type COMP_BASE_STATS = _comp_base_stats;
pub type _loc = libc::c_uint;
pub const LOC_TURRET: _loc = 1;
pub const LOC_DEFAULT: _loc = 0;
pub type _weapon_class = libc::c_uint;
pub const NUM_WEAPON_CLASS: _weapon_class = 2;
pub const WC_HEAT: _weapon_class = 1;
pub const WC_KINETIC: _weapon_class = 0;
pub type WEAPON_CLASS = _weapon_class;
pub type _weapon_subclass = libc::c_uint;
pub const NUM_WEAPON_SUBCLASS: _weapon_subclass = 17;
pub const WSC_EMP: _weapon_subclass = 16;
pub const WSC_COMMAND: _weapon_subclass = 15;
pub const WSC_BOMB: _weapon_subclass = 14;
pub const WSC_LAS_SAT: _weapon_subclass = 13;
pub const WSC_SLOWROCKET: _weapon_subclass = 12;
pub const WSC_SLOWMISSILE: _weapon_subclass = 11;
pub const WSC_AAGUN: _weapon_subclass = 10;
pub const WSC_ELECTRONIC: _weapon_subclass = 9;
pub const WSC_HOWITZERS: _weapon_subclass = 8;
pub const WSC_FLAME: _weapon_subclass = 7;
pub const WSC_GAUSS: _weapon_subclass = 6;
pub const WSC_ENERGY: _weapon_subclass = 5;
pub const WSC_ROCKET: _weapon_subclass = 4;
pub const WSC_MISSILE: _weapon_subclass = 3;
pub const WSC_MORTARS: _weapon_subclass = 2;
pub const WSC_CANNON: _weapon_subclass = 1;
pub const WSC_MGUN: _weapon_subclass = 0;
pub type WEAPON_SUBCLASS = _weapon_subclass;
pub type _movement_model = libc::c_uint;
pub const NUM_MOVEMENT_MODEL: _movement_model = 6;
pub const MM_SWEEP: _movement_model = 5;
pub const MM_ERRATICDIRECT: _movement_model = 4;
pub const MM_HOMINGINDIRECT: _movement_model = 3;
pub const MM_HOMINGDIRECT: _movement_model = 2;
pub const MM_INDIRECT: _movement_model = 1;
pub const MM_DIRECT: _movement_model = 0;
pub type MOVEMENT_MODEL = _movement_model;
pub type _weapon_effect = libc::c_uint;
pub const WE_NUMEFFECTS: _weapon_effect = 6;
pub const WE_ANTI_AIRCRAFT: _weapon_effect = 5;
pub const WE_FLAMER: _weapon_effect = 4;
pub const WE_ARTILLERY_ROUND: _weapon_effect = 3;
pub const WE_BUNKER_BUSTER: _weapon_effect = 2;
pub const WE_ANTI_TANK: _weapon_effect = 1;
pub const WE_ANTI_PERSONNEL: _weapon_effect = 0;
pub type WEAPON_EFFECT = _weapon_effect;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _body_stats {
    pub ref_0: UDWORD,
    pub pName: *mut STRING,
    pub techLevel: TECH_LEVEL,
    pub buildPower: UDWORD,
    pub buildPoints: UDWORD,
    pub weight: UDWORD,
    pub hitPoints: UDWORD,
    pub systemPoints: UDWORD,
    pub body: UDWORD,
    pub design: BOOL,
    pub pIMD: *mut iIMDShape,
    pub size: UBYTE,
    pub weaponSlots: UDWORD,
    pub armourValue: [UDWORD; 2],
    pub powerOutput: UDWORD,
    pub ppIMDList: *mut *mut iIMDShape,
    pub pFlameIMD: *mut iIMDShape,
}
pub type BODY_STATS = _body_stats;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _brain_stats {
    pub ref_0: UDWORD,
    pub pName: *mut STRING,
    pub techLevel: TECH_LEVEL,
    pub buildPower: UDWORD,
    pub buildPoints: UDWORD,
    pub weight: UDWORD,
    pub hitPoints: UDWORD,
    pub systemPoints: UDWORD,
    pub body: UDWORD,
    pub design: BOOL,
    pub pIMD: *mut iIMDShape,
    pub progCap: UDWORD,
    pub psWeaponStat: *mut _weapon_stats,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _weapon_stats {
    pub ref_0: UDWORD,
    pub pName: *mut STRING,
    pub techLevel: TECH_LEVEL,
    pub buildPower: UDWORD,
    pub buildPoints: UDWORD,
    pub weight: UDWORD,
    pub hitPoints: UDWORD,
    pub systemPoints: UDWORD,
    pub body: UDWORD,
    pub design: BOOL,
    pub pIMD: *mut iIMDShape,
    pub shortRange: UDWORD,
    pub longRange: UDWORD,
    pub minRange: UDWORD,
    pub shortHit: UDWORD,
    pub longHit: UDWORD,
    pub firePause: UDWORD,
    pub numExplosions: UDWORD,
    pub numRounds: UBYTE,
    pub reloadTime: UDWORD,
    pub damage: UDWORD,
    pub radius: UDWORD,
    pub radiusHit: UDWORD,
    pub radiusDamage: UDWORD,
    pub incenTime: UDWORD,
    pub incenDamage: UDWORD,
    pub incenRadius: UDWORD,
    pub flightSpeed: UDWORD,
    pub indirectHeight: UDWORD,
    pub fireOnMove: FIREONMOVE,
    pub weaponClass: WEAPON_CLASS,
    pub weaponSubClass: WEAPON_SUBCLASS,
    pub movementModel: MOVEMENT_MODEL,
    pub weaponEffect: WEAPON_EFFECT,
    pub recoilValue: UDWORD,
    pub rotate: UBYTE,
    pub maxElevation: UBYTE,
    pub minElevation: SBYTE,
    pub facePlayer: UBYTE,
    pub faceInFlight: UBYTE,
    pub effectSize: UBYTE,
    pub lightWorld: BOOL,
    pub surfaceToAir: UBYTE,
    pub vtolAttackRuns: UBYTE,
    pub directLife: UDWORD,
    pub radiusLife: UDWORD,
    pub pMountGraphic: *mut iIMDShape,
    pub pMuzzleGraphic: *mut iIMDShape,
    pub pInFlightGraphic: *mut iIMDShape,
    pub pTargetHitGraphic: *mut iIMDShape,
    pub pTargetMissGraphic: *mut iIMDShape,
    pub pWaterHitGraphic: *mut iIMDShape,
    pub pTrailGraphic: *mut iIMDShape,
    pub iAudioFireID: SDWORD,
    pub iAudioImpactID: SDWORD,
}
pub type FIREONMOVE = _fireonmove;
pub type _fireonmove = libc::c_uint;
pub const FOM_YES: _fireonmove = 2;
pub const FOM_PARTIAL: _fireonmove = 1;
pub const FOM_NO: _fireonmove = 0;
pub type BRAIN_STATS = _brain_stats;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _propulsion_stats {
    pub ref_0: UDWORD,
    pub pName: *mut STRING,
    pub techLevel: TECH_LEVEL,
    pub buildPower: UDWORD,
    pub buildPoints: UDWORD,
    pub weight: UDWORD,
    pub hitPoints: UDWORD,
    pub systemPoints: UDWORD,
    pub body: UDWORD,
    pub design: BOOL,
    pub pIMD: *mut iIMDShape,
    pub maxSpeed: UDWORD,
    pub propulsionType: UBYTE,
}
pub type PROPULSION_STATS = _propulsion_stats;
pub type _sensor_type = libc::c_uint;
pub const SUPER_SENSOR: _sensor_type = 4;
pub const VTOL_INTERCEPT_SENSOR: _sensor_type = 3;
pub const VTOL_CB_SENSOR: _sensor_type = 2;
pub const INDIRECT_CB_SENSOR: _sensor_type = 1;
pub const STANDARD_SENSOR: _sensor_type = 0;
pub type SENSOR_TYPE = _sensor_type;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _sensor_stats {
    pub ref_0: UDWORD,
    pub pName: *mut STRING,
    pub techLevel: TECH_LEVEL,
    pub buildPower: UDWORD,
    pub buildPoints: UDWORD,
    pub weight: UDWORD,
    pub hitPoints: UDWORD,
    pub systemPoints: UDWORD,
    pub body: UDWORD,
    pub design: BOOL,
    pub pIMD: *mut iIMDShape,
    pub range: UDWORD,
    pub power: UDWORD,
    pub location: UDWORD,
    pub type_0: SENSOR_TYPE,
    pub time: UDWORD,
    pub pMountGraphic: *mut iIMDShape,
}
pub type SENSOR_STATS = _sensor_stats;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _ecm_stats {
    pub ref_0: UDWORD,
    pub pName: *mut STRING,
    pub techLevel: TECH_LEVEL,
    pub buildPower: UDWORD,
    pub buildPoints: UDWORD,
    pub weight: UDWORD,
    pub hitPoints: UDWORD,
    pub systemPoints: UDWORD,
    pub body: UDWORD,
    pub design: BOOL,
    pub pIMD: *mut iIMDShape,
    pub range: UDWORD,
    pub power: UDWORD,
    pub location: UDWORD,
    pub pMountGraphic: *mut iIMDShape,
}
pub type ECM_STATS = _ecm_stats;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _repair_stats {
    pub ref_0: UDWORD,
    pub pName: *mut STRING,
    pub techLevel: TECH_LEVEL,
    pub buildPower: UDWORD,
    pub buildPoints: UDWORD,
    pub weight: UDWORD,
    pub hitPoints: UDWORD,
    pub systemPoints: UDWORD,
    pub body: UDWORD,
    pub design: BOOL,
    pub pIMD: *mut iIMDShape,
    pub repairPoints: UDWORD,
    pub repairArmour: BOOL,
    pub location: UDWORD,
    pub time: UDWORD,
    pub pMountGraphic: *mut iIMDShape,
}
pub type REPAIR_STATS = _repair_stats;
pub type WEAPON_STATS = _weapon_stats;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _construct_stats {
    pub ref_0: UDWORD,
    pub pName: *mut STRING,
    pub techLevel: TECH_LEVEL,
    pub buildPower: UDWORD,
    pub buildPoints: UDWORD,
    pub weight: UDWORD,
    pub hitPoints: UDWORD,
    pub systemPoints: UDWORD,
    pub body: UDWORD,
    pub design: BOOL,
    pub pIMD: *mut iIMDShape,
    pub constructPoints: UDWORD,
    pub pMountGraphic: *mut iIMDShape,
}
pub type CONSTRUCT_STATS = _construct_stats;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _weapon_upgrade {
    pub firePause: UBYTE,
    pub shortHit: UWORD,
    pub longHit: UWORD,
    pub damage: UWORD,
    pub radiusDamage: UWORD,
    pub incenDamage: UWORD,
    pub radiusHit: UWORD,
}
pub type WEAPON_UPGRADE = _weapon_upgrade;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _sensor_upgrade {
    pub power: UWORD,
    pub range: UWORD,
}
pub type SENSOR_UPGRADE = _sensor_upgrade;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _ecm_upgrade {
    pub power: UWORD,
}
pub type ECM_UPGRADE = _ecm_upgrade;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _repair_upgrade {
    pub repairPoints: UWORD,
}
pub type REPAIR_UPGRADE = _repair_upgrade;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _body_upgrade {
    pub powerOutput: UWORD,
    pub body: UWORD,
    pub armourValue: [UWORD; 2],
}
//UDWORD		dummy;
//	BOOL		drawnThisFrame;		// for sorting - have we drawn the imd already?
// last frame it was drawn
//	UDWORD		animFrame;			// anim Frame
//	SDWORD		bucketDepth;
//	BOOL		onScreen;
//	UDWORD		numTiles;
/* weapon stats which can be upgraded by research*/
/*sensor stats which can be upgraded by research*/
/*ECM stats which can be upgraded by research*/
/*repair stats which can be upgraded by research*/
/*constructor stats which can be upgraded by research*/
/*body stats which can be upgraded by research*/
pub type BODY_UPGRADE = _body_upgrade;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _function {
    pub ref_0: UDWORD,
    pub pName: *mut STRING,
    pub type_0: UBYTE,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _repair_droid_function {
    pub ref_0: UDWORD,
    pub pName: *mut STRING,
    pub type_0: UBYTE,
    pub repairPoints: UDWORD,
}
pub type REPAIR_DROID_FUNCTION = _repair_droid_function;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _structure_stats {
    pub ref_0: UDWORD,
    pub pName: *mut STRING,
    pub type_0: UDWORD,
    pub techLevel: TECH_LEVEL,
    pub strength: STRUCT_STRENGTH,
    pub terrainType: UDWORD,
    pub baseWidth: UDWORD,
    pub baseBreadth: UDWORD,
    pub foundationType: UDWORD,
    pub buildPoints: UDWORD,
    pub height: UDWORD,
    pub armourValue: UDWORD,
    pub bodyPoints: UDWORD,
    pub repairSystem: UDWORD,
    pub powerToBuild: UDWORD,
    pub resistance: UDWORD,
    pub sizeModifier: UDWORD,
    pub pIMD: *mut iIMDShape,
    pub pBaseIMD: *mut iIMDShape,
    pub pECM: *mut _ecm_stats,
    pub pSensor: *mut _sensor_stats,
    pub psWeapStat: *mut _weapon_stats,
    pub numFuncs: UDWORD,
    pub defaultFunc: SDWORD,
    pub asFuncList: *mut *mut _function,
}
pub type STRUCT_STRENGTH = _struct_strength;
pub type _struct_strength = libc::c_uint;
pub const NUM_STRUCT_STRENGTH: _struct_strength = 4;
pub const STRENGTH_BUNKER: _struct_strength = 3;
pub const STRENGTH_HARD: _struct_strength = 2;
pub const STRENGTH_MEDIUM: _struct_strength = 1;
pub const STRENGTH_SOFT: _struct_strength = 0;
/*
 * MoveDef.h
 *
 * Structure definitions for movement structures.
 *
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _path_point {
    pub x: UBYTE,
    pub y: UBYTE,
}
pub type PATH_POINT = _path_point;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _move_control {
    pub Status: UBYTE,
    pub Mask: UBYTE,
    pub Position: UBYTE,
    pub numPoints: UBYTE,
    pub asPath: [PATH_POINT; 100],
    pub DestinationX: SDWORD,
    pub DestinationY: SDWORD,
    pub srcX: SDWORD,
    pub srcY: SDWORD,
    pub targetX: SDWORD,
    pub targetY: SDWORD,
    pub fx: FRACT,
    pub fy: FRACT,
    pub speed: FRACT,
    pub boundX: SWORD,
    pub boundY: SWORD,
    pub dir: SWORD,
    pub bumpDir: SWORD,
    pub bumpTime: UDWORD,
    pub lastBump: UWORD,
    pub pauseTime: UWORD,
    pub bumpX: UWORD,
    pub bumpY: UWORD,
    pub shuffleStart: UDWORD,
    pub psFormation: *mut _formation,
    pub iVertSpeed: SWORD,
    pub iAttackRuns: UWORD,
    pub fz: FRACT,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _formation {
    pub refCount: SWORD,
    pub size: SWORD,
    pub rankDist: SWORD,
    pub dir: SWORD,
    pub x: SDWORD,
    pub y: SDWORD,
    pub asLines: [F_LINE; 4],
    pub numLines: SWORD,
    pub maxRank: UBYTE,
    pub free: SBYTE,
    pub asMembers: [F_MEMBER; 20],
    pub iSpeed: UDWORD,
    pub psNext: *mut _formation,
}
// information about a formation member
pub type F_MEMBER = _f_member;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _f_member {
    pub line: SBYTE,
    pub next: SBYTE,
    pub dist: SWORD,
    pub psObj: *mut BASE_OBJECT,
}
// which line this member is on
// the next member on this line
// distance along the line
// the member unit
/* **************************************************************************/
/*
 * base.h
 *
 * Definitions for the base object type.
 *
 */
/* **************************************************************************/
/* **************************************************************************/
/* **************************************************************************/
// Droids
// All Buildings
// Things like roads, trees, bridges, fires
// Comes out of guns, stupid :-)
// for the camera tracking
/* **************************************************************************/
/* The type of object */
/* ID number of the object */
/* Object's location */
/* Object's direction +ve rotation about y axis*/
/* Object's pitch +ve nose up*/
/* Object's roll +ve left up, right down */
/* screen coordinate details */
/* Which player the object belongs to */
/* Which group selection is the droid currently in? */
/* Whether the object is selected */
/* might want this elsewhere */
/* Which cluster the object is a member of */
/* Whether object is visible to specific player */
/* When an object was destroyed, if 0 still alive */
/*BOOL			    (*damage)(pointerType	*psObject, */
/*UDWORD		damage, */
/* UDWORD		weaponClass); - Damage function */
/*UDWORD				emissionInterval;	how frequently does it puff out damage smoke?*/
/* when did it last puff out smoke? */
/* Data for fire damage */
/* TRUE if the object is in a fire */
/* When the object entered the fire */
/* How much damage has been done since the object */
/* entered the fire */
/* Pointer to next object in list */
/* Pointer to previois object in list */
/* **************************************************************************/
pub type BASE_OBJECT = _base_object;
/*
 * FormationDef.h
 *
 */
// maximum number of lines in a formation
// maximum number of unit members of a formation (cannot be more that 128)
// information about a formation line
// a linked list of the formation members on this line is maintained
// using their index in the asMembers array.  (-1 == 'NULL')
// (cuts down the memory use over proper pointers)
pub type F_LINE = _f_line;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _f_line {
    pub xoffset: SWORD,
    pub yoffset: SWORD,
    pub dir: SWORD,
    pub member: SBYTE,
}
pub type MOVE_CONTROL = _move_control;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct research_stats {
    pub ref_0: UDWORD,
    pub pName: *mut STRING,
    pub techCode: UBYTE,
    pub techLevel: TECH_LEVEL,
    pub subGroup: UWORD,
    pub researchPoints: UWORD,
    pub researchPower: UDWORD,
    pub keyTopic: UBYTE,
    pub storeCount: UBYTE,
    pub numPRRequired: UBYTE,
    pub pPRList: *mut UWORD,
    pub numStructures: UBYTE,
    pub pStructList: *mut UWORD,
    pub numFunctions: UBYTE,
    pub pFunctionList: *mut *mut _function,
    pub numRedStructs: UBYTE,
    pub pRedStructs: *mut UWORD,
    pub numRedArtefacts: UBYTE,
    pub pRedArtefacts: *mut *mut COMP_BASE_STATS,
    pub numStructResults: UBYTE,
    pub pStructureResults: *mut UWORD,
    pub numArteResults: UBYTE,
    pub pArtefactResults: *mut *mut COMP_BASE_STATS,
    pub pReplacedArtefacts: *mut *mut COMP_BASE_STATS,
    pub pViewData: *mut _viewdata,
    pub iconID: UWORD,
    pub psStat: *mut BASE_STATS,
    pub pIMD: *mut iIMDShape,
    pub pIMD2: *mut iIMDShape,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _viewdata {
    pub pName: *mut STRING,
    pub type_0: VIEW_TYPE,
    pub numText: UBYTE,
    pub ppTextMsg: *mut *mut STRING,
    pub pData: *mut libc::c_void,
}
pub type VIEW_TYPE = _view_type;
pub type _view_type = libc::c_uint;
pub const VIEW_TYPES: _view_type = 4;
pub const VIEW_RPLX: _view_type = 3;
pub const VIEW_PROX: _view_type = 2;
pub const VIEW_RPL: _view_type = 1;
pub const VIEW_RES: _view_type = 0;
pub type RESEARCH = research_stats;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _player_research {
    pub currentPoints: UDWORD,
    pub ResearchStatus: UBYTE,
}
pub type PLAYER_RESEARCH = _player_research;
// position relative to center
// orientation of line
// first member in the 'linked list' of members
/* Only needed for Alex's movement update ? */
//	UDWORD	timeStarted;
//	UDWORD	arrivalTime;
//	UDWORD	pathStarted;
//	BOOL	startedMoving;
//	UDWORD	lastTime;
//	BOOL	speedChange;
/*
 * Weapons.h
 *
 * Definitions for the weapons
 *
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _weapon {
    pub nStat: UDWORD,
    pub hitPoints: UDWORD,
    pub ammo: UDWORD,
    pub lastFired: UDWORD,
    pub recoilValue: UDWORD,
}
pub type WEAPON = _weapon;
/* **************************************************************************/
/* ensure ANIM2D/3D structs same size */
/* width of container bitmap */
/* ensure ANIM2D/3D structs same size */
/* **************************************************************************/
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ANIM_STATE {
    pub uwFrame: UWORD,
    pub vecPos: VECTOR3D,
    pub vecAngle: VECTOR3D,
    pub vecScale: VECTOR3D,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct VECTOR3D {
    pub x: SDWORD,
    pub y: SDWORD,
    pub z: SDWORD,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct BASEANIM {
    pub szFileName: [libc::c_char; 256],
    pub animType: libc::c_char,
    pub uwID: UWORD,
    pub uwFrameRate: UWORD,
    pub uwStates: UWORD,
    pub uwObj: UWORD,
    pub uwAnimTime: UWORD,
    pub ubType: UBYTE,
    pub psStates: *mut ANIM_STATE,
    pub psNext: *mut BASEANIM,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ANIM3D {
    pub szFileName: [libc::c_char; 256],
    pub animType: libc::c_char,
    pub uwID: UWORD,
    pub uwFrameRate: UWORD,
    pub uwStates: UWORD,
    pub uwObj: UWORD,
    pub uwAnimTime: UWORD,
    pub ubType: UBYTE,
    pub psStates: *mut ANIM_STATE,
    pub psNext: *mut BASEANIM,
    pub psFrames: *mut iIMDShape,
    pub apFrame: *mut *mut iIMDShape,
}
/* **************************************************************************/
/*
 * Animobj.h
 *
 * Animation object types and function headers
 *
 * Gareth Jones 14/11/97
 */
/* **************************************************************************/
/* **************************************************************************/
/* **************************************************************************/
/* **************************************************************************/
/* forward struct declarations */
/* **************************************************************************/
/* typedefs */
/* **************************************************************************/
/* struct member macros */
/* this must be the last entry in this structure */
/* **************************************************************************/
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ANIM_OBJECT {
    pub psNext: *mut ANIM_OBJECT,
    pub uwID: UWORD,
    pub psAnim: *mut ANIM3D,
    pub psParent: *mut libc::c_void,
    pub udwStartTime: UDWORD,
    pub udwStartDelay: UDWORD,
    pub uwCycles: UWORD,
    pub bVisible: BOOL,
    pub pDoneFunc: ANIMOBJDONEFUNC,
    pub apComponents: [COMPONENT_OBJECT; 10],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct COMPONENT_OBJECT {
    pub position: VECTOR3D,
    pub orientation: VECTOR3D,
    pub psParent: *mut libc::c_void,
    pub psShape: *mut iIMDShape,
}
pub type ANIMOBJDONEFUNC
    =
    Option<unsafe extern "C" fn(_: *mut ANIM_OBJECT) -> ()>;
/*
 * DroidDef.h
 *
 * Droid structure definitions
 */
/* The number of components in the asParts / asBits arrays */
//(COMP_NUMCOMPONENTS - 2)
/* The maximum number of droid weapons and programs */
//3
//#define DROID_MAXPROGS		3
// This should really be logarithmic
//defines how many times to perform the iteration on looking for a blank location
//used to get a location next to a droid - withinh one tile
/* The different types of droid */
// NOTE, if you add to, or change this list then you'll need
// to update the DroidSelectionWeights lookup table in Display.c
pub type _droid_type = libc::c_uint;
// Any droid, Only used as a parameter for intGotoNextDroidType(droidtype).
//cyborg repair droid - new for update 7/6/99
pub const DROID_ANY: _droid_type = 13;
//cyborg repair droid - new for update 28/5/99
pub const DROID_CYBORG_SUPER: _droid_type = 12;
//cyborg constructor droid - new for update 28/5/99
pub const DROID_CYBORG_REPAIR: _droid_type = 11;
// Default droid
pub const DROID_CYBORG_CONSTRUCT: _droid_type = 10;
// Repair droid
pub const DROID_DEFAULT: _droid_type = 9;
// Command droid
pub const DROID_REPAIR: _droid_type = 8;
// guess what this is!
pub const DROID_COMMAND: _droid_type = 7;
// cyborg-type thang
pub const DROID_TRANSPORTER: _droid_type = 6;
// person
pub const DROID_CYBORG: _droid_type = 5;
// Constructor droid
pub const DROID_PERSON: _droid_type = 4;
// ECM droid
pub const DROID_CONSTRUCT: _droid_type = 3;
// Sensor droid
pub const DROID_ECM: _droid_type = 2;
// Weapon droid
pub const DROID_SENSOR: _droid_type = 1;
pub const DROID_WEAPON: _droid_type = 0;
pub type DROID_TYPE = _droid_type;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _component {
    pub nStat: UBYTE,
}
pub type COMPONENT = _component;
// Allowing a maximum of 255 stats per file
//UDWORD					hitPoints; NOT USED?
/* Possibly a set of function pointers here to be called when
	 * damage is done to a component, power is low ...
	 */
// maximum number of queued orders
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _order_list {
    pub order: SDWORD,
    pub psOrderTarget: *mut libc::c_void,
    pub x: UWORD,
    pub y: UWORD,
    pub x2: UWORD,
    pub y2: UWORD,
}
pub type ORDER_LIST = _order_list;
//line build requires two sets of coords
// maximum number of characters in a droid name
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _droid_template {
    pub ref_0: UDWORD,
    pub pName: *mut STRING,
    pub aName: [STRING; 60],
    pub NameVersion: UBYTE,
    pub asParts: [SDWORD; 8],
    pub buildPoints: UDWORD,
    pub powerPoints: UDWORD,
    pub storeCount: UDWORD,
    pub numWeaps: UDWORD,
    pub asWeaps: [UDWORD; 1],
    pub droidType: DROID_TYPE,
    pub multiPlayerID: UDWORD,
    pub psNext: *mut _droid_template,
}
pub type DROID_TEMPLATE = _droid_template;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _droid {
    pub type_0: OBJECT_TYPE,
    pub id: UDWORD,
    pub x: UWORD,
    pub y: UWORD,
    pub z: UWORD,
    pub direction: UWORD,
    pub pitch: SWORD,
    pub roll: SWORD,
    pub psNext: *mut _droid,
    pub sDisplay: SCREEN_DISP_DATA,
    pub player: UBYTE,
    pub group: UBYTE,
    pub selected: UBYTE,
    pub cluster: UBYTE,
    pub visible: [UBYTE; 8],
    pub died: UDWORD,
    pub lastEmission: UDWORD,
    pub inFire: BOOL,
    pub burnStart: UDWORD,
    pub burnDamage: UDWORD,
    pub aName: [STRING; 60],
    pub droidType: DROID_TYPE,
    pub asBits: [COMPONENT; 8],
    pub weight: UDWORD,
    pub baseSpeed: UDWORD,
    pub sensorRange: UDWORD,
    pub sensorPower: UDWORD,
    pub ECMMod: UDWORD,
    pub originalBody: UDWORD,
    pub body: UDWORD,
    pub armour: [UDWORD; 2],
    pub numKills: UWORD,
    pub turretRotation: UWORD,
    pub turretPitch: UWORD,
    pub NameVersion: UBYTE,
    pub currRayAng: UBYTE,
    pub resistance: SWORD,
    pub asWeaps: [WEAPON; 1],
    pub psGroup: *mut _droid_group,
    pub psGrpNext: *mut _droid,
    pub psBaseStruct: *mut _structure,
    pub listSize: SDWORD,
    pub asOrderList: [ORDER_LIST; 10],
    pub order: SDWORD,
    pub orderX: UWORD,
    pub orderY: UWORD,
    pub orderX2: UWORD,
    pub orderY2: UWORD,
    pub lastHitWeapon: UDWORD,
    pub timeLastHit: UDWORD,
    pub bTargetted: BOOL,
    pub psTarget: *mut _base_object,
    pub psTarStats: *mut _base_stats,
    pub secondaryOrder: UDWORD,
    pub lastSync: UDWORD,
    pub action: SDWORD,
    pub actionX: UDWORD,
    pub actionY: UDWORD,
    pub psActionTarget: *mut _base_object,
    pub actionStarted: UDWORD,
    pub actionPoints: UDWORD,
    pub powerAccrued: UWORD,
    pub illumination: UBYTE,
    pub updateFlags: UBYTE,
    pub sMove: MOVE_CONTROL,
    pub psCurAnim: *mut ANIM_OBJECT,
    pub iAudioID: SDWORD,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _structure {
    pub type_0: OBJECT_TYPE,
    pub id: UDWORD,
    pub x: UWORD,
    pub y: UWORD,
    pub z: UWORD,
    pub direction: UWORD,
    pub pitch: SWORD,
    pub roll: SWORD,
    pub psNext: *mut _structure,
    pub sDisplay: SCREEN_DISP_DATA,
    pub player: UBYTE,
    pub group: UBYTE,
    pub selected: UBYTE,
    pub cluster: UBYTE,
    pub visible: [UBYTE; 8],
    pub died: UDWORD,
    pub lastEmission: UDWORD,
    pub inFire: BOOL,
    pub burnStart: UDWORD,
    pub burnDamage: UDWORD,
    pub pStructureType: *mut STRUCTURE_STATS,
    pub status: UBYTE,
    pub currentBuildPts: SWORD,
    pub currentPowerAccrued: SWORD,
    pub body: UWORD,
    pub armour: UWORD,
    pub resistance: SWORD,
    pub lastResistance: UDWORD,
    pub sensorRange: UWORD,
    pub sensorPower: UWORD,
    pub turretRotation: UWORD,
    pub turretPitch: UWORD,
    pub timeLastHit: UDWORD,
    pub lastHitWeapon: UDWORD,
    pub radarX: UWORD,
    pub radarY: UWORD,
    pub ecmPower: UWORD,
    pub pFunctionality: *mut FUNCTIONALITY,
    pub targetted: UBYTE,
    pub asWeaps: [WEAPON; 1],
    pub psTarget: *mut BASE_OBJECT,
    pub psCurAnim: *mut ANIM_OBJECT,
}
pub type FUNCTIONALITY = [UBYTE; 40];
pub type STRUCTURE_STATS = _structure_stats;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _droid_group {
    pub type_0: SWORD,
    pub refCount: SWORD,
    pub psList: *mut DROID,
    pub psCommander: *mut DROID,
    pub sRunData: RUN_DATA,
}
pub type RUN_DATA = _run_data;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _run_data {
    pub sPos: POINT,
    pub forceLevel: UBYTE,
    pub healthLevel: UBYTE,
    pub leadership: UBYTE,
}
pub type DROID = _droid;
pub type C2RustUnnamed = libc::c_uint;
pub const NUM_DIFF_BUILDINGS: C2RustUnnamed = 22;
pub const REF_SAT_UPLINK: C2RustUnnamed = 21;
pub const REF_MISSILE_SILO: C2RustUnnamed = 20;
pub const REF_REARM_PAD: C2RustUnnamed = 19;
pub const REF_LAB: C2RustUnnamed = 18;
pub const REF_VTOL_FACTORY: C2RustUnnamed = 17;
pub const REF_CYBORG_FACTORY: C2RustUnnamed = 16;
pub const REF_DEMOLISH: C2RustUnnamed = 15;
pub const REF_BRIDGE: C2RustUnnamed = 14;
pub const REF_COMMAND_CONTROL: C2RustUnnamed = 13;
pub const REF_REPAIR_FACILITY: C2RustUnnamed = 12;
pub const REF_RESEARCH_MODULE: C2RustUnnamed = 11;
pub const REF_RESEARCH: C2RustUnnamed = 10;
pub const REF_BLASTDOOR: C2RustUnnamed = 9;
pub const REF_WALLCORNER: C2RustUnnamed = 8;
pub const REF_WALL: C2RustUnnamed = 7;
pub const REF_DEFENSE: C2RustUnnamed = 6;
pub const REF_RESOURCE_EXTRACTOR: C2RustUnnamed = 5;
pub const REF_POWER_MODULE: C2RustUnnamed = 4;
pub const REF_POWER_GEN: C2RustUnnamed = 3;
pub const REF_FACTORY_MODULE: C2RustUnnamed = 2;
pub const REF_FACTORY: C2RustUnnamed = 1;
pub const REF_HQ: C2RustUnnamed = 0;
pub type _position_type = libc::c_uint;
pub const POS_TEMPDELIVERY: _position_type = 3;
pub const POS_PROXOBJ: _position_type = 2;
pub const POS_PROXDATA: _position_type = 1;
pub const POS_DELIVERY: _position_type = 0;
pub type POSITION_TYPE = _position_type;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _flag_position {
    pub type_0: POSITION_TYPE,
    pub frameNumber: UDWORD,
    pub screenX: UDWORD,
    pub screenY: UDWORD,
    pub screenR: UDWORD,
    pub player: UDWORD,
    pub selected: BOOL,
    pub coords: iVector,
    pub factoryInc: UBYTE,
    pub factoryType: UBYTE,
    pub psNext: *mut _flag_position,
}
pub type FLAG_POSITION = _flag_position;
pub type _struct_states = libc::c_uint;
pub const SS_BEING_DEMOLISHED: _struct_states = 2;
pub const SS_BUILT: _struct_states = 1;
pub const SS_BEING_BUILT: _struct_states = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _research_facility {
    pub psSubject: *mut _base_stats,
    pub capacity: UDWORD,
    pub timeStarted: UDWORD,
    pub researchPoints: UDWORD,
    pub timeToResearch: UDWORD,
    pub psBestTopic: *mut _base_stats,
    pub powerAccrued: UDWORD,
    pub timeStartHold: UDWORD,
}
pub type RESEARCH_FACILITY = _research_facility;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _factory {
    pub capacity: UBYTE,
    pub quantity: UBYTE,
    pub loopsPerformed: UBYTE,
    pub productionOutput: UBYTE,
    pub powerAccrued: UDWORD,
    pub psSubject: *mut BASE_STATS,
    pub timeStarted: UDWORD,
    pub timeToBuild: UDWORD,
    pub timeStartHold: UDWORD,
    pub psAssemblyPoint: *mut FLAG_POSITION,
    pub psFormation: *mut _formation,
    pub psCommander: *mut _droid,
    pub secondaryOrder: UDWORD,
}
pub type FACTORY = _factory;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _res_extractor {
    pub power: UDWORD,
    pub timeLastUpdated: UDWORD,
    pub active: BOOL,
    pub psPowerGen: *mut _structure,
}
pub type RES_EXTRACTOR = _res_extractor;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _power_gen {
    pub power: UDWORD,
    pub multiplier: UDWORD,
    pub capacity: UDWORD,
    pub apResExtractors: [*mut _structure; 4],
}
pub type POWER_GEN = _power_gen;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct REPAIR_FACILITY {
    pub power: UDWORD,
    pub timeStarted: UDWORD,
    pub psObj: *mut BASE_OBJECT,
    pub powerAccrued: UDWORD,
    pub psDeliveryPoint: *mut FLAG_POSITION,
    pub currentPtsAdded: UDWORD,
    pub psGroup: *mut _droid_group,
    pub psGrpNext: *mut _droid,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _rearm_pad {
    pub reArmPoints: UDWORD,
    pub timeStarted: UDWORD,
    pub psObj: *mut BASE_OBJECT,
    pub currentPtsAdded: UDWORD,
}
pub type REARM_PAD = _rearm_pad;
pub type STRUCTURE = _structure;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _structure_limits {
    pub limit: UBYTE,
    pub currentQuantity: UBYTE,
    pub globalLimit: UBYTE,
}
pub type STRUCTURE_LIMITS = _structure_limits;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _production_run {
    pub quantity: UBYTE,
    pub built: UBYTE,
    pub psTemplate: *mut _droid_template,
}
/* Pointer to next template*/
//seperate the numfactory from numflag
//this is used for module graphics - factory and vtol factory
pub type PRODUCTION_RUN = _production_run;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _structure_upgrade {
    pub armour: UWORD,
    pub body: UWORD,
    pub resistance: UWORD,
}
//number to build
//number built on current run
//template to build
/* structure stats which can be upgraded by research*/
pub type STRUCTURE_UPGRADE = _structure_upgrade;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _wallDefence_upgrade {
    pub armour: UWORD,
    pub body: UWORD,
}
/* wall/Defence structure stats which can be upgraded by research*/
pub type WALLDEFENCE_UPGRADE = _wallDefence_upgrade;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _upgrade {
    pub modifier: UWORD,
}
pub type UPGRADE = _upgrade;
pub type RESEARCH_UPGRADE = UPGRADE;
pub type PRODUCTION_UPGRADE = UPGRADE;
pub type REPAIR_FACILITY_UPGRADE = UPGRADE;
pub type POWER_UPGRADE = UPGRADE;
pub type REARM_UPGRADE = UPGRADE;
//% to increase the stat by
/*
 * FeatureDef.h
 *
 * Structure definitions for features
 *
 */
pub type _feature_type = libc::c_uint;
pub const FEAT_SKYSCRAPER: _feature_type = 12;
pub const FEAT_TREE: _feature_type = 11;
pub const FEAT_OIL_DRUM: _feature_type = 10;
pub const FEAT_LOS_OBJ: _feature_type = 9;
pub const FEAT_DROID: _feature_type = 8;
pub const FEAT_BUILDING: _feature_type = 7;
pub const FEAT_VEHICLE: _feature_type = 6;
pub const FEAT_BOULDER: _feature_type = 5;
pub const FEAT_OIL_RESOURCE: _feature_type = 4;
pub const FEAT_GEN_ARTE: _feature_type = 3;
pub const FEAT_TANK: _feature_type = 2;
pub const FEAT_HOVER: _feature_type = 1;
pub const FEAT_BUILD_WRECK: _feature_type = 0;
pub type FEATURE_TYPE = _feature_type;
//FEAT_MESA,	no longer used
	//FEAT_MESA2,	
	//FEAT_CLIFF,
	//FEAT_STACK,
	//FEAT_BUILD_WRECK1,
	//FEAT_BUILD_WRECK2,
	//FEAT_BUILD_WRECK3,
	//FEAT_BUILD_WRECK4,
	//FEAT_BOULDER1,
	//FEAT_BOULDER2,
	//FEAT_BOULDER3,
	//FEAT_FUTCAR,
	//FEAT_FUTVAN,
/* Stats for a feature */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _feature_stats {
    pub ref_0: UDWORD,
    pub pName: *mut STRING,
    pub subType: FEATURE_TYPE,
    pub psImd: *mut iIMDShape,
    pub baseWidth: UWORD,
    pub baseBreadth: UWORD,
    pub tileDraw: BOOL,
    pub allowLOS: BOOL,
    pub visibleAtStart: BOOL,
    pub damageable: BOOL,
    pub body: UDWORD,
    pub armour: UDWORD,
}
pub type FEATURE_STATS = _feature_stats;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _feature {
    pub type_0: OBJECT_TYPE,
    pub id: UDWORD,
    pub x: UWORD,
    pub y: UWORD,
    pub z: UWORD,
    pub direction: UWORD,
    pub pitch: SWORD,
    pub roll: SWORD,
    pub psNext: *mut _feature,
    pub sDisplay: SCREEN_DISP_DATA,
    pub player: UBYTE,
    pub group: UBYTE,
    pub selected: UBYTE,
    pub cluster: UBYTE,
    pub visible: [UBYTE; 8],
    pub died: UDWORD,
    pub lastEmission: UDWORD,
    pub inFire: BOOL,
    pub burnStart: UDWORD,
    pub burnDamage: UDWORD,
    pub psStats: *mut FEATURE_STATS,
    pub startTime: UDWORD,
    pub body: UDWORD,
    pub gfxScaling: UWORD,
    pub timeLastHit: UDWORD,
    pub bTargetted: BOOL,
}
pub type FEATURE = _feature;
pub type _terrain_type = libc::c_uint;
pub const TER_MAX: _terrain_type = 12;
pub const TER_SLUSH: _terrain_type = 11;
pub const TER_SHEETICE: _terrain_type = 10;
pub const TER_RUBBLE: _terrain_type = 9;
pub const TER_CLIFFFACE: _terrain_type = 8;
pub const TER_WATER: _terrain_type = 7;
pub const TER_ROAD: _terrain_type = 6;
pub const TER_PINKROCK: _terrain_type = 5;
pub const TER_REDBRUSH: _terrain_type = 4;
pub const TER_GREENMUD: _terrain_type = 3;
pub const TER_BAKEDEARTH: _terrain_type = 2;
pub const TER_SANDYBRUSH: _terrain_type = 1;
pub const TER_SAND: _terrain_type = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _maptile {
    pub tileInfoBits: UBYTE,
    pub tileVisBits: UBYTE,
    pub height: UBYTE,
    pub illumination: UBYTE,
    pub texture: UWORD,
    pub bMaxed: UBYTE,
    pub level: UBYTE,
    pub inRange: UBYTE,
}
pub type MAPTILE = _maptile;
// Feature armour
/* Store a map coordinate and it's associated tile, used by mapCalcLine */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _tile_coord {
    pub x: UDWORD,
    pub y: UDWORD,
    pub psTile: *mut MAPTILE,
}
pub type TILE_COORD = _tile_coord;
pub type _droid_action = libc::c_uint;
pub const DACTION_FIRESUPPORT_RETREAT: _droid_action = 39;
pub const DACTION_RETURNTOPOS: _droid_action = 38;
pub const DACTION_CLEARREARMPAD: _droid_action = 37;
pub const DACTION_VTOLATTACK: _droid_action = 36;
pub const DACTION_WAITDURINGREARM: _droid_action = 35;
pub const DACTION_MOVETOREARMPOINT: _droid_action = 34;
pub const DACTION_WAITFORREARM: _droid_action = 33;
pub const DACTION_MOVETOREARM: _droid_action = 32;
pub const DACTION_MOVETOCLEAR: _droid_action = 31;
pub const DACTION_MOVETORESTORE: _droid_action = 30;
pub const DACTION_MOVETODROIDREPAIR: _droid_action = 29;
pub const DACTION_WAITDURINGREPAIR: _droid_action = 28;
pub const DACTION_MOVETOREPAIRPOINT: _droid_action = 27;
pub const DACTION_WAITFORREPAIR: _droid_action = 26;
pub const DACTION_MOVETOOBSERVE: _droid_action = 25;
pub const DACTION_ROTATETOATTACK: _droid_action = 24;
pub const DACTION_MOVETOATTACK: _droid_action = 23;
pub const DACTION_FOUNDATION_WANDER: _droid_action = 22;
pub const DACTION_BUILDWANDER: _droid_action = 21;
pub const DACTION_MOVETOREPAIR: _droid_action = 20;
pub const DACTION_MOVETODEMOLISH: _droid_action = 19;
pub const DACTION_MOVETOBUILD: _droid_action = 18;
pub const DACTION_MOVEFIRE: _droid_action = 17;
pub const DACTION_CLEARWRECK: _droid_action = 16;
pub const DACTION_RESTORE: _droid_action = 15;
pub const DACTION_DROIDREPAIR: _droid_action = 14;
pub const DACTION_TRANSPORTIN: _droid_action = 13;
pub const DACTION_TRANSPORTWAITTOFLYIN: _droid_action = 12;
pub const DACTION_TRANSPORTOUT: _droid_action = 11;
pub const DACTION_DESTRUCT: _droid_action = 10;
pub const DACTION_SULK: _droid_action = 9;
pub const DACTION_FIRESUPPORT: _droid_action = 8;
pub const DACTION_OBSERVE: _droid_action = 7;
pub const DACTION_ATTACK: _droid_action = 6;
pub const DACTION_REPAIR: _droid_action = 5;
pub const DACTION_DEMOLISH: _droid_action = 4;
pub const DACTION_BUILD_FOUNDATION: _droid_action = 3;
pub const DACTION_BUILD: _droid_action = 2;
pub const DACTION_MOVE: _droid_action = 1;
pub const DACTION_NONE: _droid_action = 0;
pub type C2RustUnnamed_0 = libc::c_uint;
// User saved game - in the middle of a level
// User saved game - at the start of a level.
pub const GTYPE_SAVE_MIDMISSION: C2RustUnnamed_0 = 4;
// Stand alone mission.
pub const GTYPE_SAVE_START: C2RustUnnamed_0 = 3;
// Scenario scroll area expansion.
pub const GTYPE_MISSION: C2RustUnnamed_0 = 2;
// Initial scenario state.
pub const GTYPE_SCENARIO_EXPAND: C2RustUnnamed_0 = 1;
pub const GTYPE_SCENARIO_START: C2RustUnnamed_0 = 0;
// data for changing between levels
pub const LDS_EXPAND: _level_type = 4;
/*
 * MissionDef.h
 *
 * Structure definitions for Mission
 *
 */
//mission types
//used to set the reinforcement time on hold whilst the Transporter is unable to land
//hopefully they'll never need to set it this high for other reasons!
//this is used to compare the value passed in from the scripts with which is multiplied by 100
//storage structure for values that need to be kept between missions
pub type MISSION = _mission;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _mission {
    pub type_0: UDWORD,
    pub psMapTiles: *mut MAPTILE,
    pub aMapLinePoints: *mut TILE_COORD,
    pub mapWidth: UDWORD,
    pub mapHeight: UDWORD,
    pub psGateways: *mut _gateway,
    pub apRLEZones: *mut *mut UBYTE,
    pub gwNumZones: SDWORD,
    pub aNumEquiv: *mut UBYTE,
    pub apEquivZones: *mut *mut UBYTE,
    pub aZoneReachable: *mut UBYTE,
    pub scrollMinX: UDWORD,
    pub scrollMinY: UDWORD,
    pub scrollMaxX: UDWORD,
    pub scrollMaxY: UDWORD,
    pub apsStructLists: [*mut STRUCTURE; 8],
    pub apsDroidLists: [*mut DROID; 8],
    pub apsFeatureLists: [*mut FEATURE; 8],
    pub apsFlagPosLists: [*mut FLAG_POSITION; 8],
    pub asPower: [PLAYER_POWER; 8],
    pub startTime: UDWORD,
    pub time: SDWORD,
    pub ETA: SDWORD,
    pub cheatTime: UDWORD,
    pub homeLZ_X: UWORD,
    pub homeLZ_Y: UWORD,
    pub playerX: SDWORD,
    pub playerY: SDWORD,
    pub iTranspEntryTileX: [UWORD; 8],
    pub iTranspEntryTileY: [UWORD; 8],
    pub iTranspExitTileX: [UWORD; 8],
    pub iTranspExitTileY: [UWORD; 8],
}
//MISSION_TYPE		type;							//defines which start and end functions to use
//defines which start and end functions to use - see levels_type in levels.h
//the original mapTiles
//the original mapLinePoints
//the original mapWidth
//the original mapHeight
//the gateway list
//the RLE map zones
//the number of map zones
//zone equivalence data
//scroll coords for original map
//original object lists
//struct _proximity_display	*apsProxDisp[MAX_PLAYERS];
//time the mission started
//how long the mission can last
// < 0 = no limit
//time taken for reinforcements to arrive
// < 0 = none allowed
//time the cheating started (mission time-wise!)
//LANDING_ZONE		homeLZ;
//selectedPlayer's LZ x and y
//original view position
/* transporter entry/exit tiles */
/*
 * Power.h
 *
 * Definitions for the Power Functionality.
 *
 */
// free power on collection of oildrum.
//% used to determine the power cost of repairing a droid
                                         //definately DON'T WANT the brackets round 1/2 - it will equate to zero!
//used to multiply all repair calculations by to avaoid rounding errors
//OLD PLAYER_POWER
//typedef struct _player_power
//{
//	UDWORD		availablePower;		/* quantity that can be used from the Generators */
//	UDWORD		extractedPower;		/* quantity being extracted but not converted 
//									   by a Generator */
//	SDWORD		capacity;			/* the spare capacity of the generators */
//	SDWORD		usedPower;			/* quantity currently being used */
//} PLAYER_POWER;
//NEW PLAYER_POWER
pub type PLAYER_POWER = _player_power;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _player_power {
    pub currentPower: UDWORD,
    pub extractedPower: UDWORD,
    pub psLastPowered: *mut _base_object,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _gateway {
    pub x1: UBYTE,
    pub y1: UBYTE,
    pub x2: UBYTE,
    pub y2: UBYTE,
    pub zone1: UBYTE,
    pub zone2: UBYTE,
    pub psNext: *mut _gateway,
    pub psLinks: *mut GATEWAY_LINK,
    pub zone1Links: UBYTE,
    pub zone2Links: UBYTE,
    pub flags: UBYTE,
    pub dist: SWORD,
    pub est: SWORD,
    pub psOpen: *mut _gateway,
    pub psRoute: *mut _gateway,
}
//UDWORD		initialPower;	    HAVEN'T FOUND A USE FOR IT YET! AB 26/8/98	
									    /* what the initial power level is - set 
									    in script not sure if will need it, but 
									    keeping for now*/
/* the current amount of power avaialble 
									    to the player*/
/* the power extracted but not converted */
/*the last object that received power 
									    before it ran out*/
/*
 * GatewayDef.h
 *
 * Structure definitions for routing gateways.
 *
 */
pub type GATEWAY_LINK = _gateway_link;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _gateway_link {
    pub psGateway: *mut _gateway,
    pub dist: SWORD,
    pub flags: SWORD,
}
pub const DORDER_NONE: _droid_order = 0;
pub type STRUCTLIMITS_SAVEHEADER = _structLimits_save_header;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _structLimits_save_header {
    pub aFileType: [STRING; 4],
    pub version: UDWORD,
    pub quantity: UDWORD,
}
pub type SAVE_STRUCTLIMITS = _save_structLimits;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_structLimits {
    pub name: [CHAR; 60],
    pub limit: UBYTE,
    pub player: UBYTE,
}
pub type SAVE_STRUCTLIMITS_V2 = _save_structLimits_v2;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_structLimits_v2 {
    pub name: [CHAR; 40],
    pub limit: UBYTE,
    pub player: UBYTE,
}
pub type COMMAND_SAVEHEADER = _command_save_header;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _command_save_header {
    pub aFileType: [STRING; 4],
    pub version: UDWORD,
    pub quantity: UDWORD,
}
pub type SAVE_COMMAND = _save_command;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_command {
    pub droidID: UDWORD,
}
pub type FLAG_SAVEHEADER = _flag_save_header;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _flag_save_header {
    pub aFileType: [STRING; 4],
    pub version: UDWORD,
    pub quantity: UDWORD,
}
pub type SAVE_FLAG = _save_flag;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_flag {
    pub type_0: POSITION_TYPE,
    pub frameNumber: UDWORD,
    pub screenX: UDWORD,
    pub screenY: UDWORD,
    pub screenR: UDWORD,
    pub player: UDWORD,
    pub selected: BOOL,
    pub coords: iVector,
    pub factoryInc: UBYTE,
    pub factoryType: UBYTE,
    pub dummyNOTUSED: UBYTE,
    pub dummyNOTUSED2: UBYTE,
    pub repairId: UDWORD,
}
pub type SAVE_FLAG_V18 = _save_flag_v18;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_flag_v18 {
    pub type_0: POSITION_TYPE,
    pub frameNumber: UDWORD,
    pub screenX: UDWORD,
    pub screenY: UDWORD,
    pub screenR: UDWORD,
    pub player: UDWORD,
    pub selected: BOOL,
    pub coords: iVector,
    pub factoryInc: UBYTE,
    pub factoryType: UBYTE,
    pub dummyNOTUSED: UBYTE,
    pub dummyNOTUSED2: UBYTE,
}
pub type PRODUCTION_SAVEHEADER = _production_save_header;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _production_save_header {
    pub aFileType: [STRING; 4],
    pub version: UDWORD,
}
/*the type of position obj - FlagPos or ProxDisp*/
/*when the Position was last drawn*/
/*screen coords and radius of Position imd */
/*which player the Position belongs to*/
/*flag to indicate whether the Position */
//the world coords of the Position
//indicates whether the first, second etc factory
//indicates whether standard, cyborg or vtol factory
//sub value. needed to order production points.
/*the type of position obj - FlagPos or ProxDisp*/
/*when the Position was last drawn*/
/*screen coords and radius of Position imd */
/*which player the Position belongs to*/
/*flag to indicate whether the Position */
//the world coords of the Position
//indicates whether the first, second etc factory
//indicates whether standard, cyborg or vtol factory
//sub value. needed to order production points.
//PRODUCTION_RUN		asProductionRun[NUM_FACTORY_TYPES][MAX_FACTORY][MAX_PROD_RUN];
pub type SAVE_PRODUCTION = _save_production;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_production {
    pub quantity: UBYTE,
    pub built: UBYTE,
    pub multiPlayerID: UDWORD,
}
//number to build
//number built on current run
//template to build
/* Structure definitions for loading and saving map data */
pub type STRUCTLIST_SAVEHEADER = _structList_save_header;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _structList_save_header {
    pub aFileType: [STRING; 4],
    pub version: UDWORD,
    pub quantity: UDWORD,
}
pub type SAVE_STRUCTLIST = _save_structList;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_structList {
    pub name: [CHAR; 60],
    pub state: UBYTE,
    pub player: UBYTE,
}
pub type SAVE_STRUCTLIST_V6 = _save_structList_v6;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_structList_v6 {
    pub name: [CHAR; 40],
    pub state: UBYTE,
    pub player: UBYTE,
}
/* Structure definitions for loading and saving map data */
pub type COMPLIST_SAVEHEADER = _compList_save_header;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _compList_save_header {
    pub aFileType: [STRING; 4],
    pub version: UDWORD,
    pub quantity: UDWORD,
}
pub type SAVE_COMPLIST = _save_compList;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_compList {
    pub name: [CHAR; 60],
    pub type_0: UBYTE,
    pub state: UBYTE,
    pub player: UBYTE,
}
pub type SAVE_COMPLIST_V6 = _save_compList_v6;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_compList_v6 {
    pub name: [CHAR; 40],
    pub type_0: UBYTE,
    pub state: UBYTE,
    pub player: UBYTE,
}
pub type STRUCT_SAVEHEADER = _struct_save_header;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _struct_save_header {
    pub aFileType: [STRING; 4],
    pub version: UDWORD,
    pub quantity: UDWORD,
}
pub const ID_SOUND_POWER_HUM: C2RustUnnamed_1 = 295;
pub type SAVE_STRUCTURE = _save_structure;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_structure {
    pub name: [STRING; 60],
    pub id: UDWORD,
    pub x: UDWORD,
    pub y: UDWORD,
    pub z: UDWORD,
    pub direction: UDWORD,
    pub player: UDWORD,
    pub inFire: BOOL,
    pub burnStart: UDWORD,
    pub burnDamage: UDWORD,
    pub status: UBYTE,
    pub currentBuildPts: SDWORD,
    pub body: UDWORD,
    pub armour: UDWORD,
    pub resistance: UDWORD,
    pub dummy1: UDWORD,
    pub subjectInc: UDWORD,
    pub timeStarted: UDWORD,
    pub output: UDWORD,
    pub capacity: UDWORD,
    pub quantity: UDWORD,
    pub factoryInc: UDWORD,
    pub loopsPerformed: UBYTE,
    pub powerAccrued: UDWORD,
    pub dummy2: UDWORD,
    pub droidTimeStarted: UDWORD,
    pub timeToBuild: UDWORD,
    pub timeStartHold: UDWORD,
    pub visible: [UBYTE; 8],
    pub researchName: [libc::c_char; 60],
    pub currentPowerAccrued: SWORD,
    pub commandId: UDWORD,
}
/*research inc or factory prod id*/
pub type SAVE_STRUCTURE_V20 = _save_structure_v20;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_structure_v20 {
    pub name: [STRING; 60],
    pub id: UDWORD,
    pub x: UDWORD,
    pub y: UDWORD,
    pub z: UDWORD,
    pub direction: UDWORD,
    pub player: UDWORD,
    pub inFire: BOOL,
    pub burnStart: UDWORD,
    pub burnDamage: UDWORD,
    pub status: UBYTE,
    pub currentBuildPts: SDWORD,
    pub body: UDWORD,
    pub armour: UDWORD,
    pub resistance: UDWORD,
    pub dummy1: UDWORD,
    pub subjectInc: UDWORD,
    pub timeStarted: UDWORD,
    pub output: UDWORD,
    pub capacity: UDWORD,
    pub quantity: UDWORD,
    pub factoryInc: UDWORD,
    pub loopsPerformed: UBYTE,
    pub powerAccrued: UDWORD,
    pub dummy2: UDWORD,
    pub droidTimeStarted: UDWORD,
    pub timeToBuild: UDWORD,
    pub timeStartHold: UDWORD,
    pub visible: [UBYTE; 8],
    pub researchName: [libc::c_char; 60],
    pub currentPowerAccrued: SWORD,
}
pub type SAVE_STRUCTURE_V17 = _save_structure_v17;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_structure_v17 {
    pub name: [STRING; 40],
    pub id: UDWORD,
    pub x: UDWORD,
    pub y: UDWORD,
    pub z: UDWORD,
    pub direction: UDWORD,
    pub player: UDWORD,
    pub inFire: BOOL,
    pub burnStart: UDWORD,
    pub burnDamage: UDWORD,
    pub status: UBYTE,
    pub currentBuildPts: SDWORD,
    pub body: UDWORD,
    pub armour: UDWORD,
    pub resistance: UDWORD,
    pub dummy1: UDWORD,
    pub subjectInc: UDWORD,
    pub timeStarted: UDWORD,
    pub output: UDWORD,
    pub capacity: UDWORD,
    pub quantity: UDWORD,
    pub factoryInc: UDWORD,
    pub loopsPerformed: UBYTE,
    pub powerAccrued: UDWORD,
    pub dummy2: UDWORD,
    pub droidTimeStarted: UDWORD,
    pub timeToBuild: UDWORD,
    pub timeStartHold: UDWORD,
    pub visible: [UBYTE; 8],
    pub researchName: [libc::c_char; 40],
    pub currentPowerAccrued: SWORD,
}
pub type SAVE_STRUCTURE_V15 = _save_structure_v15;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_structure_v15 {
    pub name: [STRING; 40],
    pub id: UDWORD,
    pub x: UDWORD,
    pub y: UDWORD,
    pub z: UDWORD,
    pub direction: UDWORD,
    pub player: UDWORD,
    pub inFire: BOOL,
    pub burnStart: UDWORD,
    pub burnDamage: UDWORD,
    pub status: UBYTE,
    pub currentBuildPts: SDWORD,
    pub body: UDWORD,
    pub armour: UDWORD,
    pub resistance: UDWORD,
    pub dummy1: UDWORD,
    pub subjectInc: UDWORD,
    pub timeStarted: UDWORD,
    pub output: UDWORD,
    pub capacity: UDWORD,
    pub quantity: UDWORD,
    pub factoryInc: UDWORD,
    pub loopsPerformed: UBYTE,
    pub powerAccrued: UDWORD,
    pub dummy2: UDWORD,
    pub droidTimeStarted: UDWORD,
    pub timeToBuild: UDWORD,
    pub timeStartHold: UDWORD,
    pub visible: [UBYTE; 8],
    pub researchName: [libc::c_char; 40],
}
pub type SAVE_STRUCTURE_V14 = _save_structure_v14;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_structure_v14 {
    pub name: [STRING; 40],
    pub id: UDWORD,
    pub x: UDWORD,
    pub y: UDWORD,
    pub z: UDWORD,
    pub direction: UDWORD,
    pub player: UDWORD,
    pub inFire: BOOL,
    pub burnStart: UDWORD,
    pub burnDamage: UDWORD,
    pub status: UBYTE,
    pub currentBuildPts: SDWORD,
    pub body: UDWORD,
    pub armour: UDWORD,
    pub resistance: UDWORD,
    pub dummy1: UDWORD,
    pub subjectInc: UDWORD,
    pub timeStarted: UDWORD,
    pub output: UDWORD,
    pub capacity: UDWORD,
    pub quantity: UDWORD,
    pub factoryInc: UDWORD,
    pub loopsPerformed: UBYTE,
    pub powerAccrued: UDWORD,
    pub dummy2: UDWORD,
    pub droidTimeStarted: UDWORD,
    pub timeToBuild: UDWORD,
    pub timeStartHold: UDWORD,
    pub visible: [UBYTE; 8],
}
pub type SAVE_STRUCTURE_V12 = _save_structure_v12;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_structure_v12 {
    pub name: [STRING; 40],
    pub id: UDWORD,
    pub x: UDWORD,
    pub y: UDWORD,
    pub z: UDWORD,
    pub direction: UDWORD,
    pub player: UDWORD,
    pub inFire: BOOL,
    pub burnStart: UDWORD,
    pub burnDamage: UDWORD,
    pub status: UBYTE,
    pub currentBuildPts: SDWORD,
    pub body: UDWORD,
    pub armour: UDWORD,
    pub resistance: UDWORD,
    pub dummy1: UDWORD,
    pub subjectInc: UDWORD,
    pub timeStarted: UDWORD,
    pub output: UDWORD,
    pub capacity: UDWORD,
    pub quantity: UDWORD,
    pub factoryInc: UDWORD,
    pub loopsPerformed: UBYTE,
    pub powerAccrued: UDWORD,
    pub dummy2: UDWORD,
    pub droidTimeStarted: UDWORD,
    pub timeToBuild: UDWORD,
    pub timeStartHold: UDWORD,
}
/*
 *	STRUCTURE Definitions
 */
/*research inc or factory prod id*/
pub type SAVE_STRUCTURE_V2 = _save_structure_v2;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_structure_v2 {
    pub name: [STRING; 40],
    pub id: UDWORD,
    pub x: UDWORD,
    pub y: UDWORD,
    pub z: UDWORD,
    pub direction: UDWORD,
    pub player: UDWORD,
    pub inFire: BOOL,
    pub burnStart: UDWORD,
    pub burnDamage: UDWORD,
    pub status: UBYTE,
    pub currentBuildPts: SDWORD,
    pub body: UDWORD,
    pub armour: UDWORD,
    pub resistance: UDWORD,
    pub dummy1: UDWORD,
    pub subjectInc: UDWORD,
    pub timeStarted: UDWORD,
    pub output: UDWORD,
    pub capacity: UDWORD,
    pub quantity: UDWORD,
}
pub type FEATURE_SAVEHEADER = _feature_save_header;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _feature_save_header {
    pub aFileType: [STRING; 4],
    pub version: UDWORD,
    pub quantity: UDWORD,
}
pub type SAVE_FEATURE = _save_feature;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_feature {
    pub name: [STRING; 60],
    pub id: UDWORD,
    pub x: UDWORD,
    pub y: UDWORD,
    pub z: UDWORD,
    pub direction: UDWORD,
    pub player: UDWORD,
    pub inFire: BOOL,
    pub burnStart: UDWORD,
    pub burnDamage: UDWORD,
    pub visible: [UBYTE; 8],
}
pub type SAVE_FEATURE_V14 = _save_feature_v14;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_feature_v14 {
    pub name: [STRING; 40],
    pub id: UDWORD,
    pub x: UDWORD,
    pub y: UDWORD,
    pub z: UDWORD,
    pub direction: UDWORD,
    pub player: UDWORD,
    pub inFire: BOOL,
    pub burnStart: UDWORD,
    pub burnDamage: UDWORD,
    pub visible: [UBYTE; 8],
}
pub type SAVE_FEATURE_V2 = _save_feature_v2;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_feature_v2 {
    pub name: [STRING; 40],
    pub id: UDWORD,
    pub x: UDWORD,
    pub y: UDWORD,
    pub z: UDWORD,
    pub direction: UDWORD,
    pub player: UDWORD,
    pub inFire: BOOL,
    pub burnStart: UDWORD,
    pub burnDamage: UDWORD,
}
pub type DROID_SAVEHEADER = _droid_save_header;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _droid_save_header {
    pub aFileType: [STRING; 4],
    pub version: UDWORD,
    pub quantity: UDWORD,
}
pub type DROID_GROUP = _droid_group;
pub const DROID_ON_TRANSPORT: _droid_save_type = 1;
pub type SAVE_DROID = _save_droid;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_droid {
    pub name: [STRING; 60],
    pub id: UDWORD,
    pub x: UDWORD,
    pub y: UDWORD,
    pub z: UDWORD,
    pub direction: UDWORD,
    pub player: UDWORD,
    pub inFire: BOOL,
    pub burnStart: UDWORD,
    pub burnDamage: UDWORD,
    pub asBits: [SAVE_COMPONENT; 8],
    pub body: UDWORD,
    pub droidType: UBYTE,
    pub saveType: UDWORD,
    pub numWeaps: UDWORD,
    pub asWeaps: [SAVE_WEAPON; 3],
    pub numKills: UDWORD,
    pub turretRotation: UWORD,
    pub turretPitch: UWORD,
    pub order: SDWORD,
    pub orderX: UWORD,
    pub orderY: UWORD,
    pub orderX2: UWORD,
    pub orderY2: UWORD,
    pub timeLastHit: UDWORD,
    pub targetID: UDWORD,
    pub secondaryOrder: UDWORD,
    pub action: SDWORD,
    pub actionX: UDWORD,
    pub actionY: UDWORD,
    pub actionTargetID: UDWORD,
    pub actionStarted: UDWORD,
    pub actionPoints: UDWORD,
    pub actionHeight: UWORD,
    pub tarStatName: [CHAR; 60],
    pub baseStructID: UDWORD,
    pub group: UBYTE,
    pub selected: UBYTE,
    pub cluster_unused: UBYTE,
    pub visible: [UBYTE; 8],
    pub died: UDWORD,
    pub lastEmission: UDWORD,
    pub commandId: UDWORD,
    pub resistance: SDWORD,
    pub sMove: SAVE_MOVE_CONTROL,
    pub formationDir: SWORD,
    pub formationX: SDWORD,
    pub formationY: SDWORD,
}
pub type SAVE_MOVE_CONTROL = _save_move_control;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_move_control {
    pub Status: UBYTE,
    pub Mask: UBYTE,
    pub Position: UBYTE,
    pub numPoints: UBYTE,
    pub asPath: [PATH_POINT; 100],
    pub DestinationX: SDWORD,
    pub DestinationY: SDWORD,
    pub srcX: SDWORD,
    pub srcY: SDWORD,
    pub targetX: SDWORD,
    pub targetY: SDWORD,
    pub fx: FRACT,
    pub fy: FRACT,
    pub speed: FRACT,
    pub boundX: SWORD,
    pub boundY: SWORD,
    pub dir: SWORD,
    pub bumpDir: SWORD,
    pub bumpTime: UDWORD,
    pub lastBump: UWORD,
    pub pauseTime: UWORD,
    pub bumpX: UWORD,
    pub bumpY: UWORD,
    pub shuffleStart: UDWORD,
    pub psFormation: *mut _formation,
    pub iVertSpeed: SWORD,
    pub iAttackRuns: UWORD,
}
pub type SAVE_WEAPON = _save_weapon;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_weapon {
    pub name: [STRING; 60],
    pub hitPoints: UDWORD,
    pub ammo: UDWORD,
    pub lastFired: UDWORD,
}
pub type SAVE_COMPONENT = _save_component;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_component {
    pub name: [STRING; 60],
}
// Inactive, Navigating or moving point to point status
// Mask used for the creation of this path
//	SBYTE	Direction;					// Direction object should be moving (0-7) 0=Up,1=Up-Right
//	SDWORD	Speed;						// Speed at which object moves along the movement list
// Position in asPath
// number of points in asPath
//	PATH_POINT	MovementList[TRAVELSIZE];
// Pointer to list of block X,Y coordinates.
// When initialised list is terminated by (0xffff,0xffff)
										// Values prefixed by 0x8000 are pixel coordinates instead of
										// block coordinates
// DestinationX,Y should match objects current X,Y
//		location for this movement to be complete.
//   	UDWORD	Direction3D;				// *** not necessary
//	UDWORD	TargetDir;					// *** not necessary Direction the object should be facing
//	SDWORD	Gradient;					// Gradient of line
//	SDWORD	DeltaX;						// Distance from start to end position of current movement X
//	SDWORD	DeltaY;						// Distance from start to end position of current movement Y
//	SDWORD	XStep;						// Adjustment to the characters X position each movement
//	SDWORD	YStep;						// Adjustment to the characters Y position each movement
//	SDWORD	DestPixelX;					// Pixel coordinate destination for pixel movement (NOT the final X)
//	SDWORD	DestPixelY;					// Pixel coordiante destination for pixel movement (NOT the final Y)
/* Stuff for John's movement update */
// droid location as a fract
//	FRACT	dx,dy;						// x and y change for current direction
	// NOTE: this is supposed to replace Speed
// Speed of motion
// Vector for the end of path boundary
// direction of motion (not the direction the droid is facing)
// direction at last bump
// time of first bump with something
// time of last bump with a droid - relative to bumpTime
// when MOVEPAUSE started - relative to bumpTime
// position of last bump
// when a shuffle started
// formation the droid is currently a member of
/* vtol movement - GJ */
/* Only needed for Alex's movement update ? */
//	UDWORD	timeStarted;
//	UDWORD	arrivalTime;
//	UDWORD	pathStarted;
//	BOOL	startedMoving;
//	UDWORD	lastTime;
//	BOOL	speedChange;
//- remove at some point
// information about a formation
pub type FORMATION = _formation;
// number of units using the formation
// maximum length of the lines
// seperation between the ranks
// direction of the formation
// position of the front of the formation
// the lines that make up a formation
// the units that have a position allocated in the formation
// formation speed (currently speed of slowest member) - GJ - sorry.
/*
 * Formation.h
 *
 * Control units moving in formation.
 *
 */
pub type FORMATION_TYPE = _formation_type;
pub type _formation_type = libc::c_uint;
pub const FT_COLUMN: _formation_type = 1;
pub const FT_LINE: _formation_type = 0;
pub type SAVE_DROID_V21 = _save_droid_v21;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_droid_v21 {
    pub name: [STRING; 60],
    pub id: UDWORD,
    pub x: UDWORD,
    pub y: UDWORD,
    pub z: UDWORD,
    pub direction: UDWORD,
    pub player: UDWORD,
    pub inFire: BOOL,
    pub burnStart: UDWORD,
    pub burnDamage: UDWORD,
    pub asBits: [SAVE_COMPONENT; 8],
    pub body: UDWORD,
    pub droidType: UBYTE,
    pub saveType: UDWORD,
    pub numWeaps: UDWORD,
    pub asWeaps: [SAVE_WEAPON; 3],
    pub numKills: UDWORD,
    pub turretRotation: UWORD,
    pub turretPitch: UWORD,
    pub order: SDWORD,
    pub orderX: UWORD,
    pub orderY: UWORD,
    pub orderX2: UWORD,
    pub orderY2: UWORD,
    pub timeLastHit: UDWORD,
    pub targetID: UDWORD,
    pub secondaryOrder: UDWORD,
    pub action: SDWORD,
    pub actionX: UDWORD,
    pub actionY: UDWORD,
    pub actionTargetID: UDWORD,
    pub actionStarted: UDWORD,
    pub actionPoints: UDWORD,
    pub actionHeight: UWORD,
    pub tarStatName: [CHAR; 60],
    pub baseStructID: UDWORD,
    pub group: UBYTE,
    pub selected: UBYTE,
    pub cluster_unused: UBYTE,
    pub visible: [UBYTE; 8],
    pub died: UDWORD,
    pub lastEmission: UDWORD,
    pub commandId: UDWORD,
}
//DROID_SAVE_20 replaces all previous saves uses 60 character names
pub type SAVE_DROID_V20 = _save_droid_v20;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_droid_v20 {
    pub name: [STRING; 60],
    pub id: UDWORD,
    pub x: UDWORD,
    pub y: UDWORD,
    pub z: UDWORD,
    pub direction: UDWORD,
    pub player: UDWORD,
    pub inFire: BOOL,
    pub burnStart: UDWORD,
    pub burnDamage: UDWORD,
    pub asBits: [SAVE_COMPONENT; 8],
    pub body: UDWORD,
    pub droidType: UBYTE,
    pub saveType: UDWORD,
    pub numWeaps: UDWORD,
    pub asWeaps: [SAVE_WEAPON; 3],
    pub numKills: UDWORD,
    pub turretRotation: UWORD,
    pub turretPitch: UWORD,
    pub order: SDWORD,
    pub orderX: UWORD,
    pub orderY: UWORD,
    pub orderX2: UWORD,
    pub orderY2: UWORD,
    pub timeLastHit: UDWORD,
    pub targetID: UDWORD,
    pub secondaryOrder: UDWORD,
    pub action: SDWORD,
    pub actionX: UDWORD,
    pub actionY: UDWORD,
    pub actionTargetID: UDWORD,
    pub actionStarted: UDWORD,
    pub actionPoints: UDWORD,
    pub actionHeight: UWORD,
    pub tarStatName: [CHAR; 60],
    pub baseStructID: UDWORD,
    pub group: UBYTE,
    pub selected: UBYTE,
    pub cluster_unused: UBYTE,
    pub visible: [UBYTE; 8],
    pub died: UDWORD,
    pub lastEmission: UDWORD,
}
//DROID_SAVE_18 replaces DROID_SAVE_14
pub type SAVE_DROID_V18 = _save_droid_v18;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_droid_v18 {
    pub name: [STRING; 40],
    pub id: UDWORD,
    pub x: UDWORD,
    pub y: UDWORD,
    pub z: UDWORD,
    pub direction: UDWORD,
    pub player: UDWORD,
    pub inFire: BOOL,
    pub burnStart: UDWORD,
    pub burnDamage: UDWORD,
    pub asBits: [SAVE_COMPONENT_V19; 8],
    pub body: UDWORD,
    pub droidType: UBYTE,
    pub saveType: UDWORD,
    pub numWeaps: UDWORD,
    pub asWeaps: [SAVE_WEAPON_V19; 3],
    pub numKills: UDWORD,
    pub turretRotation: UWORD,
    pub turretPitch: UWORD,
    pub order: SDWORD,
    pub orderX: UWORD,
    pub orderY: UWORD,
    pub orderX2: UWORD,
    pub orderY2: UWORD,
    pub timeLastHit: UDWORD,
    pub targetID: UDWORD,
    pub secondaryOrder: UDWORD,
    pub action: SDWORD,
    pub actionX: UDWORD,
    pub actionY: UDWORD,
    pub actionTargetID: UDWORD,
    pub actionStarted: UDWORD,
    pub actionPoints: UDWORD,
    pub actionHeight: UWORD,
    pub tarStatName: [CHAR; 40],
    pub baseStructID: UDWORD,
    pub group: UBYTE,
    pub selected: UBYTE,
    pub cluster_unused: UBYTE,
    pub visible: [UBYTE; 8],
    pub died: UDWORD,
    pub lastEmission: UDWORD,
}
pub type SAVE_WEAPON_V19 = _save_weapon_v19;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_weapon_v19 {
    pub name: [STRING; 40],
    pub hitPoints: UDWORD,
    pub ammo: UDWORD,
    pub lastFired: UDWORD,
}
pub type SAVE_COMPONENT_V19 = _save_component_v19;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_component_v19 {
    pub name: [STRING; 40],
}
pub type SAVE_DROID_V14 = _save_droid_v14;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_droid_v14 {
    pub name: [STRING; 40],
    pub id: UDWORD,
    pub x: UDWORD,
    pub y: UDWORD,
    pub z: UDWORD,
    pub direction: UDWORD,
    pub player: UDWORD,
    pub inFire: BOOL,
    pub burnStart: UDWORD,
    pub burnDamage: UDWORD,
    pub asBits: [SAVE_COMPONENT_V19; 8],
    pub body: UDWORD,
    pub droidType: UBYTE,
    pub saveType: UDWORD,
    pub numWeaps: UDWORD,
    pub asWeaps: [SAVE_WEAPON_V19; 3],
    pub numKills: UDWORD,
    pub turretRotation: UWORD,
    pub turretPitch: UWORD,
    pub order: SDWORD,
    pub orderX: UWORD,
    pub orderY: UWORD,
    pub orderX2: UWORD,
    pub orderY2: UWORD,
    pub timeLastHit: UDWORD,
    pub targetID: UDWORD,
    pub secondaryOrder: UDWORD,
    pub action: SDWORD,
    pub actionX: UDWORD,
    pub actionY: UDWORD,
    pub actionTargetID: UDWORD,
    pub actionStarted: UDWORD,
    pub actionPoints: UDWORD,
    pub actionHeight: UWORD,
    pub tarStatName: [CHAR; 20],
    pub baseStructID: UDWORD,
    pub group: UBYTE,
    pub selected: UBYTE,
    pub cluster_unused: UBYTE,
    pub visible: [UBYTE; 8],
    pub died: UDWORD,
    pub lastEmission: UDWORD,
}
pub type DROID_ORDER = _droid_order;
pub type _droid_order = libc::c_uint;
pub const DORDER_RTR_SPECIFIED: _droid_order = 37;
pub const DORDER_LEAVEMAP: _droid_order = 36;
pub const DORDER_RECOVER: _droid_order = 35;
pub const DORDER_SCOUT_ATTACKWALL: _droid_order = 34;
pub const DORDER_MOVE_ATTACKWALL: _droid_order = 33;
pub const DORDER_REARM: _droid_order = 32;
pub const DORDER_PATROL: _droid_order = 31;
pub const DORDER_CLEARWRECK: _droid_order = 30;
pub const DORDER_RUNBURN: _droid_order = 29;
pub const DORDER_SCOUT: _droid_order = 28;
pub const DORDER_RESTORE: _droid_order = 27;
pub const DORDER_DROIDREPAIR: _droid_order = 26;
pub const DORDER_GUARD: _droid_order = 25;
pub const DORDER_TRANSPORTRETURN: _droid_order = 24;
pub const DORDER_TRANSPORTIN: _droid_order = 23;
pub const DORDER_TRANSPORTOUT: _droid_order = 22;
pub const DORDER_RECYCLE: _droid_order = 21;
pub const DORDER_BUILDMODULE: _droid_order = 20;
pub const DORDER_COMMAND: _droid_order = 19;
pub const DORDER_ATTACKTARGET: _droid_order = 18;
pub const DORDER_DISEMBARK: _droid_order = 17;
pub const DORDER_EMBARK: _droid_order = 16;
pub const DORDER_RUN: _droid_order = 15;
pub const DORDER_RTR: _droid_order = 14;
pub const DORDER_RTB: _droid_order = 13;
pub const DORDER_DESTRUCT: _droid_order = 12;
pub const DORDER_RETREAT: _droid_order = 11;
pub const DORDER_FIRESUPPORT: _droid_order = 10;
pub const DORDER_OBSERVE: _droid_order = 9;
pub const DORDER_REPAIR: _droid_order = 8;
pub const DORDER_DEMOLISH: _droid_order = 7;
pub const DORDER_LINEBUILD: _droid_order = 6;
pub const DORDER_HELPBUILD: _droid_order = 5;
pub const DORDER_BUILD: _droid_order = 4;
pub const DORDER_ATTACK: _droid_order = 3;
pub const DORDER_MOVE: _droid_order = 2;
pub const DORDER_STOP: _droid_order = 1;
pub type SAVE_DROID_V12 = _save_droid_v12;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_droid_v12 {
    pub name: [STRING; 40],
    pub id: UDWORD,
    pub x: UDWORD,
    pub y: UDWORD,
    pub z: UDWORD,
    pub direction: UDWORD,
    pub player: UDWORD,
    pub inFire: BOOL,
    pub burnStart: UDWORD,
    pub burnDamage: UDWORD,
    pub asBits: [SAVE_COMPONENT_V19; 8],
    pub body: UDWORD,
    pub droidType: UBYTE,
    pub saveType: UDWORD,
    pub numWeaps: UDWORD,
    pub asWeaps: [SAVE_WEAPON_V19; 3],
    pub numKills: UDWORD,
    pub turretRotation: UWORD,
    pub turretPitch: UWORD,
    pub order: SDWORD,
    pub orderX: UWORD,
    pub orderY: UWORD,
    pub orderX2: UWORD,
    pub orderY2: UWORD,
    pub timeLastHit: UDWORD,
    pub targetID: UDWORD,
    pub secondaryOrder: UDWORD,
    pub action: SDWORD,
    pub actionX: UDWORD,
    pub actionY: UDWORD,
    pub actionTargetID: UDWORD,
    pub actionStarted: UDWORD,
    pub actionPoints: UDWORD,
    pub actionHeight: UWORD,
}
//- remove at some point
/*save DROID SAVE 11 */
pub type SAVE_DROID_V11 = _save_droid_v11;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_droid_v11 {
    pub name: [STRING; 40],
    pub id: UDWORD,
    pub x: UDWORD,
    pub y: UDWORD,
    pub z: UDWORD,
    pub direction: UDWORD,
    pub player: UDWORD,
    pub inFire: BOOL,
    pub burnStart: UDWORD,
    pub burnDamage: UDWORD,
    pub asBits: [SAVE_COMPONENT_V19; 8],
    pub body: UDWORD,
    pub droidType: UBYTE,
    pub saveType: UBYTE,
    pub numWeaps: UDWORD,
    pub asWeaps: [SAVE_WEAPON_V19; 3],
    pub numKills: UDWORD,
    pub turretRotation: UWORD,
    pub turretPitch: UWORD,
}
pub type SAVE_DROID_V9 = _save_droid_v9;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_droid_v9 {
    pub name: [STRING; 40],
    pub id: UDWORD,
    pub x: UDWORD,
    pub y: UDWORD,
    pub z: UDWORD,
    pub direction: UDWORD,
    pub player: UDWORD,
    pub inFire: BOOL,
    pub burnStart: UDWORD,
    pub burnDamage: UDWORD,
    pub asBits: [SAVE_COMPONENT_V19; 8],
    pub body: UDWORD,
    pub droidType: UBYTE,
    pub saveType: UDWORD,
    pub numWeaps: UDWORD,
    pub asWeaps: [SAVE_WEAPON_V19; 3],
    pub numKills: UDWORD,
}
pub type DROIDINIT_SAVEHEADER = _droidinit_save_header;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _droidinit_save_header {
    pub aFileType: [STRING; 4],
    pub version: UDWORD,
    pub quantity: UDWORD,
}
pub type SAVE_DROIDINIT = _save_droidinit;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_droidinit {
    pub name: [STRING; 40],
    pub id: UDWORD,
    pub x: UDWORD,
    pub y: UDWORD,
    pub z: UDWORD,
    pub direction: UDWORD,
    pub player: UDWORD,
    pub inFire: BOOL,
    pub burnStart: UDWORD,
    pub burnDamage: UDWORD,
}
pub type RESEARCH_SAVEHEADER = _research_save_header;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _research_save_header {
    pub aFileType: [STRING; 4],
    pub version: UDWORD,
    pub quantity: UDWORD,
}
pub type SAVE_RESEARCH = _save_research;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_research {
    pub name: [CHAR; 60],
    pub possible: [UBYTE; 8],
    pub researched: [UBYTE; 8],
    pub currentPoints: [UDWORD; 8],
}
pub type SAVE_RESEARCH_V8 = _save_research_v8;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_research_v8 {
    pub name: [CHAR; 40],
    pub possible: [UBYTE; 8],
    pub researched: [UBYTE; 8],
    pub currentPoints: [UDWORD; 8],
}
pub type LANDING_ZONE = _landing_zone;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _landing_zone {
    pub x1: UBYTE,
    pub y1: UBYTE,
    pub x2: UBYTE,
    pub y2: UBYTE,
}
pub type SAVE_GAME = save_game;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct save_game {
    pub gameTime: UDWORD,
    pub GameType: UDWORD,
    pub ScrollMinX: SDWORD,
    pub ScrollMinY: SDWORD,
    pub ScrollMaxX: UDWORD,
    pub ScrollMaxY: UDWORD,
    pub levelName: [STRING; 20],
    pub power: [SAVE_POWER; 8],
    pub currentPlayerPos: iView,
    pub missionTime: UDWORD,
    pub saveKey: UDWORD,
    pub missionOffTime: SDWORD,
    pub missionETA: SDWORD,
    pub missionHomeLZ_X: UWORD,
    pub missionHomeLZ_Y: UWORD,
    pub missionPlayerX: SDWORD,
    pub missionPlayerY: SDWORD,
    pub iTranspEntryTileX: [UWORD; 8],
    pub iTranspEntryTileY: [UWORD; 8],
    pub iTranspExitTileX: [UWORD; 8],
    pub iTranspExitTileY: [UWORD; 8],
    pub aDefaultSensor: [UDWORD; 8],
    pub aDefaultECM: [UDWORD; 8],
    pub aDefaultRepair: [UDWORD; 8],
    pub offWorldKeepLists: BOOL,
    pub aDroidExperience: [[UBYTE; 32]; 8],
    pub RubbleTile: UDWORD,
    pub WaterTile: UDWORD,
    pub fogColour: UDWORD,
    pub fogState: UDWORD,
    pub sLandingZone: [LANDING_ZONE; 9],
    pub objId: UDWORD,
    pub buildDate: [libc::c_char; 256],
    pub oldestVersion: UDWORD,
    pub validityKey: UDWORD,
    pub alliances: [[UBYTE; 8]; 8],
    pub playerColour: [UBYTE; 8],
    pub radarZoom: UBYTE,
    pub bDroidsToSafetyFlag: UBYTE,
    pub asVTOLReturnPos: [POINT; 8],
    pub asRunData: [RUN_DATA; 8],
    pub reinforceTime: UDWORD,
    pub bPlayCountDown: UBYTE,
    pub bPlayerHasWon: UBYTE,
    pub bPlayerHasLost: UBYTE,
    pub dummy3: UBYTE,
    pub awDroidExperience: [[UWORD; 32]; 8],
    pub missionScrollMinX: UWORD,
    pub missionScrollMinY: UWORD,
    pub missionScrollMaxX: UWORD,
    pub missionScrollMaxY: UWORD,
    pub scrGameLevel: SDWORD,
    pub bExtraVictoryFlag: UBYTE,
    pub bExtraFailFlag: UBYTE,
    pub bTrackTransporter: UBYTE,
    pub missionCheatTime: SDWORD,
    pub sGame: MULTIPLAYERGAME,
    pub sNetPlay: NETPLAY,
    pub savePlayer: UDWORD,
    pub sPName: [STRING; 32],
    pub multiPlayer: BOOL,
    pub sPlayer2dpid: [DPID; 8],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct NETPLAY {
    pub games: [GAMESTRUCT; 12],
    pub players: [PLAYER; 8],
    pub playercount: UDWORD,
    pub dpidPlayer: DPID,
    pub bComms: BOOL,
    pub bHost: BOOL,
    pub bLobbyLaunched: BOOL,
    pub bSpectator: BOOL,
    pub bEncryptAllPackets: BOOL,
    pub cryptKey: [UDWORD; 4],
    pub bCaptureInUse: BOOL,
    pub bAllowCaptureRecord: BOOL,
    pub bAllowCapturePlay: BOOL,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PLAYER {
    pub dpid: DPID,
    pub name: [libc::c_char; 64],
    pub bHost: BOOL,
    pub bSpectator: BOOL,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct GAMESTRUCT {
    pub name: [libc::c_char; 64],
    pub desc: SESSIONDESC,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SESSIONDESC {
    pub dwSize: DWORD,
    pub dwFlags: DWORD,
    pub host: [libc::c_char; 16],
    pub dwMaxPlayers: DWORD,
    pub dwCurrentPlayers: DWORD,
    pub dwUser1: DWORD,
    pub dwUser2: DWORD,
    pub dwUser3: DWORD,
    pub dwUser4: DWORD,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct MULTIPLAYERGAME {
    pub type_0: UBYTE,
    pub map: [STRING; 128],
    pub version: [libc::c_char; 8],
    pub maxPlayers: UBYTE,
    pub name: [STRING; 128],
    pub bComputerPlayers: BOOL,
    pub fog: BOOL,
    pub power: UDWORD,
    pub base: UBYTE,
    pub alliance: UBYTE,
    pub limit: UBYTE,
    pub bytesPerSec: UWORD,
    pub packetsPerSec: UBYTE,
    pub encryptKey: UBYTE,
    pub skDiff: [UBYTE; 8],
}
pub type SAVE_POWER = _savePower;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _savePower {
    pub currentPower: UDWORD,
    pub extractedPower: UDWORD,
}
pub type TEMPLATE_SAVEHEADER = _template_save_header;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _template_save_header {
    pub aFileType: [STRING; 4],
    pub version: UDWORD,
    pub quantity: UDWORD,
}
pub type SAVE_TEMPLATE = _save_template;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_template {
    pub name: [CHAR; 60],
    pub ref_0: UDWORD,
    pub player: UDWORD,
    pub droidType: UBYTE,
    pub asParts: [[STRING; 60]; 8],
    pub numWeaps: UDWORD,
    pub asWeaps: [[STRING; 60]; 3],
    pub multiPlayerID: UDWORD,
}
pub type SAVE_TEMPLATE_V14 = _save_template_v14;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_template_v14 {
    pub name: [CHAR; 40],
    pub ref_0: UDWORD,
    pub player: UDWORD,
    pub droidType: UBYTE,
    pub asParts: [[STRING; 40]; 8],
    pub numWeaps: UDWORD,
    pub asWeaps: [[STRING; 40]; 3],
    pub multiPlayerID: UDWORD,
}
//PROGRAMS NEED TO BE REMOVED FROM DROIDS - 7/8/98
// multiPlayerID for templates needs to be saved - 29/10/98
// multiPlayerID for templates needs to be saved - 29/10/98
pub type SAVE_TEMPLATE_V2 = _save_template_v2;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_template_v2 {
    pub name: [CHAR; 40],
    pub ref_0: UDWORD,
    pub player: UDWORD,
    pub droidType: UBYTE,
    pub asParts: [[STRING; 40]; 8],
    pub numWeaps: UDWORD,
    pub asWeaps: [[STRING; 40]; 3],
    pub numProgs: UDWORD,
    pub asProgs: [[STRING; 40]; 3],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TILETYPE_SAVEHEADER {
    pub aFileType: [STRING; 4],
    pub version: UDWORD,
    pub quantity: UDWORD,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PLAYERSTATS {
    pub played: DWORD,
    pub wins: DWORD,
    pub loses: DWORD,
    pub totalKills: DWORD,
    pub totalScore: SDWORD,
    pub recentKills: DWORD,
    pub recentScore: SDWORD,
    pub killsToAdd: DWORD,
    pub scoreToAdd: SDWORD,
}
//used to display the proximity messages
pub type PROXIMITY_DISPLAY = _proximity_display;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _proximity_display {
    pub type_0: POSITION_TYPE,
    pub frameNumber: UDWORD,
    pub screenX: UDWORD,
    pub screenY: UDWORD,
    pub screenR: UDWORD,
    pub player: UDWORD,
    pub selected: BOOL,
    pub psMessage: *mut MESSAGE,
    pub radarX: UDWORD,
    pub radarY: UDWORD,
    pub timeLastDrawn: UDWORD,
    pub strobe: UDWORD,
    pub buttonID: UDWORD,
    pub psNext: *mut _proximity_display,
}
//message associated with this 'button'
//Used to store the radar coords - if to be drawn
//stores the time the 'button' was last drawn for animation
//id of image last used
//id of the button for the interface
//pointer to the next in the list
//base structure for each message
pub type MESSAGE = _message;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _message {
    pub type_0: MESSAGE_TYPE,
    pub id: UDWORD,
    pub pViewData: *mut MSG_VIEWDATA,
    pub read: BOOL,
    pub player: UDWORD,
    pub psNext: *mut _message,
}
pub type MSG_VIEWDATA = *mut libc::c_void;
pub type MESSAGE_TYPE = _message_type;
pub type _message_type = libc::c_uint;
pub const MSG_TYPES: _message_type = 4;
pub const MSG_PROXIMITY: _message_type = 3;
pub const MSG_MISSION: _message_type = 2;
pub const MSG_CAMPAIGN: _message_type = 1;
pub const MSG_RESEARCH: _message_type = 0;
pub type GAME_SAVEHEADER = _game_save_header;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _game_save_header {
    pub aFileType: [STRING; 4],
    pub version: UDWORD,
}
//The type of message
//ID number of the message
//VIEWDATA		*pViewData;				//Pointer to view data - if any - should be some!
//Pointer to view data - if any - should be some!
//flag to indicate whether message has been read
//which player this message belongs to
//pointer to the next in the list
//extra code for the patch - saves out whether cheated with the mission timer
pub type SAVE_GAME_V31 = save_game_v31;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct save_game_v31 {
    pub gameTime: UDWORD,
    pub GameType: UDWORD,
    pub ScrollMinX: SDWORD,
    pub ScrollMinY: SDWORD,
    pub ScrollMaxX: UDWORD,
    pub ScrollMaxY: UDWORD,
    pub levelName: [STRING; 20],
    pub power: [SAVE_POWER; 8],
    pub currentPlayerPos: iView,
    pub missionTime: UDWORD,
    pub saveKey: UDWORD,
    pub missionOffTime: SDWORD,
    pub missionETA: SDWORD,
    pub missionHomeLZ_X: UWORD,
    pub missionHomeLZ_Y: UWORD,
    pub missionPlayerX: SDWORD,
    pub missionPlayerY: SDWORD,
    pub iTranspEntryTileX: [UWORD; 8],
    pub iTranspEntryTileY: [UWORD; 8],
    pub iTranspExitTileX: [UWORD; 8],
    pub iTranspExitTileY: [UWORD; 8],
    pub aDefaultSensor: [UDWORD; 8],
    pub aDefaultECM: [UDWORD; 8],
    pub aDefaultRepair: [UDWORD; 8],
    pub offWorldKeepLists: BOOL,
    pub aDroidExperience: [[UBYTE; 32]; 8],
    pub RubbleTile: UDWORD,
    pub WaterTile: UDWORD,
    pub fogColour: UDWORD,
    pub fogState: UDWORD,
    pub sLandingZone: [LANDING_ZONE; 9],
    pub objId: UDWORD,
    pub buildDate: [libc::c_char; 256],
    pub oldestVersion: UDWORD,
    pub validityKey: UDWORD,
    pub alliances: [[UBYTE; 8]; 8],
    pub playerColour: [UBYTE; 8],
    pub radarZoom: UBYTE,
    pub bDroidsToSafetyFlag: UBYTE,
    pub asVTOLReturnPos: [POINT; 8],
    pub asRunData: [RUN_DATA; 8],
    pub reinforceTime: UDWORD,
    pub bPlayCountDown: UBYTE,
    pub bPlayerHasWon: UBYTE,
    pub bPlayerHasLost: UBYTE,
    pub dummy3: UBYTE,
    pub awDroidExperience: [[UWORD; 32]; 8],
    pub missionScrollMinX: UWORD,
    pub missionScrollMinY: UWORD,
    pub missionScrollMaxX: UWORD,
    pub missionScrollMaxY: UWORD,
    pub scrGameLevel: SDWORD,
    pub bExtraVictoryFlag: UBYTE,
    pub bExtraFailFlag: UBYTE,
    pub bTrackTransporter: UBYTE,
    pub missionCheatTime: SDWORD,
}
pub type SAVE_GAME_V30 = save_game_v30;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct save_game_v30 {
    pub gameTime: UDWORD,
    pub GameType: UDWORD,
    pub ScrollMinX: SDWORD,
    pub ScrollMinY: SDWORD,
    pub ScrollMaxX: UDWORD,
    pub ScrollMaxY: UDWORD,
    pub levelName: [STRING; 20],
    pub power: [SAVE_POWER; 8],
    pub currentPlayerPos: iView,
    pub missionTime: UDWORD,
    pub saveKey: UDWORD,
    pub missionOffTime: SDWORD,
    pub missionETA: SDWORD,
    pub missionHomeLZ_X: UWORD,
    pub missionHomeLZ_Y: UWORD,
    pub missionPlayerX: SDWORD,
    pub missionPlayerY: SDWORD,
    pub iTranspEntryTileX: [UWORD; 8],
    pub iTranspEntryTileY: [UWORD; 8],
    pub iTranspExitTileX: [UWORD; 8],
    pub iTranspExitTileY: [UWORD; 8],
    pub aDefaultSensor: [UDWORD; 8],
    pub aDefaultECM: [UDWORD; 8],
    pub aDefaultRepair: [UDWORD; 8],
    pub offWorldKeepLists: BOOL,
    pub aDroidExperience: [[UBYTE; 32]; 8],
    pub RubbleTile: UDWORD,
    pub WaterTile: UDWORD,
    pub fogColour: UDWORD,
    pub fogState: UDWORD,
    pub sLandingZone: [LANDING_ZONE; 9],
    pub objId: UDWORD,
    pub buildDate: [libc::c_char; 256],
    pub oldestVersion: UDWORD,
    pub validityKey: UDWORD,
    pub alliances: [[UBYTE; 8]; 8],
    pub playerColour: [UBYTE; 8],
    pub radarZoom: UBYTE,
    pub bDroidsToSafetyFlag: UBYTE,
    pub asVTOLReturnPos: [POINT; 8],
    pub asRunData: [RUN_DATA; 8],
    pub reinforceTime: UDWORD,
    pub bPlayCountDown: UBYTE,
    pub bPlayerHasWon: UBYTE,
    pub bPlayerHasLost: UBYTE,
    pub dummy3: UBYTE,
    pub awDroidExperience: [[UWORD; 32]; 8],
    pub missionScrollMinX: UWORD,
    pub missionScrollMinY: UWORD,
    pub missionScrollMaxX: UWORD,
    pub missionScrollMaxY: UWORD,
    pub scrGameLevel: SDWORD,
    pub bExtraVictoryFlag: UBYTE,
    pub bExtraFailFlag: UBYTE,
    pub bTrackTransporter: UBYTE,
}
pub type SAVE_GAME_V29 = save_game_v29;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct save_game_v29 {
    pub gameTime: UDWORD,
    pub GameType: UDWORD,
    pub ScrollMinX: SDWORD,
    pub ScrollMinY: SDWORD,
    pub ScrollMaxX: UDWORD,
    pub ScrollMaxY: UDWORD,
    pub levelName: [STRING; 20],
    pub power: [SAVE_POWER; 8],
    pub currentPlayerPos: iView,
    pub missionTime: UDWORD,
    pub saveKey: UDWORD,
    pub missionOffTime: SDWORD,
    pub missionETA: SDWORD,
    pub missionHomeLZ_X: UWORD,
    pub missionHomeLZ_Y: UWORD,
    pub missionPlayerX: SDWORD,
    pub missionPlayerY: SDWORD,
    pub iTranspEntryTileX: [UWORD; 8],
    pub iTranspEntryTileY: [UWORD; 8],
    pub iTranspExitTileX: [UWORD; 8],
    pub iTranspExitTileY: [UWORD; 8],
    pub aDefaultSensor: [UDWORD; 8],
    pub aDefaultECM: [UDWORD; 8],
    pub aDefaultRepair: [UDWORD; 8],
    pub offWorldKeepLists: BOOL,
    pub aDroidExperience: [[UBYTE; 32]; 8],
    pub RubbleTile: UDWORD,
    pub WaterTile: UDWORD,
    pub fogColour: UDWORD,
    pub fogState: UDWORD,
    pub sLandingZone: [LANDING_ZONE; 9],
    pub objId: UDWORD,
    pub buildDate: [libc::c_char; 256],
    pub oldestVersion: UDWORD,
    pub validityKey: UDWORD,
    pub alliances: [[UBYTE; 8]; 8],
    pub playerColour: [UBYTE; 8],
    pub radarZoom: UBYTE,
    pub bDroidsToSafetyFlag: UBYTE,
    pub asVTOLReturnPos: [POINT; 8],
    pub asRunData: [RUN_DATA; 8],
    pub reinforceTime: UDWORD,
    pub bPlayCountDown: UBYTE,
    pub bPlayerHasWon: UBYTE,
    pub bPlayerHasLost: UBYTE,
    pub dummy3: UBYTE,
    pub awDroidExperience: [[UWORD; 32]; 8],
    pub missionScrollMinX: UWORD,
    pub missionScrollMinY: UWORD,
    pub missionScrollMaxX: UWORD,
    pub missionScrollMaxY: UWORD,
}
/*
#define GAME_SAVE_V27		\
	UDWORD	gameTime;		\
	UDWORD	GameType;		\
	SDWORD	ScrollMinX;		\
	SDWORD	ScrollMinY;		\
	UDWORD	ScrollMaxX;		\
	UDWORD	ScrollMaxY;		\
	STRING	levelName[MAX_LEVEL_SIZE];	\
	SAVE_POWER	power[MAX_PLAYERS];		\
	iView	currentPlayerPos;	\
	UDWORD	missionTime;	\
	UDWORD	saveKey;		\
	SDWORD	missionOffTime;	\
	SDWORD	missionETA;		\
    UWORD   missionHomeLZ_X;\
    UWORD   missionHomeLZ_Y;\
	SDWORD	missionPlayerX;	\
	SDWORD	missionPlayerY;	\
	UWORD	iTranspEntryTileX[MAX_PLAYERS];	\
	UWORD	iTranspEntryTileY[MAX_PLAYERS];	\
	UWORD	iTranspExitTileX[MAX_PLAYERS];	\
	UWORD	iTranspExitTileY[MAX_PLAYERS];	\
	UDWORD 	aDefaultSensor[MAX_PLAYERS];	\
	UDWORD	aDefaultECM[MAX_PLAYERS];		\
	UDWORD	aDefaultRepair[MAX_PLAYERS];	\
	BOOL	offWorldKeepLists;\
	UWORD	aDroidExperience[MAX_PLAYERS][MAX_RECYCLED_DROIDS];\
	UDWORD	RubbleTile;		\
	UDWORD	WaterTile;		\
	UDWORD	fogColour;		\
	UDWORD	fogState;		\
	LANDING_ZONE   sLandingZone[MAX_NOGO_AREAS];\
	UDWORD  objId;			\
	char	buildDate[MAX_STR_LENGTH];		\
	UDWORD	oldestVersion;	\
	UDWORD	validityKey;\
	UBYTE	alliances[MAX_PLAYERS][MAX_PLAYERS];\
	UBYTE	playerColour[MAX_PLAYERS];\
	UBYTE	radarZoom;		\
	UBYTE	bDroidsToSafetyFlag;	\
	POINT	asVTOLReturnPos[MAX_PLAYERS];\
	RUN_DATA asRunData[MAX_PLAYERS];\
	UDWORD	reinforceTime;	\
	UBYTE	bPlayCountDown;	\
	UBYTE	bPlayerHasWon;	\
	UBYTE	bPlayerHasLost;	\
	UBYTE	dummy3

typedef struct save_game_v27
{
	GAME_SAVE_V27;
} SAVE_GAME_V27;
*/
pub type SAVE_GAME_V27 = save_game_v27;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct save_game_v27 {
    pub gameTime: UDWORD,
    pub GameType: UDWORD,
    pub ScrollMinX: SDWORD,
    pub ScrollMinY: SDWORD,
    pub ScrollMaxX: UDWORD,
    pub ScrollMaxY: UDWORD,
    pub levelName: [STRING; 20],
    pub power: [SAVE_POWER; 8],
    pub currentPlayerPos: iView,
    pub missionTime: UDWORD,
    pub saveKey: UDWORD,
    pub missionOffTime: SDWORD,
    pub missionETA: SDWORD,
    pub missionHomeLZ_X: UWORD,
    pub missionHomeLZ_Y: UWORD,
    pub missionPlayerX: SDWORD,
    pub missionPlayerY: SDWORD,
    pub iTranspEntryTileX: [UWORD; 8],
    pub iTranspEntryTileY: [UWORD; 8],
    pub iTranspExitTileX: [UWORD; 8],
    pub iTranspExitTileY: [UWORD; 8],
    pub aDefaultSensor: [UDWORD; 8],
    pub aDefaultECM: [UDWORD; 8],
    pub aDefaultRepair: [UDWORD; 8],
    pub offWorldKeepLists: BOOL,
    pub aDroidExperience: [[UBYTE; 32]; 8],
    pub RubbleTile: UDWORD,
    pub WaterTile: UDWORD,
    pub fogColour: UDWORD,
    pub fogState: UDWORD,
    pub sLandingZone: [LANDING_ZONE; 9],
    pub objId: UDWORD,
    pub buildDate: [libc::c_char; 256],
    pub oldestVersion: UDWORD,
    pub validityKey: UDWORD,
    pub alliances: [[UBYTE; 8]; 8],
    pub playerColour: [UBYTE; 8],
    pub radarZoom: UBYTE,
    pub bDroidsToSafetyFlag: UBYTE,
    pub asVTOLReturnPos: [POINT; 8],
    pub asRunData: [RUN_DATA; 8],
    pub reinforceTime: UDWORD,
    pub bPlayCountDown: UBYTE,
    pub bPlayerHasWon: UBYTE,
    pub bPlayerHasLost: UBYTE,
    pub dummy3: UBYTE,
    pub awDroidExperience: [[UWORD; 32]; 8],
}
pub type SAVE_GAME_V24 = save_game_v24;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct save_game_v24 {
    pub gameTime: UDWORD,
    pub GameType: UDWORD,
    pub ScrollMinX: SDWORD,
    pub ScrollMinY: SDWORD,
    pub ScrollMaxX: UDWORD,
    pub ScrollMaxY: UDWORD,
    pub levelName: [STRING; 20],
    pub power: [SAVE_POWER; 8],
    pub currentPlayerPos: iView,
    pub missionTime: UDWORD,
    pub saveKey: UDWORD,
    pub missionOffTime: SDWORD,
    pub missionETA: SDWORD,
    pub missionHomeLZ_X: UWORD,
    pub missionHomeLZ_Y: UWORD,
    pub missionPlayerX: SDWORD,
    pub missionPlayerY: SDWORD,
    pub iTranspEntryTileX: [UWORD; 8],
    pub iTranspEntryTileY: [UWORD; 8],
    pub iTranspExitTileX: [UWORD; 8],
    pub iTranspExitTileY: [UWORD; 8],
    pub aDefaultSensor: [UDWORD; 8],
    pub aDefaultECM: [UDWORD; 8],
    pub aDefaultRepair: [UDWORD; 8],
    pub offWorldKeepLists: BOOL,
    pub aDroidExperience: [[UBYTE; 32]; 8],
    pub RubbleTile: UDWORD,
    pub WaterTile: UDWORD,
    pub fogColour: UDWORD,
    pub fogState: UDWORD,
    pub sLandingZone: [LANDING_ZONE; 9],
    pub objId: UDWORD,
    pub buildDate: [libc::c_char; 256],
    pub oldestVersion: UDWORD,
    pub validityKey: UDWORD,
    pub alliances: [[UBYTE; 8]; 8],
    pub playerColour: [UBYTE; 8],
    pub radarZoom: UBYTE,
    pub bDroidsToSafetyFlag: UBYTE,
    pub asVTOLReturnPos: [POINT; 8],
    pub asRunData: [RUN_DATA; 8],
    pub reinforceTime: UDWORD,
    pub bPlayCountDown: UBYTE,
    pub bPlayerHasWon: UBYTE,
    pub bPlayerHasLost: UBYTE,
    pub dummy3: UBYTE,
}
pub type SAVE_GAME_V22 = save_game_v22;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct save_game_v22 {
    pub gameTime: UDWORD,
    pub GameType: UDWORD,
    pub ScrollMinX: SDWORD,
    pub ScrollMinY: SDWORD,
    pub ScrollMaxX: UDWORD,
    pub ScrollMaxY: UDWORD,
    pub levelName: [STRING; 20],
    pub power: [SAVE_POWER; 8],
    pub currentPlayerPos: iView,
    pub missionTime: UDWORD,
    pub saveKey: UDWORD,
    pub missionOffTime: SDWORD,
    pub missionETA: SDWORD,
    pub missionHomeLZ_X: UWORD,
    pub missionHomeLZ_Y: UWORD,
    pub missionPlayerX: SDWORD,
    pub missionPlayerY: SDWORD,
    pub iTranspEntryTileX: [UWORD; 8],
    pub iTranspEntryTileY: [UWORD; 8],
    pub iTranspExitTileX: [UWORD; 8],
    pub iTranspExitTileY: [UWORD; 8],
    pub aDefaultSensor: [UDWORD; 8],
    pub aDefaultECM: [UDWORD; 8],
    pub aDefaultRepair: [UDWORD; 8],
    pub offWorldKeepLists: BOOL,
    pub aDroidExperience: [[UBYTE; 32]; 8],
    pub RubbleTile: UDWORD,
    pub WaterTile: UDWORD,
    pub fogColour: UDWORD,
    pub fogState: UDWORD,
    pub sLandingZone: [LANDING_ZONE; 9],
    pub objId: UDWORD,
    pub buildDate: [libc::c_char; 256],
    pub oldestVersion: UDWORD,
    pub validityKey: UDWORD,
    pub alliances: [[UBYTE; 8]; 8],
    pub playerColour: [UBYTE; 8],
    pub radarZoom: UBYTE,
    pub bDroidsToSafetyFlag: UBYTE,
    pub asVTOLReturnPos: [POINT; 8],
    pub asRunData: [RUN_DATA; 8],
}
pub type SAVE_GAME_V20 = save_game_v20;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct save_game_v20 {
    pub gameTime: UDWORD,
    pub GameType: UDWORD,
    pub ScrollMinX: SDWORD,
    pub ScrollMinY: SDWORD,
    pub ScrollMaxX: UDWORD,
    pub ScrollMaxY: UDWORD,
    pub levelName: [STRING; 20],
    pub power: [SAVE_POWER; 8],
    pub currentPlayerPos: iView,
    pub missionTime: UDWORD,
    pub saveKey: UDWORD,
    pub missionOffTime: SDWORD,
    pub missionETA: SDWORD,
    pub missionHomeLZ_X: UWORD,
    pub missionHomeLZ_Y: UWORD,
    pub missionPlayerX: SDWORD,
    pub missionPlayerY: SDWORD,
    pub iTranspEntryTileX: [UWORD; 8],
    pub iTranspEntryTileY: [UWORD; 8],
    pub iTranspExitTileX: [UWORD; 8],
    pub iTranspExitTileY: [UWORD; 8],
    pub aDefaultSensor: [UDWORD; 8],
    pub aDefaultECM: [UDWORD; 8],
    pub aDefaultRepair: [UDWORD; 8],
    pub offWorldKeepLists: BOOL,
    pub aDroidExperience: [[UBYTE; 32]; 8],
    pub RubbleTile: UDWORD,
    pub WaterTile: UDWORD,
    pub fogColour: UDWORD,
    pub fogState: UDWORD,
    pub sLandingZone: [LANDING_ZONE; 9],
    pub objId: UDWORD,
    pub buildDate: [libc::c_char; 256],
    pub oldestVersion: UDWORD,
    pub validityKey: UDWORD,
    pub alliances: [[UBYTE; 8]; 8],
    pub playerColour: [UBYTE; 8],
    pub radarZoom: UBYTE,
    pub bDroidsToSafetyFlag: UBYTE,
    pub asVTOLReturnPos: [POINT; 8],
}
pub type SAVE_GAME_V19 = save_game_v19;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct save_game_v19 {
    pub gameTime: UDWORD,
    pub GameType: UDWORD,
    pub ScrollMinX: SDWORD,
    pub ScrollMinY: SDWORD,
    pub ScrollMaxX: UDWORD,
    pub ScrollMaxY: UDWORD,
    pub levelName: [STRING; 20],
    pub power: [SAVE_POWER; 8],
    pub currentPlayerPos: iView,
    pub missionTime: UDWORD,
    pub saveKey: UDWORD,
    pub missionOffTime: SDWORD,
    pub missionETA: SDWORD,
    pub missionHomeLZ_X: UWORD,
    pub missionHomeLZ_Y: UWORD,
    pub missionPlayerX: SDWORD,
    pub missionPlayerY: SDWORD,
    pub iTranspEntryTileX: [UWORD; 8],
    pub iTranspEntryTileY: [UWORD; 8],
    pub iTranspExitTileX: [UWORD; 8],
    pub iTranspExitTileY: [UWORD; 8],
    pub aDefaultSensor: [UDWORD; 8],
    pub aDefaultECM: [UDWORD; 8],
    pub aDefaultRepair: [UDWORD; 8],
    pub offWorldKeepLists: BOOL,
    pub aDroidExperience: [[UBYTE; 32]; 8],
    pub RubbleTile: UDWORD,
    pub WaterTile: UDWORD,
    pub fogColour: UDWORD,
    pub fogState: UDWORD,
    pub sLandingZone: [LANDING_ZONE; 9],
    pub objId: UDWORD,
    pub buildDate: [libc::c_char; 256],
    pub oldestVersion: UDWORD,
    pub validityKey: UDWORD,
    pub alliances: [[UBYTE; 8]; 8],
    pub playerColour: [UBYTE; 8],
    pub radarZoom: UBYTE,
}
pub type SAVE_GAME_V18 = save_game_v18;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct save_game_v18 {
    pub gameTime: UDWORD,
    pub GameType: UDWORD,
    pub ScrollMinX: SDWORD,
    pub ScrollMinY: SDWORD,
    pub ScrollMaxX: UDWORD,
    pub ScrollMaxY: UDWORD,
    pub levelName: [STRING; 20],
    pub power: [SAVE_POWER; 8],
    pub currentPlayerPos: iView,
    pub missionTime: UDWORD,
    pub saveKey: UDWORD,
    pub missionOffTime: SDWORD,
    pub missionETA: SDWORD,
    pub missionHomeLZ_X: UWORD,
    pub missionHomeLZ_Y: UWORD,
    pub missionPlayerX: SDWORD,
    pub missionPlayerY: SDWORD,
    pub iTranspEntryTileX: [UWORD; 8],
    pub iTranspEntryTileY: [UWORD; 8],
    pub iTranspExitTileX: [UWORD; 8],
    pub iTranspExitTileY: [UWORD; 8],
    pub aDefaultSensor: [UDWORD; 8],
    pub aDefaultECM: [UDWORD; 8],
    pub aDefaultRepair: [UDWORD; 8],
    pub offWorldKeepLists: BOOL,
    pub aDroidExperience: [[UBYTE; 32]; 8],
    pub RubbleTile: UDWORD,
    pub WaterTile: UDWORD,
    pub fogColour: UDWORD,
    pub fogState: UDWORD,
    pub sLandingZone: [LANDING_ZONE; 9],
    pub objId: UDWORD,
    pub buildDate: [libc::c_char; 256],
    pub oldestVersion: UDWORD,
    pub validityKey: UDWORD,
}
pub type SAVE_GAME_V17 = save_game_v17;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct save_game_v17 {
    pub gameTime: UDWORD,
    pub GameType: UDWORD,
    pub ScrollMinX: SDWORD,
    pub ScrollMinY: SDWORD,
    pub ScrollMaxX: UDWORD,
    pub ScrollMaxY: UDWORD,
    pub levelName: [STRING; 20],
    pub power: [SAVE_POWER; 8],
    pub currentPlayerPos: iView,
    pub missionTime: UDWORD,
    pub saveKey: UDWORD,
    pub missionOffTime: SDWORD,
    pub missionETA: SDWORD,
    pub missionHomeLZ_X: UWORD,
    pub missionHomeLZ_Y: UWORD,
    pub missionPlayerX: SDWORD,
    pub missionPlayerY: SDWORD,
    pub iTranspEntryTileX: [UWORD; 8],
    pub iTranspEntryTileY: [UWORD; 8],
    pub iTranspExitTileX: [UWORD; 8],
    pub iTranspExitTileY: [UWORD; 8],
    pub aDefaultSensor: [UDWORD; 8],
    pub aDefaultECM: [UDWORD; 8],
    pub aDefaultRepair: [UDWORD; 8],
    pub offWorldKeepLists: BOOL,
    pub aDroidExperience: [[UBYTE; 32]; 8],
    pub RubbleTile: UDWORD,
    pub WaterTile: UDWORD,
    pub fogColour: UDWORD,
    pub fogState: UDWORD,
    pub sLandingZone: [LANDING_ZONE; 9],
    pub objId: UDWORD,
}
pub type SAVE_GAME_V16 = save_game_v16;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct save_game_v16 {
    pub gameTime: UDWORD,
    pub GameType: UDWORD,
    pub ScrollMinX: SDWORD,
    pub ScrollMinY: SDWORD,
    pub ScrollMaxX: UDWORD,
    pub ScrollMaxY: UDWORD,
    pub levelName: [STRING; 20],
    pub power: [SAVE_POWER; 8],
    pub currentPlayerPos: iView,
    pub missionTime: UDWORD,
    pub saveKey: UDWORD,
    pub missionOffTime: SDWORD,
    pub missionETA: SDWORD,
    pub missionHomeLZ_X: UWORD,
    pub missionHomeLZ_Y: UWORD,
    pub missionPlayerX: SDWORD,
    pub missionPlayerY: SDWORD,
    pub iTranspEntryTileX: [UWORD; 8],
    pub iTranspEntryTileY: [UWORD; 8],
    pub iTranspExitTileX: [UWORD; 8],
    pub iTranspExitTileY: [UWORD; 8],
    pub aDefaultSensor: [UDWORD; 8],
    pub aDefaultECM: [UDWORD; 8],
    pub aDefaultRepair: [UDWORD; 8],
    pub offWorldKeepLists: BOOL,
    pub aDroidExperience: [[UBYTE; 32]; 8],
    pub RubbleTile: UDWORD,
    pub WaterTile: UDWORD,
    pub fogColour: UDWORD,
    pub fogState: UDWORD,
    pub sLandingZone: [LANDING_ZONE; 9],
}
pub type SAVE_GAME_V15 = save_game_v15;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct save_game_v15 {
    pub gameTime: UDWORD,
    pub GameType: UDWORD,
    pub ScrollMinX: SDWORD,
    pub ScrollMinY: SDWORD,
    pub ScrollMaxX: UDWORD,
    pub ScrollMaxY: UDWORD,
    pub levelName: [STRING; 20],
    pub power: [SAVE_POWER; 8],
    pub currentPlayerPos: iView,
    pub missionTime: UDWORD,
    pub saveKey: UDWORD,
    pub missionOffTime: SDWORD,
    pub missionETA: SDWORD,
    pub missionHomeLZ_X: UWORD,
    pub missionHomeLZ_Y: UWORD,
    pub missionPlayerX: SDWORD,
    pub missionPlayerY: SDWORD,
    pub iTranspEntryTileX: [UWORD; 8],
    pub iTranspEntryTileY: [UWORD; 8],
    pub iTranspExitTileX: [UWORD; 8],
    pub iTranspExitTileY: [UWORD; 8],
    pub aDefaultSensor: [UDWORD; 8],
    pub aDefaultECM: [UDWORD; 8],
    pub aDefaultRepair: [UDWORD; 8],
    pub offWorldKeepLists: BOOL,
    pub aDroidExperience: [[UBYTE; 32]; 8],
    pub RubbleTile: UDWORD,
    pub WaterTile: UDWORD,
    pub fogColour: UDWORD,
    pub fogState: UDWORD,
}
pub type SAVE_GAME_V14 = save_game_v14;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct save_game_v14 {
    pub gameTime: UDWORD,
    pub GameType: UDWORD,
    pub ScrollMinX: SDWORD,
    pub ScrollMinY: SDWORD,
    pub ScrollMaxX: UDWORD,
    pub ScrollMaxY: UDWORD,
    pub levelName: [STRING; 20],
    pub power: [SAVE_POWER; 8],
    pub currentPlayerPos: iView,
    pub missionTime: UDWORD,
    pub saveKey: UDWORD,
    pub missionOffTime: SDWORD,
    pub missionETA: SDWORD,
    pub missionHomeLZ_X: UWORD,
    pub missionHomeLZ_Y: UWORD,
    pub missionPlayerX: SDWORD,
    pub missionPlayerY: SDWORD,
    pub iTranspEntryTileX: [UWORD; 8],
    pub iTranspEntryTileY: [UWORD; 8],
    pub iTranspExitTileX: [UWORD; 8],
    pub iTranspExitTileY: [UWORD; 8],
    pub aDefaultSensor: [UDWORD; 8],
    pub aDefaultECM: [UDWORD; 8],
    pub aDefaultRepair: [UDWORD; 8],
}
pub type SAVE_GAME_V12 = save_game_v12;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct save_game_v12 {
    pub gameTime: UDWORD,
    pub GameType: UDWORD,
    pub ScrollMinX: SDWORD,
    pub ScrollMinY: SDWORD,
    pub ScrollMaxX: UDWORD,
    pub ScrollMaxY: UDWORD,
    pub levelName: [STRING; 20],
    pub power: [SAVE_POWER; 8],
    pub currentPlayerPos: iView,
    pub missionTime: UDWORD,
    pub saveKey: UDWORD,
}
pub type SAVE_GAME_V11 = save_game_v11;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct save_game_v11 {
    pub gameTime: UDWORD,
    pub GameType: UDWORD,
    pub ScrollMinX: SDWORD,
    pub ScrollMinY: SDWORD,
    pub ScrollMaxX: UDWORD,
    pub ScrollMaxY: UDWORD,
    pub levelName: [STRING; 20],
    pub power: [SAVE_POWER; 8],
    pub currentPlayerPos: iView,
}
pub type SAVE_GAME_V10 = save_game_v10;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct save_game_v10 {
    pub gameTime: UDWORD,
    pub GameType: UDWORD,
    pub ScrollMinX: SDWORD,
    pub ScrollMinY: SDWORD,
    pub ScrollMaxX: UDWORD,
    pub ScrollMaxY: UDWORD,
    pub levelName: [STRING; 20],
    pub power: [SAVE_POWER; 8],
}
// off map mission (extra map data)
pub const LDS_EXPAND_LIMBO: _level_type = 8;
// the WRF/WDG files needed for a particular level
// the WRF/WDG files needed for a particular level
pub type LEVEL_DATASET = _level_dataset;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _level_dataset {
    pub type_0: SWORD,
    pub players: SWORD,
    pub game: SWORD,
    pub pName: *mut STRING,
    pub dataDir: libc::c_int,
    pub apDataFiles: [*mut STRING; 9],
    pub psBaseData: *mut _level_dataset,
    pub psChange: *mut _level_dataset,
    pub psNext: *mut _level_dataset,
}
// type of map
// number of players for the map
// index of WRF/WDG that loads the scenario file
// title for the level
// title for the level
// the WRF/WDG files for the level
// in load order
// LEVEL_DATASET that must be loaded for this level to load
// LEVEL_DATASET used when changing to this level from another
// extra data for expanding a campaign map
pub const LDS_BETWEEN: _level_type = 5;
// the data set for a campaign (no map data)
pub const LDS_CAMSTART: _level_type = 2;
/* Type of game , one of the GTYPE_... enums. */
/* Scroll Limits */
//name of the level to load up when mid game
pub type SAVE_GAME_V7 = save_game_v7;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct save_game_v7 {
    pub gameTime: UDWORD,
    pub GameType: UDWORD,
    pub ScrollMinX: SDWORD,
    pub ScrollMinY: SDWORD,
    pub ScrollMaxX: UDWORD,
    pub ScrollMaxY: UDWORD,
    pub levelName: [STRING; 20],
}
pub type MESSAGE_SAVEHEADER = _message_save_header;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _message_save_header {
    pub aFileType: [STRING; 4],
    pub version: UDWORD,
    pub quantity: UDWORD,
}
pub type VIEWDATA = _viewdata;
pub type SAVE_MESSAGE = _save_message;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _save_message {
    pub type_0: MESSAGE_TYPE,
    pub bObj: BOOL,
    pub name: [CHAR; 20],
    pub objId: UDWORD,
    pub read: BOOL,
    pub player: UDWORD,
}
//name ID of the message - used for loading in and identifying
//the type of view
//the number of textmessages associated with this data
//Pointer to text messages - if any
/*the data required to view - either a
							  VIEW_RESEARCH, VIEW_PROXIMITY or VIEW_REPLAY*/
//The type of message
//Id for Proximity messages!
//flag to indicate whether message has been read
//which player this message belongs to
// info required to view a proximity message
pub type VIEW_PROXIMITY = _view_proximity;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _view_proximity {
    pub x: UDWORD,
    pub y: UDWORD,
    pub z: UDWORD,
    pub proxType: PROX_TYPE,
    pub audioID: SDWORD,
}
pub type PROX_TYPE = _prox_type;
pub type _prox_type = libc::c_uint;
pub const PROX_TYPES: _prox_type = 3;
pub const PROX_ARTEFACT: _prox_type = 2;
pub const PROX_RESOURCE: _prox_type = 1;
pub const PROX_ENEMY: _prox_type = 0;
//world coords for position of Proximity message
/*ID of the audio track to play - if any */
// mapdata for the start of a campaign
pub const LDS_CAMCHANGE: _level_type = 3;
/* The different types of droid */
pub type DROID_SAVE_TYPE = _droid_save_type;
pub type _droid_save_type = libc::c_uint;
pub const DROID_NORMAL: _droid_save_type = 0;
pub const GT_COMMAND: _group_type = 1;
pub type _group_type = libc::c_uint;
pub const GT_TRANSPORTER: _group_type = 2;
pub const GT_NORMAL: _group_type = 0;
pub type C2RustUnnamed_1 = libc::c_int;
pub const ID_MAX_SOUND: C2RustUnnamed_1 = 354;
pub const ID_SOUND_LAS_SAT_COUNTDOWN: C2RustUnnamed_1 = 353;
pub const ID_SOUND_UPLINK: C2RustUnnamed_1 = 352;
pub const ID_SOUND_PLASMA_FLAMER: C2RustUnnamed_1 = 351;
pub const ID_SOUND_LASER_HEAVY: C2RustUnnamed_1 = 350;
pub const ID_SOUND_EMP: C2RustUnnamed_1 = 349;
pub const ID_SOUND_CYBORG_HEAVY: C2RustUnnamed_1 = 348;
pub const ID_SOUND_CYBORG_GROUND: C2RustUnnamed_1 = 347;
pub const ID_SOUND_NEXUS_UNIT_NEUTRALISED: C2RustUnnamed_1 = 346;
pub const ID_SOUND_NEXUS_UNIT_ABSORBED: C2RustUnnamed_1 = 345;
pub const ID_SOUND_NEXUS_SYNAPTIC_LINK: C2RustUnnamed_1 = 344;
pub const ID_SOUND_NEXUS_STRUCTURE_NEUTRALISED: C2RustUnnamed_1 = 343;
pub const ID_SOUND_NEXUS_STRUCTURE_ABSORBED: C2RustUnnamed_1 = 342;
pub const ID_SOUND_NEXUS_RESEARCH_ABSORBED: C2RustUnnamed_1 = 341;
pub const ID_SOUND_NEXUS_PRODUCTION_COMPLETED: C2RustUnnamed_1 = 340;
pub const ID_SOUND_NEXUS_LAUGH3: C2RustUnnamed_1 = 339;
pub const ID_SOUND_NEXUS_LAUGH2: C2RustUnnamed_1 = 338;
pub const ID_SOUND_NEXUS_LAUGH1: C2RustUnnamed_1 = 337;
pub const ID_SOUND_NEXUS_DEFENCES_NEUTRALISED: C2RustUnnamed_1 = 336;
pub const ID_SOUND_NEXUS_DEFENCES_ABSORBED: C2RustUnnamed_1 = 335;
pub const ID_SOUND_INCOMING_LASER_SAT_STRIKE: C2RustUnnamed_1 = 334;
pub const ID_SOUND_LASER_SATELLITE_FIRING: C2RustUnnamed_1 = 333;
pub const ID_SOUND_TEAM_GAMMA_RESCUED: C2RustUnnamed_1 = 332;
pub const ID_SOUND_TEAM_BETA_RESCUED: C2RustUnnamed_1 = 331;
pub const ID_SOUND_TEAM_ALPHA_RESCUED: C2RustUnnamed_1 = 330;
pub const ID_SOUND_TEAM_GAMMA_ERADICATED: C2RustUnnamed_1 = 329;
pub const ID_SOUND_TEAM_BETA_ERADICATED: C2RustUnnamed_1 = 328;
pub const ID_SOUND_TEAM_ALPHA_ERADICATED: C2RustUnnamed_1 = 327;
pub const ID_SOUND_ENEMY_TRANSPORT_LANDING: C2RustUnnamed_1 = 326;
pub const ID_SOUND_ENEMY_ESCAPING: C2RustUnnamed_1 = 325;
pub const ID_SOUND_ENEMY_ESCAPED: C2RustUnnamed_1 = 324;
pub const ID_SOUND_OUT_OF_TIME: C2RustUnnamed_1 = 323;
pub const ID_SOUND_GROUP_INFECTED: C2RustUnnamed_1 = 322;
pub const ID_SOUND_STRUCTURE_INFECTED: C2RustUnnamed_1 = 321;
pub const ID_SOUND_OBJECTIVE_DESTROYED: C2RustUnnamed_1 = 320;
pub const ID_SOUND_OBJECTIVE_CAPTURED: C2RustUnnamed_1 = 319;
pub const ID_SOUND_GROUP_CAPTURED: C2RustUnnamed_1 = 318;
pub const ID_SOUND_GROUP_RESCUED: C2RustUnnamed_1 = 317;
pub const ID_SOUND_UNITS_RESCUED: C2RustUnnamed_1 = 316;
pub const ID_SOUND_CIVILIANS_RESCUED: C2RustUnnamed_1 = 315;
pub const ID_SOUND_CIVILIAN_RESCUED: C2RustUnnamed_1 = 314;
pub const ID_SOUND_STRUCTURE_CAPTURED: C2RustUnnamed_1 = 313;
pub const ID_SOUND_MISSILE_NME_DETECTED: C2RustUnnamed_1 = 312;
pub const ID_SOUND_MISSILE_SILO: C2RustUnnamed_1 = 311;
pub const ID_SOUND_SAM_SITE: C2RustUnnamed_1 = 310;
pub const ID_SOUND_NUCLEAR_REACTOR: C2RustUnnamed_1 = 309;
pub const ID_SOUND_NASDA_CENTRAL: C2RustUnnamed_1 = 308;
pub const ID_SOUND_SATELLITE_UPLINK: C2RustUnnamed_1 = 307;
pub const ID_SOUND_LANDING_ZONE: C2RustUnnamed_1 = 306;
pub const ID_SOUND_NOFAULTS: C2RustUnnamed_1 = 305;
pub const ID_SOUND_OF_SILENCE: C2RustUnnamed_1 = 304;
pub const ID_SOUND_BARB_SCREAM3: C2RustUnnamed_1 = 303;
pub const ID_SOUND_BARB_SCREAM2: C2RustUnnamed_1 = 302;
pub const ID_SOUND_BARB_SCREAM: C2RustUnnamed_1 = 301;
pub const ID_SOUND_HELP: C2RustUnnamed_1 = 300;
pub const ID_SOUND_FIRE_ROAR: C2RustUnnamed_1 = 299;
pub const ID_SOUND_ECM_TOWER: C2RustUnnamed_1 = 298;
pub const ID_SOUND_STEAM: C2RustUnnamed_1 = 297;
pub const ID_SOUND_POWER_SPARK: C2RustUnnamed_1 = 296;
pub const ID_SOUND_OIL_PUMP_2: C2RustUnnamed_1 = 294;
pub const ID_SOUND_CYBORG_MOVE: C2RustUnnamed_1 = 293;
pub const ID_SOUND_HOVER_STOP: C2RustUnnamed_1 = 292;
pub const ID_SOUND_HOVER_START: C2RustUnnamed_1 = 291;
pub const ID_SOUND_HOVER_MOVE: C2RustUnnamed_1 = 290;
pub const ID_SOUND_TREAD: C2RustUnnamed_1 = 289;
pub const ID_SOUND_VTOL_MOVE: C2RustUnnamed_1 = 288;
pub const ID_SOUND_VTOL_OFF: C2RustUnnamed_1 = 287;
pub const ID_SOUND_VTOL_LAND: C2RustUnnamed_1 = 286;
pub const ID_SOUND_BLIMP_TAKE_OFF: C2RustUnnamed_1 = 285;
pub const ID_SOUND_BLIMP_LAND: C2RustUnnamed_1 = 284;
pub const ID_SOUND_BLIMP_IDLE: C2RustUnnamed_1 = 283;
pub const ID_SOUND_BLIMP_FLIGHT: C2RustUnnamed_1 = 282;
pub const ID_SOUND_CONSTRUCTOR_SHUTDOWN: C2RustUnnamed_1 = 281;
pub const ID_SOUND_CONSTRUCTOR_MOVE: C2RustUnnamed_1 = 280;
pub const ID_SOUND_CONSTRUCTOR_MOVEOFF: C2RustUnnamed_1 = 279;
pub const ID_SOUND_NEXUS_EXPLOSION: C2RustUnnamed_1 = 278;
pub const ID_SOUND_BUILDING_FALL: C2RustUnnamed_1 = 277;
pub const ID_SOUND_BARB_SQUISH: C2RustUnnamed_1 = 276;
pub const ID_SOUND_RICOCHET_3: C2RustUnnamed_1 = 275;
pub const ID_SOUND_RICOCHET_2: C2RustUnnamed_1 = 274;
pub const ID_SOUND_RICOCHET_1: C2RustUnnamed_1 = 273;
pub const ID_SOUND_EXPLOSION_ANTITANK: C2RustUnnamed_1 = 272;
pub const ID_SOUND_EXPLOSION: C2RustUnnamed_1 = 271;
pub const ID_SOUND_EXPLOSION_LASER: C2RustUnnamed_1 = 270;
pub const ID_SOUND_EXPLOSION_SMALL: C2RustUnnamed_1 = 269;
pub const ID_SOUND_CONSTRUCTION_4: C2RustUnnamed_1 = 268;
pub const ID_SOUND_CONSTRUCTION_3: C2RustUnnamed_1 = 267;
pub const ID_SOUND_CONSTRUCTION_2: C2RustUnnamed_1 = 266;
pub const ID_SOUND_CONSTRUCTION_1: C2RustUnnamed_1 = 265;
pub const ID_SOUND_CONSTRUCTION_LOOP: C2RustUnnamed_1 = 264;
pub const ID_SOUND_CONSTRUCTION_START: C2RustUnnamed_1 = 263;
pub const ID_SOUND_WELD_2: C2RustUnnamed_1 = 262;
pub const ID_SOUND_WELD_1: C2RustUnnamed_1 = 261;
pub const ID_SOUND_NEXUS_TOWER: C2RustUnnamed_1 = 260;
pub const ID_SOUND_HIVEL_CANNON: C2RustUnnamed_1 = 259;
pub const ID_SOUND_RAPID_CANNON: C2RustUnnamed_1 = 258;
pub const ID_SOUND_ASSAULT_MG: C2RustUnnamed_1 = 257;
pub const ID_SOUND_SPLASH: C2RustUnnamed_1 = 256;
pub const ID_SOUND_BABA_MG_TOWER: C2RustUnnamed_1 = 255;
pub const ID_SOUND_BABA_MG_HEAVY: C2RustUnnamed_1 = 254;
pub const ID_SOUND_BABA_MG_3: C2RustUnnamed_1 = 253;
pub const ID_SOUND_BABA_MG_2: C2RustUnnamed_1 = 252;
pub const ID_SOUND_BABA_MG_1: C2RustUnnamed_1 = 251;
pub const ID_SOUND_HOWITZ_FLIGHT: C2RustUnnamed_1 = 250;
pub const ID_SOUND_MORTAR: C2RustUnnamed_1 = 249;
pub const ID_SOUND_BEAM_LASER: C2RustUnnamed_1 = 248;
pub const ID_SOUND_PULSE_LASER: C2RustUnnamed_1 = 247;
pub const ID_SOUND_FLAME_THROWER: C2RustUnnamed_1 = 246;
pub const ID_SOUND_MEDIUM_CANNON: C2RustUnnamed_1 = 245;
pub const ID_SOUND_SMALL_CANNON: C2RustUnnamed_1 = 244;
pub const ID_SOUND_LARGE_CANNON: C2RustUnnamed_1 = 243;
pub const ID_SOUND_GAUSSGUN: C2RustUnnamed_1 = 242;
pub const ID_SOUND_ROTARY_LASER: C2RustUnnamed_1 = 241;
pub const ID_SOUND_ROCKET: C2RustUnnamed_1 = 240;
pub const ID_SOUND_COLL_ENEMY_DESTROYED: C2RustUnnamed_1 = 239;
pub const ID_SOUND_COLL_INTERCEPT_AND_DESTROY: C2RustUnnamed_1 = 238;
pub const ID_SOUND_COLL_DIE: C2RustUnnamed_1 = 237;
pub const ID_SOUND_COLL_STARTING_ATTACK_RUN: C2RustUnnamed_1 = 236;
pub const ID_SOUND_COLL_ENGAGING: C2RustUnnamed_1 = 235;
pub const ID_SOUND_COLL_ENEMY_DETECTED: C2RustUnnamed_1 = 234;
pub const ID_SOUND_COLL_FIRE: C2RustUnnamed_1 = 233;
pub const ID_SOUND_COLL_ATTACK: C2RustUnnamed_1 = 232;
pub const ID_SOUND_COLL_DESTROYING_BIOLOGICALS: C2RustUnnamed_1 = 231;
pub const ID_SOUND_COLL_CLEANSE_AND_DESTROY: C2RustUnnamed_1 = 230;
pub const ID_SOUND_ABORTING_ATTACK_RUN3: C2RustUnnamed_1 = 229;
pub const ID_SOUND_COMMENCING_ATTACK_RUN3: C2RustUnnamed_1 = 228;
pub const ID_SOUND_LOCKED_ON3: C2RustUnnamed_1 = 227;
pub const ID_SOUND_RETURNING_TO_BASE3: C2RustUnnamed_1 = 226;
pub const ID_SOUND_ON_OUR_WAY3: C2RustUnnamed_1 = 225;
pub const ID_SOUND_ENEMY_LOCATED3: C2RustUnnamed_1 = 224;
pub const ID_SOUND_ABORTING_ATTACK_RUN2: C2RustUnnamed_1 = 223;
pub const ID_SOUND_COMMENCING_ATTACK_RUN2: C2RustUnnamed_1 = 222;
pub const ID_SOUND_LOCKED_ON2: C2RustUnnamed_1 = 221;
pub const ID_SOUND_RETURNING_TO_BASE2: C2RustUnnamed_1 = 220;
pub const ID_SOUND_ON_OUR_WAY2: C2RustUnnamed_1 = 219;
pub const ID_SOUND_ENEMY_LOCATED2: C2RustUnnamed_1 = 218;
pub const ID_SOUND_ABORTING_ATTACK_RUN1: C2RustUnnamed_1 = 217;
pub const ID_SOUND_COMMENCING_ATTACK_RUN1: C2RustUnnamed_1 = 216;
pub const ID_SOUND_LOCKED_ON1: C2RustUnnamed_1 = 215;
pub const ID_SOUND_RETURNING_TO_BASE1: C2RustUnnamed_1 = 214;
pub const ID_SOUND_ON_OUR_WAY1: C2RustUnnamed_1 = 213;
pub const ID_SOUND_ENEMY_LOCATED1: C2RustUnnamed_1 = 212;
pub const ID_SOUND_PREPARE_FOR_DUST_OFF: C2RustUnnamed_1 = 211;
pub const ID_SOUND_GO_GO_GO: C2RustUnnamed_1 = 210;
pub const ID_SOUND_GREEN_LIGHT_IN_2: C2RustUnnamed_1 = 209;
pub const ID_SOUND_GREEN_LIGHT_IN_3: C2RustUnnamed_1 = 208;
pub const ID_SOUND_GREEN_LIGHT_IN_4: C2RustUnnamed_1 = 207;
pub const ID_SOUND_GREEN_LIGHT_IN_5: C2RustUnnamed_1 = 206;
pub const ID_SOUND_ALRIGHT_BOYS: C2RustUnnamed_1 = 205;
pub const ID_SOUND_APPROACHING_LZ: C2RustUnnamed_1 = 204;
pub const ID_SOUND_RADIOCLICK_6: C2RustUnnamed_1 = 203;
pub const ID_SOUND_RADIOCLICK_5: C2RustUnnamed_1 = 202;
pub const ID_SOUND_RADIOCLICK_4: C2RustUnnamed_1 = 201;
pub const ID_SOUND_RADIOCLICK_3: C2RustUnnamed_1 = 200;
pub const ID_SOUND_RADIOCLICK_2: C2RustUnnamed_1 = 199;
pub const ID_SOUND_RADIOCLICK_1: C2RustUnnamed_1 = 198;
pub const ID_SOUND_COM_HEADING_FOR_RALLY_POINT: C2RustUnnamed_1 = 197;
pub const ID_SOUND_COM_RETURNING_FOR_REPAIR: C2RustUnnamed_1 = 196;
pub const ID_SOUND_COM_UNABLE_TO_COMPLY: C2RustUnnamed_1 = 195;
pub const ID_SOUND_COM_NO_ROUTE_AVAILABLE: C2RustUnnamed_1 = 194;
pub const ID_SOUND_COM_ROUTE_OBSTRUCTED: C2RustUnnamed_1 = 193;
pub const ID_SOUND_COM_ENEMY_VTOLS_DETECTED: C2RustUnnamed_1 = 192;
pub const ID_SOUND_COM_ENEMY_BATTERY_DETECTED: C2RustUnnamed_1 = 191;
pub const ID_SOUND_COM_NEXUS_DETECTED: C2RustUnnamed_1 = 190;
pub const ID_SOUND_COM_NEXUS_TURRET_DETECTED: C2RustUnnamed_1 = 189;
pub const ID_SOUND_COM_NEXUS_TOWER_DETECTED: C2RustUnnamed_1 = 188;
pub const ID_SOUND_COM_FRIENDLY_LZ_DETECTED: C2RustUnnamed_1 = 187;
pub const ID_SOUND_COM_ENEMY_LZ_DETECTED: C2RustUnnamed_1 = 186;
pub const ID_SOUND_COM_ENEMY_TRANSPORT_DETECTED: C2RustUnnamed_1 = 185;
pub const ID_SOUND_COM_ALLY_DETECTED: C2RustUnnamed_1 = 184;
pub const ID_SOUND_COM_ENEMY_BASE_DETECTED: C2RustUnnamed_1 = 183;
pub const ID_SOUND_COM_ENEMY_DETECTED: C2RustUnnamed_1 = 182;
pub const ID_SOUND_COM_ARTEFACT_DETECTED: C2RustUnnamed_1 = 181;
pub const ID_SOUND_COM_RESOURCE_DETECTED: C2RustUnnamed_1 = 180;
pub const ID_SOUND_COM_SCAV_OUTPOST_DETECTED: C2RustUnnamed_1 = 179;
pub const ID_SOUND_COM_SCAV_BASE_DETECTED: C2RustUnnamed_1 = 178;
pub const ID_SOUND_COM_SCAVS_DETECTED: C2RustUnnamed_1 = 177;
pub const ID_SOUND_COMMANDER: C2RustUnnamed_1 = 176;
pub const ID_SOUND_REPORTING: C2RustUnnamed_1 = 175;
pub const ID_SOUND_GROUP_9: C2RustUnnamed_1 = 174;
pub const ID_SOUND_GROUP_8: C2RustUnnamed_1 = 173;
pub const ID_SOUND_GROUP_7: C2RustUnnamed_1 = 172;
pub const ID_SOUND_GROUP_6: C2RustUnnamed_1 = 171;
pub const ID_SOUND_GROUP_5: C2RustUnnamed_1 = 170;
pub const ID_SOUND_GROUP_4: C2RustUnnamed_1 = 169;
pub const ID_SOUND_GROUP_3: C2RustUnnamed_1 = 168;
pub const ID_SOUND_GROUP_2: C2RustUnnamed_1 = 167;
pub const ID_SOUND_GROUP_1: C2RustUnnamed_1 = 166;
pub const ID_SOUND_GROUP_0: C2RustUnnamed_1 = 165;
pub const ID_SOUND_GROUP: C2RustUnnamed_1 = 164;
pub const ID_UNITS_TRANSFER: C2RustUnnamed_1 = 163;
pub const ID_TECHNOLOGY_TRANSFER: C2RustUnnamed_1 = 162;
pub const ID_SENSOR_DOWNLOAD: C2RustUnnamed_1 = 161;
pub const ID_POWER_TRANSMIT: C2RustUnnamed_1 = 160;
pub const ID_GIFT: C2RustUnnamed_1 = 159;
pub const ID_CLAN_EXIT: C2RustUnnamed_1 = 158;
pub const ID_CLAN_ENTER: C2RustUnnamed_1 = 157;
pub const ID_ALLIANCE_OFF: C2RustUnnamed_1 = 156;
pub const ID_ALLIANCE_BRO: C2RustUnnamed_1 = 155;
pub const ID_ALLIANCE_ACC: C2RustUnnamed_1 = 154;
pub const ID_SOUND_ENTERING_WARZONE: C2RustUnnamed_1 = 153;
pub const ID_SOUND_MISSILE_CODES_CRACKED: C2RustUnnamed_1 = 152;
pub const ID_SOUND_3RD_MISSILE_CODES_DECIPHERED: C2RustUnnamed_1 = 151;
pub const ID_SOUND_2ND_MISSILE_CODES_DECIPHERED: C2RustUnnamed_1 = 150;
pub const ID_SOUND_1ST_MISSILE_CODES_DECIPHERED: C2RustUnnamed_1 = 149;
pub const ID_SOUND_MISSILE_CODES_DECIPHERED: C2RustUnnamed_1 = 148;
pub const ID_SOUND_YOU_ARE_DEFEATED: C2RustUnnamed_1 = 147;
pub const ID_SOUND_SYSTEM_FAILURE_IMMINENT: C2RustUnnamed_1 = 146;
pub const ID_SOUND_UNIT_CAPTURED: C2RustUnnamed_1 = 145;
pub const ID_SOUND_1_MINUTE_REMAINING: C2RustUnnamed_1 = 144;
pub const ID_SOUND_2_MINUTES_REMAINING: C2RustUnnamed_1 = 143;
pub const ID_SOUND_3_MINUTES_REMAINING: C2RustUnnamed_1 = 142;
pub const ID_SOUND_5_MINUTES_REMAINING: C2RustUnnamed_1 = 141;
pub const ID_SOUND_10_MINUTES_REMAINING: C2RustUnnamed_1 = 140;
pub const ID_SOUND_MISSION_TIMER_ACTIVATED: C2RustUnnamed_1 = 139;
pub const ID_SOUND_OBJECTIVE_FAILED: C2RustUnnamed_1 = 138;
pub const ID_SOUND_OBJECTIVE_ACCOMPLISHED: C2RustUnnamed_1 = 137;
pub const ID_SOUND_MISSION_SUCCESSFUL: C2RustUnnamed_1 = 136;
pub const ID_SOUND_MISSION_FAILED: C2RustUnnamed_1 = 135;
pub const ID_SOUND_INCOMING_INTELLIGENCE_REPORT: C2RustUnnamed_1 = 134;
pub const ID_SOUND_INCOMING_TRANSMISSION: C2RustUnnamed_1 = 133;
pub const ID_SOUND_TECHNOLOGY_TAKEN: C2RustUnnamed_1 = 132;
pub const ID_SOUND_RESEARCH_STOLEN: C2RustUnnamed_1 = 131;
pub const ID_SOUND_MISSION_RESULTS: C2RustUnnamed_1 = 130;
pub const ID_SOUND_WARZONE_ACTIVE: C2RustUnnamed_1 = 129;
pub const ID_SOUND_WARZONE_PAUSED: C2RustUnnamed_1 = 128;
pub const ID_SOUND_MISSION_UPDATE: C2RustUnnamed_1 = 127;
pub const ID_SOUND_MISSION_OBJECTIVE: C2RustUnnamed_1 = 126;
pub const ID_SOUND_TRANSPORT_UNABLE_TO_LAND: C2RustUnnamed_1 = 125;
pub const ID_SOUND_TRANSPORT_RETURNING_TO_BASE: C2RustUnnamed_1 = 124;
pub const ID_SOUND_LZ_CLEAR: C2RustUnnamed_1 = 123;
pub const ID_SOUND_LZ_COMPROMISED: C2RustUnnamed_1 = 122;
pub const ID_SOUND_TRANSPORT_REPAIRING: C2RustUnnamed_1 = 121;
pub const ID_SOUND_TRANSPORT_UNDER_ATTACK: C2RustUnnamed_1 = 120;
pub const ID_SOUND_TRANSPORT_LANDING: C2RustUnnamed_1 = 119;
pub const ID_SOUND_REINFORCEMENTS_IN_TRANSIT: C2RustUnnamed_1 = 118;
pub const ID_SOUND_REINFORCEMENTS_AVAILABLE: C2RustUnnamed_1 = 117;
pub const ID_SOUND_NO_ROUTE_AVAILABLE: C2RustUnnamed_1 = 116;
pub const ID_SOUND_ROUTE_OBSTRUCTED: C2RustUnnamed_1 = 115;
pub const ID_SOUND_COMMANDER_REPORTING: C2RustUnnamed_1 = 114;
pub const ID_SOUND_GROUP_REPORTING: C2RustUnnamed_1 = 113;
pub const ID_SOUND_ASSIGNED_TO_COMMANDER: C2RustUnnamed_1 = 112;
pub const ID_SOUND_EXCELLENT: C2RustUnnamed_1 = 111;
pub const ID_SOUND_WELL_DONE: C2RustUnnamed_1 = 110;
pub const ID_SOUND_THAT_IS_INCORRECT: C2RustUnnamed_1 = 109;
pub const ID_SOUND_NO: C2RustUnnamed_1 = 108;
pub const ID_SOUND_NOT_POSSIBLE_TRY_AGAIN: C2RustUnnamed_1 = 107;
pub const ID_SOUND_SCATTER: C2RustUnnamed_1 = 106;
pub const ID_SOUND_RECYCLING: C2RustUnnamed_1 = 105;
pub const ID_SOUND_RETURN_TO_LZ: C2RustUnnamed_1 = 104;
pub const ID_SOUND_PATROL: C2RustUnnamed_1 = 103;
pub const ID_SOUND_PURSUE: C2RustUnnamed_1 = 102;
pub const ID_SOUND_GUARD: C2RustUnnamed_1 = 101;
pub const ID_SOUND_HOLD_POSITION: C2RustUnnamed_1 = 100;
pub const ID_SOUND_CEASEFIRE: C2RustUnnamed_1 = 99;
pub const ID_SOUND_RETURN_FIRE: C2RustUnnamed_1 = 98;
pub const ID_SOUND_FIRE_AT_WILL: C2RustUnnamed_1 = 97;
pub const ID_SOUND_NO_RETREAT: C2RustUnnamed_1 = 96;
pub const ID_SOUND_RETREAT_AT_HEAVY_DAMAGE: C2RustUnnamed_1 = 95;
pub const ID_SOUND_RETREAT_AT_MEDIUM_DAMAGE: C2RustUnnamed_1 = 94;
pub const ID_SOUND_OPTIMUM_RANGE: C2RustUnnamed_1 = 93;
pub const ID_SOUND_LONG_RANGE: C2RustUnnamed_1 = 92;
pub const ID_SOUND_SHORT_RANGE: C2RustUnnamed_1 = 91;
pub const ID_SOUND_COMMAND_CONSOLE_ACTIVATED: C2RustUnnamed_1 = 90;
pub const ID_SOUND_INTERCEPTORS_ASSIGNED: C2RustUnnamed_1 = 89;
pub const ID_SOUND_ASSIGNED: C2RustUnnamed_1 = 88;
pub const ID_SOUND_VTOLS_ENGAGING: C2RustUnnamed_1 = 87;
pub const ID_SOUND_REARMING: C2RustUnnamed_1 = 86;
pub const ID_SOUND_INTERCEPTORS_LAUNCHED: C2RustUnnamed_1 = 85;
pub const ID_SOUND_BATTERY_FIRING_COUNTER_ATTACK: C2RustUnnamed_1 = 84;
pub const ID_SOUND_ENEMY_BATTERY_LOCATED: C2RustUnnamed_1 = 83;
pub const ID_SOUND_ASSIGNED_TO_COUNTER_RADAR: C2RustUnnamed_1 = 82;
pub const ID_SOUND_SENSOR_LOCKED_ON: C2RustUnnamed_1 = 81;
pub const ID_SOUND_ASSIGNED_TO_SENSOR: C2RustUnnamed_1 = 80;
pub const ID_SOUND_UNIT_RETURNING_FOR_REPAIR: C2RustUnnamed_1 = 79;
pub const ID_SOUND_UNIT_RETREATING: C2RustUnnamed_1 = 78;
pub const ID_SOUND_UNIT_DESTROYED: C2RustUnnamed_1 = 77;
pub const ID_SOUND_UNIT_UNDER_ATTACK: C2RustUnnamed_1 = 76;
pub const ID_SOUND_LZ2: C2RustUnnamed_1 = 75;
pub const ID_SOUND_LZ1: C2RustUnnamed_1 = 74;
pub const ID_SOUND_ENEMY_LZ: C2RustUnnamed_1 = 73;
pub const ID_SOUND_INCOMING_ENEMY_TRANSPORT: C2RustUnnamed_1 = 72;
pub const ID_SOUND_ENEMY_BASE_ERADICATED: C2RustUnnamed_1 = 71;
pub const ID_SOUND_ENEMY_BASE: C2RustUnnamed_1 = 70;
pub const ID_SOUND_SCAVENGER_BASE_ERADICATED: C2RustUnnamed_1 = 69;
pub const ID_SOUND_SCAVENGER_OUTPOST_ERADICATED: C2RustUnnamed_1 = 68;
pub const ID_SOUND_SCAVENGER_OUTPOST: C2RustUnnamed_1 = 67;
pub const ID_SOUND_SCAVENGER_BASE: C2RustUnnamed_1 = 66;
pub const ID_SOUND_ENEMY_VTOLS_DETECTED: C2RustUnnamed_1 = 65;
pub const ID_SOUND_ENEMY_BATTERY_DETECTED: C2RustUnnamed_1 = 64;
pub const ID_SOUND_NEXUS_UNIT_DETECTED: C2RustUnnamed_1 = 63;
pub const ID_SOUND_NEXUS_TURRET_DETECTED: C2RustUnnamed_1 = 62;
pub const ID_SOUND_NEXUS_TOWER_DETECTED: C2RustUnnamed_1 = 61;
pub const ID_SOUND_FRIENDLY_LZ_DETECTED: C2RustUnnamed_1 = 60;
pub const ID_SOUND_ENEMY_LZ_DETECTED: C2RustUnnamed_1 = 59;
pub const ID_SOUND_ENEMY_TRANSPORT_DETECTED: C2RustUnnamed_1 = 58;
pub const ID_SOUND_ALLY_DETECTED: C2RustUnnamed_1 = 57;
pub const ID_SOUND_ENEMY_BASE_DETECTED: C2RustUnnamed_1 = 56;
pub const ID_SOUND_ENEMY_UNIT_DETECTED: C2RustUnnamed_1 = 55;
pub const ID_SOUND_ARTEFACT_DISC: C2RustUnnamed_1 = 54;
pub const ID_SOUND_POWER_RESOURCE: C2RustUnnamed_1 = 53;
pub const ID_SOUND_SCAVENGER_OUTPOST_DETECTED: C2RustUnnamed_1 = 52;
pub const ID_SOUND_SCAVENGER_BASE_DETECTED: C2RustUnnamed_1 = 51;
pub const ID_SOUND_SCAVENGERS_DETECTED: C2RustUnnamed_1 = 50;
pub const ID_SOUND_UNIT_REPAIRED: C2RustUnnamed_1 = 49;
pub const ID_SOUND_DELIVERY_POINT_ASSIGNED_TO: C2RustUnnamed_1 = 48;
pub const ID_SOUND_DELIVERY_POINT_ASSIGNED: C2RustUnnamed_1 = 47;
pub const ID_SOUND_PRODUCTION_CANCELLED: C2RustUnnamed_1 = 46;
pub const ID_SOUND_PRODUCTION_PAUSED: C2RustUnnamed_1 = 45;
pub const ID_SOUND_DROID_COMPLETED: C2RustUnnamed_1 = 44;
pub const ID_SOUND_PRODUCTION_STARTED: C2RustUnnamed_1 = 43;
pub const ID_SOUND_CYBORG_RESEARCH_COMPLETED: C2RustUnnamed_1 = 42;
pub const ID_SOUND_WEAPON_RESEARCH_COMPLETED: C2RustUnnamed_1 = 41;
pub const ID_SOUND_SYSTEMS_RESEARCH_COMPLETED: C2RustUnnamed_1 = 40;
pub const ID_SOUND_VEHICLE_RESEARCH_COMPLETED: C2RustUnnamed_1 = 39;
pub const ID_SOUND_COMPUTER_RESEARCH_COMPLETED: C2RustUnnamed_1 = 38;
pub const ID_SOUND_POWER_RESEARCH_COMPLETED: C2RustUnnamed_1 = 37;
pub const ID_SOUND_STRUCTURE_RESEARCH_COMPLETED: C2RustUnnamed_1 = 36;
pub const ID_SOUND_MAJOR_RESEARCH: C2RustUnnamed_1 = 35;
pub const ID_SOUND_RESEARCH_COMPLETED: C2RustUnnamed_1 = 34;
pub const ID_SOUND_NEW_CYBORG_AVAILABLE: C2RustUnnamed_1 = 33;
pub const ID_SOUND_NEW_COMPONENT_AVAILABLE: C2RustUnnamed_1 = 32;
pub const ID_SOUND_NEW_STRUCTURE_AVAILABLE: C2RustUnnamed_1 = 31;
pub const ID_SOUND_NEW_RESEARCH_PROJ_AVAILABLE: C2RustUnnamed_1 = 30;
pub const ID_SOUND_ARTIFACT_RECOVERED: C2RustUnnamed_1 = 29;
pub const ID_SOUND_ARTIFACT: C2RustUnnamed_1 = 28;
pub const ID_SOUND_RESEARCH_FACILITY_REQUIRED: C2RustUnnamed_1 = 27;
pub const ID_SOUND_POWER_GENERATOR_REQUIRED: C2RustUnnamed_1 = 26;
pub const ID_SOUND_POWER_TRANSFER_IN_PROGRESS: C2RustUnnamed_1 = 25;
pub const ID_SOUND_RESOURCE_DEPLETED: C2RustUnnamed_1 = 24;
pub const ID_SOUND_DERRICK_DESTROYED: C2RustUnnamed_1 = 23;
pub const ID_SOUND_DERRICK_UNDER_ATTACK: C2RustUnnamed_1 = 22;
pub const ID_SOUND_RESOURCE_HERE: C2RustUnnamed_1 = 21;
pub const ID_SOUND_POWER_LOW: C2RustUnnamed_1 = 20;
pub const ID_SOUND_POWER_GENERATOR_DESTROYED: C2RustUnnamed_1 = 19;
pub const ID_SOUND_POWER_GENERATOR_UNDER_ATTACK: C2RustUnnamed_1 = 18;
pub const ID_SOUND_STRUCTURE_DEMOLISHED: C2RustUnnamed_1 = 17;
pub const ID_SOUND_STRUCTURE_REPAIR_IN_PROGRESS: C2RustUnnamed_1 = 16;
pub const ID_SOUND_STRUCTURE_UNDER_ATTACK: C2RustUnnamed_1 = 15;
pub const ID_SOUND_STRUCTURE_COMPLETED: C2RustUnnamed_1 = 14;
pub const ID_SOUND_CONSTRUCTION_STARTED: C2RustUnnamed_1 = 13;
pub const ID_SOUND_DESIGN_COMPLETED: C2RustUnnamed_1 = 12;
pub const ID_SOUND_PROPULSION_SELECTED: C2RustUnnamed_1 = 11;
pub const ID_SOUND_BODY_SELECTED: C2RustUnnamed_1 = 10;
pub const ID_SOUND_TURRET_SELECTED: C2RustUnnamed_1 = 9;
pub const ID_SOUND_GAME_SHUTDOWN: C2RustUnnamed_1 = 8;
pub const ID_SOUND_MESSAGEEND: C2RustUnnamed_1 = 7;
pub const ID_SOUND_BUILD_FAIL: C2RustUnnamed_1 = 6;
pub const ID_SOUND_ZOOM_ON_RADAR: C2RustUnnamed_1 = 5;
pub const FE_AUDIO_MESSAGEEND: C2RustUnnamed_1 = 4;
pub const ID_SOUND_BUTTON_CLICK_5: C2RustUnnamed_1 = 3;
pub const ID_SOUND_SELECT: C2RustUnnamed_1 = 2;
pub const ID_SOUND_WINDOWOPEN: C2RustUnnamed_1 = 1;
pub const ID_SOUND_WINDOWCLOSE: C2RustUnnamed_1 = 0;
pub const NO_SOUND: C2RustUnnamed_1 = -1;
// Weapon droid
/*
 * Levels.h
 *
 * Control the data loading for game levels
 *
 */
// maximum number of WRF/WDG files
// types of level datasets
pub type _level_type = libc::c_uint;
//flags when not got a mission to go back to or when 
//already on one - ****LEAVE AS LAST ONE****
// off map saving any droids (selectedPlayer) at end into apsLimboDroids
pub const LDS_NONE: _level_type = 10;
// expand campaign map using droids held in apsLimboDroids
pub const LDS_MKEEP_LIMBO: _level_type = 9;
// off map mission (extra map data)
pub const LDS_MCLEAR: _level_type = 7;
// pause between missions
pub const LDS_MKEEP: _level_type = 6;
// all data required for a stand alone level
pub const LDS_CAMPAIGN: _level_type = 1;
pub const LDS_COMPLETE: _level_type = 0;
/* Endianness hacks */
#[inline]
unsafe extern "C" fn endian_uword(mut uword: *mut UWORD) { }
#[inline]
unsafe extern "C" fn endian_sword(mut sword: *mut SWORD) { }
#[inline]
unsafe extern "C" fn endian_udword(mut udword: *mut UDWORD) { }
#[inline]
unsafe extern "C" fn endian_sdword(mut sdword: *mut SDWORD) { }
#[inline]
unsafe extern "C" fn endian_fract(mut fract: *mut FRACT) { }
// unique ID creation thing..
static mut saveGameVersion: UDWORD = 0 as libc::c_int as UDWORD;
static mut saveGameOnMission: BOOL = 0 as libc::c_int;
static mut saveGameData: SAVE_GAME =
    SAVE_GAME{gameTime: 0,
              GameType: 0,
              ScrollMinX: 0,
              ScrollMinY: 0,
              ScrollMaxX: 0,
              ScrollMaxY: 0,
              levelName: [0; 20],
              power: [SAVE_POWER{currentPower: 0, extractedPower: 0,}; 8],
              currentPlayerPos:
                  iView{p: iVector{x: 0, y: 0, z: 0,},
                        r: iVector{x: 0, y: 0, z: 0,},},
              missionTime: 0,
              saveKey: 0,
              missionOffTime: 0,
              missionETA: 0,
              missionHomeLZ_X: 0,
              missionHomeLZ_Y: 0,
              missionPlayerX: 0,
              missionPlayerY: 0,
              iTranspEntryTileX: [0; 8],
              iTranspEntryTileY: [0; 8],
              iTranspExitTileX: [0; 8],
              iTranspExitTileY: [0; 8],
              aDefaultSensor: [0; 8],
              aDefaultECM: [0; 8],
              aDefaultRepair: [0; 8],
              offWorldKeepLists: 0,
              aDroidExperience: [[0; 32]; 8],
              RubbleTile: 0,
              WaterTile: 0,
              fogColour: 0,
              fogState: 0,
              sLandingZone: [LANDING_ZONE{x1: 0, y1: 0, x2: 0, y2: 0,}; 9],
              objId: 0,
              buildDate: [0; 256],
              oldestVersion: 0,
              validityKey: 0,
              alliances: [[0; 8]; 8],
              playerColour: [0; 8],
              radarZoom: 0,
              bDroidsToSafetyFlag: 0,
              asVTOLReturnPos: [POINT{x: 0, y: 0,}; 8],
              asRunData:
                  [RUN_DATA{sPos: POINT{x: 0, y: 0,},
                            forceLevel: 0,
                            healthLevel: 0,
                            leadership: 0,}; 8],
              reinforceTime: 0,
              bPlayCountDown: 0,
              bPlayerHasWon: 0,
              bPlayerHasLost: 0,
              dummy3: 0,
              awDroidExperience: [[0; 32]; 8],
              missionScrollMinX: 0,
              missionScrollMinY: 0,
              missionScrollMaxX: 0,
              missionScrollMaxY: 0,
              scrGameLevel: 0,
              bExtraVictoryFlag: 0,
              bExtraFailFlag: 0,
              bTrackTransporter: 0,
              missionCheatTime: 0,
              sGame:
                  MULTIPLAYERGAME{type_0: 0,
                                  map: [0; 128],
                                  version: [0; 8],
                                  maxPlayers: 0,
                                  name: [0; 128],
                                  bComputerPlayers: 0,
                                  fog: 0,
                                  power: 0,
                                  base: 0,
                                  alliance: 0,
                                  limit: 0,
                                  bytesPerSec: 0,
                                  packetsPerSec: 0,
                                  encryptKey: 0,
                                  skDiff: [0; 8],},
              sNetPlay:
                  NETPLAY{games:
                              [GAMESTRUCT{name: [0; 64],
                                          desc:
                                              SESSIONDESC{dwSize: 0,
                                                          dwFlags: 0,
                                                          host: [0; 16],
                                                          dwMaxPlayers: 0,
                                                          dwCurrentPlayers: 0,
                                                          dwUser1: 0,
                                                          dwUser2: 0,
                                                          dwUser3: 0,
                                                          dwUser4: 0,},}; 12],
                          players:
                              [PLAYER{dpid: 0,
                                      name: [0; 64],
                                      bHost: 0,
                                      bSpectator: 0,}; 8],
                          playercount: 0,
                          dpidPlayer: 0,
                          bComms: 0,
                          bHost: 0,
                          bLobbyLaunched: 0,
                          bSpectator: 0,
                          bEncryptAllPackets: 0,
                          cryptKey: [0; 4],
                          bCaptureInUse: 0,
                          bAllowCaptureRecord: 0,
                          bAllowCapturePlay: 0,},
              savePlayer: 0,
              sPName: [0; 32],
              multiPlayer: 0,
              sPlayer2dpid: [0; 8],};
static mut oldestSaveGameVersion: UDWORD = 33 as libc::c_int as UDWORD;
static mut validityKey: UDWORD = 0 as libc::c_int as UDWORD;
static mut savedGameTime: UDWORD = 0;
static mut savedObjId: UDWORD = 0;
//static UDWORD			HashedName;
//static STRUCTURE *psStructList;
//static FEATURE *psFeatureList;
//static FLAG_POSITION **ppsCurrentFlagPosLists;
static mut startX: SDWORD = 0;
static mut startY: SDWORD = 0;
static mut width: UDWORD = 0;
static mut height: UDWORD = 0;
static mut gameType: UDWORD = 0;
static mut IsScenario: BOOL = 0;
#[no_mangle]
pub unsafe extern "C" fn getSaveStructNameV19(mut psSaveStructure:
                                                  *mut SAVE_STRUCTURE_V17)
 -> *mut libc::c_char {
    return (*psSaveStructure).name.as_mut_ptr();
}
#[no_mangle]
pub unsafe extern "C" fn getSaveStructNameV(mut psSaveStructure:
                                                *mut SAVE_STRUCTURE)
 -> *mut libc::c_char {
    return (*psSaveStructure).name.as_mut_ptr();
}
// UserSaveGame is TRUE when the save game is not a new level (User Save Game)
/*This just loads up the .gam file to determine which level data to set up - split up
so can be called in levLoadData when starting a game from a load save game*/
/*This just loads up the .gam file to determine which level data to set up - split up
so can be called in levLoadData when starting a game from a load save game*/
// -----------------------------------------------------------------------------------------
#[no_mangle]
pub unsafe extern "C" fn loadGameInit(mut pGameToLoad: *mut STRING) -> BOOL {
    let mut pFileData: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut fileSize: UDWORD = 0;
    /* Load in the chosen file data */
    pFileData = DisplayBuffer;
    if loadFileToBuffer(pGameToLoad, pFileData, displayBufferSize,
                        &mut fileSize) == 0 {
        debug(LOG_NEVER,
              b"loadgame: Fail2\n\x00" as *const u8 as *const libc::c_char);
    } else if gameLoad(pFileData, fileSize) == 0 {
        // FIXME Probably should never arrive here?
        debug(LOG_NEVER,
              b"loadgame: Fail4\n\x00" as *const u8 as *const libc::c_char);
    } else { return 1 as libc::c_int }
    debug(LOG_NEVER,
          b"loadgame: ERROR\n\x00" as *const u8 as *const libc::c_char);
    /* Start the game clock */
    gameTimeStart();
    //#ifndef PSX
//	if (multiPlayerInUse)
//	{
//		bMultiPlayer = TRUE;				// reenable multi player messages.
//		multiPlayerInUse = FALSE;
//	}
//#endif
    return 0 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
// Load a file from a save game into the psx.
// This is divided up into 2 parts ...
//
// if it is a level loaded up from CD then UserSaveGame will by false
// UserSaveGame ... Extra stuff to load after scripts
#[no_mangle]
pub unsafe extern "C" fn loadMissionExtras(mut pGameToLoad: *mut STRING,
                                           mut levelType: SWORD) -> BOOL {
    let mut aFileName: [STRING; 256] = [0; 256];
    let mut fileExten: UDWORD = 0;
    let mut fileSize: UDWORD = 0;
    let mut pFileData: *mut libc::c_char = 0 as *mut libc::c_char;
    strcpy(aFileName.as_mut_ptr(), pGameToLoad);
    fileExten =
        strlen(pGameToLoad).wrapping_sub(3 as libc::c_int as libc::c_uint);
    aFileName[fileExten.wrapping_sub(1 as libc::c_int as libc::c_uint) as
                  usize] = '\u{0}' as i32 as STRING;
    strcat(aFileName.as_mut_ptr(),
           b"\\\x00" as *const u8 as *const libc::c_char);
    //#ifdef NEW_SAVE //V11 Save
    if saveGameVersion >= 11 as libc::c_int as libc::c_uint {
        //if user save game then load up the messages AFTER any droids or structures are loaded
        if gameType == GTYPE_SAVE_START as libc::c_int as libc::c_uint ||
               gameType ==
                   GTYPE_SAVE_MIDMISSION as libc::c_int as libc::c_uint {
            //load in the message list file
            aFileName[fileExten as usize] = '\u{0}' as i32 as STRING;
            strcat(aFileName.as_mut_ptr(),
                   b"mesState.bjo\x00" as *const u8 as *const libc::c_char);
            // Load in the chosen file data
            pFileData = DisplayBuffer;
            if loadFileToBufferNoError(aFileName.as_mut_ptr(), pFileData,
                                       displayBufferSize, &mut fileSize) != 0
               {
                //load the message status data
                if !pFileData.is_null() {
                    if loadSaveMessage(pFileData, fileSize, levelType) == 0 {
                        debug(LOG_NEVER,
                              b"loadMissionExtras: Fail 2\n\x00" as *const u8
                                  as *const libc::c_char);
                        return 0 as libc::c_int
                    }
                }
            }
        }
    }
    //#endif
    return 1 as libc::c_int;
}
/* **************************************************************************/
/*
 *	Global ProtoTypes
 */
/* **************************************************************************/
// -----------------------------------------------------------------------------------------
// UserSaveGame ... this is true when you are loading a players save game
#[no_mangle]
pub unsafe extern "C" fn loadGame(mut pGameToLoad: *mut STRING,
                                  mut keepObjects: BOOL, mut freeMem: BOOL,
                                  mut UserSaveGame: BOOL) -> BOOL {
    let mut current_block: u64;
    let mut aFileName: [STRING; 256] = [0; 256];
    //OPENFILENAME		sOFN;
    let mut fileExten: UDWORD = 0;
    let mut fileSize: UDWORD = 0;
    let mut pl: UDWORD = 0;
    let mut pFileData: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut player: UDWORD = 0;
    let mut inc: UDWORD = 0;
    let mut i: UDWORD = 0;
    let mut j: UDWORD = 0;
    let mut psCurr: *mut DROID = 0 as *mut DROID;
    let mut missionScrollMinX: UWORD = 0 as libc::c_int as UWORD;
    let mut missionScrollMinY: UWORD = 0 as libc::c_int as UWORD;
    let mut missionScrollMaxX: UWORD = 0 as libc::c_int as UWORD;
    let mut missionScrollMaxY: UWORD = 0 as libc::c_int as UWORD;
    debug(LOG_NEVER, b"loadGame\n\x00" as *const u8 as *const libc::c_char);
    /* Stop the game clock */
    gameTimeStop(); //added 14 may 98 JPS to solve kev's problem with no firing droids
    if gameType == GTYPE_SAVE_START as libc::c_int as libc::c_uint ||
           gameType == GTYPE_SAVE_MIDMISSION as libc::c_int as libc::c_uint {
        gameTimeReset(savedGameTime);
        //need to reset the event timer too - AB 14/01/99
        eventTimeReset(savedGameTime.wrapping_div(100 as libc::c_int as
                                                      libc::c_uint));
    }
    /* Clear all the objects off the map and free up the map memory */
    proj_FreeAllProjectiles(); //always clear this
    if freeMem != 0 {
        //clear out the audio
        audio_StopAll();
        freeAllDroids();
        freeAllStructs();
        freeAllFeatures();
        //	droidTemplateShutDown();
        !psMapTiles.is_null();
        if !aMapLinePoints.is_null() {
            memFreeRelease(aMapLinePoints as *mut libc::c_void);
            aMapLinePoints = 0 as *mut TILE_COORD
        }
        //clear all the messages?
        releaseAllProxDisp();
    }
    if keepObjects == 0 {
        //initialise the lists
        player = 0 as libc::c_int as UDWORD;
        while player < 8 as libc::c_int as libc::c_uint {
            apsDroidLists[player as usize] = 0 as *mut DROID;
            apsStructLists[player as usize] = 0 as *mut STRUCTURE;
            apsFeatureLists[player as usize] = 0 as *mut FEATURE;
            apsFlagPosLists[player as usize] = 0 as *mut FLAG_POSITION;
            //clear all the messages?
            apsProxDisp[player as usize] = 0 as *mut PROXIMITY_DISPLAY;
            player = player.wrapping_add(1)
        }
        initFactoryNumFlag();
    }
    if UserSaveGame != 0 {
        //always !keepObjects
        //initialise the lists
        player = 0 as libc::c_int as UDWORD;
        while player < 8 as libc::c_int as libc::c_uint {
            apsLimboDroids[player as usize] = 0 as *mut DROID;
            mission.apsDroidLists[player as usize] = 0 as *mut DROID;
            mission.apsStructLists[player as usize] = 0 as *mut STRUCTURE;
            mission.apsFeatureLists[player as usize] = 0 as *mut FEATURE;
            mission.apsFlagPosLists[player as usize] =
                0 as *mut FLAG_POSITION;
            player = player.wrapping_add(1)
        }
        memset(asStructureUpgrade.as_mut_ptr() as *mut libc::c_void,
               0 as libc::c_int,
               (8 as libc::c_int as
                    libc::c_uint).wrapping_mul(::std::mem::size_of::<STRUCTURE_UPGRADE>()
                                                   as libc::c_ulong));
        memset(asWallDefenceUpgrade.as_mut_ptr() as *mut libc::c_void,
               0 as libc::c_int,
               (8 as libc::c_int as
                    libc::c_uint).wrapping_mul(::std::mem::size_of::<WALLDEFENCE_UPGRADE>()
                                                   as libc::c_ulong));
        memset(asResearchUpgrade.as_mut_ptr() as *mut libc::c_void,
               0 as libc::c_int,
               (8 as libc::c_int as
                    libc::c_uint).wrapping_mul(::std::mem::size_of::<RESEARCH_UPGRADE>()
                                                   as libc::c_ulong));
        memset(asPowerUpgrade.as_mut_ptr() as *mut libc::c_void,
               0 as libc::c_int,
               (8 as libc::c_int as
                    libc::c_uint).wrapping_mul(::std::mem::size_of::<POWER_UPGRADE>()
                                                   as libc::c_ulong));
        memset(asRepairFacUpgrade.as_mut_ptr() as *mut libc::c_void,
               0 as libc::c_int,
               (8 as libc::c_int as
                    libc::c_uint).wrapping_mul(::std::mem::size_of::<REPAIR_FACILITY_UPGRADE>()
                                                   as libc::c_ulong));
        memset(asProductionUpgrade.as_mut_ptr() as *mut libc::c_void,
               0 as libc::c_int,
               ((8 as libc::c_int * 3 as libc::c_int) as
                    libc::c_uint).wrapping_mul(::std::mem::size_of::<PRODUCTION_UPGRADE>()
                                                   as libc::c_ulong));
        memset(asReArmUpgrade.as_mut_ptr() as *mut libc::c_void,
               0 as libc::c_int,
               (8 as libc::c_int as
                    libc::c_uint).wrapping_mul(::std::mem::size_of::<REARM_UPGRADE>()
                                                   as libc::c_ulong));
        memset(asWeaponUpgrade.as_mut_ptr() as *mut libc::c_void,
               0 as libc::c_int,
               ((8 as libc::c_int * NUM_WEAPON_SUBCLASS as libc::c_int) as
                    libc::c_uint).wrapping_mul(::std::mem::size_of::<WEAPON_UPGRADE>()
                                                   as libc::c_ulong));
        memset(asSensorUpgrade.as_mut_ptr() as *mut libc::c_void,
               0 as libc::c_int,
               (8 as libc::c_int as
                    libc::c_uint).wrapping_mul(::std::mem::size_of::<SENSOR_UPGRADE>()
                                                   as libc::c_ulong));
        memset(asECMUpgrade.as_mut_ptr() as *mut libc::c_void,
               0 as libc::c_int,
               (8 as libc::c_int as
                    libc::c_uint).wrapping_mul(::std::mem::size_of::<ECM_UPGRADE>()
                                                   as libc::c_ulong));
        memset(asRepairUpgrade.as_mut_ptr() as *mut libc::c_void,
               0 as libc::c_int,
               (8 as libc::c_int as
                    libc::c_uint).wrapping_mul(::std::mem::size_of::<REPAIR_UPGRADE>()
                                                   as libc::c_ulong));
        memset(asBodyUpgrade.as_mut_ptr() as *mut libc::c_void,
               0 as libc::c_int,
               (8 as libc::c_int as
                    libc::c_uint).wrapping_mul(::std::mem::size_of::<BODY_UPGRADE>()
                                                   as
                                                   libc::c_ulong).wrapping_mul(2
                                                                                   as
                                                                                   libc::c_int
                                                                                   as
                                                                                   libc::c_uint));
    }
    //JPS 25 feb
    //JPS 25 feb
		//initialise upgrades
		//initialise the structure upgrade arrays
    //initialise the upgrade structures
    //Stuff added after level load to avoid being reset or initialised during load
    if UserSaveGame != 0 {
        //always !keepObjects
        if saveGameVersion >= 11 as libc::c_int as libc::c_uint {
            //v21
            //camera position
            disp3d_setView(&mut saveGameData.currentPlayerPos);
        }
        if saveGameVersion >= 12 as libc::c_int as libc::c_uint {
            mission.startTime = saveGameData.missionTime
        }
        //set the scroll varaibles
        startX = saveGameData.ScrollMinX;
        startY = saveGameData.ScrollMinY;
        width =
            saveGameData.ScrollMaxX.wrapping_sub(saveGameData.ScrollMinX as
                                                     libc::c_uint);
        height =
            saveGameData.ScrollMaxY.wrapping_sub(saveGameData.ScrollMinY as
                                                     libc::c_uint);
        gameType = saveGameData.GameType;
        if saveGameVersion >= 11 as libc::c_int as libc::c_uint {
            //camera position
            disp3d_setView(&mut saveGameData.currentPlayerPos);
        }
        if saveGameVersion >= 14 as libc::c_int as libc::c_uint {
            //mission data
            mission.time = saveGameData.missionOffTime;
            mission.ETA = saveGameData.missionETA;
            mission.homeLZ_X = saveGameData.missionHomeLZ_X;
            mission.homeLZ_Y = saveGameData.missionHomeLZ_Y;
            mission.playerX = saveGameData.missionPlayerX;
            mission.playerY = saveGameData.missionPlayerY;
            //mission data
            player = 0 as libc::c_int as UDWORD;
            while player < 8 as libc::c_int as libc::c_uint {
                aDefaultSensor[player as usize] =
                    saveGameData.aDefaultSensor[player as usize];
                aDefaultECM[player as usize] =
                    saveGameData.aDefaultECM[player as usize];
                aDefaultRepair[player as usize] =
                    saveGameData.aDefaultRepair[player as usize];
                //check for self repair having been set
                if aDefaultRepair[player as usize] !=
                       0 as libc::c_int as libc::c_uint &&
                       (*asRepairStats.offset(aDefaultRepair[player as usize]
                                                  as isize)).location ==
                           LOC_DEFAULT as libc::c_int as libc::c_uint {
                    enableSelfRepair(player as UBYTE);
                }
                mission.iTranspEntryTileX[player as usize] =
                    saveGameData.iTranspEntryTileX[player as usize];
                mission.iTranspEntryTileY[player as usize] =
                    saveGameData.iTranspEntryTileY[player as usize];
                mission.iTranspExitTileX[player as usize] =
                    saveGameData.iTranspExitTileX[player as usize];
                mission.iTranspExitTileY[player as usize] =
                    saveGameData.iTranspExitTileY[player as usize];
                player = player.wrapping_add(1)
            }
        }
        if saveGameVersion >= 15 as libc::c_int as libc::c_uint {
            //V21
            offWorldKeepLists = saveGameData.offWorldKeepLists;
            setRubbleTile(saveGameData.RubbleTile);
            setUnderwaterTile(saveGameData.WaterTile);
            if saveGameData.fogState == 0 as libc::c_int as libc::c_uint {
                //no fog
                pie_EnableFog(0 as libc::c_int);
                fogStatus = 0 as libc::c_int as UDWORD
            } else if saveGameData.fogState ==
                          1 as libc::c_int as libc::c_uint {
                //fog using old code assume background and depth
                if war_GetFog() != 0 {
                    pie_EnableFog(1 as libc::c_int);
                } else { pie_EnableFog(0 as libc::c_int); }
                fogStatus = (1 as libc::c_int + 2 as libc::c_int) as UDWORD
            } else {
                //version 18+ fog
                if war_GetFog() != 0 {
                    pie_EnableFog(1 as libc::c_int);
                } else { pie_EnableFog(0 as libc::c_int); }
                fogStatus = saveGameData.fogState;
                fogStatus &= 7 as libc::c_int as libc::c_uint
            }
            pie_SetFogColour(saveGameData.fogColour);
        }
        if saveGameVersion >= 19 as libc::c_int as libc::c_uint {
            //V21
            i = 0 as libc::c_int as UDWORD;
            while i < 8 as libc::c_int as libc::c_uint {
                j = 0 as libc::c_int as UDWORD;
                while j < 8 as libc::c_int as libc::c_uint {
                    alliances[i as usize][j as usize] =
                        saveGameData.alliances[i as usize][j as usize];
                    j = j.wrapping_add(1)
                }
                i = i.wrapping_add(1)
            }
            i = 0 as libc::c_int as UDWORD;
            while i < 8 as libc::c_int as libc::c_uint {
                setPlayerColour(i,
                                saveGameData.playerColour[i as usize] as
                                    UDWORD);
                i = i.wrapping_add(1)
            }
            SetRadarZoom(saveGameData.radarZoom as UWORD);
        }
        if saveGameVersion >= 20 as libc::c_int as libc::c_uint {
            //V21
            setDroidsToSafetyFlag(saveGameData.bDroidsToSafetyFlag as BOOL);
            inc = 0 as libc::c_int as UDWORD;
            while inc < 8 as libc::c_int as libc::c_uint {
                memcpy(&mut *asVTOLReturnPos.as_mut_ptr().offset(inc as isize)
                           as *mut POINT as *mut libc::c_void,
                       &mut *saveGameData.asVTOLReturnPos.as_mut_ptr().offset(inc
                                                                                  as
                                                                                  isize)
                           as *mut POINT as *const libc::c_void,
                       ::std::mem::size_of::<POINT>() as libc::c_ulong);
                inc = inc.wrapping_add(1)
            }
        }
        if saveGameVersion >= 22 as libc::c_int as libc::c_uint {
            //V22
            inc = 0 as libc::c_int as UDWORD;
            while inc < 8 as libc::c_int as libc::c_uint {
                memcpy(&mut *asRunData.as_mut_ptr().offset(inc as isize) as
                           *mut RUN_DATA as *mut libc::c_void,
                       &mut *saveGameData.asRunData.as_mut_ptr().offset(inc as
                                                                            isize)
                           as *mut RUN_DATA as *const libc::c_void,
                       ::std::mem::size_of::<RUN_DATA>() as libc::c_ulong);
                inc = inc.wrapping_add(1)
            }
        }
        if saveGameVersion >= 24 as libc::c_int as libc::c_uint {
            //V24
            missionSetReinforcementTime(saveGameData.reinforceTime);
            /*			setPlayCountDown(saveGameData.bPlayCountDown);
			setPlayerHasWon(saveGameData.bPlayerHasWon);
			setPlayerHasLost(saveGameData.bPlayerHasLost);*/
            if saveGameData.bPlayCountDown as libc::c_int <= 1 as libc::c_int
               {
                setPlayCountDown(saveGameData.bPlayCountDown);
            }
            if saveGameData.bPlayerHasWon as libc::c_int <= 1 as libc::c_int {
                setPlayerHasWon(saveGameData.bPlayerHasWon as BOOL);
            }
            if saveGameData.bPlayerHasLost as libc::c_int <= 1 as libc::c_int
               {
                setPlayerHasLost(saveGameData.bPlayerHasLost as BOOL);
            }
        }
        if saveGameVersion >= 27 as libc::c_int as libc::c_uint {
            // horrible hack to catch savegames that were saving garbage into these fields
            //V27
            player = 0 as libc::c_int as UDWORD;
            while player < 8 as libc::c_int as libc::c_uint {
                inc = 0 as libc::c_int as UDWORD;
                while inc < 32 as libc::c_int as libc::c_uint {
                    aDroidExperience[player as usize][inc as usize] =
                        saveGameData.awDroidExperience[player as
                                                           usize][inc as
                                                                      usize];
                    inc = inc.wrapping_add(1)
                }
                player = player.wrapping_add(1)
            }
        } else {
            player = 0 as libc::c_int as UDWORD;
            while player < 8 as libc::c_int as libc::c_uint {
                inc = 0 as libc::c_int as UDWORD;
                while inc < 32 as libc::c_int as libc::c_uint {
                    aDroidExperience[player as usize][inc as usize] =
                        saveGameData.aDroidExperience[player as
                                                          usize][inc as usize]
                            as UWORD;
                    inc = inc.wrapping_add(1)
                }
                player = player.wrapping_add(1)
            }
        }
        if saveGameVersion >= 30 as libc::c_int as libc::c_uint {
            scrGameLevel = saveGameData.scrGameLevel;
            bExtraVictoryFlag = saveGameData.bExtraVictoryFlag as BOOL;
            bExtraFailFlag = saveGameData.bExtraFailFlag as BOOL;
            bTrackTransporter = saveGameData.bTrackTransporter as BOOL
        }
        //extra code added for the first patch (v1.1) to save out if mission time is not being counted
        if saveGameVersion >= 31 as libc::c_int as libc::c_uint {
            //mission data
            mission.cheatTime = saveGameData.missionCheatTime as UDWORD
        }
        // skirmish saves.
        if saveGameVersion >= 33 as libc::c_int as libc::c_uint {
            let mut playerStats: PLAYERSTATS =
                PLAYERSTATS{played: 0,
                            wins: 0,
                            loses: 0,
                            totalKills: 0,
                            totalScore: 0,
                            recentKills: 0,
                            recentScore: 0,
                            killsToAdd: 0,
                            scoreToAdd: 0,}; // stats stuff
            game = saveGameData.sGame;
            NetPlay = saveGameData.sNetPlay;
            selectedPlayer = saveGameData.savePlayer;
            productionPlayer = selectedPlayer as SBYTE;
            bMultiPlayer = saveGameData.multiPlayer;
            cmdDroidMultiExpBoost(1 as libc::c_int);
            inc = 0 as libc::c_int as UDWORD;
            while inc < 8 as libc::c_int as libc::c_uint {
                player2dpid[inc as usize] =
                    saveGameData.sPlayer2dpid[inc as usize];
                inc = inc.wrapping_add(1)
            }
            if bMultiPlayer != 0 {
                blockSuspendUsage();
                loadMultiStats(saveGameData.sPName.as_mut_ptr(),
                               &mut playerStats);
                setMultiStats(NetPlay.dpidPlayer, playerStats,
                              0 as libc::c_int);
                setMultiStats(NetPlay.dpidPlayer, playerStats,
                              1 as libc::c_int);
                blockUnsuspendUsage();
            }
        }
    }
    //clear the player Power structs
    if gameType != GTYPE_SAVE_START as libc::c_int as libc::c_uint &&
           gameType != GTYPE_SAVE_MIDMISSION as libc::c_int as libc::c_uint &&
           keepObjects == 0 {
        clearPlayerPower();
    }
    //initialise the scroll values
	//startX = startY = width = height = 0;
    //before loading the data - turn power off so don't get any power low warnings
    powerCalculated = 0 as libc::c_int;
    /* Load in the chosen file data */
/*#ifndef PSX
	pFileData = DisplayBuffer;
	if (!loadFileToBuffer(aFileName, pFileData, displayBufferSize, &fileSize))
	{
		DBPRINTF(("loadgame: Fail2\n"));
		goto error;
	}
#else
	if (loadFileFromWDG(aFileName,&pFileData,&fileSize,WDG_USESUPPLIED)!=WDG_OK)
	{
		DBPRINTF(("loadgame: Fail3\n"));
		goto error;
	}
#endif
	if (!gameLoad(pFileData, fileSize))
	{
		DBPRINTF(("loadgame: Fail4\n"));
		goto error;
	}
	//aFileName[fileExten - 1] = '\0';
	//strcat(aFileName, "\\");
*/
    strcpy(aFileName.as_mut_ptr(), pGameToLoad); // hack - !
    fileExten =
        strlen(aFileName.as_mut_ptr()).wrapping_sub(3 as libc::c_int as
                                                        libc::c_uint);
    aFileName[fileExten.wrapping_sub(1 as libc::c_int as libc::c_uint) as
                  usize] = '\u{0}' as i32 as STRING;
    strcat(aFileName.as_mut_ptr(),
           b"\\\x00" as *const u8 as *const libc::c_char);
    //the terrain type WILL only change with Campaign changes (well at the moment!)
	//if (freeMem) - this now works for Cam Start and Cam Change
    if gameType != GTYPE_SCENARIO_EXPAND as libc::c_int as libc::c_uint ||
           UserSaveGame != 0 {
        //		loadingScreenCallback();
        //load in the terrain type map
        aFileName[fileExten as usize] = '\u{0}' as i32 as STRING;
        strcat(aFileName.as_mut_ptr(),
               b"TTypes.ttp\x00" as *const u8 as *const libc::c_char);
        /* Load in the chosen file data */
        pFileData = DisplayBuffer;
        if loadFileToBuffer(aFileName.as_mut_ptr(), pFileData,
                            displayBufferSize, &mut fileSize) == 0 {
            debug(LOG_NEVER,
                  b"loadgame: Fail23\n\x00" as *const u8 as
                      *const libc::c_char);
            current_block = 9873574167579496540;
        } else if !pFileData.is_null() {
            if loadTerrainTypeMap(pFileData, fileSize) == 0 {
                debug(LOG_NEVER,
                      b"loadgame: Fail25\n\x00" as *const u8 as
                          *const libc::c_char);
                current_block = 9873574167579496540;
            } else { current_block = 12972356734185922794; }
        } else { current_block = 12972356734185922794; }
    } else { current_block = 12972356734185922794; }
    match current_block {
        12972356734185922794 =>
        //load the terrain type data
        //load up the Droid Templates BEFORE any structures are loaded
        //	loadingScreenCallback();
        {
            if IsScenario == 0 as libc::c_int {
                //NOT ANY MORE - use multiPlayerID (unique template id) to prevent duplicate's being loaded
		//Only want to clear the lists in the final version of the game
                //#ifdef FINAL
		//first clear the templates
//		droidTemplateShutDown();
		// only free player 0 templates - keep all the others from the stats
//#define ALLOW_ACCESS_TEMPLATES
                let mut pTemplate: *mut DROID_TEMPLATE =
                    0 as *mut DROID_TEMPLATE;
                let mut pNext: *mut DROID_TEMPLATE = 0 as *mut DROID_TEMPLATE;
                pTemplate = apsDroidTemplates[0 as libc::c_int as usize];
                while !pTemplate.is_null() {
                    pNext = (*pTemplate).psNext;
                    heapFree(psTemplateHeap, pTemplate as *mut libc::c_void);
                    pTemplate = pNext
                }
                apsDroidTemplates[0 as libc::c_int as usize] =
                    0 as *mut DROID_TEMPLATE;
                //JPS 25 feb (reverse templates moved from here)
                // In Multiplayer, clear templates out first.....
                if bMultiPlayer != 0 {
                    inc = 0 as libc::c_int as UDWORD;
                    while inc < 8 as libc::c_int as libc::c_uint {
                        while !apsDroidTemplates[inc as usize].is_null() {
                            // clear the old template out.
                            let mut psTempl: *mut DROID_TEMPLATE =
                                0 as *mut DROID_TEMPLATE;
                            psTempl =
                                (*apsDroidTemplates[inc as usize]).psNext;
                            heapFree(psTemplateHeap,
                                     apsDroidTemplates[inc as usize] as
                                         *mut libc::c_void);
                            apsDroidTemplates[inc as usize] = psTempl
                        }
                        inc = inc.wrapping_add(1)
                    }
                }
                //load in the templates
                //	loadingScreenCallback();
                aFileName[fileExten as usize] = '\u{0}' as i32 as STRING;
                strcat(aFileName.as_mut_ptr(),
                       b"templ.bjo\x00" as *const u8 as *const libc::c_char);
                /* Load in the chosen file data */
                pFileData = DisplayBuffer;
                if loadFileToBuffer(aFileName.as_mut_ptr(), pFileData,
                                    displayBufferSize, &mut fileSize) == 0 {
                    debug(LOG_NEVER,
                          b"loadgame: Fail20\n\x00" as *const u8 as
                              *const libc::c_char);
                    current_block = 9873574167579496540;
                } else if loadSaveTemplate(pFileData, fileSize) == 0 {
                    debug(LOG_NEVER,
                          b"loadgame: Fail22\n\x00" as *const u8 as
                              *const libc::c_char);
                    current_block = 9873574167579496540;
                } else { current_block = 1030684006266329021; }
            } else { current_block = 1030684006266329021; }
            match current_block {
                9873574167579496540 => { }
                _ => {
                    if saveGameOnMission != 0 && UserSaveGame != 0 {
                        //load the data into apsTemplates
                        //		loadingScreenCallback();
                        memSetBlockHeap(psMapHeap); //should be set
                        //the scroll limits for the mission map have already been written
                        if saveGameVersion >=
                               29 as libc::c_int as libc::c_uint {
                            missionScrollMinX = mission.scrollMinX as UWORD;
                            missionScrollMinY = mission.scrollMinY as UWORD;
                            missionScrollMaxX = mission.scrollMaxX as UWORD;
                            missionScrollMaxY = mission.scrollMaxY as UWORD
                        }
                        //load the map and the droids then swap pointers
//		psMapTiles = NULL;
//		aMapLinePoints = NULL;
		//load in the map file
                        aFileName[fileExten as usize] =
                            '\u{0}' as i32 as STRING;
                        strcat(aFileName.as_mut_ptr(),
                               b"mission.map\x00" as *const u8 as
                                   *const libc::c_char);
                        /* Load in the chosen file data */
                        pFileData = DisplayBuffer;
                        if loadFileToBufferNoError(aFileName.as_mut_ptr(),
                                                   pFileData,
                                                   displayBufferSize,
                                                   &mut fileSize) != 0 {
                            if mapLoad(pFileData, fileSize) == 0 {
                                debug(LOG_NEVER,
                                      b"loadgame: Fail7\n\x00" as *const u8 as
                                          *const libc::c_char);
                                return 0 as libc::c_int
                            }
                        }
                        //load in the visibility file
                        aFileName[fileExten as usize] =
                            '\u{0}' as i32 as STRING;
                        strcat(aFileName.as_mut_ptr(),
                               b"misvis.bjo\x00" as *const u8 as
                                   *const libc::c_char);
                        /* Load in the chosen file data */
                        pFileData = DisplayBuffer;
                        if loadFileToBufferNoError(aFileName.as_mut_ptr(),
                                                   pFileData,
                                                   displayBufferSize,
                                                   &mut fileSize) != 0 {
                            //load the visibility data
                            if !pFileData.is_null() {
                                if readVisibilityData(pFileData, fileSize) ==
                                       0 {
                                    debug(LOG_NEVER,
                                          b"loadgame: Fail33\n\x00" as
                                              *const u8 as
                                              *const libc::c_char);
                                    current_block = 9873574167579496540;
                                } else {
                                    current_block = 6128882510526660344;
                                }
                            } else { current_block = 6128882510526660344; }
                        } else { current_block = 6128882510526660344; }
                        match current_block {
                            9873574167579496540 => { }
                            _ => {
                                //set mission heap
                                memSetBlockHeap(psMissionHeap);
                                // reload the objects that were in the mission list
//except droids these are always loaded directly to the mission.apsDroidList
/*
	*apsFlagPosLists[MAX_PLAYERS];
	asPower[MAX_PLAYERS];
*/
                                //		loadingScreenCallback();
                                //load in the features -do before the structures
                                aFileName[fileExten as usize] =
                                    '\u{0}' as i32 as STRING;
                                strcat(aFileName.as_mut_ptr(),
                                       b"mFeat.bjo\x00" as *const u8 as
                                           *const libc::c_char);
                                /* Load in the chosen file data */
                                pFileData = DisplayBuffer;
                                if loadFileToBuffer(aFileName.as_mut_ptr(),
                                                    pFileData,
                                                    displayBufferSize,
                                                    &mut fileSize) == 0 {
                                    debug(LOG_NEVER,
                                          b"loadgame: Fail14\n\x00" as
                                              *const u8 as
                                              *const libc::c_char);
                                    current_block = 9873574167579496540;
                                } else if loadSaveFeature(pFileData, fileSize)
                                              == 0 {
                                    debug(LOG_NEVER,
                                          b"loadgame: Fail16\n\x00" as
                                              *const u8 as
                                              *const libc::c_char);
                                    current_block = 9873574167579496540;
                                } else {
                                    //load the data into apsFeatureLists
                                    //load in the mission structures
                                    aFileName[fileExten as usize] =
                                        '\u{0}' as i32 as STRING;
                                    strcat(aFileName.as_mut_ptr(),
                                           b"mStruct.bjo\x00" as *const u8 as
                                               *const libc::c_char);
                                    /* Load in the chosen file data */
                                    pFileData = DisplayBuffer;
                                    if loadFileToBuffer(aFileName.as_mut_ptr(),
                                                        pFileData,
                                                        displayBufferSize,
                                                        &mut fileSize) == 0 {
                                        debug(LOG_NEVER,
                                              b"loadgame: Fail17\n\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        current_block = 9873574167579496540;
                                    } else if loadSaveStructure(pFileData,
                                                                fileSize) == 0
                                     {
                                        debug(LOG_NEVER,
                                              b"loadgame: Fail19\n\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        current_block = 9873574167579496540;
                                    } else {
                                        //load the data into apsStructLists
                                        //		loadingScreenCallback();
                                        if bMultiPlayer != 0 {
                                            pl = 0 as libc::c_int as UDWORD;
                                            while pl <
                                                      8 as libc::c_int as
                                                          libc::c_uint {
                                                // ajl. must do for every player to stop multiplay/pc players going gaga.
                                                //reverse the structure lists so the Research Facilities are in the same order as when saved
                                                reverseObjectList(&mut *apsStructLists.as_mut_ptr().offset(pl
                                                                                                               as
                                                                                                               isize)
                                                                      as
                                                                      *mut *mut STRUCTURE
                                                                      as
                                                                      *mut *mut BASE_OBJECT);
                                                pl = pl.wrapping_add(1)
                                            }
                                        }
                                        //		loadingScreenCallback();
                                        //load in the mission droids
                                        aFileName[fileExten as usize] =
                                            '\u{0}' as i32 as STRING;
                                        if saveGameVersion <
                                               27 as libc::c_int as
                                                   libc::c_uint {
                                            //V27
                                            strcat(aFileName.as_mut_ptr(),
                                                   b"mDroid.bjo\x00" as
                                                       *const u8 as
                                                       *const libc::c_char);
                                        } else {
                                            strcat(aFileName.as_mut_ptr(),
                                                   b"mUnit.bjo\x00" as
                                                       *const u8 as
                                                       *const libc::c_char);
                                        }
                                        /* Load in the chosen file data */
                                        pFileData = DisplayBuffer;
                                        if loadFileToBufferNoError(aFileName.as_mut_ptr(),
                                                                   pFileData,
                                                                   displayBufferSize,
                                                                   &mut fileSize)
                                               != 0 {
                                            //load the data into mission.apsDroidLists
			//ppsCurrentDroidLists = mission.apsDroidLists;
                                            if loadSaveDroid(pFileData,
                                                             fileSize,
                                                             apsDroidLists.as_mut_ptr())
                                                   == 0 {
                                                debug(LOG_NEVER,
                                                      b"loadgame: Fail12\n\x00"
                                                          as *const u8 as
                                                          *const libc::c_char);
                                                current_block =
                                                    9873574167579496540;
                                            } else {
                                                current_block =
                                                    10779579613334775377;
                                            }
                                        } else {
                                            current_block =
                                                10779579613334775377;
                                        }
                                        match current_block {
                                            9873574167579496540 => { }
                                            _ => {
                                                /*after we've loaded in the units we need to redo the orientation because
        the direction may have been saved - we need to do it outside of the loop
        whilst the current map is valid for the units*/
                                                player =
                                                    0 as libc::c_int as
                                                        UDWORD;
                                                while player <
                                                          8 as libc::c_int as
                                                              libc::c_uint {
                                                    psCurr =
                                                        apsDroidLists[player
                                                                          as
                                                                          usize];
                                                    while !psCurr.is_null() {
                                                        if !((*psCurr).droidType
                                                                 as
                                                                 libc::c_uint
                                                                 ==
                                                                 DROID_PERSON
                                                                     as
                                                                     libc::c_int
                                                                     as
                                                                     libc::c_uint
                                                                 ||
                                                                 cyborgDroid(psCurr)
                                                                     != 0 ||
                                                                 (*psCurr).droidType
                                                                     as
                                                                     libc::c_uint
                                                                     ==
                                                                     DROID_TRANSPORTER
                                                                         as
                                                                         libc::c_int
                                                                         as
                                                                         libc::c_uint)
                                                           {
                                                            if (*psCurr).x as
                                                                   libc::c_int
                                                                   !=
                                                                   512 as
                                                                       libc::c_int
                                                                       *
                                                                       127 as
                                                                           libc::c_int
                                                               {
                                                                updateDroidOrientation(psCurr);
                                                            }
                                                        }
                                                        psCurr =
                                                            (*psCurr).psNext
                                                    }
                                                    player =
                                                        player.wrapping_add(1)
                                                }
                                                //		loadingScreenCallback();
                                                //load in the flag list file
                                                aFileName[fileExten as usize]
                                                    =
                                                    '\u{0}' as i32 as STRING;
                                                strcat(aFileName.as_mut_ptr(),
                                                       b"mFlagState.bjo\x00"
                                                           as *const u8 as
                                                           *const libc::c_char);
                                                // Load in the chosen file data
                                                pFileData = DisplayBuffer;
                                                if loadFileToBuffer(aFileName.as_mut_ptr(),
                                                                    pFileData,
                                                                    displayBufferSize,
                                                                    &mut fileSize)
                                                       == 0 {
                                                    debug(LOG_NEVER,
                                                          b"loadMissionExtras: Fail 3\n\x00"
                                                              as *const u8 as
                                                              *const libc::c_char);
                                                    return 0 as libc::c_int
                                                }
                                                //load the flag status data
                                                if !pFileData.is_null() {
                                                    if loadSaveFlag(pFileData,
                                                                    fileSize)
                                                           == 0 {
                                                        debug(LOG_NEVER,
                                                              b"loadMissionExtras: Fail 4\n\x00"
                                                                  as *const u8
                                                                  as
                                                                  *const libc::c_char);
                                                        return 0 as
                                                                   libc::c_int
                                                    }
                                                }
                                                swapMissionPointers();
                                                //once the mission map has been loaded reset the mission scroll limits
                                                if saveGameVersion >=
                                                       29 as libc::c_int as
                                                           libc::c_uint {
                                                    mission.scrollMinX =
                                                        missionScrollMinX as
                                                            UDWORD;
                                                    mission.scrollMinY =
                                                        missionScrollMinY as
                                                            UDWORD;
                                                    mission.scrollMaxX =
                                                        missionScrollMaxX as
                                                            UDWORD;
                                                    mission.scrollMaxY =
                                                        missionScrollMaxY as
                                                            UDWORD
                                                }
                                                current_block =
                                                    13791588947665731104;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else { current_block = 13791588947665731104; }
                    match current_block {
                        9873574167579496540 => { }
                        _ =>
                        //if Campaign Expand then don't load in another map
                        {
                            if gameType !=
                                   GTYPE_SCENARIO_EXPAND as libc::c_int as
                                       libc::c_uint {
                                //		loadingScreenCallback();
                                psMapTiles = 0 as *mut MAPTILE;
                                aMapLinePoints = 0 as *mut TILE_COORD;
                                //load in the map file
                                aFileName[fileExten as usize] =
                                    '\u{0}' as i32 as STRING;
                                strcat(aFileName.as_mut_ptr(),
                                       b"game.map\x00" as *const u8 as
                                           *const libc::c_char);
                                /* Load in the chosen file data */
                                pFileData = DisplayBuffer;
                                if loadFileToBuffer(aFileName.as_mut_ptr(),
                                                    pFileData,
                                                    displayBufferSize,
                                                    &mut fileSize) == 0 {
                                    debug(LOG_NEVER,
                                          b"loadgame: Fail5\n\x00" as
                                              *const u8 as
                                              *const libc::c_char);
                                    current_block = 9873574167579496540;
                                } else {
                                    // on the PSX we check for a fail ... in case we run out of mem (likely!)
		// well if it is good enough for the PSX it's good enough for the PC - John.
                                    if mapLoad(pFileData, fileSize) == 0 {
                                        debug(LOG_NEVER,
                                              b"loadgame: Fail7\n\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
                                        return 0 as libc::c_int
                                    }
                                    current_block = 16280550096250383041;
                                }
                            } else { current_block = 16280550096250383041; }
                            match current_block {
                                9873574167579496540 => { }
                                _ =>
                                //save game stuff added after map load
                                //	loadingScreenCallback();
                                {
                                    if saveGameVersion >=
                                           16 as libc::c_int as libc::c_uint {
                                        inc = 0 as libc::c_int as UDWORD;
                                        while inc <
                                                  9 as libc::c_int as
                                                      libc::c_uint {
                                            setNoGoArea(saveGameData.sLandingZone[inc
                                                                                      as
                                                                                      usize].x1,
                                                        saveGameData.sLandingZone[inc
                                                                                      as
                                                                                      usize].y1,
                                                        saveGameData.sLandingZone[inc
                                                                                      as
                                                                                      usize].x2,
                                                        saveGameData.sLandingZone[inc
                                                                                      as
                                                                                      usize].y2,
                                                        inc as UBYTE);
                                            inc = inc.wrapping_add(1)
                                        }
                                    }
                                    //adjust the scroll range for the new map or the expanded map
                                    setMapScroll();
                                    //initialise the Templates' build and power points before loading in any droids
                                    initTemplatePoints();
                                    //if user save game then load up the research BEFORE any droids or structures are loaded
                                    if gameType ==
                                           GTYPE_SAVE_START as libc::c_int as
                                               libc::c_uint ||
                                           gameType ==
                                               GTYPE_SAVE_MIDMISSION as
                                                   libc::c_int as libc::c_uint
                                       {
                                        //		loadingScreenCallback();
                                        //load in the research list file
                                        aFileName[fileExten as usize] =
                                            '\u{0}' as i32 as STRING;
                                        strcat(aFileName.as_mut_ptr(),
                                               b"resState.bjo\x00" as
                                                   *const u8 as
                                                   *const libc::c_char);
                                        // Load in the chosen file data
//#ifndef PSX
                                        pFileData = DisplayBuffer;
                                        if loadFileToBuffer(aFileName.as_mut_ptr(),
                                                            pFileData,
                                                            displayBufferSize,
                                                            &mut fileSize) ==
                                               0 {
                                            debug(LOG_NEVER,
                                                  b"loadgame: Fail32\n\x00" as
                                                      *const u8 as
                                                      *const libc::c_char);
                                            current_block =
                                                9873574167579496540;
                                        } else if !pFileData.is_null() {
                                            if loadSaveResearch(pFileData,
                                                                fileSize) == 0
                                               {
                                                debug(LOG_NEVER,
                                                      b"loadgame: Fail33\n\x00"
                                                          as *const u8 as
                                                          *const libc::c_char);
                                                current_block =
                                                    9873574167579496540;
                                            } else {
                                                current_block =
                                                    12234353528221127802;
                                            }
                                        } else {
                                            current_block =
                                                12234353528221127802;
                                        }
                                    } else {
                                        current_block = 12234353528221127802;
                                    }
                                    match current_block {
                                        9873574167579496540 => { }
                                        _ => {
                                            if IsScenario == 1 as libc::c_int
                                               {
                                                //#else
//		if (!LoadGameLoad(aFileName,&pFileData,&fileSize,UserSaveGame)) goto error;
//#endif
                                                //load the research status data
                                                //		loadingScreenCallback();
                                                //load in the droid initialisation file
                                                aFileName[fileExten as usize]
                                                    =
                                                    '\u{0}' as i32 as STRING;
                                                strcat(aFileName.as_mut_ptr(),
                                                       b"dinit.bjo\x00" as
                                                           *const u8 as
                                                           *const libc::c_char);
                                                /* Load in the chosen file data */
                                                pFileData = DisplayBuffer;
                                                if loadFileToBuffer(aFileName.as_mut_ptr(),
                                                                    pFileData,
                                                                    displayBufferSize,
                                                                    &mut fileSize)
                                                       == 0 {
                                                    debug(LOG_NEVER,
                                                          b"loadgame: Fail8\n\x00"
                                                              as *const u8 as
                                                              *const libc::c_char);
                                                    current_block =
                                                        9873574167579496540;
                                                } else if loadSaveDroidInit(pFileData,
                                                                            fileSize)
                                                              == 0 {
                                                    debug(LOG_NEVER,
                                                          b"loadgame: Fail10\n\x00"
                                                              as *const u8 as
                                                              *const libc::c_char);
                                                    current_block =
                                                        9873574167579496540;
                                                } else {
                                                    current_block =
                                                        18196689952765653975;
                                                }
                                            } else {
                                                //		loadingScreenCallback();
                                                //load in the droids
                                                aFileName[fileExten as usize]
                                                    =
                                                    '\u{0}' as i32 as STRING;
                                                if saveGameVersion <
                                                       27 as libc::c_int as
                                                           libc::c_uint {
                                                    //V27
                                                    strcat(aFileName.as_mut_ptr(),
                                                           b"droid.bjo\x00" as
                                                               *const u8 as
                                                               *const libc::c_char);
                                                } else {
                                                    strcat(aFileName.as_mut_ptr(),
                                                           b"unit.bjo\x00" as
                                                               *const u8 as
                                                               *const libc::c_char);
                                                }
                                                /* Load in the chosen file data */
                                                pFileData = DisplayBuffer;
                                                if loadFileToBuffer(aFileName.as_mut_ptr(),
                                                                    pFileData,
                                                                    displayBufferSize,
                                                                    &mut fileSize)
                                                       == 0 {
                                                    debug(LOG_NEVER,
                                                          b"loadgame: Fail11\n\x00"
                                                              as *const u8 as
                                                              *const libc::c_char);
                                                    current_block =
                                                        9873574167579496540;
                                                } else if loadSaveDroid(pFileData,
                                                                        fileSize,
                                                                        apsDroidLists.as_mut_ptr())
                                                              == 0 {
                                                    debug(LOG_NEVER,
                                                          b"loadgame: Fail12\n\x00"
                                                              as *const u8 as
                                                              *const libc::c_char);
                                                    current_block =
                                                        9873574167579496540;
                                                } else {
                                                    //load the data into apsDroidLists
		//ppsCurrentDroidLists = apsDroidLists;
                                                    /*after we've loaded in the units we need to redo the orientation because
        the direction may have been saved - we need to do it outside of the loop
        whilst the current map is valid for the units*/
                                                    player =
                                                        0 as libc::c_int as
                                                            UDWORD;
                                                    while player <
                                                              8 as libc::c_int
                                                                  as
                                                                  libc::c_uint
                                                          {
                                                        psCurr =
                                                            apsDroidLists[player
                                                                              as
                                                                              usize];
                                                        while !psCurr.is_null()
                                                              {
                                                            if !((*psCurr).droidType
                                                                     as
                                                                     libc::c_uint
                                                                     ==
                                                                     DROID_PERSON
                                                                         as
                                                                         libc::c_int
                                                                         as
                                                                         libc::c_uint
                                                                     ||
                                                                     cyborgDroid(psCurr)
                                                                         != 0
                                                                     ||
                                                                     (*psCurr).droidType
                                                                         as
                                                                         libc::c_uint
                                                                         ==
                                                                         DROID_TRANSPORTER
                                                                             as
                                                                             libc::c_int
                                                                             as
                                                                             libc::c_uint)
                                                               {
                                                                if (*psCurr).x
                                                                       as
                                                                       libc::c_int
                                                                       !=
                                                                       512 as
                                                                           libc::c_int
                                                                           *
                                                                           127
                                                                               as
                                                                               libc::c_int
                                                                   {
                                                                    updateDroidOrientation(psCurr);
                                                                }
                                                            }
                                                            psCurr =
                                                                (*psCurr).psNext
                                                        }
                                                        player =
                                                            player.wrapping_add(1)
                                                    }
                                                    //		loadingScreenCallback();
                                                    if saveGameVersion >=
                                                           12 as libc::c_int
                                                               as libc::c_uint
                                                       {
                                                        if saveGameOnMission
                                                               == 0 {
                                                            //load in the mission droids
                                                            aFileName[fileExten
                                                                          as
                                                                          usize]
                                                                =
                                                                '\u{0}' as i32
                                                                    as STRING;
                                                            if saveGameVersion
                                                                   <
                                                                   27 as
                                                                       libc::c_int
                                                                       as
                                                                       libc::c_uint
                                                               {
                                                                //V27
                                                                strcat(aFileName.as_mut_ptr(),
                                                                       b"mDroid.bjo\x00"
                                                                           as
                                                                           *const u8
                                                                           as
                                                                           *const libc::c_char);
                                                            } else {
                                                                strcat(aFileName.as_mut_ptr(),
                                                                       b"mUnit.bjo\x00"
                                                                           as
                                                                           *const u8
                                                                           as
                                                                           *const libc::c_char);
                                                            }
                                                            /* Load in the chosen file data */
                                                            pFileData =
                                                                DisplayBuffer;
                                                            if loadFileToBufferNoError(aFileName.as_mut_ptr(),
                                                                                       pFileData,
                                                                                       displayBufferSize,
                                                                                       &mut fileSize)
                                                                   != 0 {
                                                                //load the data into mission.apsDroidLists
					//ppsCurrentDroidLists = mission.apsDroidLists;
                                                                if loadSaveDroid(pFileData,
                                                                                 fileSize,
                                                                                 mission.apsDroidLists.as_mut_ptr())
                                                                       == 0 {
                                                                    debug(LOG_NEVER,
                                                                          b"loadgame: Fail12\n\x00"
                                                                              as
                                                                              *const u8
                                                                              as
                                                                              *const libc::c_char);
                                                                    current_block
                                                                        =
                                                                        9873574167579496540;
                                                                } else {
                                                                    current_block
                                                                        =
                                                                        18196689952765653975;
                                                                }
                                                            } else {
                                                                current_block
                                                                    =
                                                                    18196689952765653975;
                                                            }
                                                        } else {
                                                            current_block =
                                                                18196689952765653975;
                                                        }
                                                    } else {
                                                        current_block =
                                                            18196689952765653975;
                                                    }
                                                }
                                            }
                                            match current_block {
                                                9873574167579496540 => { }
                                                _ =>
                                                //	loadingScreenCallback();
                                                //21feb	if (saveGameOnMission && UserSaveGame)
//21feb	{
                                                {
                                                    if saveGameVersion >=
                                                           23 as libc::c_int
                                                               as libc::c_uint
                                                       {
                                                        //load in the limbo droids
                                                        aFileName[fileExten as
                                                                      usize] =
                                                            '\u{0}' as i32 as
                                                                STRING;
                                                        strcat(aFileName.as_mut_ptr(),
                                                               b"limbo.bjo\x00"
                                                                   as
                                                                   *const u8
                                                                   as
                                                                   *const libc::c_char);
                                                        /* Load in the chosen file data */
                                                        pFileData =
                                                            DisplayBuffer;
                                                        if loadFileToBufferNoError(aFileName.as_mut_ptr(),
                                                                                   pFileData,
                                                                                   displayBufferSize,
                                                                                   &mut fileSize)
                                                               != 0 {
                                                            //load the data into apsDroidLists
			//ppsCurrentDroidLists = apsLimboDroids;
                                                            if loadSaveDroid(pFileData,
                                                                             fileSize,
                                                                             apsLimboDroids.as_mut_ptr())
                                                                   == 0 {
                                                                debug(LOG_NEVER,
                                                                      b"loadgame: Fail12\n\x00"
                                                                          as
                                                                          *const u8
                                                                          as
                                                                          *const libc::c_char);
                                                                current_block
                                                                    =
                                                                    9873574167579496540;
                                                            } else {
                                                                current_block
                                                                    =
                                                                    15849589987095405551;
                                                            }
                                                        } else {
                                                            current_block =
                                                                15849589987095405551;
                                                        }
                                                    } else {
                                                        current_block =
                                                            15849589987095405551;
                                                    }
                                                    match current_block {
                                                        9873574167579496540 =>
                                                        {
                                                        }
                                                        _ =>
                                                        //	loadingScreenCallback();
                                                        //load in the features -do before the structures
                                                        {
                                                            aFileName[fileExten
                                                                          as
                                                                          usize]
                                                                =
                                                                '\u{0}' as i32
                                                                    as STRING;
                                                            strcat(aFileName.as_mut_ptr(),
                                                                   b"feat.bjo\x00"
                                                                       as
                                                                       *const u8
                                                                       as
                                                                       *const libc::c_char);
                                                            /* Load in the chosen file data */
                                                            pFileData =
                                                                DisplayBuffer;
                                                            if loadFileToBuffer(aFileName.as_mut_ptr(),
                                                                                pFileData,
                                                                                displayBufferSize,
                                                                                &mut fileSize)
                                                                   == 0 {
                                                                debug(LOG_NEVER,
                                                                      b"loadgame: Fail14\n\x00"
                                                                          as
                                                                          *const u8
                                                                          as
                                                                          *const libc::c_char);
                                                            } else if loadSaveFeature(pFileData,
                                                                                      fileSize)
                                                                          == 0
                                                             {
                                                                debug(LOG_NEVER,
                                                                      b"loadgame: Fail16\n\x00"
                                                                          as
                                                                          *const u8
                                                                          as
                                                                          *const libc::c_char);
                                                            } else {
                                                                //load the data into apsFeatureLists
                                                                //load droid templates moved from here to BEFORE any structures loaded in
                                                                //load in the structures
                                                                //	loadingScreenCallback();
                                                                aFileName[fileExten
                                                                              as
                                                                              usize]
                                                                    =
                                                                    '\u{0}' as
                                                                        i32 as
                                                                        STRING;
                                                                strcat(aFileName.as_mut_ptr(),
                                                                       b"struct.bjo\x00"
                                                                           as
                                                                           *const u8
                                                                           as
                                                                           *const libc::c_char);
                                                                /* Load in the chosen file data */
                                                                pFileData =
                                                                    DisplayBuffer;
                                                                if loadFileToBuffer(aFileName.as_mut_ptr(),
                                                                                    pFileData,
                                                                                    displayBufferSize,
                                                                                    &mut fileSize)
                                                                       == 0 {
                                                                    debug(LOG_NEVER,
                                                                          b"loadgame: Fail17\n\x00"
                                                                              as
                                                                              *const u8
                                                                              as
                                                                              *const libc::c_char);
                                                                } else if loadSaveStructure(pFileData,
                                                                                            fileSize)
                                                                              ==
                                                                              0
                                                                 {
                                                                    debug(LOG_NEVER,
                                                                          b"loadgame: Fail19\n\x00"
                                                                              as
                                                                              *const u8
                                                                              as
                                                                              *const libc::c_char);
                                                                } else {
                                                                    //load the data into apsStructLists
                                                                    //	loadingScreenCallback();
                                                                    if gameType
                                                                           ==
                                                                           GTYPE_SAVE_START
                                                                               as
                                                                               libc::c_int
                                                                               as
                                                                               libc::c_uint
                                                                           ||
                                                                           gameType
                                                                               ==
                                                                               GTYPE_SAVE_MIDMISSION
                                                                                   as
                                                                                   libc::c_int
                                                                                   as
                                                                                   libc::c_uint
                                                                       {
                                                                        pl =
                                                                            0
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                UDWORD;
                                                                        while pl
                                                                                  <
                                                                                  8
                                                                                      as
                                                                                      libc::c_int
                                                                                      as
                                                                                      libc::c_uint
                                                                              {
                                                                            // ajl. must do for every player to stop multiplay/pc players going gaga.
                                                                            //reverse the structure lists so the Research Facilities are in the same order as when saved
                                                                            reverseObjectList(&mut *apsStructLists.as_mut_ptr().offset(pl
                                                                                                                                           as
                                                                                                                                           isize)
                                                                                                  as
                                                                                                  *mut *mut STRUCTURE
                                                                                                  as
                                                                                                  *mut *mut BASE_OBJECT);
                                                                            pl
                                                                                =
                                                                                pl.wrapping_add(1)
                                                                        }
                                                                    }
                                                                    //if user save game then load up the current level for structs and components
                                                                    if gameType
                                                                           ==
                                                                           GTYPE_SAVE_START
                                                                               as
                                                                               libc::c_int
                                                                               as
                                                                               libc::c_uint
                                                                           ||
                                                                           gameType
                                                                               ==
                                                                               GTYPE_SAVE_MIDMISSION
                                                                                   as
                                                                                   libc::c_int
                                                                                   as
                                                                                   libc::c_uint
                                                                       {
                                                                        //		loadingScreenCallback();
                                                                        //load in the component list file
                                                                        aFileName[fileExten
                                                                                      as
                                                                                      usize]
                                                                            =
                                                                            '\u{0}'
                                                                                as
                                                                                i32
                                                                                as
                                                                                STRING;
                                                                        strcat(aFileName.as_mut_ptr(),
                                                                               b"compL.bjo\x00"
                                                                                   as
                                                                                   *const u8
                                                                                   as
                                                                                   *const libc::c_char);
                                                                        /* Load in the chosen file data */
                                                                        pFileData
                                                                            =
                                                                            DisplayBuffer;
                                                                        if loadFileToBuffer(aFileName.as_mut_ptr(),
                                                                                            pFileData,
                                                                                            displayBufferSize,
                                                                                            &mut fileSize)
                                                                               ==
                                                                               0
                                                                           {
                                                                            debug(LOG_NEVER,
                                                                                  b"loadgame: Fail26\n\x00"
                                                                                      as
                                                                                      *const u8
                                                                                      as
                                                                                      *const libc::c_char);
                                                                            current_block
                                                                                =
                                                                                9873574167579496540;
                                                                        } else {
                                                                            //load the component list data
                                                                            if !pFileData.is_null()
                                                                               {
                                                                                if loadSaveCompList(pFileData,
                                                                                                    fileSize)
                                                                                       ==
                                                                                       0
                                                                                   {
                                                                                    debug(LOG_NEVER,
                                                                                          b"loadgame: Fail28\n\x00"
                                                                                              as
                                                                                              *const u8
                                                                                              as
                                                                                              *const libc::c_char);
                                                                                    current_block
                                                                                        =
                                                                                        9873574167579496540;
                                                                                } else {
                                                                                    current_block
                                                                                        =
                                                                                        2885348163762349817;
                                                                                }
                                                                            } else {
                                                                                current_block
                                                                                    =
                                                                                    2885348163762349817;
                                                                            }
                                                                            match current_block
                                                                                {
                                                                                9873574167579496540
                                                                                =>
                                                                                {
                                                                                }
                                                                                _
                                                                                =>

                                                                                //		loadingScreenCallback();
                                                                                //load in the structure type list file
                                                                                {
                                                                                    aFileName[fileExten
                                                                                                  as
                                                                                                  usize]
                                                                                        =
                                                                                        '\u{0}'
                                                                                            as
                                                                                            i32
                                                                                            as
                                                                                            STRING;
                                                                                    strcat(aFileName.as_mut_ptr(),
                                                                                           b"strType.bjo\x00"
                                                                                               as
                                                                                               *const u8
                                                                                               as
                                                                                               *const libc::c_char);
                                                                                    /* Load in the chosen file data */
                                                                                    pFileData
                                                                                        =
                                                                                        DisplayBuffer;
                                                                                    if loadFileToBuffer(aFileName.as_mut_ptr(),
                                                                                                        pFileData,
                                                                                                        displayBufferSize,
                                                                                                        &mut fileSize)
                                                                                           ==
                                                                                           0
                                                                                       {
                                                                                        debug(LOG_NEVER,
                                                                                              b"loadgame: Fail29\n\x00"
                                                                                                  as
                                                                                                  *const u8
                                                                                                  as
                                                                                                  *const libc::c_char);
                                                                                        current_block
                                                                                            =
                                                                                            9873574167579496540;
                                                                                    } else if !pFileData.is_null()
                                                                                     {
                                                                                        if loadSaveStructTypeList(pFileData,
                                                                                                                  fileSize)
                                                                                               ==
                                                                                               0
                                                                                           {
                                                                                            debug(LOG_NEVER,
                                                                                                  b"loadgame: Fail31\n\x00"
                                                                                                      as
                                                                                                      *const u8
                                                                                                      as
                                                                                                      *const libc::c_char);
                                                                                            current_block
                                                                                                =
                                                                                                9873574167579496540;
                                                                                        } else {
                                                                                            current_block
                                                                                                =
                                                                                                5282966931892662513;
                                                                                        }
                                                                                    } else {
                                                                                        current_block
                                                                                            =
                                                                                            5282966931892662513;
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    } else {
                                                                        current_block
                                                                            =
                                                                            5282966931892662513;
                                                                    }
                                                                    match current_block
                                                                        {
                                                                        9873574167579496540
                                                                        => {
                                                                        }
                                                                        _ =>
                                                                        //load the structure type list data
                                                                        //	loadingScreenCallback();
                                                                        //#ifdef NEW_SAVE //V11 Save
                                                                        {
                                                                            if saveGameVersion
                                                                                   >=
                                                                                   11
                                                                                       as
                                                                                       libc::c_int
                                                                                       as
                                                                                       libc::c_uint
                                                                               {
                                                                                //if user save game then load up the Visibility
                                                                                if gameType
                                                                                       ==
                                                                                       GTYPE_SAVE_START
                                                                                           as
                                                                                           libc::c_int
                                                                                           as
                                                                                           libc::c_uint
                                                                                       ||
                                                                                       gameType
                                                                                           ==
                                                                                           GTYPE_SAVE_MIDMISSION
                                                                                               as
                                                                                               libc::c_int
                                                                                               as
                                                                                               libc::c_uint
                                                                                   {
                                                                                    //load in the visibility file
                                                                                    aFileName[fileExten
                                                                                                  as
                                                                                                  usize]
                                                                                        =
                                                                                        '\u{0}'
                                                                                            as
                                                                                            i32
                                                                                            as
                                                                                            STRING;
                                                                                    strcat(aFileName.as_mut_ptr(),
                                                                                           b"VisState.bjo\x00"
                                                                                               as
                                                                                               *const u8
                                                                                               as
                                                                                               *const libc::c_char);
                                                                                    // Load in the chosen file data
                                                                                    pFileData
                                                                                        =
                                                                                        DisplayBuffer;
                                                                                    if loadFileToBufferNoError(aFileName.as_mut_ptr(),
                                                                                                               pFileData,
                                                                                                               displayBufferSize,
                                                                                                               &mut fileSize)
                                                                                           !=
                                                                                           0
                                                                                       {
                                                                                        //load the visibility data
                                                                                        if !pFileData.is_null()
                                                                                           {
                                                                                            if readVisibilityData(pFileData,
                                                                                                                  fileSize)
                                                                                                   ==
                                                                                                   0
                                                                                               {
                                                                                                debug(LOG_NEVER,
                                                                                                      b"loadgame: Fail33\n\x00"
                                                                                                          as
                                                                                                          *const u8
                                                                                                          as
                                                                                                          *const libc::c_char);
                                                                                                current_block
                                                                                                    =
                                                                                                    9873574167579496540;
                                                                                            } else {
                                                                                                current_block
                                                                                                    =
                                                                                                    1693412874670514397;
                                                                                            }
                                                                                        } else {
                                                                                            current_block
                                                                                                =
                                                                                                1693412874670514397;
                                                                                        }
                                                                                    } else {
                                                                                        current_block
                                                                                            =
                                                                                            1693412874670514397;
                                                                                    }
                                                                                } else {
                                                                                    current_block
                                                                                        =
                                                                                        1693412874670514397;
                                                                                }
                                                                            } else {
                                                                                current_block
                                                                                    =
                                                                                    1693412874670514397;
                                                                            }
                                                                            match current_block
                                                                                {
                                                                                9873574167579496540
                                                                                =>
                                                                                {
                                                                                }
                                                                                _
                                                                                =>

                                                                                //#endif
                                                                                //	loadingScreenCallback();
                                                                                //#ifdef NEW_SAVE_V13 //V13 Save
                                                                                {
                                                                                    if saveGameVersion
                                                                                           >
                                                                                           12
                                                                                               as
                                                                                               libc::c_int
                                                                                               as
                                                                                               libc::c_uint
                                                                                       {
                                                                                        //if user save game then load up the Visibility
                                                                                        if gameType
                                                                                               ==
                                                                                               GTYPE_SAVE_START
                                                                                                   as
                                                                                                   libc::c_int
                                                                                                   as
                                                                                                   libc::c_uint
                                                                                               ||
                                                                                               gameType
                                                                                                   ==
                                                                                                   GTYPE_SAVE_MIDMISSION
                                                                                                       as
                                                                                                       libc::c_int
                                                                                                       as
                                                                                                       libc::c_uint
                                                                                           {
                                                                                            //load in the message list file
                                                                                            aFileName[fileExten
                                                                                                          as
                                                                                                          usize]
                                                                                                =
                                                                                                '\u{0}'
                                                                                                    as
                                                                                                    i32
                                                                                                    as
                                                                                                    STRING;
                                                                                            strcat(aFileName.as_mut_ptr(),
                                                                                                   b"prodState.bjo\x00"
                                                                                                       as
                                                                                                       *const u8
                                                                                                       as
                                                                                                       *const libc::c_char);
                                                                                            // Load in the chosen file data
                                                                                            pFileData
                                                                                                =
                                                                                                DisplayBuffer;
                                                                                            if loadFileToBufferNoError(aFileName.as_mut_ptr(),
                                                                                                                       pFileData,
                                                                                                                       displayBufferSize,
                                                                                                                       &mut fileSize)
                                                                                                   !=
                                                                                                   0
                                                                                               {
                                                                                                //load the visibility data
                                                                                                if !pFileData.is_null()
                                                                                                   {
                                                                                                    if loadSaveProduction(pFileData,
                                                                                                                          fileSize)
                                                                                                           ==
                                                                                                           0
                                                                                                       {
                                                                                                        debug(LOG_NEVER,
                                                                                                              b"loadgame: Fail33\n\x00"
                                                                                                                  as
                                                                                                                  *const u8
                                                                                                                  as
                                                                                                                  *const libc::c_char);
                                                                                                        current_block
                                                                                                            =
                                                                                                            9873574167579496540;
                                                                                                    } else {
                                                                                                        current_block
                                                                                                            =
                                                                                                            508140742962724306;
                                                                                                    }
                                                                                                } else {
                                                                                                    current_block
                                                                                                        =
                                                                                                        508140742962724306;
                                                                                                }
                                                                                            } else {
                                                                                                current_block
                                                                                                    =
                                                                                                    508140742962724306;
                                                                                            }
                                                                                        } else {
                                                                                            current_block
                                                                                                =
                                                                                                508140742962724306;
                                                                                        }
                                                                                    } else {
                                                                                        current_block
                                                                                            =
                                                                                            508140742962724306;
                                                                                    }
                                                                                    match current_block
                                                                                        {
                                                                                        9873574167579496540
                                                                                        =>
                                                                                        {
                                                                                        }
                                                                                        _
                                                                                        =>

                                                                                        //#endif
                                                                                        //	loadingScreenCallback();
                                                                                        {
                                                                                            if saveGameVersion
                                                                                                   >
                                                                                                   12
                                                                                                       as
                                                                                                       libc::c_int
                                                                                                       as
                                                                                                       libc::c_uint
                                                                                               {
                                                                                                //if user save game then load up the FX
                                                                                                if gameType
                                                                                                       ==
                                                                                                       GTYPE_SAVE_START
                                                                                                           as
                                                                                                           libc::c_int
                                                                                                           as
                                                                                                           libc::c_uint
                                                                                                       ||
                                                                                                       gameType
                                                                                                           ==
                                                                                                           GTYPE_SAVE_MIDMISSION
                                                                                                               as
                                                                                                               libc::c_int
                                                                                                               as
                                                                                                               libc::c_uint
                                                                                                   {
                                                                                                    //load in the message list file
                                                                                                    aFileName[fileExten
                                                                                                                  as
                                                                                                                  usize]
                                                                                                        =
                                                                                                        '\u{0}'
                                                                                                            as
                                                                                                            i32
                                                                                                            as
                                                                                                            STRING;
                                                                                                    strcat(aFileName.as_mut_ptr(),
                                                                                                           b"FXState.bjo\x00"
                                                                                                               as
                                                                                                               *const u8
                                                                                                               as
                                                                                                               *const libc::c_char);
                                                                                                    // Load in the chosen file data
                                                                                                    pFileData
                                                                                                        =
                                                                                                        DisplayBuffer;
                                                                                                    if loadFileToBufferNoError(aFileName.as_mut_ptr(),
                                                                                                                               pFileData,
                                                                                                                               displayBufferSize,
                                                                                                                               &mut fileSize)
                                                                                                           !=
                                                                                                           0
                                                                                                       {
                                                                                                        //load the fx data
                                                                                                        if !pFileData.is_null()
                                                                                                           {
                                                                                                            if readFXData(pFileData,
                                                                                                                          fileSize)
                                                                                                                   ==
                                                                                                                   0
                                                                                                               {
                                                                                                                debug(LOG_NEVER,
                                                                                                                      b"loadgame: Fail33\n\x00"
                                                                                                                          as
                                                                                                                          *const u8
                                                                                                                          as
                                                                                                                          *const libc::c_char);
                                                                                                                current_block
                                                                                                                    =
                                                                                                                    9873574167579496540;
                                                                                                            } else {
                                                                                                                current_block
                                                                                                                    =
                                                                                                                    17336618653903260752;
                                                                                                            }
                                                                                                        } else {
                                                                                                            current_block
                                                                                                                =
                                                                                                                17336618653903260752;
                                                                                                        }
                                                                                                    } else {
                                                                                                        current_block
                                                                                                            =
                                                                                                            17336618653903260752;
                                                                                                    }
                                                                                                } else {
                                                                                                    current_block
                                                                                                        =
                                                                                                        17336618653903260752;
                                                                                                }
                                                                                            } else {
                                                                                                current_block
                                                                                                    =
                                                                                                    17336618653903260752;
                                                                                            }
                                                                                            match current_block
                                                                                                {
                                                                                                9873574167579496540
                                                                                                =>
                                                                                                {
                                                                                                }
                                                                                                _
                                                                                                =>

                                                                                                //	loadingScreenCallback();
                                                                                                {
                                                                                                    if saveGameVersion
                                                                                                           >=
                                                                                                           16
                                                                                                               as
                                                                                                               libc::c_int
                                                                                                               as
                                                                                                               libc::c_uint
                                                                                                       {
                                                                                                        //if user save game then load up the FX
                                                                                                        if gameType
                                                                                                               ==
                                                                                                               GTYPE_SAVE_START
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   libc::c_uint
                                                                                                               ||
                                                                                                               gameType
                                                                                                                   ==
                                                                                                                   GTYPE_SAVE_MIDMISSION
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       libc::c_uint
                                                                                                           {
                                                                                                            //load in the message list file
                                                                                                            aFileName[fileExten
                                                                                                                          as
                                                                                                                          usize]
                                                                                                                =
                                                                                                                '\u{0}'
                                                                                                                    as
                                                                                                                    i32
                                                                                                                    as
                                                                                                                    STRING;
                                                                                                            strcat(aFileName.as_mut_ptr(),
                                                                                                                   b"Score.bjo\x00"
                                                                                                                       as
                                                                                                                       *const u8
                                                                                                                       as
                                                                                                                       *const libc::c_char);
                                                                                                            // Load in the chosen file data
                                                                                                            pFileData
                                                                                                                =
                                                                                                                DisplayBuffer;
                                                                                                            if loadFileToBufferNoError(aFileName.as_mut_ptr(),
                                                                                                                                       pFileData,
                                                                                                                                       displayBufferSize,
                                                                                                                                       &mut fileSize)
                                                                                                                   !=
                                                                                                                   0
                                                                                                               {
                                                                                                                //load the fx data
                                                                                                                if !pFileData.is_null()
                                                                                                                   {
                                                                                                                    if readScoreData(pFileData,
                                                                                                                                     fileSize)
                                                                                                                           ==
                                                                                                                           0
                                                                                                                       {
                                                                                                                        debug(LOG_NEVER,
                                                                                                                              b"loadgame: Fail33\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char);
                                                                                                                        current_block
                                                                                                                            =
                                                                                                                            9873574167579496540;
                                                                                                                    } else {
                                                                                                                        current_block
                                                                                                                            =
                                                                                                                            10325342238833500232;
                                                                                                                    }
                                                                                                                } else {
                                                                                                                    current_block
                                                                                                                        =
                                                                                                                        10325342238833500232;
                                                                                                                }
                                                                                                            } else {
                                                                                                                current_block
                                                                                                                    =
                                                                                                                    10325342238833500232;
                                                                                                            }
                                                                                                        } else {
                                                                                                            current_block
                                                                                                                =
                                                                                                                10325342238833500232;
                                                                                                        }
                                                                                                    } else {
                                                                                                        current_block
                                                                                                            =
                                                                                                            10325342238833500232;
                                                                                                    }
                                                                                                    match current_block
                                                                                                        {
                                                                                                        9873574167579496540
                                                                                                        =>
                                                                                                        {
                                                                                                        }
                                                                                                        _
                                                                                                        =>

                                                                                                        //	loadingScreenCallback();
                                                                                                        //#endif
//#ifdef NEW_SAVE_V12 //v12 Save
                                                                                                        {
                                                                                                            if saveGameVersion
                                                                                                                   >=
                                                                                                                   12
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       libc::c_uint
                                                                                                               {
                                                                                                                //if user save game then load up the flags AFTER any droids or structures are loaded
                                                                                                                if gameType
                                                                                                                       ==
                                                                                                                       GTYPE_SAVE_START
                                                                                                                           as
                                                                                                                           libc::c_int
                                                                                                                           as
                                                                                                                           libc::c_uint
                                                                                                                       ||
                                                                                                                       gameType
                                                                                                                           ==
                                                                                                                           GTYPE_SAVE_MIDMISSION
                                                                                                                               as
                                                                                                                               libc::c_int
                                                                                                                               as
                                                                                                                               libc::c_uint
                                                                                                                   {
                                                                                                                    //load in the flag list file
                                                                                                                    aFileName[fileExten
                                                                                                                                  as
                                                                                                                                  usize]
                                                                                                                        =
                                                                                                                        '\u{0}'
                                                                                                                            as
                                                                                                                            i32
                                                                                                                            as
                                                                                                                            STRING;
                                                                                                                    strcat(aFileName.as_mut_ptr(),
                                                                                                                           b"flagState.bjo\x00"
                                                                                                                               as
                                                                                                                               *const u8
                                                                                                                               as
                                                                                                                               *const libc::c_char);
                                                                                                                    // Load in the chosen file data
                                                                                                                    pFileData
                                                                                                                        =
                                                                                                                        DisplayBuffer;
                                                                                                                    if loadFileToBuffer(aFileName.as_mut_ptr(),
                                                                                                                                        pFileData,
                                                                                                                                        displayBufferSize,
                                                                                                                                        &mut fileSize)
                                                                                                                           ==
                                                                                                                           0
                                                                                                                       {
                                                                                                                        debug(LOG_NEVER,
                                                                                                                              b"loadMissionExtras: Fail 3\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char);
                                                                                                                        return 0
                                                                                                                                   as
                                                                                                                                   libc::c_int
                                                                                                                    }
                                                                                                                    //load the flag status data
                                                                                                                    if !pFileData.is_null()
                                                                                                                       {
                                                                                                                        if loadSaveFlag(pFileData,
                                                                                                                                        fileSize)
                                                                                                                               ==
                                                                                                                               0
                                                                                                                           {
                                                                                                                            debug(LOG_NEVER,
                                                                                                                                  b"loadMissionExtras: Fail 4\n\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char);
                                                                                                                            return 0
                                                                                                                                       as
                                                                                                                                       libc::c_int
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                            //	loadingScreenCallback();
                                                                                                            if saveGameVersion
                                                                                                                   >=
                                                                                                                   21
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       libc::c_uint
                                                                                                               {
                                                                                                                //rebuild the apsCommandDesignation AFTER all droids and structures are loaded
                                                                                                                if gameType
                                                                                                                       ==
                                                                                                                       GTYPE_SAVE_START
                                                                                                                           as
                                                                                                                           libc::c_int
                                                                                                                           as
                                                                                                                           libc::c_uint
                                                                                                                       ||
                                                                                                                       gameType
                                                                                                                           ==
                                                                                                                           GTYPE_SAVE_MIDMISSION
                                                                                                                               as
                                                                                                                               libc::c_int
                                                                                                                               as
                                                                                                                               libc::c_uint
                                                                                                                   {
                                                                                                                    //load in the command list file
                                                                                                                    aFileName[fileExten
                                                                                                                                  as
                                                                                                                                  usize]
                                                                                                                        =
                                                                                                                        '\u{0}'
                                                                                                                            as
                                                                                                                            i32
                                                                                                                            as
                                                                                                                            STRING;
                                                                                                                    strcat(aFileName.as_mut_ptr(),
                                                                                                                           b"command.bjo\x00"
                                                                                                                               as
                                                                                                                               *const u8
                                                                                                                               as
                                                                                                                               *const libc::c_char);
                                                                                                                    // Load in the chosen file data
                                                                                                                    pFileData
                                                                                                                        =
                                                                                                                        DisplayBuffer;
                                                                                                                    if loadFileToBuffer(aFileName.as_mut_ptr(),
                                                                                                                                        pFileData,
                                                                                                                                        displayBufferSize,
                                                                                                                                        &mut fileSize)
                                                                                                                           ==
                                                                                                                           0
                                                                                                                       {
                                                                                                                        debug(LOG_NEVER,
                                                                                                                              b"loadMissionExtras: Fail 5\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char);
                                                                                                                        return 0
                                                                                                                                   as
                                                                                                                                   libc::c_int
                                                                                                                    }
                                                                                                                    //load the command list data
                                                                                                                    if !pFileData.is_null()
                                                                                                                       {
                                                                                                                        if loadSaveCommandLists(pFileData,
                                                                                                                                                fileSize)
                                                                                                                               ==
                                                                                                                               0
                                                                                                                           {
                                                                                                                            debug(LOG_NEVER,
                                                                                                                                  b"loadMissionExtras: Fail 6\n\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char);
                                                                                                                            return 0
                                                                                                                                       as
                                                                                                                                       libc::c_int
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                            //	loadingScreenCallback();
                                                                                                            if saveGameVersion
                                                                                                                   >=
                                                                                                                   15
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       libc::c_uint
                                                                                                                   &&
                                                                                                                   UserSaveGame
                                                                                                                       !=
                                                                                                                       0
                                                                                                               {
                                                                                                                //load in the mission structures
                                                                                                                aFileName[fileExten
                                                                                                                              as
                                                                                                                              usize]
                                                                                                                    =
                                                                                                                    '\u{0}'
                                                                                                                        as
                                                                                                                        i32
                                                                                                                        as
                                                                                                                        STRING;
                                                                                                                strcat(aFileName.as_mut_ptr(),
                                                                                                                       b"limits.bjo\x00"
                                                                                                                           as
                                                                                                                           *const u8
                                                                                                                           as
                                                                                                                           *const libc::c_char);
                                                                                                                /* Load in the chosen file data */
                                                                                                                pFileData
                                                                                                                    =
                                                                                                                    DisplayBuffer;
                                                                                                                if loadFileToBuffer(aFileName.as_mut_ptr(),
                                                                                                                                    pFileData,
                                                                                                                                    displayBufferSize,
                                                                                                                                    &mut fileSize)
                                                                                                                       ==
                                                                                                                       0
                                                                                                                   {
                                                                                                                    debug(LOG_NEVER,
                                                                                                                          b"loadgame: Fail17\n\x00"
                                                                                                                              as
                                                                                                                              *const u8
                                                                                                                              as
                                                                                                                              *const libc::c_char);
                                                                                                                    current_block
                                                                                                                        =
                                                                                                                        9873574167579496540;
                                                                                                                } else if loadSaveStructLimits(pFileData,
                                                                                                                                               fileSize)
                                                                                                                              ==
                                                                                                                              0
                                                                                                                 {
                                                                                                                    debug(LOG_NEVER,
                                                                                                                          b"loadgame: Fail19\n\x00"
                                                                                                                              as
                                                                                                                              *const u8
                                                                                                                              as
                                                                                                                              *const libc::c_char);
                                                                                                                    current_block
                                                                                                                        =
                                                                                                                        9873574167579496540;
                                                                                                                } else {
                                                                                                                    //load the data into apsStructLists
                                                                                                                    //set up the structure Limits
                                                                                                                    setCurrentStructQuantity(0
                                                                                                                                                 as
                                                                                                                                                 libc::c_int);
                                                                                                                    current_block
                                                                                                                        =
                                                                                                                        12173671604335795711;
                                                                                                                }
                                                                                                            } else {
                                                                                                                //load in the structure limits
		//load the data into structLimits DONE IN SCRIPTS NOW so just init
                                                                                                                initStructLimits();
                                                                                                                //set up the structure Limits
                                                                                                                setCurrentStructQuantity(1
                                                                                                                                             as
                                                                                                                                             libc::c_int);
                                                                                                                current_block
                                                                                                                    =
                                                                                                                    12173671604335795711;
                                                                                                            }
                                                                                                            match current_block
                                                                                                                {
                                                                                                                9873574167579496540
                                                                                                                =>
                                                                                                                {
                                                                                                                }
                                                                                                                _
                                                                                                                =>

                                                                                                                //	loadingScreenCallback();
                                                                                                                //check that delivery points haven't been put down in invalid location
                                                                                                                {
                                                                                                                    checkDeliveryPoints(saveGameVersion);
                                                                                                                    if gameType
                                                                                                                           ==
                                                                                                                           GTYPE_SAVE_START
                                                                                                                               as
                                                                                                                               libc::c_int
                                                                                                                               as
                                                                                                                               libc::c_uint
                                                                                                                           ||
                                                                                                                           gameType
                                                                                                                               ==
                                                                                                                               GTYPE_SAVE_MIDMISSION
                                                                                                                                   as
                                                                                                                                   libc::c_int
                                                                                                                                   as
                                                                                                                                   libc::c_uint
                                                                                                                       {
                                                                                                                        //	loadingScreenCallback();
                                                                                                                        pl
                                                                                                                            =
                                                                                                                            0
                                                                                                                                as
                                                                                                                                libc::c_int
                                                                                                                                as
                                                                                                                                UDWORD;
                                                                                                                        while pl
                                                                                                                                  <
                                                                                                                                  8
                                                                                                                                      as
                                                                                                                                      libc::c_int
                                                                                                                                      as
                                                                                                                                      libc::c_uint
                                                                                                                              {
                                                                                                                            // ajl. must do for every player to stop multiplay/pc players going gaga.
                                                                                                                            //reverse the structure lists so the Research Facilities are in the same order as when saved
                                                                                                                            reverseTemplateList(&mut *apsDroidTemplates.as_mut_ptr().offset(pl
                                                                                                                                                                                                as
                                                                                                                                                                                                isize)
                                                                                                                                                    as
                                                                                                                                                    *mut *mut DROID_TEMPLATE);
                                                                                                                            pl
                                                                                                                                =
                                                                                                                                pl.wrapping_add(1)
                                                                                                                        }
                                                                                                                        //		loadingScreenCallback();
                                                                                                                        pl
                                                                                                                            =
                                                                                                                            0
                                                                                                                                as
                                                                                                                                libc::c_int
                                                                                                                                as
                                                                                                                                UDWORD;
                                                                                                                        while pl
                                                                                                                                  <
                                                                                                                                  8
                                                                                                                                      as
                                                                                                                                      libc::c_int
                                                                                                                                      as
                                                                                                                                      libc::c_uint
                                                                                                                              {
                                                                                                                            //reverse the droid lists so selections occur in the same order
                                                                                                                            reverseObjectList(&mut *apsLimboDroids.as_mut_ptr().offset(pl
                                                                                                                                                                                           as
                                                                                                                                                                                           isize)
                                                                                                                                                  as
                                                                                                                                                  *mut *mut DROID
                                                                                                                                                  as
                                                                                                                                                  *mut *mut BASE_OBJECT);
                                                                                                                            pl
                                                                                                                                =
                                                                                                                                pl.wrapping_add(1)
                                                                                                                        }
                                                                                                                        //		loadingScreenCallback();
                                                                                                                        pl
                                                                                                                            =
                                                                                                                            0
                                                                                                                                as
                                                                                                                                libc::c_int
                                                                                                                                as
                                                                                                                                UDWORD;
                                                                                                                        while pl
                                                                                                                                  <
                                                                                                                                  8
                                                                                                                                      as
                                                                                                                                      libc::c_int
                                                                                                                                      as
                                                                                                                                      libc::c_uint
                                                                                                                              {
                                                                                                                            //reverse the droid lists so selections occur in the same order
                                                                                                                            reverseObjectList(&mut *apsDroidLists.as_mut_ptr().offset(pl
                                                                                                                                                                                          as
                                                                                                                                                                                          isize)
                                                                                                                                                  as
                                                                                                                                                  *mut *mut DROID
                                                                                                                                                  as
                                                                                                                                                  *mut *mut BASE_OBJECT);
                                                                                                                            pl
                                                                                                                                =
                                                                                                                                pl.wrapping_add(1)
                                                                                                                        }
                                                                                                                        //		loadingScreenCallback();
                                                                                                                        pl
                                                                                                                            =
                                                                                                                            0
                                                                                                                                as
                                                                                                                                libc::c_int
                                                                                                                                as
                                                                                                                                UDWORD;
                                                                                                                        while pl
                                                                                                                                  <
                                                                                                                                  8
                                                                                                                                      as
                                                                                                                                      libc::c_int
                                                                                                                                      as
                                                                                                                                      libc::c_uint
                                                                                                                              {
                                                                                                                            //reverse the droid lists so selections occur in the same order
                                                                                                                            reverseObjectList(&mut *mission.apsDroidLists.as_mut_ptr().offset(pl
                                                                                                                                                                                                  as
                                                                                                                                                                                                  isize)
                                                                                                                                                  as
                                                                                                                                                  *mut *mut DROID
                                                                                                                                                  as
                                                                                                                                                  *mut *mut BASE_OBJECT);
                                                                                                                            pl
                                                                                                                                =
                                                                                                                                pl.wrapping_add(1)
                                                                                                                        }
                                                                                                                        //		loadingScreenCallback();
                                                                                                                        pl
                                                                                                                            =
                                                                                                                            0
                                                                                                                                as
                                                                                                                                libc::c_int
                                                                                                                                as
                                                                                                                                UDWORD;
                                                                                                                        while pl
                                                                                                                                  <
                                                                                                                                  8
                                                                                                                                      as
                                                                                                                                      libc::c_int
                                                                                                                                      as
                                                                                                                                      libc::c_uint
                                                                                                                              {
                                                                                                                            //reverse the struct lists so selections occur in the same order
                                                                                                                            reverseObjectList(&mut *mission.apsStructLists.as_mut_ptr().offset(pl
                                                                                                                                                                                                   as
                                                                                                                                                                                                   isize)
                                                                                                                                                  as
                                                                                                                                                  *mut *mut STRUCTURE
                                                                                                                                                  as
                                                                                                                                                  *mut *mut BASE_OBJECT);
                                                                                                                            pl
                                                                                                                                =
                                                                                                                                pl.wrapping_add(1)
                                                                                                                        }
                                                                                                                        //		loadingScreenCallback();
                                                                                                                        pl
                                                                                                                            =
                                                                                                                            0
                                                                                                                                as
                                                                                                                                libc::c_int
                                                                                                                                as
                                                                                                                                UDWORD;
                                                                                                                        while pl
                                                                                                                                  <
                                                                                                                                  8
                                                                                                                                      as
                                                                                                                                      libc::c_int
                                                                                                                                      as
                                                                                                                                      libc::c_uint
                                                                                                                              {
                                                                                                                            //reverse the droid lists so selections occur in the same order
                                                                                                                            reverseObjectList(&mut *apsFeatureLists.as_mut_ptr().offset(pl
                                                                                                                                                                                            as
                                                                                                                                                                                            isize)
                                                                                                                                                  as
                                                                                                                                                  *mut *mut FEATURE
                                                                                                                                                  as
                                                                                                                                                  *mut *mut BASE_OBJECT);
                                                                                                                            pl
                                                                                                                                =
                                                                                                                                pl.wrapping_add(1)
                                                                                                                        }
                                                                                                                        //		loadingScreenCallback();
                                                                                                                        pl
                                                                                                                            =
                                                                                                                            0
                                                                                                                                as
                                                                                                                                libc::c_int
                                                                                                                                as
                                                                                                                                UDWORD;
                                                                                                                        while pl
                                                                                                                                  <
                                                                                                                                  8
                                                                                                                                      as
                                                                                                                                      libc::c_int
                                                                                                                                      as
                                                                                                                                      libc::c_uint
                                                                                                                              {
                                                                                                                            //reverse the droid lists so selections occur in the same order
                                                                                                                            reverseObjectList(&mut *mission.apsFeatureLists.as_mut_ptr().offset(pl
                                                                                                                                                                                                    as
                                                                                                                                                                                                    isize)
                                                                                                                                                  as
                                                                                                                                                  *mut *mut FEATURE
                                                                                                                                                  as
                                                                                                                                                  *mut *mut BASE_OBJECT);
                                                                                                                            pl
                                                                                                                                =
                                                                                                                                pl.wrapping_add(1)
                                                                                                                        }
                                                                                                                    }
                                                                                                                    /* Reset the player AI */
                                                                                                                    playerReset();
                                                                                                                    //turn power on for rest of game
                                                                                                                    powerCalculated
                                                                                                                        =
                                                                                                                        1
                                                                                                                            as
                                                                                                                            libc::c_int;
                                                                                                                    //	loadingScreenCallback();
                                                                                                                    if saveGameVersion
                                                                                                                           >
                                                                                                                           12
                                                                                                                               as
                                                                                                                               libc::c_int
                                                                                                                               as
                                                                                                                               libc::c_uint
                                                                                                                       {
                                                                                                                        if keepObjects
                                                                                                                               ==
                                                                                                                               0
                                                                                                                           {
                                                                                                                            //only reset the pointers if they were set
                                                                                                                            //reset the object pointers in the droid target lists
                                                                                                                            loadDroidSetPointers();
                                                                                                                        }
                                                                                                                    }
                                                                                                                    //	loadingScreenCallback();
                                                                                                                    if saveGameVersion
                                                                                                                           >
                                                                                                                           20
                                                                                                                               as
                                                                                                                               libc::c_int
                                                                                                                               as
                                                                                                                               libc::c_uint
                                                                                                                       {
                                                                                                                        if keepObjects
                                                                                                                               ==
                                                                                                                               0
                                                                                                                           {
                                                                                                                            //only reset the pointers if they were set
                                                                                                                            //reset the object pointers in the structure lists
                                                                                                                            loadStructSetPointers();
                                                                                                                        }
                                                                                                                    }
                                                                                                                    //don't need to do this anymore - AB 22/04/98
	//set up the power levels for each player if not
	/*if (!keepObjects)
	{
		clearPlayerPower();
		initPlayerPower();
	}*/
                                                                                                                    //set all players to have some power at start - will be scripted!
	//newGameInitPower();
                                                                                                                    //set these values to suitable for first map - will be scripted!
	//setLandingZone(10,51,12,53);
                                                                                                                    //if user save game then reset the time - THIS SETS BOTH TIMERS - BEWARE IF YOU USE IT
                                                                                                                    if gameType
                                                                                                                           ==
                                                                                                                           GTYPE_SAVE_START
                                                                                                                               as
                                                                                                                               libc::c_int
                                                                                                                               as
                                                                                                                               libc::c_uint
                                                                                                                           ||
                                                                                                                           gameType
                                                                                                                               ==
                                                                                                                               GTYPE_SAVE_MIDMISSION
                                                                                                                                   as
                                                                                                                                   libc::c_int
                                                                                                                                   as
                                                                                                                                   libc::c_uint
                                                                                                                       {
                                                                                                                        if gameTime
                                                                                                                               ==
                                                                                                                               savedGameTime
                                                                                                                           {
                                                                                                                        } else {
                                                                                                                            debug(LOG_ERROR,
                                                                                                                                  b"loadGame; game time modified during load\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char); //added 14 may 98 JPS to solve kev's problem with no firing droids
                                                                                                                        };
                                                                                                                        if gameTime
                                                                                                                               ==
                                                                                                                               savedGameTime
                                                                                                                           {
                                                                                                                        } else {
                                                                                                                            debug(LOG_ERROR,
                                                                                                                                  b"Assert in Warzone: %s:%d : %s (%s)\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char,
                                                                                                                                  b"game.c\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char,
                                                                                                                                  2693
                                                                                                                                      as
                                                                                                                                      libc::c_int,
                                                                                                                                  (*::std::mem::transmute::<&[u8; 9],
                                                                                                                                                            &[libc::c_char; 9]>(b"loadGame\x00")).as_ptr(),
                                                                                                                                  b"gameTime == savedGameTime\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char);
                                                                                                                        };
                                                                                                                        gameTimeReset(savedGameTime);
                                                                                                                        //need to reset the event timer too - AB 14/01/99
                                                                                                                        eventTimeReset(savedGameTime.wrapping_div(100
                                                                                                                                                                      as
                                                                                                                                                                      libc::c_int
                                                                                                                                                                      as
                                                                                                                                                                      libc::c_uint));
                                                                                                                        //reset the objId for new objects
                                                                                                                        if saveGameVersion
                                                                                                                               >=
                                                                                                                               17
                                                                                                                                   as
                                                                                                                                   libc::c_int
                                                                                                                                   as
                                                                                                                                   libc::c_uint
                                                                                                                           {
                                                                                                                            objID
                                                                                                                                =
                                                                                                                                savedObjId
                                                                                                                        }
                                                                                                                    }
                                                                                                                    //check the research button isn't flashing unnecessarily
    //cancel first
                                                                                                                    stopReticuleButtonFlash(5
                                                                                                                                                as
                                                                                                                                                libc::c_int
                                                                                                                                                as
                                                                                                                                                UDWORD);
                                                                                                                    //then see if needs to be set
                                                                                                                    intCheckResearchButton();
                                                                                                                    //set up the mission countdown flag
                                                                                                                    setMissionCountDown();
                                                                                                                    /* Start the game clock */
                                                                                                                    gameTimeStart();
                                                                                                                    //after the clock has been reset need to check if any res_extractors are active
                                                                                                                    checkResExtractorsActive();
                                                                                                                    //#ifndef PSX
//	if (multiPlayerInUse)
//	{
//		bMultiPlayer = TRUE;				// reenable multi player messages.
//		multiPlayerInUse = FALSE;
//	}
//#endif
   //	initViewPosition();
                                                                                                                    setViewAngle(-(75
                                                                                                                                       as
                                                                                                                                       libc::c_int));
                                                                                                                    setDesiredPitch(325
                                                                                                                                        as
                                                                                                                                        libc::c_int);
                                                                                                                    //check if limbo_expand mission has changed to an expand mission for user save game (mid-mission)
                                                                                                                    if gameType
                                                                                                                           ==
                                                                                                                           GTYPE_SAVE_MIDMISSION
                                                                                                                               as
                                                                                                                               libc::c_int
                                                                                                                               as
                                                                                                                               libc::c_uint
                                                                                                                           &&
                                                                                                                           missionLimboExpand()
                                                                                                                               !=
                                                                                                                               0
                                                                                                                       {
                                                                                                                        /*when all the units have moved from the mission.apsDroidList then the
        campaign has been reset to an EXPAND type - OK so there should have
        been another flag to indicate this state has changed but its late in
        the day excuses...excuses...excuses*/
                                                                                                                        if mission.apsDroidLists[selectedPlayer
                                                                                                                                                     as
                                                                                                                                                     usize].is_null()
                                                                                                                           {
                                                                                                                            //set the mission type
                                                                                                                            startMissionSave(LDS_EXPAND
                                                                                                                                                 as
                                                                                                                                                 libc::c_int);
                                                                                                                        }
                                                                                                                    }
                                                                                                                    //set this if come into a save game mid mission
                                                                                                                    if gameType
                                                                                                                           ==
                                                                                                                           GTYPE_SAVE_MIDMISSION
                                                                                                                               as
                                                                                                                               libc::c_int
                                                                                                                               as
                                                                                                                               libc::c_uint
                                                                                                                       {
                                                                                                                        setScriptWinLoseVideo(0
                                                                                                                                                  as
                                                                                                                                                  libc::c_int
                                                                                                                                                  as
                                                                                                                                                  UBYTE);
                                                                                                                    }
                                                                                                                    //need to clear before setting up
                                                                                                                    clearMissionWidgets();
                                                                                                                    //put any widgets back on for the missions
                                                                                                                    resetMissionWidgets();
                                                                                                                    debug(LOG_NEVER,
                                                                                                                          b"loadGame: done\n\x00"
                                                                                                                              as
                                                                                                                              *const u8
                                                                                                                              as
                                                                                                                              *const libc::c_char);
                                                                                                                    return 1
                                                                                                                               as
                                                                                                                               libc::c_int
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        _ => { }
    }
    debug(LOG_NEVER,
          b"loadgame: ERROR\n\x00" as *const u8 as *const libc::c_char);
    /* Clear all the objects off the map and free up the map memory */
    freeAllDroids();
    freeAllStructs();
    freeAllFeatures();
    droidTemplateShutDown();
    !psMapTiles.is_null();
    if !aMapLinePoints.is_null() {
        memFreeRelease(aMapLinePoints as *mut libc::c_void);
        aMapLinePoints = 0 as *mut TILE_COORD
    }
    psMapTiles = 0 as *mut MAPTILE;
    aMapLinePoints = 0 as *mut TILE_COORD;
    /*if (!loadFile("blank.map", &pFileData, &fileSize))
	{
		return FALSE;
	}

	if (!mapLoad(pFileData, fileSize))
	{
		return FALSE;
	}

	FREE(pFileData);*/
    /* Start the game clock */
    gameTimeStart();
    //#ifndef PSX
//	if (multiPlayerInUse)
//	{
//		bMultiPlayer = TRUE;				// reenable multi player messages.
//		multiPlayerInUse = FALSE;
//	}
//#endif
    return 0 as libc::c_int;
}
// Modified by AlexL , now takes a filename, with no popup....
#[no_mangle]
pub unsafe extern "C" fn saveGame(mut aFileName: *mut STRING,
                                  mut saveType: SDWORD) -> BOOL {
    let mut current_block: u64;
    let mut fileExtension: UDWORD = 0;
    let mut psHeap: *mut BLOCK_HEAP = 0 as *mut BLOCK_HEAP;
    let mut psDroid: *mut DROID = 0 as *mut DROID;
    let mut psNext: *mut DROID = 0 as *mut DROID;
    strcpy(aFileName, unix_path(aFileName));
    psHeap = memGetBlockHeap();
    memSetBlockHeap(0 as *mut _block_heap);
    fileExtension =
        strlen(aFileName).wrapping_sub(3 as libc::c_int as libc::c_uint);
    gameTimeStop();
    /* Write the data to the file */
    if !(writeGameFile(aFileName, saveType) == 0) {
        //remove the file extension
        *aFileName.offset(strlen(aFileName).wrapping_sub(4 as libc::c_int as
                                                             libc::c_uint) as
                              isize) = '\u{0}' as i32 as STRING;
        //create dir will fail if directory already exists but don't care!
        PHYSFS_mkdir(aFileName);
        //save the map file
        strcat(aFileName, b"/\x00" as *const u8 as *const libc::c_char);
        strcat(aFileName,
               b"game.map\x00" as *const u8 as *const libc::c_char);
        /* Write the data to the file */
        if !(writeMapFile(aFileName) == 0) {
            //create the droids filename
            *aFileName.offset(fileExtension as isize) =
                '\u{0}' as i32 as STRING;
            strcat(aFileName,
                   b"unit.bjo\x00" as *const u8 as *const libc::c_char);
            /*Write the current droid lists to the file*/
	//ppsCurrentDroidLists = apsDroidLists;
            if !(writeDroidFile(aFileName, apsDroidLists.as_mut_ptr()) == 0) {
                //create the structures filename
                *aFileName.offset(fileExtension as isize) =
                    '\u{0}' as i32 as STRING;
                strcat(aFileName,
                       b"struct.bjo\x00" as *const u8 as *const libc::c_char);
                /*Write the data to the file*/
                if !(writeStructFile(aFileName) == 0) {
                    /*
    //we do this later on!!!!
	//create the production filename
	// aFileName[fileExtension] = '\0';
	strcat(aFileName, "prod.bjo");
	//Write the data to the file
	if (!writeProductionFile(aFileName))
	{
		goto error;
	}
*/
                    //create the templates filename
                    *aFileName.offset(fileExtension as isize) =
                        '\u{0}' as i32 as STRING;
                    strcat(aFileName,
                           b"templ.bjo\x00" as *const u8 as
                               *const libc::c_char);
                    /*Write the data to the file*/
                    if !(writeTemplateFile(aFileName) == 0) {
                        //create the features filename
                        *aFileName.offset(fileExtension as isize) =
                            '\u{0}' as i32 as STRING;
                        strcat(aFileName,
                               b"feat.bjo\x00" as *const u8 as
                                   *const libc::c_char);
                        /*Write the data to the file*/
                        if !(writeFeatureFile(aFileName) == 0) {
                            //create the terrain types filename
                            *aFileName.offset(fileExtension as isize) =
                                '\u{0}' as i32 as STRING;
                            strcat(aFileName,
                                   b"TTypes.ttp\x00" as *const u8 as
                                       *const libc::c_char);
                            /*Write the data to the file*/
                            if !(writeTerrainTypeMapFile(aFileName) == 0) {
                                //create the strucutLimits filename
                                *aFileName.offset(fileExtension as isize) =
                                    '\u{0}' as i32 as STRING;
                                strcat(aFileName,
                                       b"limits.bjo\x00" as *const u8 as
                                           *const libc::c_char);
                                /*Write the data to the file*/
                                if !(writeStructLimitsFile(aFileName) == 0) {
                                    //create the component lists filename
                                    *aFileName.offset(fileExtension as isize)
                                        = '\u{0}' as i32 as STRING;
                                    strcat(aFileName,
                                           b"CompL.bjo\x00" as *const u8 as
                                               *const libc::c_char);
                                    /*Write the data to the file*/
                                    if !(writeCompListFile(aFileName) == 0) {
                                        //create the structure type lists filename
                                        *aFileName.offset(fileExtension as
                                                              isize) =
                                            '\u{0}' as i32 as STRING;
                                        strcat(aFileName,
                                               b"StrType.bjo\x00" as *const u8
                                                   as *const libc::c_char);
                                        /*Write the data to the file*/
                                        if !(writeStructTypeListFile(aFileName)
                                                 == 0) {
                                            //create the research filename
                                            *aFileName.offset(fileExtension as
                                                                  isize) =
                                                '\u{0}' as i32 as STRING;
                                            strcat(aFileName,
                                                   b"ResState.bjo\x00" as
                                                       *const u8 as
                                                       *const libc::c_char);
                                            /*Write the data to the file*/
                                            if !(writeResearchFile(aFileName)
                                                     == 0) {
                                                //#ifdef NEW_SAVE //V11 Save
	//create the message filename
                                                *aFileName.offset(fileExtension
                                                                      as
                                                                      isize) =
                                                    '\u{0}' as i32 as STRING;
                                                strcat(aFileName,
                                                       b"MesState.bjo\x00" as
                                                           *const u8 as
                                                           *const libc::c_char);
                                                /*Write the data to the file*/
                                                if !(writeMessageFile(aFileName)
                                                         == 0) {
                                                    //#endif
                                                    //#ifdef NEW_SAVE //V14 Save
	//create the proximity message filename
                                                    *aFileName.offset(fileExtension
                                                                          as
                                                                          isize)
                                                        =
                                                        '\u{0}' as i32 as
                                                            STRING;
                                                    strcat(aFileName,
                                                           b"ProxState.bjo\x00"
                                                               as *const u8 as
                                                               *const libc::c_char);
                                                    /*Write the data to the file*/
                                                    if !(writeMessageFile(aFileName)
                                                             == 0) {
                                                        //#endif
                                                        //#ifdef NEW_SAVE //V11 Save
	//create the message filename
                                                        *aFileName.offset(fileExtension
                                                                              as
                                                                              isize)
                                                            =
                                                            '\u{0}' as i32 as
                                                                STRING;
                                                        strcat(aFileName,
                                                               b"VisState.bjo\x00"
                                                                   as
                                                                   *const u8
                                                                   as
                                                                   *const libc::c_char);
                                                        /*Write the data to the file*/
                                                        if !(writeVisibilityData(aFileName)
                                                                 == 0) {
                                                            //#endif
                                                            //#ifdef NEW_SAVE_V13 //V13 Save
	//create the message filename
                                                            *aFileName.offset(fileExtension
                                                                                  as
                                                                                  isize)
                                                                =
                                                                '\u{0}' as i32
                                                                    as STRING;
                                                            strcat(aFileName,
                                                                   b"ProdState.bjo\x00"
                                                                       as
                                                                       *const u8
                                                                       as
                                                                       *const libc::c_char);
                                                            /*Write the data to the file*/
                                                            if !(writeProductionFile(aFileName)
                                                                     == 0) {
                                                                //#endif
                                                                //#ifdef FX_SAVE //added at V13 save
	//create the message filename
                                                                *aFileName.offset(fileExtension
                                                                                      as
                                                                                      isize)
                                                                    =
                                                                    '\u{0}' as
                                                                        i32 as
                                                                        STRING;
                                                                strcat(aFileName,
                                                                       b"FXState.bjo\x00"
                                                                           as
                                                                           *const u8
                                                                           as
                                                                           *const libc::c_char);
                                                                /*Write the data to the file*/
                                                                if !(writeFXData(aFileName)
                                                                         == 0)
                                                                   {
                                                                    //#endif
                                                                    //added at V15 save
	//create the message filename
                                                                    *aFileName.offset(fileExtension
                                                                                          as
                                                                                          isize)
                                                                        =
                                                                        '\u{0}'
                                                                            as
                                                                            i32
                                                                            as
                                                                            STRING;
                                                                    strcat(aFileName,
                                                                           b"Score.bjo\x00"
                                                                               as
                                                                               *const u8
                                                                               as
                                                                               *const libc::c_char);
                                                                    /*Write the data to the file*/
                                                                    if !(writeScoreData(aFileName)
                                                                             ==
                                                                             0)
                                                                       {
                                                                        //#endif
                                                                        //#ifdef NEW_SAVE //V12 Save
	//create the message filename
                                                                        *aFileName.offset(fileExtension
                                                                                              as
                                                                                              isize)
                                                                            =
                                                                            '\u{0}'
                                                                                as
                                                                                i32
                                                                                as
                                                                                STRING;
                                                                        strcat(aFileName,
                                                                               b"FlagState.bjo\x00"
                                                                                   as
                                                                                   *const u8
                                                                                   as
                                                                                   *const libc::c_char);
                                                                        /*Write the data to the file*/
                                                                        if !(writeFlagFile(aFileName)
                                                                                 ==
                                                                                 0)
                                                                           {
                                                                            //#endif
                                                                            //#ifdef NEW_SAVE //V21 Save
	//create the message filename
                                                                            *aFileName.offset(fileExtension
                                                                                                  as
                                                                                                  isize)
                                                                                =
                                                                                '\u{0}'
                                                                                    as
                                                                                    i32
                                                                                    as
                                                                                    STRING;
                                                                            strcat(aFileName,
                                                                                   b"command.bjo\x00"
                                                                                       as
                                                                                       *const u8
                                                                                       as
                                                                                       *const libc::c_char);
                                                                            /*Write the data to the file*/
                                                                            if !(writeCommandLists(aFileName)
                                                                                     ==
                                                                                     0)
                                                                               {
                                                                                //#endif
                                                                                //create the structLimits filename
	/*aFileName[sOFN.nFileExtension] = '\0';
	strcat(aFileName, "limits.bjo");*/
	/*Write the data to the file DONE IN SCRIPTS NOW*/
	/*if (!writeStructLimitsFile(aFileName))
	{
		goto error;
	}*/
                                                                                // save the script state if necessary
                                                                                if saveType
                                                                                       ==
                                                                                       GTYPE_SAVE_MIDMISSION
                                                                                           as
                                                                                           libc::c_int
                                                                                   {
                                                                                    *aFileName.offset(fileExtension.wrapping_sub(1
                                                                                                                                     as
                                                                                                                                     libc::c_int
                                                                                                                                     as
                                                                                                                                     libc::c_uint)
                                                                                                          as
                                                                                                          isize)
                                                                                        =
                                                                                        '\u{0}'
                                                                                            as
                                                                                            i32
                                                                                            as
                                                                                            STRING;
                                                                                    strcat(aFileName,
                                                                                           b".es\x00"
                                                                                               as
                                                                                               *const u8
                                                                                               as
                                                                                               *const libc::c_char);
                                                                                    /*Write the data to the file*/
                                                                                    if writeScriptState(aFileName)
                                                                                           ==
                                                                                           0
                                                                                       {
                                                                                        current_block
                                                                                            =
                                                                                            11762449138341724283;
                                                                                    } else {
                                                                                        current_block
                                                                                            =
                                                                                            2168227384378665163;
                                                                                    }
                                                                                } else {
                                                                                    current_block
                                                                                        =
                                                                                        2168227384378665163;
                                                                                }
                                                                                match current_block
                                                                                    {
                                                                                    11762449138341724283
                                                                                    =>
                                                                                    {
                                                                                    }
                                                                                    _
                                                                                    =>
                                                                                    {
                                                                                        //create the droids filename
                                                                                        *aFileName.offset(fileExtension.wrapping_sub(1
                                                                                                                                         as
                                                                                                                                         libc::c_int
                                                                                                                                         as
                                                                                                                                         libc::c_uint)
                                                                                                              as
                                                                                                              isize)
                                                                                            =
                                                                                            '\u{0}'
                                                                                                as
                                                                                                i32
                                                                                                as
                                                                                                STRING;
                                                                                        strcat(aFileName,
                                                                                               b"\\mUnit.bjo\x00"
                                                                                                   as
                                                                                                   *const u8
                                                                                                   as
                                                                                                   *const libc::c_char);
                                                                                        /*Write the swapped droid lists to the file*/
	//ppsCurrentDroidLists = mission.apsDroidLists;
                                                                                        if !(writeDroidFile(aFileName,
                                                                                                            mission.apsDroidLists.as_mut_ptr())
                                                                                                 ==
                                                                                                 0)
                                                                                           {
                                                                                            //21feb now done always
	//create the limbo filename
	//clear the list
                                                                                            if saveGameVersion
                                                                                                   <
                                                                                                   25
                                                                                                       as
                                                                                                       libc::c_int
                                                                                                       as
                                                                                                       libc::c_uint
                                                                                               {
                                                                                                psDroid
                                                                                                    =
                                                                                                    apsLimboDroids[selectedPlayer
                                                                                                                       as
                                                                                                                       usize];
                                                                                                while !psDroid.is_null()
                                                                                                      {
                                                                                                    psNext
                                                                                                        =
                                                                                                        (*psDroid).psNext;
                                                                                                    //limbo list invalidate XY
                                                                                                    (*psDroid).x
                                                                                                        =
                                                                                                        (512
                                                                                                             as
                                                                                                             libc::c_int
                                                                                                             *
                                                                                                             127
                                                                                                                 as
                                                                                                                 libc::c_int)
                                                                                                            as
                                                                                                            UWORD;
                                                                                                    (*psDroid).y
                                                                                                        =
                                                                                                        (512
                                                                                                             as
                                                                                                             libc::c_int
                                                                                                             *
                                                                                                             127
                                                                                                                 as
                                                                                                                 libc::c_int)
                                                                                                            as
                                                                                                            UWORD;
                                                                                                    //this is mainly for VTOLs
                                                                                                    (*psDroid).psBaseStruct
                                                                                                        =
                                                                                                        0
                                                                                                            as
                                                                                                            *mut _structure;
                                                                                                    (*psDroid).cluster
                                                                                                        =
                                                                                                        0
                                                                                                            as
                                                                                                            libc::c_int
                                                                                                            as
                                                                                                            UBYTE;
                                                                                                    orderDroid(psDroid,
                                                                                                               DORDER_STOP);
                                                                                                    psDroid
                                                                                                        =
                                                                                                        psNext
                                                                                                }
                                                                                            }
                                                                                            *aFileName.offset(fileExtension
                                                                                                                  as
                                                                                                                  isize)
                                                                                                =
                                                                                                '\u{0}'
                                                                                                    as
                                                                                                    i32
                                                                                                    as
                                                                                                    STRING;
                                                                                            strcat(aFileName,
                                                                                                   b"limbo.bjo\x00"
                                                                                                       as
                                                                                                       *const u8
                                                                                                       as
                                                                                                       *const libc::c_char);
                                                                                            /*Write the swapped droid lists to the file*/
	//ppsCurrentDroidLists = apsLimboDroids;
                                                                                            if !(writeDroidFile(aFileName,
                                                                                                                apsLimboDroids.as_mut_ptr())
                                                                                                     ==
                                                                                                     0)
                                                                                               {
                                                                                                if saveGameOnMission
                                                                                                       !=
                                                                                                       0
                                                                                                   {
                                                                                                    //mission save swap the mission pointers and save the changes
                                                                                                    swapMissionPointers();
                                                                                                    //now save the map and droids
                                                                                                    //save the map file
                                                                                                    *aFileName.offset(fileExtension
                                                                                                                          as
                                                                                                                          isize)
                                                                                                        =
                                                                                                        '\u{0}'
                                                                                                            as
                                                                                                            i32
                                                                                                            as
                                                                                                            STRING;
                                                                                                    strcat(aFileName,
                                                                                                           b"mission.map\x00"
                                                                                                               as
                                                                                                               *const u8
                                                                                                               as
                                                                                                               *const libc::c_char);
                                                                                                    /* Write the data to the file */
                                                                                                    if writeMapFile(aFileName)
                                                                                                           ==
                                                                                                           0
                                                                                                       {
                                                                                                        current_block
                                                                                                            =
                                                                                                            11762449138341724283;
                                                                                                    } else {
                                                                                                        //save the map file
                                                                                                        *aFileName.offset(fileExtension
                                                                                                                              as
                                                                                                                              isize)
                                                                                                            =
                                                                                                            '\u{0}'
                                                                                                                as
                                                                                                                i32
                                                                                                                as
                                                                                                                STRING;
                                                                                                        strcat(aFileName,
                                                                                                               b"misvis.bjo\x00"
                                                                                                                   as
                                                                                                                   *const u8
                                                                                                                   as
                                                                                                                   *const libc::c_char);
                                                                                                        /* Write the data to the file */
                                                                                                        if writeVisibilityData(aFileName)
                                                                                                               ==
                                                                                                               0
                                                                                                           {
                                                                                                            current_block
                                                                                                                =
                                                                                                                11762449138341724283;
                                                                                                        } else {
                                                                                                            //create the structures filename
                                                                                                            *aFileName.offset(fileExtension
                                                                                                                                  as
                                                                                                                                  isize)
                                                                                                                =
                                                                                                                '\u{0}'
                                                                                                                    as
                                                                                                                    i32
                                                                                                                    as
                                                                                                                    STRING;
                                                                                                            strcat(aFileName,
                                                                                                                   b"mStruct.bjo\x00"
                                                                                                                       as
                                                                                                                       *const u8
                                                                                                                       as
                                                                                                                       *const libc::c_char);
                                                                                                            /*Write the data to the file*/
                                                                                                            if writeStructFile(aFileName)
                                                                                                                   ==
                                                                                                                   0
                                                                                                               {
                                                                                                                current_block
                                                                                                                    =
                                                                                                                    11762449138341724283;
                                                                                                            } else {
                                                                                                                //create the features filename
                                                                                                                *aFileName.offset(fileExtension
                                                                                                                                      as
                                                                                                                                      isize)
                                                                                                                    =
                                                                                                                    '\u{0}'
                                                                                                                        as
                                                                                                                        i32
                                                                                                                        as
                                                                                                                        STRING;
                                                                                                                strcat(aFileName,
                                                                                                                       b"mFeat.bjo\x00"
                                                                                                                           as
                                                                                                                           *const u8
                                                                                                                           as
                                                                                                                           *const libc::c_char);
                                                                                                                /*Write the data to the file*/
                                                                                                                if writeFeatureFile(aFileName)
                                                                                                                       ==
                                                                                                                       0
                                                                                                                   {
                                                                                                                    current_block
                                                                                                                        =
                                                                                                                        11762449138341724283;
                                                                                                                } else {
                                                                                                                    //create the message filename
                                                                                                                    *aFileName.offset(fileExtension
                                                                                                                                          as
                                                                                                                                          isize)
                                                                                                                        =
                                                                                                                        '\u{0}'
                                                                                                                            as
                                                                                                                            i32
                                                                                                                            as
                                                                                                                            STRING;
                                                                                                                    strcat(aFileName,
                                                                                                                           b"mFlagState.bjo\x00"
                                                                                                                               as
                                                                                                                               *const u8
                                                                                                                               as
                                                                                                                               *const libc::c_char);
                                                                                                                    /*Write the data to the file*/
                                                                                                                    if writeFlagFile(aFileName)
                                                                                                                           ==
                                                                                                                           0
                                                                                                                       {
                                                                                                                        current_block
                                                                                                                            =
                                                                                                                            11762449138341724283;
                                                                                                                    } else {
                                                                                                                        //mission save swap back so we can restart the game
                                                                                                                        swapMissionPointers();
                                                                                                                        current_block
                                                                                                                            =
                                                                                                                            14913924298693586572;
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                } else {
                                                                                                    current_block
                                                                                                        =
                                                                                                        14913924298693586572;
                                                                                                }
                                                                                                match current_block
                                                                                                    {
                                                                                                    11762449138341724283
                                                                                                    =>
                                                                                                    {
                                                                                                    }
                                                                                                    _
                                                                                                    =>
                                                                                                    {
                                                                                                        memSetBlockHeap(psHeap);
                                                                                                        /* Start the game clock */
                                                                                                        gameTimeStart();
                                                                                                        return 1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    memSetBlockHeap(psHeap);
    /* Start the game clock */
    gameTimeStart();
    return 0 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
unsafe extern "C" fn writeMapFile(mut pFileName: *mut STRING) -> BOOL {
    let mut pFileData: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut fileSize: UDWORD = 0;
    let mut status: BOOL = 1 as libc::c_int;
    /* Get the save data */
    status = mapSave(&mut pFileData, &mut fileSize);
    if status != 0 {
        /* Write the data to the file */
        status = saveFile(pFileName, pFileData, fileSize)
    }
    if !pFileData.is_null() {
        memFreeRelease(pFileData as *mut libc::c_void);
        pFileData = 0 as *mut libc::c_char
    }
    return status;
}
//direct access for forceloader
//static BOOL LoadGameFromWDG;
/* **************************************************************************/
/*
 *	Local ProtoTypes
 */
/* **************************************************************************/
// -----------------------------------------------------------------------------------------
#[no_mangle]
pub unsafe extern "C" fn gameLoad(mut pFileData: *mut libc::c_char,
                                  mut filesize: UDWORD) -> BOOL {
    let mut psHeader: *mut GAME_SAVEHEADER = 0 as *mut GAME_SAVEHEADER;
    /* Check the file type */
    psHeader = pFileData as *mut GAME_SAVEHEADER;
    if (*psHeader).aFileType[0 as libc::c_int as usize] as libc::c_int !=
           'g' as i32 ||
           (*psHeader).aFileType[1 as libc::c_int as usize] as libc::c_int !=
               'a' as i32 ||
           (*psHeader).aFileType[2 as libc::c_int as usize] as libc::c_int !=
               'm' as i32 ||
           (*psHeader).aFileType[3 as libc::c_int as usize] as libc::c_int !=
               'e' as i32 {
        debug(LOG_ERROR,
              b"gameLoad: Incorrect file type\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    /* GAME_SAVEHEADER */
    endian_udword(&mut (*psHeader).version);
    //increment to the start of the data
    pFileData = pFileData.offset(8 as libc::c_int as isize);
    debug(LOG_NEVER,
          b"gl .gam file is version %d\n\x00" as *const u8 as
              *const libc::c_char, (*psHeader).version);
    //set main version Id from game file
    saveGameVersion = (*psHeader).version;
    /* Check the file version */
    if (*psHeader).version < 7 as libc::c_int as libc::c_uint {
        debug(LOG_ERROR,
              b"gameLoad: unsupported save format version %d\x00" as *const u8
                  as *const libc::c_char, (*psHeader).version);
        abort();
    } else {
        if (*psHeader).version < 9 as libc::c_int as libc::c_uint {
            if gameLoadV7(pFileData, filesize) == 0 {
                return 0 as libc::c_int
            }
        } else if (*psHeader).version <= 33 as libc::c_int as libc::c_uint {
            if gameLoadV(pFileData, filesize, (*psHeader).version) == 0 {
                return 0 as libc::c_int
            }
        } else {
            debug(LOG_ERROR,
                  b"gameLoad: undefined save format version %d\x00" as
                      *const u8 as *const libc::c_char, (*psHeader).version);
            abort();
        }
    }
    //	DBMB(("IsScenario = %d\nfor the game that's being loaded.", IsScenario));
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
// Get campaign number stuff is not needed in this form on the PSX (thank you very much)
#[no_mangle]
pub unsafe extern "C" fn getCampaignV(mut pFileData: *mut libc::c_char,
                                      mut filesize: UDWORD,
                                      mut version: UDWORD) -> BOOL {
    let mut psSaveGame: *mut SAVE_GAME = 0 as *mut SAVE_GAME;
    let mut sizeOfSaveGame: UDWORD = 0 as libc::c_int as UDWORD;
    let mut campaign: UDWORD = 0;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    psSaveGame = pFileData as *mut SAVE_GAME;
    //size is now variable so only check old save games
    if version < 14 as libc::c_int as libc::c_uint {
        return 0 as libc::c_int
    } else {
        if version <= 16 as libc::c_int as libc::c_uint {
            sizeOfSaveGame =
                ::std::mem::size_of::<SAVE_GAME_V16>() as libc::c_ulong
        } else if version <= 17 as libc::c_int as libc::c_uint {
            sizeOfSaveGame =
                ::std::mem::size_of::<SAVE_GAME_V17>() as libc::c_ulong
        } else if version <= 18 as libc::c_int as libc::c_uint {
            sizeOfSaveGame =
                ::std::mem::size_of::<SAVE_GAME_V18>() as libc::c_ulong
        } else if version <= 19 as libc::c_int as libc::c_uint {
            sizeOfSaveGame =
                ::std::mem::size_of::<SAVE_GAME_V19>() as libc::c_ulong
        } else if version <= 21 as libc::c_int as libc::c_uint {
            sizeOfSaveGame =
                ::std::mem::size_of::<SAVE_GAME_V20>() as libc::c_ulong
        } else if version <= 23 as libc::c_int as libc::c_uint {
            sizeOfSaveGame =
                ::std::mem::size_of::<SAVE_GAME_V22>() as libc::c_ulong
        } else if version <= 26 as libc::c_int as libc::c_uint {
            sizeOfSaveGame =
                ::std::mem::size_of::<SAVE_GAME_V24>() as libc::c_ulong
        } else if version <= 28 as libc::c_int as libc::c_uint {
            sizeOfSaveGame =
                ::std::mem::size_of::<SAVE_GAME_V27>() as libc::c_ulong
        } else if version <= 29 as libc::c_int as libc::c_uint {
            sizeOfSaveGame =
                ::std::mem::size_of::<SAVE_GAME_V29>() as libc::c_ulong
        } else if version <= 30 as libc::c_int as libc::c_uint {
            sizeOfSaveGame =
                ::std::mem::size_of::<SAVE_GAME_V30>() as libc::c_ulong
        } else if version <= 32 as libc::c_int as libc::c_uint {
            sizeOfSaveGame =
                ::std::mem::size_of::<SAVE_GAME_V31>() as libc::c_ulong
        } else if version <= 33 as libc::c_int as libc::c_uint {
            sizeOfSaveGame =
                ::std::mem::size_of::<SAVE_GAME>() as libc::c_ulong
        }
    }
    if sizeOfSaveGame.wrapping_add(8 as libc::c_int as libc::c_uint) >
           filesize {
        debug(LOG_ERROR,
              b"getCampaign: unexpected end of file\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    /* SAVE_GAME is GAME_SAVE_V33 */
	/* GAME_SAVE_V33 includes GAME_SAVE_V31 */
    if version >= 33 as libc::c_int as libc::c_uint {
        endian_udword(&mut (*psSaveGame).sGame.power);
        endian_uword(&mut (*psSaveGame).sGame.bytesPerSec);
        i = 0 as libc::c_int;
        while i < 12 as libc::c_int {
            endian_sdword(&mut (*(*psSaveGame).sNetPlay.games.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize)).desc.dwSize);
            endian_sdword(&mut (*(*psSaveGame).sNetPlay.games.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize)).desc.dwFlags);
            endian_sdword(&mut (*(*psSaveGame).sNetPlay.games.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize)).desc.dwMaxPlayers);
            endian_sdword(&mut (*(*psSaveGame).sNetPlay.games.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize)).desc.dwCurrentPlayers);
            endian_sdword(&mut (*(*psSaveGame).sNetPlay.games.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize)).desc.dwUser1);
            endian_sdword(&mut (*(*psSaveGame).sNetPlay.games.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize)).desc.dwUser2);
            endian_sdword(&mut (*(*psSaveGame).sNetPlay.games.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize)).desc.dwUser3);
            endian_sdword(&mut (*(*psSaveGame).sNetPlay.games.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize)).desc.dwUser4);
            i += 1
        }
        i = 0 as libc::c_int;
        while i < 8 as libc::c_int {
            endian_sdword(&mut (*(*psSaveGame).sNetPlay.players.as_mut_ptr().offset(i
                                                                                        as
                                                                                        isize)).dpid);
            i += 1
        }
        endian_udword(&mut (*psSaveGame).sNetPlay.playercount);
        endian_sdword(&mut (*psSaveGame).sNetPlay.dpidPlayer);
        i = 0 as libc::c_int;
        while i < 4 as libc::c_int {
            endian_udword(&mut *(*psSaveGame).sNetPlay.cryptKey.as_mut_ptr().offset(i
                                                                                        as
                                                                                        isize));
            i += 1
        }
        endian_udword(&mut (*psSaveGame).savePlayer);
        i = 0 as libc::c_int;
        while i < 8 as libc::c_int {
            endian_sdword(&mut *(*psSaveGame).sPlayer2dpid.as_mut_ptr().offset(i
                                                                                   as
                                                                                   isize));
            i += 1
        }
    }
    /* GAME_SAVE_V31 includes GAME_SAVE_V30 */
    if version >= 31 as libc::c_int as libc::c_uint {
        endian_sdword(&mut (*psSaveGame).missionCheatTime);
    }
    /* GAME_SAVE_V30 includes GAME_SAVE_V29 */
    if version >= 30 as libc::c_int as libc::c_uint {
        endian_sdword(&mut (*psSaveGame).scrGameLevel);
    }
    /* GAME_SAVE_V29 includes GAME_SAVE_V27 */
    if version >= 29 as libc::c_int as libc::c_uint {
        endian_uword(&mut (*psSaveGame).missionScrollMinX);
        endian_uword(&mut (*psSaveGame).missionScrollMinY);
        endian_uword(&mut (*psSaveGame).missionScrollMaxX);
        endian_uword(&mut (*psSaveGame).missionScrollMaxY);
    }
    /* GAME_SAVE_V27 includes GAME_SAVE_V24 */
    if version >= 27 as libc::c_int as libc::c_uint {
        i = 0 as libc::c_int;
        while i < 8 as libc::c_int {
            j = 0 as libc::c_int;
            while j < 32 as libc::c_int {
                endian_uword(&mut *(*(*psSaveGame).awDroidExperience.as_mut_ptr().offset(i
                                                                                             as
                                                                                             isize)).as_mut_ptr().offset(j
                                                                                                                             as
                                                                                                                             isize));
                j += 1
            }
            i += 1
        }
    }
    /* GAME_SAVE_V24 includes GAME_SAVE_V22 */
    if version >= 24 as libc::c_int as libc::c_uint {
        endian_udword(&mut (*psSaveGame).reinforceTime);
    }
    /* GAME_SAVE_V22 includes GAME_SAVE_V20 */
    if version >= 22 as libc::c_int as libc::c_uint {
        i = 0 as libc::c_int;
        while i < 8 as libc::c_int {
            endian_sdword(&mut (*(*psSaveGame).asRunData.as_mut_ptr().offset(i
                                                                                 as
                                                                                 isize)).sPos.x);
            endian_sdword(&mut (*(*psSaveGame).asRunData.as_mut_ptr().offset(i
                                                                                 as
                                                                                 isize)).sPos.y);
            i += 1
        }
    }
    /* GAME_SAVE_V20 includes GAME_SAVE_V19 */
    if version >= 20 as libc::c_int as libc::c_uint {
        i = 0 as libc::c_int;
        while i < 8 as libc::c_int {
            endian_sdword(&mut (*(*psSaveGame).asVTOLReturnPos.as_mut_ptr().offset(i
                                                                                       as
                                                                                       isize)).x);
            endian_sdword(&mut (*(*psSaveGame).asVTOLReturnPos.as_mut_ptr().offset(i
                                                                                       as
                                                                                       isize)).y);
            i += 1
        }
    }
    /* GAME_SAVE_V19 includes GAME_SAVE_V18 */
    (version) >= 19 as libc::c_int as libc::c_uint;
    /* GAME_SAVE_V18 includes GAME_SAVE_V17 */
    if version >= 18 as libc::c_int as libc::c_uint {
        endian_udword(&mut (*psSaveGame).oldestVersion);
        endian_udword(&mut (*psSaveGame).validityKey);
    }
    /* GAME_SAVE_V17 includes GAME_SAVE_V16 */
    if version >= 17 as libc::c_int as libc::c_uint {
        endian_udword(&mut (*psSaveGame).objId);
    }
    /* GAME_SAVE_V16 includes GAME_SAVE_V15 */
    (version) >= 16 as libc::c_int as libc::c_uint;
    /* GAME_SAVE_V15 includes GAME_SAVE_V14 */
    if version >= 15 as libc::c_int as libc::c_uint {
        endian_udword(&mut (*psSaveGame).RubbleTile);
        endian_udword(&mut (*psSaveGame).WaterTile);
        endian_udword(&mut (*psSaveGame).fogColour);
        endian_udword(&mut (*psSaveGame).fogState);
    }
    /* GAME_SAVE_V14 includes GAME_SAVE_V12 */
    if version >= 14 as libc::c_int as libc::c_uint {
        endian_sdword(&mut (*psSaveGame).missionOffTime);
        endian_sdword(&mut (*psSaveGame).missionETA);
        endian_uword(&mut (*psSaveGame).missionHomeLZ_X);
        endian_uword(&mut (*psSaveGame).missionHomeLZ_Y);
        endian_sdword(&mut (*psSaveGame).missionPlayerX);
        endian_sdword(&mut (*psSaveGame).missionPlayerY);
        i = 0 as libc::c_int;
        while i < 8 as libc::c_int {
            endian_uword(&mut *(*psSaveGame).iTranspEntryTileX.as_mut_ptr().offset(i
                                                                                       as
                                                                                       isize));
            endian_uword(&mut *(*psSaveGame).iTranspEntryTileY.as_mut_ptr().offset(i
                                                                                       as
                                                                                       isize));
            endian_uword(&mut *(*psSaveGame).iTranspExitTileX.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize));
            endian_uword(&mut *(*psSaveGame).iTranspExitTileY.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize));
            endian_udword(&mut *(*psSaveGame).aDefaultSensor.as_mut_ptr().offset(i
                                                                                     as
                                                                                     isize));
            endian_udword(&mut *(*psSaveGame).aDefaultECM.as_mut_ptr().offset(i
                                                                                  as
                                                                                  isize));
            endian_udword(&mut *(*psSaveGame).aDefaultRepair.as_mut_ptr().offset(i
                                                                                     as
                                                                                     isize));
            i += 1
        }
    }
    /* GAME_SAVE_V12 includes GAME_SAVE_V11 */
    if version >= 12 as libc::c_int as libc::c_uint {
        endian_udword(&mut (*psSaveGame).missionTime);
        endian_udword(&mut (*psSaveGame).saveKey);
    }
    /* GAME_SAVE_V11 includes GAME_SAVE_V10 */
    if version >= 11 as libc::c_int as libc::c_uint {
        endian_sdword(&mut (*psSaveGame).currentPlayerPos.p.x);
        endian_sdword(&mut (*psSaveGame).currentPlayerPos.p.y);
        endian_sdword(&mut (*psSaveGame).currentPlayerPos.p.z);
        endian_sdword(&mut (*psSaveGame).currentPlayerPos.r.x);
        endian_sdword(&mut (*psSaveGame).currentPlayerPos.r.y);
        endian_sdword(&mut (*psSaveGame).currentPlayerPos.r.z);
    }
    /* GAME_SAVE_V10 includes GAME_SAVE_V7 */
    if version >= 10 as libc::c_int as libc::c_uint {
        i = 0 as libc::c_int;
        while i < 8 as libc::c_int {
            endian_udword(&mut (*(*psSaveGame).power.as_mut_ptr().offset(i as
                                                                             isize)).currentPower);
            endian_udword(&mut (*(*psSaveGame).power.as_mut_ptr().offset(i as
                                                                             isize)).extractedPower);
            i += 1
        }
    }
    /* GAME_SAVE_V7 */
    if version >= 7 as libc::c_int as libc::c_uint {
        endian_udword(&mut (*psSaveGame).gameTime);
        endian_udword(&mut (*psSaveGame).GameType);
        endian_sdword(&mut (*psSaveGame).ScrollMinX);
        endian_sdword(&mut (*psSaveGame).ScrollMinY);
        endian_udword(&mut (*psSaveGame).ScrollMaxX);
        endian_udword(&mut (*psSaveGame).ScrollMaxY);
    }
    //	savedGameTime = psSaveGame->gameTime;
    campaign = (*psSaveGame).saveKey;
    campaign &= (0x100 as libc::c_int - 1 as libc::c_int) as libc::c_uint;
    return campaign as BOOL;
}
// Get the campaign number for loadGameInit game
// -----------------------------------------------------------------------------------------
// Returns the campaign number  --- apparently this is does alot less than it look like
    // / it now does even less than it looks like on the psx ... cause its pc only
#[no_mangle]
pub unsafe extern "C" fn getCampaign(mut pGameToLoad: *mut STRING,
                                     mut bSkipCDCheck: *mut BOOL) -> UDWORD {
    let mut pFileData: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut fileSize: UDWORD = 0;
    let mut psHeader: *mut GAME_SAVEHEADER = 0 as *mut GAME_SAVEHEADER;
    /* Load in the chosen file data */
    pFileData = DisplayBuffer;
    if loadFileToBuffer(pGameToLoad, pFileData, displayBufferSize,
                        &mut fileSize) == 0 {
        debug(LOG_NEVER,
              b"loadgame: Fail2\n\x00" as *const u8 as *const libc::c_char);
        return 0 as libc::c_int as UDWORD
    }
    // loaded the .gam file so parse the data
	/* Check the file type */
    psHeader = pFileData as *mut GAME_SAVEHEADER;
    if (*psHeader).aFileType[0 as libc::c_int as usize] as libc::c_int !=
           'g' as i32 ||
           (*psHeader).aFileType[1 as libc::c_int as usize] as libc::c_int !=
               'a' as i32 ||
           (*psHeader).aFileType[2 as libc::c_int as usize] as libc::c_int !=
               'm' as i32 ||
           (*psHeader).aFileType[3 as libc::c_int as usize] as libc::c_int !=
               'e' as i32 {
        debug(LOG_ERROR,
              b"getCampaign: Incorrect file type\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    /* GAME_SAVEHEADER */
    endian_udword(&mut (*psHeader).version);
    //increment to the start of the data
    pFileData = pFileData.offset(8 as libc::c_int as isize);
    debug(LOG_NEVER,
          b"gl .gam file is version %d\n\x00" as *const u8 as
              *const libc::c_char, (*psHeader).version);
    //set main version Id from game file
    saveGameVersion = (*psHeader).version;
    /* Check the file version */
    if (*psHeader).version < 14 as libc::c_int as libc::c_uint {
        return 0 as libc::c_int as UDWORD
    } else {
        // what the arse bollocks is this
			// the campaign number is fine prior to saving
			// you save it out in a skirmish save and
			// then don't bother putting it back in again
			// when loading so it screws loads of stuff?!?
	// dont check skirmish saves.
        if (*psHeader).version >= 33 as libc::c_int as libc::c_uint {
            if (*(pFileData as *mut SAVE_GAME)).multiPlayer ==
                   1 as libc::c_int {
                //			return 0;
                *bSkipCDCheck = 1 as libc::c_int
            }
        }
    }
    if (*psHeader).version <= 33 as libc::c_int as libc::c_uint {
        return getCampaignV(pFileData, fileSize, (*psHeader).version) as
                   UDWORD
    } else {
        debug(LOG_ERROR,
              b"getCampaign: undefined save format version %d\x00" as
                  *const u8 as *const libc::c_char, (*psHeader).version);
        abort();
    };
}
/*set validty keys for save game debugging*/
// -----------------------------------------------------------------------------------------
#[no_mangle]
pub unsafe extern "C" fn game_SetValidityKey(mut keys: UDWORD) {
    validityKey = validityKey | keys;
}
// -----------------------------------------------------------------------------------------
/* code specific to version 7 of a save game */
unsafe extern "C" fn gameLoadV7(mut pFileData: *mut libc::c_char,
                                mut filesize: UDWORD) -> BOOL {
    let mut psSaveGame: *mut SAVE_GAME_V7 = 0 as *mut SAVE_GAME_V7;
    let mut psNewLevel: *mut LEVEL_DATASET = 0 as *mut LEVEL_DATASET;
    //	DBERROR(("gameLoadV7: this is and outdated save game"));
    psSaveGame = pFileData as *mut SAVE_GAME_V7;
    if (::std::mem::size_of::<SAVE_GAME_V7>() as
            libc::c_ulong).wrapping_add(8 as libc::c_int as libc::c_uint) >
           filesize {
        debug(LOG_ERROR,
              b"gameLoad: unexpected end of file\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    /* GAME_SAVE_V7 */
    endian_udword(&mut (*psSaveGame).gameTime);
    endian_udword(&mut (*psSaveGame).GameType);
    endian_sdword(&mut (*psSaveGame).ScrollMinX);
    endian_sdword(&mut (*psSaveGame).ScrollMinY);
    endian_udword(&mut (*psSaveGame).ScrollMaxX);
    endian_udword(&mut (*psSaveGame).ScrollMaxY);
    savedGameTime = (*psSaveGame).gameTime;
    //set the scroll varaibles
    startX = (*psSaveGame).ScrollMinX;
    startY = (*psSaveGame).ScrollMinY;
    width =
        (*psSaveGame).ScrollMaxX.wrapping_sub((*psSaveGame).ScrollMinX as
                                                  libc::c_uint);
    height =
        (*psSaveGame).ScrollMaxY.wrapping_sub((*psSaveGame).ScrollMinY as
                                                  libc::c_uint);
    gameType = (*psSaveGame).GameType;
    //set IsScenario to TRUE if not a user saved game
    if gameType == GTYPE_SAVE_START as libc::c_int as libc::c_uint {
        IsScenario = 0 as libc::c_int;
        //copy the level name across
        strcpy(pLevelName.as_mut_ptr(), (*psSaveGame).levelName.as_mut_ptr());
        //load up the level dataset
        if levLoadData(pLevelName.as_mut_ptr(), saveGameName.as_mut_ptr(),
                       gameType as SDWORD) == 0 {
            return 0 as libc::c_int
        }
        // find the level dataset
        if levFindDataSet(pLevelName.as_mut_ptr(), &mut psNewLevel) == 0 {
            debug(LOG_ERROR,
                  b"gameLoadV6: couldn\'t find level data\x00" as *const u8 as
                      *const libc::c_char);
            abort();
        }
        //check to see whether mission automatically starts
		//shouldn't be able to be any other value at the moment!
        if (*psNewLevel).type_0 as libc::c_int == LDS_CAMSTART as libc::c_int
               ||
               (*psNewLevel).type_0 as libc::c_int ==
                   LDS_BETWEEN as libc::c_int ||
               (*psNewLevel).type_0 as libc::c_int ==
                   LDS_EXPAND as libc::c_int ||
               (*psNewLevel).type_0 as libc::c_int ==
                   LDS_EXPAND_LIMBO as libc::c_int {
            launchMission();
        }
    } else { IsScenario = 1 as libc::c_int }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
/* non specific version of a save game */
unsafe extern "C" fn gameLoadV(mut pFileData: *mut libc::c_char,
                               mut filesize: UDWORD, mut version: UDWORD)
 -> BOOL {
    let mut psSaveGame: *mut SAVE_GAME = 0 as *mut SAVE_GAME;
    //	LEVEL_DATASET	*psNewLevel;
    let mut inc: UBYTE = 0;
    let mut i: SDWORD = 0;
    let mut j: SDWORD = 0;
    static mut powerSaved: [SAVE_POWER; 8] =
        [SAVE_POWER{currentPower: 0, extractedPower: 0,}; 8];
    let mut sizeOfSaveGame: UDWORD = 0 as libc::c_int as UDWORD;
    let mut player: UDWORD = 0;
    let mut date: [libc::c_char; 256] = [0; 256];
    psSaveGame = &mut saveGameData;
    memcpy(psSaveGame as *mut libc::c_void, pFileData as *const libc::c_void,
           ::std::mem::size_of::<SAVE_GAME>() as libc::c_ulong);
    //VERSION_7 AND EARLIER LOADED SEPARATELY
    //size is now variable so only check old save games
    if version <= 10 as libc::c_int as libc::c_uint {
        sizeOfSaveGame =
            ::std::mem::size_of::<SAVE_GAME_V10>() as libc::c_ulong
    } else if version == 11 as libc::c_int as libc::c_uint {
        sizeOfSaveGame =
            ::std::mem::size_of::<SAVE_GAME_V11>() as libc::c_ulong
    } else if version <= 12 as libc::c_int as libc::c_uint {
        sizeOfSaveGame =
            ::std::mem::size_of::<SAVE_GAME_V12>() as libc::c_ulong
    } else if version <= 14 as libc::c_int as libc::c_uint {
        sizeOfSaveGame =
            ::std::mem::size_of::<SAVE_GAME_V14>() as libc::c_ulong
    } else if version <= 15 as libc::c_int as libc::c_uint {
        sizeOfSaveGame =
            ::std::mem::size_of::<SAVE_GAME_V15>() as libc::c_ulong
    } else if version <= 16 as libc::c_int as libc::c_uint {
        sizeOfSaveGame =
            ::std::mem::size_of::<SAVE_GAME_V16>() as libc::c_ulong
    } else if version <= 17 as libc::c_int as libc::c_uint {
        sizeOfSaveGame =
            ::std::mem::size_of::<SAVE_GAME_V17>() as libc::c_ulong
    } else if version <= 18 as libc::c_int as libc::c_uint {
        sizeOfSaveGame =
            ::std::mem::size_of::<SAVE_GAME_V18>() as libc::c_ulong
    } else if version <= 19 as libc::c_int as libc::c_uint {
        sizeOfSaveGame =
            ::std::mem::size_of::<SAVE_GAME_V19>() as libc::c_ulong
    } else if version <= 21 as libc::c_int as libc::c_uint {
        sizeOfSaveGame =
            ::std::mem::size_of::<SAVE_GAME_V20>() as libc::c_ulong
    } else if version <= 23 as libc::c_int as libc::c_uint {
        sizeOfSaveGame =
            ::std::mem::size_of::<SAVE_GAME_V22>() as libc::c_ulong
    } else if version <= 26 as libc::c_int as libc::c_uint {
        sizeOfSaveGame =
            ::std::mem::size_of::<SAVE_GAME_V24>() as libc::c_ulong
    } else if version <= 28 as libc::c_int as libc::c_uint {
        sizeOfSaveGame =
            ::std::mem::size_of::<SAVE_GAME_V27>() as libc::c_ulong
    } else if version <= 29 as libc::c_int as libc::c_uint {
        sizeOfSaveGame =
            ::std::mem::size_of::<SAVE_GAME_V29>() as libc::c_ulong
    } else if version <= 30 as libc::c_int as libc::c_uint {
        sizeOfSaveGame =
            ::std::mem::size_of::<SAVE_GAME_V30>() as libc::c_ulong
    } else if version <= 32 as libc::c_int as libc::c_uint {
        sizeOfSaveGame =
            ::std::mem::size_of::<SAVE_GAME_V31>() as libc::c_ulong
    } else if version <= 33 as libc::c_int as libc::c_uint {
        sizeOfSaveGame = ::std::mem::size_of::<SAVE_GAME>() as libc::c_ulong
    }
    if sizeOfSaveGame.wrapping_add(8 as libc::c_int as libc::c_uint) >
           filesize {
        debug(LOG_ERROR,
              b"gameLoad: unexpected end of file\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    /* SAVE_GAME is GAME_SAVE_V33 */
	/* GAME_SAVE_V33 includes GAME_SAVE_V31 */
    if version >= 33 as libc::c_int as libc::c_uint {
        endian_udword(&mut (*psSaveGame).sGame.power);
        endian_uword(&mut (*psSaveGame).sGame.bytesPerSec);
        i = 0 as libc::c_int;
        while i < 12 as libc::c_int {
            endian_sdword(&mut (*(*psSaveGame).sNetPlay.games.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize)).desc.dwSize);
            endian_sdword(&mut (*(*psSaveGame).sNetPlay.games.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize)).desc.dwFlags);
            endian_sdword(&mut (*(*psSaveGame).sNetPlay.games.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize)).desc.dwMaxPlayers);
            endian_sdword(&mut (*(*psSaveGame).sNetPlay.games.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize)).desc.dwCurrentPlayers);
            endian_sdword(&mut (*(*psSaveGame).sNetPlay.games.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize)).desc.dwUser1);
            endian_sdword(&mut (*(*psSaveGame).sNetPlay.games.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize)).desc.dwUser2);
            endian_sdword(&mut (*(*psSaveGame).sNetPlay.games.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize)).desc.dwUser3);
            endian_sdword(&mut (*(*psSaveGame).sNetPlay.games.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize)).desc.dwUser4);
            i += 1
        }
        i = 0 as libc::c_int;
        while i < 8 as libc::c_int {
            endian_sdword(&mut (*(*psSaveGame).sNetPlay.players.as_mut_ptr().offset(i
                                                                                        as
                                                                                        isize)).dpid);
            i += 1
        }
        endian_udword(&mut (*psSaveGame).sNetPlay.playercount);
        endian_sdword(&mut (*psSaveGame).sNetPlay.dpidPlayer);
        i = 0 as libc::c_int;
        while i < 4 as libc::c_int {
            endian_udword(&mut *(*psSaveGame).sNetPlay.cryptKey.as_mut_ptr().offset(i
                                                                                        as
                                                                                        isize));
            i += 1
        }
        endian_udword(&mut (*psSaveGame).savePlayer);
        i = 0 as libc::c_int;
        while i < 8 as libc::c_int {
            endian_sdword(&mut *(*psSaveGame).sPlayer2dpid.as_mut_ptr().offset(i
                                                                                   as
                                                                                   isize));
            i += 1
        }
    }
    /* GAME_SAVE_V31 includes GAME_SAVE_V30 */
    if version >= 31 as libc::c_int as libc::c_uint {
        endian_sdword(&mut (*psSaveGame).missionCheatTime);
    }
    /* GAME_SAVE_V30 includes GAME_SAVE_V29 */
    if version >= 30 as libc::c_int as libc::c_uint {
        endian_sdword(&mut (*psSaveGame).scrGameLevel);
    }
    /* GAME_SAVE_V29 includes GAME_SAVE_V27 */
    if version >= 29 as libc::c_int as libc::c_uint {
        endian_uword(&mut (*psSaveGame).missionScrollMinX);
        endian_uword(&mut (*psSaveGame).missionScrollMinY);
        endian_uword(&mut (*psSaveGame).missionScrollMaxX);
        endian_uword(&mut (*psSaveGame).missionScrollMaxY);
    }
    /* GAME_SAVE_V27 includes GAME_SAVE_V24 */
    if version >= 27 as libc::c_int as libc::c_uint {
        i = 0 as libc::c_int;
        while i < 8 as libc::c_int {
            j = 0 as libc::c_int;
            while j < 32 as libc::c_int {
                endian_uword(&mut *(*(*psSaveGame).awDroidExperience.as_mut_ptr().offset(i
                                                                                             as
                                                                                             isize)).as_mut_ptr().offset(j
                                                                                                                             as
                                                                                                                             isize));
                j += 1
            }
            i += 1
        }
    }
    /* GAME_SAVE_V24 includes GAME_SAVE_V22 */
    if version >= 24 as libc::c_int as libc::c_uint {
        endian_udword(&mut (*psSaveGame).reinforceTime);
    }
    /* GAME_SAVE_V22 includes GAME_SAVE_V20 */
    if version >= 22 as libc::c_int as libc::c_uint {
        i = 0 as libc::c_int;
        while i < 8 as libc::c_int {
            endian_sdword(&mut (*(*psSaveGame).asRunData.as_mut_ptr().offset(i
                                                                                 as
                                                                                 isize)).sPos.x);
            endian_sdword(&mut (*(*psSaveGame).asRunData.as_mut_ptr().offset(i
                                                                                 as
                                                                                 isize)).sPos.y);
            i += 1
        }
    }
    /* GAME_SAVE_V20 includes GAME_SAVE_V19 */
    if version >= 20 as libc::c_int as libc::c_uint {
        i = 0 as libc::c_int;
        while i < 8 as libc::c_int {
            endian_sdword(&mut (*(*psSaveGame).asVTOLReturnPos.as_mut_ptr().offset(i
                                                                                       as
                                                                                       isize)).x);
            endian_sdword(&mut (*(*psSaveGame).asVTOLReturnPos.as_mut_ptr().offset(i
                                                                                       as
                                                                                       isize)).y);
            i += 1
        }
    }
    /* GAME_SAVE_V19 includes GAME_SAVE_V18 */
    (version) >= 19 as libc::c_int as libc::c_uint;
    /* GAME_SAVE_V18 includes GAME_SAVE_V17 */
    if version >= 18 as libc::c_int as libc::c_uint {
        endian_udword(&mut (*psSaveGame).oldestVersion);
        endian_udword(&mut (*psSaveGame).validityKey);
    }
    /* GAME_SAVE_V17 includes GAME_SAVE_V16 */
    if version >= 17 as libc::c_int as libc::c_uint {
        endian_udword(&mut (*psSaveGame).objId);
    }
    /* GAME_SAVE_V16 includes GAME_SAVE_V15 */
    (version) >= 16 as libc::c_int as libc::c_uint;
    /* GAME_SAVE_V15 includes GAME_SAVE_V14 */
    if version >= 15 as libc::c_int as libc::c_uint {
        endian_udword(&mut (*psSaveGame).RubbleTile);
        endian_udword(&mut (*psSaveGame).WaterTile);
        endian_udword(&mut (*psSaveGame).fogColour);
        endian_udword(&mut (*psSaveGame).fogState);
    }
    /* GAME_SAVE_V14 includes GAME_SAVE_V12 */
    if version >= 14 as libc::c_int as libc::c_uint {
        endian_sdword(&mut (*psSaveGame).missionOffTime);
        endian_sdword(&mut (*psSaveGame).missionETA);
        endian_uword(&mut (*psSaveGame).missionHomeLZ_X);
        endian_uword(&mut (*psSaveGame).missionHomeLZ_Y);
        endian_sdword(&mut (*psSaveGame).missionPlayerX);
        endian_sdword(&mut (*psSaveGame).missionPlayerY);
        i = 0 as libc::c_int;
        while i < 8 as libc::c_int {
            endian_uword(&mut *(*psSaveGame).iTranspEntryTileX.as_mut_ptr().offset(i
                                                                                       as
                                                                                       isize));
            endian_uword(&mut *(*psSaveGame).iTranspEntryTileY.as_mut_ptr().offset(i
                                                                                       as
                                                                                       isize));
            endian_uword(&mut *(*psSaveGame).iTranspExitTileX.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize));
            endian_uword(&mut *(*psSaveGame).iTranspExitTileY.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize));
            endian_udword(&mut *(*psSaveGame).aDefaultSensor.as_mut_ptr().offset(i
                                                                                     as
                                                                                     isize));
            endian_udword(&mut *(*psSaveGame).aDefaultECM.as_mut_ptr().offset(i
                                                                                  as
                                                                                  isize));
            endian_udword(&mut *(*psSaveGame).aDefaultRepair.as_mut_ptr().offset(i
                                                                                     as
                                                                                     isize));
            i += 1
        }
    }
    /* GAME_SAVE_V12 includes GAME_SAVE_V11 */
    if version >= 12 as libc::c_int as libc::c_uint {
        endian_udword(&mut (*psSaveGame).missionTime);
        endian_udword(&mut (*psSaveGame).saveKey);
    }
    /* GAME_SAVE_V11 includes GAME_SAVE_V10 */
    if version >= 11 as libc::c_int as libc::c_uint {
        endian_sdword(&mut (*psSaveGame).currentPlayerPos.p.x);
        endian_sdword(&mut (*psSaveGame).currentPlayerPos.p.y);
        endian_sdword(&mut (*psSaveGame).currentPlayerPos.p.z);
        endian_sdword(&mut (*psSaveGame).currentPlayerPos.r.x);
        endian_sdword(&mut (*psSaveGame).currentPlayerPos.r.y);
        endian_sdword(&mut (*psSaveGame).currentPlayerPos.r.z);
    }
    /* GAME_SAVE_V10 includes GAME_SAVE_V7 */
    if version >= 10 as libc::c_int as libc::c_uint {
        i = 0 as libc::c_int;
        while i < 8 as libc::c_int {
            endian_udword(&mut (*(*psSaveGame).power.as_mut_ptr().offset(i as
                                                                             isize)).currentPower);
            endian_udword(&mut (*(*psSaveGame).power.as_mut_ptr().offset(i as
                                                                             isize)).extractedPower);
            i += 1
        }
    }
    /* GAME_SAVE_V7 */
    if version >= 7 as libc::c_int as libc::c_uint {
        endian_udword(&mut (*psSaveGame).gameTime);
        endian_udword(&mut (*psSaveGame).GameType);
        endian_sdword(&mut (*psSaveGame).ScrollMinX);
        endian_sdword(&mut (*psSaveGame).ScrollMinY);
        endian_udword(&mut (*psSaveGame).ScrollMaxX);
        endian_udword(&mut (*psSaveGame).ScrollMaxY);
    }
    savedGameTime = (*psSaveGame).gameTime;
    if version >= 12 as libc::c_int as libc::c_uint {
        mission.startTime = (*psSaveGame).missionTime;
        if (*psSaveGame).saveKey & 0x100 as libc::c_int as libc::c_uint != 0 {
            saveGameOnMission = 1 as libc::c_int
        } else { saveGameOnMission = 0 as libc::c_int }
    } else { saveGameOnMission = 0 as libc::c_int }
    //set the scroll varaibles
    startX = (*psSaveGame).ScrollMinX;
    startY = (*psSaveGame).ScrollMinY;
    width =
        (*psSaveGame).ScrollMaxX.wrapping_sub((*psSaveGame).ScrollMinX as
                                                  libc::c_uint);
    height =
        (*psSaveGame).ScrollMaxY.wrapping_sub((*psSaveGame).ScrollMinY as
                                                  libc::c_uint);
    gameType = (*psSaveGame).GameType;
    if version >= 11 as libc::c_int as libc::c_uint {
        //camera position
        disp3d_setView(&mut (*psSaveGame).currentPlayerPos);
    }
    //load mission data from save game these values reloaded after load game
    if version >= 14 as libc::c_int as libc::c_uint {
        //mission data
        mission.time = (*psSaveGame).missionOffTime;
        mission.ETA = (*psSaveGame).missionETA;
        mission.homeLZ_X = (*psSaveGame).missionHomeLZ_X;
        mission.homeLZ_Y = (*psSaveGame).missionHomeLZ_Y;
        mission.playerX = (*psSaveGame).missionPlayerX;
        mission.playerY = (*psSaveGame).missionPlayerY;
        player = 0 as libc::c_int as UDWORD;
        while player < 8 as libc::c_int as libc::c_uint {
            mission.iTranspEntryTileX[player as usize] =
                (*psSaveGame).iTranspEntryTileX[player as usize];
            mission.iTranspEntryTileY[player as usize] =
                (*psSaveGame).iTranspEntryTileY[player as usize];
            mission.iTranspExitTileX[player as usize] =
                (*psSaveGame).iTranspExitTileX[player as usize];
            mission.iTranspExitTileY[player as usize] =
                (*psSaveGame).iTranspExitTileY[player as usize];
            aDefaultSensor[player as usize] =
                (*psSaveGame).aDefaultSensor[player as usize];
            aDefaultECM[player as usize] =
                (*psSaveGame).aDefaultECM[player as usize];
            aDefaultRepair[player as usize] =
                (*psSaveGame).aDefaultRepair[player as usize];
            player = player.wrapping_add(1)
        }
    }
    if version >= 15 as libc::c_int as libc::c_uint {
        offWorldKeepLists = (*psSaveGame).offWorldKeepLists;
        setRubbleTile((*psSaveGame).RubbleTile);
        setUnderwaterTile((*psSaveGame).WaterTile);
        if (*psSaveGame).fogState == 0 as libc::c_int as libc::c_uint {
            //no fog
            pie_EnableFog(0 as libc::c_int);
            fogStatus = 0 as libc::c_int as UDWORD
        } else if (*psSaveGame).fogState == 1 as libc::c_int as libc::c_uint {
            //fog using old code assume background and depth
            if war_GetFog() != 0 {
                pie_EnableFog(1 as libc::c_int);
            } else { pie_EnableFog(0 as libc::c_int); }
            fogStatus = (1 as libc::c_int + 2 as libc::c_int) as UDWORD
        } else {
            //version 18+ fog
            if war_GetFog() != 0 {
                pie_EnableFog(1 as
                                  libc::c_int); // this must be done before any new Ids added
            } else { pie_EnableFog(0 as libc::c_int); }
            fogStatus = (*psSaveGame).fogState;
            fogStatus &= 7 as libc::c_int as libc::c_uint
        }
        pie_SetFogColour((*psSaveGame).fogColour);
    }
    if version >= 17 as libc::c_int as libc::c_uint {
        objID = (*psSaveGame).objId;
        savedObjId = (*psSaveGame).objId
    }
    if version >= 18 as libc::c_int as libc::c_uint {
        //version 18
        validityKey = (*psSaveGame).validityKey;
        oldestSaveGameVersion = (*psSaveGame).oldestVersion;
        if oldestSaveGameVersion > version {
            oldestSaveGameVersion = version;
            validityKey = validityKey | 0x2 as libc::c_int as libc::c_uint
        } else if oldestSaveGameVersion < version {
            validityKey = validityKey | 0x2 as libc::c_int as libc::c_uint
        }
        strcpy(date.as_mut_ptr(),
               b"May 29 2020\x00" as *const u8 as *const libc::c_char);
        if strlen(date.as_mut_ptr()) < 256 as libc::c_int as libc::c_uint {
        } else {
            debug(LOG_ERROR,
                  b"BuildDate; String error\x00" as *const u8 as
                      *const libc::c_char);
        };
        if strlen(date.as_mut_ptr()) < 256 as libc::c_int as libc::c_uint {
        } else {
            debug(LOG_ERROR,
                  b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                      *const libc::c_char,
                  b"game.c\x00" as *const u8 as *const libc::c_char,
                  3959 as libc::c_int,
                  (*::std::mem::transmute::<&[u8; 10],
                                            &[libc::c_char; 10]>(b"gameLoadV\x00")).as_ptr(),
                  b"strlen(date)<MAX_STR_LENGTH\x00" as *const u8 as
                      *const libc::c_char);
        };
        if strcmp((*psSaveGame).buildDate.as_mut_ptr(), date.as_mut_ptr()) !=
               0 as libc::c_int {
            //			ASSERT( gameType != GTYPE_SAVE_MIDMISSION,"Mid-game save out of date. Continue with caution." );
            debug(LOG_NEVER,
                  b"saveGame build date differs;\nsavegame %s\n build    %s\n\x00"
                      as *const u8 as *const libc::c_char,
                  (*psSaveGame).buildDate.as_mut_ptr(), date.as_mut_ptr());
            validityKey = validityKey | 0x1 as libc::c_int as libc::c_uint;
            if gameType ==
                   GTYPE_SAVE_MIDMISSION as libc::c_int as libc::c_uint {
                validityKey =
                    validityKey | 0x10 as libc::c_int as libc::c_uint
            }
        }
    } else {
        debug(LOG_NEVER,
              b"saveGame build date differs;\nsavegame pre-Version 18 (%s)\n build    %s\n\x00"
                  as *const u8 as *const libc::c_char,
              (*psSaveGame).buildDate.as_mut_ptr(), date.as_mut_ptr());
        oldestSaveGameVersion = 1 as libc::c_int as UDWORD;
        validityKey = 0x1 as libc::c_int as UDWORD
    }
    if version >= 19 as libc::c_int as libc::c_uint {
        //version 19
        i = 0 as libc::c_int;
        while i < 8 as libc::c_int {
            j = 0 as libc::c_int;
            while j < 8 as libc::c_int {
                alliances[i as usize][j as usize] =
                    (*psSaveGame).alliances[i as usize][j as usize];
                j += 1
            }
            i += 1
        }
        i = 0 as libc::c_int;
        while i < 8 as libc::c_int {
            setPlayerColour(i as UDWORD,
                            (*psSaveGame).playerColour[i as usize] as UDWORD);
            i += 1
        }
        SetRadarZoom((*psSaveGame).radarZoom as UWORD);
    }
    if version >= 20 as libc::c_int as libc::c_uint {
        //version 20
        setDroidsToSafetyFlag((*psSaveGame).bDroidsToSafetyFlag as BOOL);
        inc = 0 as libc::c_int as UBYTE;
        while (inc as libc::c_int) < 8 as libc::c_int {
            memcpy(&mut *asVTOLReturnPos.as_mut_ptr().offset(inc as isize) as
                       *mut POINT as *mut libc::c_void,
                   &mut *(*psSaveGame).asVTOLReturnPos.as_mut_ptr().offset(inc
                                                                               as
                                                                               isize)
                       as *mut POINT as *const libc::c_void,
                   ::std::mem::size_of::<POINT>() as libc::c_ulong);
            inc = inc.wrapping_add(1)
        }
    }
    if version >= 22 as libc::c_int as libc::c_uint {
        //version 22
        inc = 0 as libc::c_int as UBYTE;
        while (inc as libc::c_int) < 8 as libc::c_int {
            memcpy(&mut *asRunData.as_mut_ptr().offset(inc as isize) as
                       *mut RUN_DATA as *mut libc::c_void,
                   &mut *(*psSaveGame).asRunData.as_mut_ptr().offset(inc as
                                                                         isize)
                       as *mut RUN_DATA as *const libc::c_void,
                   ::std::mem::size_of::<RUN_DATA>() as libc::c_ulong);
            inc = inc.wrapping_add(1)
        }
    }
    if saveGameVersion >= 24 as libc::c_int as libc::c_uint {
        //V24
        missionSetReinforcementTime((*psSaveGame).reinforceTime);
        // horrible hack to catch savegames that were saving garbage into these fields
        if (*psSaveGame).bPlayCountDown as libc::c_int <= 1 as libc::c_int {
            setPlayCountDown((*psSaveGame).bPlayCountDown);
        }
        if (*psSaveGame).bPlayerHasWon as libc::c_int <= 1 as libc::c_int {
            setPlayerHasWon((*psSaveGame).bPlayerHasWon as BOOL);
        }
        if (*psSaveGame).bPlayerHasLost as libc::c_int <= 1 as libc::c_int {
            setPlayerHasLost((*psSaveGame).bPlayerHasLost as BOOL);
        }
    }
    if saveGameVersion >= 29 as libc::c_int as libc::c_uint {
        mission.scrollMinX = (*psSaveGame).missionScrollMinX as UDWORD;
        mission.scrollMinY = (*psSaveGame).missionScrollMinY as UDWORD;
        mission.scrollMaxX = (*psSaveGame).missionScrollMaxX as UDWORD;
        mission.scrollMaxY = (*psSaveGame).missionScrollMaxY as UDWORD
    }
    if saveGameVersion >= 30 as libc::c_int as libc::c_uint {
        scrGameLevel = (*psSaveGame).scrGameLevel;
        bExtraVictoryFlag = (*psSaveGame).bExtraVictoryFlag as BOOL;
        bExtraFailFlag = (*psSaveGame).bExtraFailFlag as BOOL;
        bTrackTransporter = (*psSaveGame).bTrackTransporter as BOOL
    }
    if saveGameVersion >= 31 as libc::c_int as libc::c_uint {
        mission.cheatTime = (*psSaveGame).missionCheatTime as UDWORD
    }
    player = 0 as libc::c_int as UDWORD;
    while player < 8 as libc::c_int as libc::c_uint {
        inc = 0 as libc::c_int as UBYTE;
        while (inc as libc::c_int) < 32 as libc::c_int {
            aDroidExperience[player as usize][inc as usize] =
                0 as libc::c_int as UWORD;
            inc = inc.wrapping_add(1)
            //clear experience before
        }
        player = player.wrapping_add(1)
    }
    //set IsScenario to TRUE if not a user saved game
    if gameType == GTYPE_SAVE_START as libc::c_int as libc::c_uint ||
           gameType == GTYPE_SAVE_MIDMISSION as libc::c_int as libc::c_uint {
        inc = 0 as libc::c_int as UBYTE;
        while (inc as libc::c_int) < 8 as libc::c_int {
            powerSaved[inc as usize].currentPower =
                (*psSaveGame).power[inc as usize].currentPower;
            powerSaved[inc as usize].extractedPower =
                (*psSaveGame).power[inc as usize].extractedPower;
            inc = inc.wrapping_add(1)
        }
        player = 0 as libc::c_int as UDWORD;
        while player < 8 as libc::c_int as libc::c_uint {
            inc = 0 as libc::c_int as UBYTE;
            while (inc as libc::c_int) < 32 as libc::c_int {
                aDroidExperience[player as usize][inc as usize] =
                    0 as libc::c_int as UWORD;
                inc = inc.wrapping_add(1)
                //clear experience before building saved units
            }
            player = player.wrapping_add(1)
        }
        IsScenario = 0 as libc::c_int;
        //copy the level name across
        strcpy(pLevelName.as_mut_ptr(), (*psSaveGame).levelName.as_mut_ptr());
        //load up the level dataset
        if levLoadData(pLevelName.as_mut_ptr(), saveGameName.as_mut_ptr(),
                       gameType as SDWORD) == 0 {
            return 0 as libc::c_int
        }
        // find the level dataset
/*		if (!levFindDataSet(pLevelName, &psNewLevel))
		{
			DBERROR(("gameLoadV6: couldn't find level data"));
			return FALSE;
		}
		//check to see whether mission automatically starts
		if (gameType == GTYPE_SAVE_START)
		{
//			launchMission();
			if (!levLoadData(pLevelName, NULL, 0))
			{
				return FALSE;
			}
		}*/
        if saveGameVersion >= 33 as libc::c_int as libc::c_uint {
            let mut playerStats: PLAYERSTATS =
                PLAYERSTATS{played: 0,
                            wins: 0,
                            loses: 0,
                            totalKills: 0,
                            totalScore: 0,
                            recentKills: 0,
                            recentScore: 0,
                            killsToAdd: 0,
                            scoreToAdd: 0,}; // stats stuff
            bMultiPlayer = (*psSaveGame).multiPlayer;
            NetPlay = (*psSaveGame).sNetPlay;
            selectedPlayer = (*psSaveGame).savePlayer;
            productionPlayer = selectedPlayer as SBYTE;
            game = (*psSaveGame).sGame;
            cmdDroidMultiExpBoost(1 as libc::c_int);
            inc = 0 as libc::c_int as UBYTE;
            while (inc as libc::c_int) < 8 as libc::c_int {
                player2dpid[inc as usize] =
                    (*psSaveGame).sPlayer2dpid[inc as usize];
                inc = inc.wrapping_add(1)
            }
            if bMultiPlayer != 0 {
                blockSuspendUsage();
                loadMultiStats((*psSaveGame).sPName.as_mut_ptr(),
                               &mut playerStats);
                setMultiStats(NetPlay.dpidPlayer, playerStats,
                              0 as libc::c_int);
                setMultiStats(NetPlay.dpidPlayer, playerStats,
                              1 as libc::c_int);
                blockUnsuspendUsage();
            }
        }
    } else { IsScenario = 1 as libc::c_int }
    //don't adjust any power if a camStart (gameType is set to GTYPE_SCENARIO_START when a camChange saveGame is loaded)
    if gameType != GTYPE_SCENARIO_START as libc::c_int as libc::c_uint {
        //set the players power
        inc = 0 as libc::c_int as UBYTE;
        while (inc as libc::c_int) < 8 as libc::c_int {
            //only overwrite selectedPlayer's power on a startMission save game
            if gameType ==
                   GTYPE_SAVE_MIDMISSION as libc::c_int as libc::c_uint ||
                   inc as libc::c_uint == selectedPlayer {
                (*asPower[inc as usize]).currentPower =
                    powerSaved[inc as usize].currentPower;
                (*asPower[inc as usize]).extractedPower =
                    powerSaved[inc as usize].extractedPower
            }
            //init the last structure
            (*asPower[inc as usize]).psLastPowered = 0 as *mut _base_object;
            inc = inc.wrapping_add(1)
        }
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
/*
Writes the game specifics to a file
*/
unsafe extern "C" fn writeGameFile(mut pFileName: *mut STRING,
                                   mut saveType: SDWORD) -> BOOL {
    let mut pFileData: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut fileSize: UDWORD = 0;
    let mut inc: UDWORD = 0;
    let mut player: UDWORD = 0;
    let mut i: SDWORD = 0;
    let mut j: SDWORD = 0;
    let mut psHeader: *mut GAME_SAVEHEADER = 0 as *mut GAME_SAVEHEADER;
    let mut psSaveGame: *mut SAVE_GAME = 0 as *mut SAVE_GAME;
    let mut psLandingZone: *mut LANDING_ZONE = 0 as *mut LANDING_ZONE;
    let mut date: [libc::c_char; 20] = [0; 20];
    let mut status: BOOL = 1 as libc::c_int;
    if saveType == GTYPE_SAVE_START as libc::c_int ||
           saveType == GTYPE_SAVE_MIDMISSION as libc::c_int {
    } else {
        debug(LOG_ERROR,
              b"writeGameFile: invalid save type\x00" as *const u8 as
                  *const libc::c_char);
    };
    if saveType == GTYPE_SAVE_START as libc::c_int ||
           saveType == GTYPE_SAVE_MIDMISSION as libc::c_int {
    } else {
        debug(LOG_ERROR,
              b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                  *const libc::c_char,
              b"game.c\x00" as *const u8 as *const libc::c_char,
              4172 as libc::c_int,
              (*::std::mem::transmute::<&[u8; 14],
                                        &[libc::c_char; 14]>(b"writeGameFile\x00")).as_ptr(),
              b"saveType == GTYPE_SAVE_START || saveType == GTYPE_SAVE_MIDMISSION\x00"
                  as *const u8 as *const libc::c_char);
    };
    /* Allocate the data buffer */
    fileSize =
        (8 as libc::c_int as
             libc::c_uint).wrapping_add(::std::mem::size_of::<SAVE_GAME>() as
                                            libc::c_ulong);
    pFileData = memMallocRelease(fileSize) as *mut libc::c_char;
    if pFileData.is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        abort();
    }
    /* Put the file header on the file */
    psHeader = pFileData as *mut GAME_SAVEHEADER;
    (*psHeader).aFileType[0 as libc::c_int as usize] = 'g' as i32 as STRING;
    (*psHeader).aFileType[1 as libc::c_int as usize] = 'a' as i32 as STRING;
    (*psHeader).aFileType[2 as libc::c_int as usize] = 'm' as i32 as STRING;
    (*psHeader).aFileType[3 as libc::c_int as usize] = 'e' as i32 as STRING;
    (*psHeader).version = 33 as libc::c_int as UDWORD;
    psSaveGame =
        pFileData.offset(8 as libc::c_int as isize) as *mut SAVE_GAME;
    // saveKeymissionIsOffworld
    (*psSaveGame).saveKey = getCampaignNumber();
    if missionIsOffworld() != 0 {
        (*psSaveGame).saveKey |= 0x100 as libc::c_int as libc::c_uint;
        saveGameOnMission = 1 as libc::c_int
    } else { saveGameOnMission = 0 as libc::c_int }
    /* Put the save game data into the buffer */
    (*psSaveGame).gameTime = gameTime;
    (*psSaveGame).missionTime = mission.startTime;
    //put in the scroll data
    (*psSaveGame).ScrollMinX = scrollMinX;
    (*psSaveGame).ScrollMinY = scrollMinY;
    (*psSaveGame).ScrollMaxX = scrollMaxX as UDWORD;
    (*psSaveGame).ScrollMaxY = scrollMaxY as UDWORD;
    (*psSaveGame).GameType = saveType as UDWORD;
    //save the current level so we can load up the STARTING point of the mission
    if strlen(pLevelName.as_mut_ptr()) > 20 as libc::c_int as libc::c_uint {
        if 0 as libc::c_int != 0 {
        } else {
            debug(LOG_ERROR,
                  b"writeGameFile:Unable to save level name - too long (max20) - %s\x00"
                      as *const u8 as *const libc::c_char,
                  pLevelName.as_mut_ptr());
        };
        if 0 as libc::c_int != 0 {
        } else {
            debug(LOG_ERROR,
                  b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                      *const libc::c_char,
                  b"game.c\x00" as *const u8 as *const libc::c_char,
                  4225 as libc::c_int,
                  (*::std::mem::transmute::<&[u8; 14],
                                            &[libc::c_char; 14]>(b"writeGameFile\x00")).as_ptr(),
                  b"FALSE\x00" as *const u8 as *const libc::c_char);
        };
    } else {
        strcpy((*psSaveGame).levelName.as_mut_ptr(), pLevelName.as_mut_ptr());
        //save out the players power
        inc = 0 as libc::c_int as UDWORD;
        while inc < 8 as libc::c_int as libc::c_uint {
            (*psSaveGame).power[inc as usize].currentPower =
                (*asPower[inc as usize]).currentPower;
            (*psSaveGame).power[inc as usize].extractedPower =
                (*asPower[inc as usize]).extractedPower;
            inc = inc.wrapping_add(1)
        }
        //camera position
        disp3d_getView(&mut (*psSaveGame).currentPlayerPos);
        //mission data
//	psSaveGame->missionStartTime =		mission.startTime;
        (*psSaveGame).missionOffTime = mission.time; //incase struct changes
        (*psSaveGame).missionETA = mission.ETA;
        (*psSaveGame).missionCheatTime = mission.cheatTime as SDWORD;
        (*psSaveGame).missionHomeLZ_X = mission.homeLZ_X;
        (*psSaveGame).missionHomeLZ_Y = mission.homeLZ_Y;
        (*psSaveGame).missionPlayerX = mission.playerX;
        (*psSaveGame).missionPlayerY = mission.playerY;
        (*psSaveGame).missionScrollMinX = mission.scrollMinX as UWORD;
        (*psSaveGame).missionScrollMinY = mission.scrollMinY as UWORD;
        (*psSaveGame).missionScrollMaxX = mission.scrollMaxX as UWORD;
        (*psSaveGame).missionScrollMaxY = mission.scrollMaxY as UWORD;
        (*psSaveGame).offWorldKeepLists = offWorldKeepLists;
        (*psSaveGame).RubbleTile = getRubbleTileNum();
        (*psSaveGame).WaterTile = getWaterTileNum();
        (*psSaveGame).fogColour = pie_GetFogColour();
        (*psSaveGame).fogState = fogStatus;
        if pie_GetFogEnabled() != 0 {
            (*psSaveGame).fogState =
                fogStatus | 8 as libc::c_int as libc::c_uint
        }
        player = 0 as libc::c_int as UDWORD;
        while player < 8 as libc::c_int as libc::c_uint {
            (*psSaveGame).iTranspEntryTileX[player as usize] =
                mission.iTranspEntryTileX[player as usize];
            (*psSaveGame).iTranspEntryTileY[player as usize] =
                mission.iTranspEntryTileY[player as usize];
            (*psSaveGame).iTranspExitTileX[player as usize] =
                mission.iTranspExitTileX[player as usize];
            (*psSaveGame).iTranspExitTileY[player as usize] =
                mission.iTranspExitTileY[player as usize];
            (*psSaveGame).aDefaultSensor[player as usize] =
                aDefaultSensor[player as usize];
            (*psSaveGame).aDefaultECM[player as usize] =
                aDefaultECM[player as usize];
            (*psSaveGame).aDefaultRepair[player as usize] =
                aDefaultRepair[player as usize];
            inc = 0 as libc::c_int as UDWORD;
            while inc < 32 as libc::c_int as libc::c_uint {
                (*psSaveGame).awDroidExperience[player as usize][inc as usize]
                    = aDroidExperience[player as usize][inc as usize];
                inc = inc.wrapping_add(1)
            }
            player = player.wrapping_add(1)
        }
        inc = 0 as libc::c_int as UDWORD;
        while inc < 9 as libc::c_int as libc::c_uint {
            psLandingZone = getLandingZone(inc as SDWORD);
            (*psSaveGame).sLandingZone[inc as usize].x1 = (*psLandingZone).x1;
            (*psSaveGame).sLandingZone[inc as usize].x2 = (*psLandingZone).x2;
            (*psSaveGame).sLandingZone[inc as usize].y1 = (*psLandingZone).y1;
            (*psSaveGame).sLandingZone[inc as usize].y2 = (*psLandingZone).y2;
            inc = inc.wrapping_add(1)
        }
        //version 17
        (*psSaveGame).objId = objID;
        //version 18
        strcpy(date.as_mut_ptr(),
               b"May 29 2020\x00" as *const u8 as *const libc::c_char);
        if strlen(date.as_mut_ptr()) < 256 as libc::c_int as libc::c_uint {
        } else {
            debug(LOG_ERROR,
                  b"BuildDate; String error\x00" as *const u8 as
                      *const libc::c_char);
        };
        if strlen(date.as_mut_ptr()) < 256 as libc::c_int as libc::c_uint {
        } else {
            debug(LOG_ERROR,
                  b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                      *const libc::c_char,
                  b"game.c\x00" as *const u8 as *const libc::c_char,
                  4293 as libc::c_int,
                  (*::std::mem::transmute::<&[u8; 14],
                                            &[libc::c_char; 14]>(b"writeGameFile\x00")).as_ptr(),
                  b"strlen(date)<MAX_STR_LENGTH\x00" as *const u8 as
                      *const libc::c_char);
        };
        strcpy((*psSaveGame).buildDate.as_mut_ptr(), date.as_mut_ptr());
        (*psSaveGame).oldestVersion = oldestSaveGameVersion;
        (*psSaveGame).validityKey = validityKey;
        //version 19
        i = 0 as libc::c_int;
        while i < 8 as libc::c_int {
            j = 0 as libc::c_int;
            while j < 8 as libc::c_int {
                (*psSaveGame).alliances[i as usize][j as usize] =
                    alliances[i as usize][j as usize];
                j += 1
            }
            i += 1
        }
        i = 0 as libc::c_int;
        while i < 8 as libc::c_int {
            (*psSaveGame).playerColour[i as usize] =
                getPlayerColour(i as UDWORD);
            i += 1
        }
        (*psSaveGame).radarZoom = GetRadarZoom() as UBYTE;
        //version 20
        (*psSaveGame).bDroidsToSafetyFlag = getDroidsToSafetyFlag() as UBYTE;
        i = 0 as libc::c_int;
        while i < 8 as libc::c_int {
            memcpy(&mut *(*psSaveGame).asVTOLReturnPos.as_mut_ptr().offset(i
                                                                               as
                                                                               isize)
                       as *mut POINT as *mut libc::c_void,
                   &mut *asVTOLReturnPos.as_mut_ptr().offset(i as isize) as
                       *mut POINT as *const libc::c_void,
                   ::std::mem::size_of::<POINT>() as libc::c_ulong);
            i += 1
        }
        //version 22
        i = 0 as libc::c_int;
        while i < 8 as libc::c_int {
            memcpy(&mut *(*psSaveGame).asRunData.as_mut_ptr().offset(i as
                                                                         isize)
                       as *mut RUN_DATA as *mut libc::c_void,
                   &mut *asRunData.as_mut_ptr().offset(i as isize) as
                       *mut RUN_DATA as *const libc::c_void,
                   ::std::mem::size_of::<RUN_DATA>() as libc::c_ulong);
            i += 1
        }
        //version 24
        (*psSaveGame).reinforceTime = missionGetReinforcementTime();
        (*psSaveGame).bPlayCountDown = getPlayCountDown() as UBYTE;
        (*psSaveGame).bPlayerHasWon = testPlayerHasWon() as UBYTE;
        (*psSaveGame).bPlayerHasLost = testPlayerHasLost() as UBYTE;
        //version 30
        (*psSaveGame).scrGameLevel = scrGameLevel;
        (*psSaveGame).bExtraFailFlag = bExtraFailFlag as UBYTE;
        (*psSaveGame).bExtraVictoryFlag = bExtraVictoryFlag as UBYTE;
        (*psSaveGame).bTrackTransporter = bTrackTransporter as UBYTE;
        // version 33
        (*psSaveGame).sGame = game;
        (*psSaveGame).savePlayer = selectedPlayer;
        (*psSaveGame).multiPlayer = bMultiPlayer;
        (*psSaveGame).sNetPlay = NetPlay;
        strcpy((*psSaveGame).sPName.as_mut_ptr(),
               getPlayerName(selectedPlayer));
        inc = 0 as libc::c_int as UDWORD;
        while inc < 8 as libc::c_int as libc::c_uint {
            (*psSaveGame).sPlayer2dpid[inc as usize] =
                player2dpid[inc as usize];
            inc = inc.wrapping_add(1)
        }
        /* SAVE_GAME is GAME_SAVE_V33 */
	/* GAME_SAVE_V33 includes GAME_SAVE_V31 */
        endian_udword(&mut (*psSaveGame).sGame.power);
        endian_uword(&mut (*psSaveGame).sGame.bytesPerSec);
        i = 0 as libc::c_int;
        while i < 12 as libc::c_int {
            endian_sdword(&mut (*(*psSaveGame).sNetPlay.games.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize)).desc.dwSize);
            endian_sdword(&mut (*(*psSaveGame).sNetPlay.games.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize)).desc.dwFlags);
            endian_sdword(&mut (*(*psSaveGame).sNetPlay.games.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize)).desc.dwMaxPlayers);
            endian_sdword(&mut (*(*psSaveGame).sNetPlay.games.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize)).desc.dwCurrentPlayers);
            endian_sdword(&mut (*(*psSaveGame).sNetPlay.games.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize)).desc.dwUser1);
            endian_sdword(&mut (*(*psSaveGame).sNetPlay.games.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize)).desc.dwUser2);
            endian_sdword(&mut (*(*psSaveGame).sNetPlay.games.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize)).desc.dwUser3);
            endian_sdword(&mut (*(*psSaveGame).sNetPlay.games.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize)).desc.dwUser4);
            i += 1
        }
        i = 0 as libc::c_int;
        while i < 8 as libc::c_int {
            endian_sdword(&mut (*(*psSaveGame).sNetPlay.players.as_mut_ptr().offset(i
                                                                                        as
                                                                                        isize)).dpid);
            i += 1
        }
        endian_udword(&mut (*psSaveGame).sNetPlay.playercount);
        endian_sdword(&mut (*psSaveGame).sNetPlay.dpidPlayer);
        i = 0 as libc::c_int;
        while i < 4 as libc::c_int {
            endian_udword(&mut *(*psSaveGame).sNetPlay.cryptKey.as_mut_ptr().offset(i
                                                                                        as
                                                                                        isize));
            i += 1
        }
        endian_udword(&mut (*psSaveGame).savePlayer);
        i = 0 as libc::c_int;
        while i < 8 as libc::c_int {
            endian_sdword(&mut *(*psSaveGame).sPlayer2dpid.as_mut_ptr().offset(i
                                                                                   as
                                                                                   isize));
            i += 1
        }
        /* GAME_SAVE_V31 includes GAME_SAVE_V30 */
        endian_sdword(&mut (*psSaveGame).missionCheatTime);
        /* GAME_SAVE_V30 includes GAME_SAVE_V29 */
        endian_sdword(&mut (*psSaveGame).scrGameLevel);
        /* GAME_SAVE_V29 includes GAME_SAVE_V27 */
        endian_uword(&mut (*psSaveGame).missionScrollMinX);
        endian_uword(&mut (*psSaveGame).missionScrollMinY);
        endian_uword(&mut (*psSaveGame).missionScrollMaxX);
        endian_uword(&mut (*psSaveGame).missionScrollMaxY);
        /* GAME_SAVE_V27 includes GAME_SAVE_V24 */
        i = 0 as libc::c_int;
        while i < 8 as libc::c_int {
            j = 0 as libc::c_int;
            while j < 32 as libc::c_int {
                endian_uword(&mut *(*(*psSaveGame).awDroidExperience.as_mut_ptr().offset(i
                                                                                             as
                                                                                             isize)).as_mut_ptr().offset(j
                                                                                                                             as
                                                                                                                             isize));
                j += 1
            }
            i += 1
        }
        /* GAME_SAVE_V24 includes GAME_SAVE_V22 */
        endian_udword(&mut (*psSaveGame).reinforceTime);
        /* GAME_SAVE_V22 includes GAME_SAVE_V20 */
        i = 0 as libc::c_int;
        while i < 8 as libc::c_int {
            endian_sdword(&mut (*(*psSaveGame).asRunData.as_mut_ptr().offset(i
                                                                                 as
                                                                                 isize)).sPos.x);
            endian_sdword(&mut (*(*psSaveGame).asRunData.as_mut_ptr().offset(i
                                                                                 as
                                                                                 isize)).sPos.y);
            i += 1
        }
        /* GAME_SAVE_V20 includes GAME_SAVE_V19 */
        i = 0 as libc::c_int;
        while i < 8 as libc::c_int {
            endian_sdword(&mut (*(*psSaveGame).asVTOLReturnPos.as_mut_ptr().offset(i
                                                                                       as
                                                                                       isize)).x);
            endian_sdword(&mut (*(*psSaveGame).asVTOLReturnPos.as_mut_ptr().offset(i
                                                                                       as
                                                                                       isize)).y);
            i += 1
        }
        /* GAME_SAVE_V19 includes GAME_SAVE_V18 */
	/* GAME_SAVE_V18 includes GAME_SAVE_V17 */
        endian_udword(&mut (*psSaveGame).oldestVersion);
        endian_udword(&mut (*psSaveGame).validityKey);
        /* GAME_SAVE_V17 includes GAME_SAVE_V16 */
        endian_udword(&mut (*psSaveGame).objId);
        /* GAME_SAVE_V16 includes GAME_SAVE_V15 */
	/* GAME_SAVE_V15 includes GAME_SAVE_V14 */
        endian_udword(&mut (*psSaveGame).RubbleTile);
        endian_udword(&mut (*psSaveGame).WaterTile);
        endian_udword(&mut (*psSaveGame).fogColour);
        endian_udword(&mut (*psSaveGame).fogState);
        /* GAME_SAVE_V14 includes GAME_SAVE_V12 */
        endian_sdword(&mut (*psSaveGame).missionOffTime);
        endian_sdword(&mut (*psSaveGame).missionETA);
        endian_uword(&mut (*psSaveGame).missionHomeLZ_X);
        endian_uword(&mut (*psSaveGame).missionHomeLZ_Y);
        endian_sdword(&mut (*psSaveGame).missionPlayerX);
        endian_sdword(&mut (*psSaveGame).missionPlayerY);
        i = 0 as libc::c_int;
        while i < 8 as libc::c_int {
            endian_uword(&mut *(*psSaveGame).iTranspEntryTileX.as_mut_ptr().offset(i
                                                                                       as
                                                                                       isize));
            endian_uword(&mut *(*psSaveGame).iTranspEntryTileY.as_mut_ptr().offset(i
                                                                                       as
                                                                                       isize));
            endian_uword(&mut *(*psSaveGame).iTranspExitTileX.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize));
            endian_uword(&mut *(*psSaveGame).iTranspExitTileY.as_mut_ptr().offset(i
                                                                                      as
                                                                                      isize));
            endian_udword(&mut *(*psSaveGame).aDefaultSensor.as_mut_ptr().offset(i
                                                                                     as
                                                                                     isize));
            endian_udword(&mut *(*psSaveGame).aDefaultECM.as_mut_ptr().offset(i
                                                                                  as
                                                                                  isize));
            endian_udword(&mut *(*psSaveGame).aDefaultRepair.as_mut_ptr().offset(i
                                                                                     as
                                                                                     isize));
            i += 1
        }
        /* GAME_SAVE_V12 includes GAME_SAVE_V11 */
        endian_udword(&mut (*psSaveGame).missionTime);
        endian_udword(&mut (*psSaveGame).saveKey);
        /* GAME_SAVE_V11 includes GAME_SAVE_V10 */
        endian_sdword(&mut (*psSaveGame).currentPlayerPos.p.x);
        endian_sdword(&mut (*psSaveGame).currentPlayerPos.p.y);
        endian_sdword(&mut (*psSaveGame).currentPlayerPos.p.z);
        endian_sdword(&mut (*psSaveGame).currentPlayerPos.r.x);
        endian_sdword(&mut (*psSaveGame).currentPlayerPos.r.y);
        endian_sdword(&mut (*psSaveGame).currentPlayerPos.r.z);
        /* GAME_SAVE_V10 includes GAME_SAVE_V7 */
        i = 0 as libc::c_int;
        while i < 8 as libc::c_int {
            endian_udword(&mut (*(*psSaveGame).power.as_mut_ptr().offset(i as
                                                                             isize)).currentPower);
            endian_udword(&mut (*(*psSaveGame).power.as_mut_ptr().offset(i as
                                                                             isize)).extractedPower);
            i += 1
        }
        /* GAME_SAVE_V7 */
        endian_udword(&mut (*psSaveGame).gameTime);
        endian_udword(&mut (*psSaveGame).GameType);
        endian_sdword(&mut (*psSaveGame).ScrollMinX);
        endian_sdword(&mut (*psSaveGame).ScrollMinY);
        endian_udword(&mut (*psSaveGame).ScrollMaxX);
        endian_udword(&mut (*psSaveGame).ScrollMaxY);
        /* GAME_SAVEHEADER */
        endian_udword(&mut (*psHeader).version);
        /* Write the data to the file */
        if !pFileData.is_null() {
            status = saveFile(pFileName, pFileData, fileSize);
            memFreeRelease(pFileData as *mut libc::c_void);
            pFileData = 0 as *mut libc::c_char;
            return status
        }
    }
    if !pFileData.is_null() {
        memFreeRelease(pFileData as *mut libc::c_void);
        pFileData = 0 as *mut libc::c_char
    }
    return 0 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
// Process the droid initialisation file (dinit.bjo). Creates droids for
// the scenario being loaded. This is *NEVER* called for a user save game
//
unsafe extern "C" fn loadSaveDroidInit(mut pFileData: *mut libc::c_char,
                                       mut filesize: UDWORD) -> BOOL {
    let mut psHeader: *mut DROIDINIT_SAVEHEADER =
        0 as *mut DROIDINIT_SAVEHEADER;
    /* Check the file type */
    psHeader = pFileData as *mut DROIDINIT_SAVEHEADER;
    if (*psHeader).aFileType[0 as libc::c_int as usize] as libc::c_int !=
           'd' as i32 ||
           (*psHeader).aFileType[1 as libc::c_int as usize] as libc::c_int !=
               'i' as i32 ||
           (*psHeader).aFileType[2 as libc::c_int as usize] as libc::c_int !=
               'n' as i32 ||
           (*psHeader).aFileType[3 as libc::c_int as usize] as libc::c_int !=
               't' as i32 {
        debug(LOG_ERROR,
              b"loadSaveUnitInit: Incorrect file type\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    /* DROIDINIT_SAVEHEADER */
    endian_udword(&mut (*psHeader).version);
    endian_udword(&mut (*psHeader).quantity);
    //increment to the start of the data
    pFileData = pFileData.offset(12 as libc::c_int as isize);
    /* Check the file version */
    if (*psHeader).version < 7 as libc::c_int as libc::c_uint {
        debug(LOG_ERROR,
              b"UnitInit; unsupported save format version %d\x00" as *const u8
                  as *const libc::c_char, (*psHeader).version);
        abort();
    } else {
        if (*psHeader).version <= 33 as libc::c_int as libc::c_uint {
            if loadSaveDroidInitV2(pFileData, filesize, (*psHeader).quantity)
                   == 0 {
                return 0 as libc::c_int
            }
        } else {
            debug(LOG_ERROR,
                  b"UnitInit: undefined save format version %d\x00" as
                      *const u8 as *const libc::c_char, (*psHeader).version);
            abort();
        }
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
// Used for all droids
unsafe extern "C" fn loadSaveDroidInitV2(mut pFileData: *mut libc::c_char,
                                         mut filesize: UDWORD,
                                         mut quantity: UDWORD) -> BOOL {
    let mut pDroidInit: *mut SAVE_DROIDINIT = 0 as *mut SAVE_DROIDINIT;
    let mut psTemplate: *mut DROID_TEMPLATE = 0 as *mut DROID_TEMPLATE;
    let mut psDroid: *mut DROID = 0 as *mut DROID;
    let mut i: UDWORD = 0;
    let mut NumberOfSkippedDroids: UDWORD = 0 as libc::c_int as UDWORD;
    pDroidInit = pFileData as *mut SAVE_DROIDINIT;
    i = 0 as libc::c_int as UDWORD;
    while i < quantity {
        /* SAVE_DROIDINIT is OBJECT_SAVE_V19 */
		/* OBJECT_SAVE_V19 */
        endian_udword(&mut (*pDroidInit).id); // now don't lose any droids ... force them to be the last player
        endian_udword(&mut (*pDroidInit).x);
        endian_udword(&mut (*pDroidInit).y);
        endian_udword(&mut (*pDroidInit).z);
        endian_udword(&mut (*pDroidInit).direction);
        endian_udword(&mut (*pDroidInit).player);
        endian_udword(&mut (*pDroidInit).burnStart);
        endian_udword(&mut (*pDroidInit).burnDamage);
        (*pDroidInit).player = RemapPlayerNumber((*pDroidInit).player);
        if (*pDroidInit).player >= 8 as libc::c_int as libc::c_uint {
            (*pDroidInit).player =
                (8 as libc::c_int - 1 as libc::c_int) as UDWORD;
            NumberOfSkippedDroids = NumberOfSkippedDroids.wrapping_add(1)
        }
        psTemplate =
            FindDroidTemplate((*pDroidInit).name.as_mut_ptr(),
                              (*pDroidInit).player);
        if psTemplate.is_null() {
            debug(LOG_NEVER,
                  b"loadSaveUnitInitV2:\nUnable to find template for %s player %d\x00"
                      as *const u8 as *const libc::c_char,
                  (*pDroidInit).name.as_mut_ptr(), (*pDroidInit).player);
        } else {
            if 1 as libc::c_int != 0 {
            } else {
                debug(LOG_ERROR,
                      b"loadSaveUnitInitV2: Invalid template pointer\x00" as
                          *const u8 as *const libc::c_char);
            };
            if 1 as libc::c_int != 0 {
            } else {
                debug(LOG_ERROR,
                      b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8
                          as *const libc::c_char,
                      b"game.c\x00" as *const u8 as *const libc::c_char,
                      4565 as libc::c_int,
                      (*::std::mem::transmute::<&[u8; 20],
                                                &[libc::c_char; 20]>(b"loadSaveDroidInitV2\x00")).as_ptr(),
                      b"PTRVALID(psTemplate, sizeof(DROID_TEMPLATE))\x00" as
                          *const u8 as *const libc::c_char);
            };
            // Need to set apCompList[pDroidInit->player][componenttype][compid] = AVAILABLE for each droid.
            psDroid =
                buildDroid(psTemplate,
                           ((*pDroidInit).x &
                                !(0x7f as libc::c_int) as
                                    libc::c_uint).wrapping_add((128 as
                                                                    libc::c_int
                                                                    /
                                                                    2 as
                                                                        libc::c_int)
                                                                   as
                                                                   libc::c_uint),
                           ((*pDroidInit).y &
                                !(0x7f as libc::c_int) as
                                    libc::c_uint).wrapping_add((128 as
                                                                    libc::c_int
                                                                    /
                                                                    2 as
                                                                        libc::c_int)
                                                                   as
                                                                   libc::c_uint),
                           (*pDroidInit).player, 0 as libc::c_int);
            if !psDroid.is_null() {
                (*psDroid).id = (*pDroidInit).id;
                (*psDroid).direction = (*pDroidInit).direction as UWORD;
                addDroid(psDroid, apsDroidLists.as_mut_ptr());
            } else {
                debug(LOG_ERROR,
                      b"This droid cannot be built - %s\x00" as *const u8 as
                          *const libc::c_char,
                      (*pDroidInit).name.as_mut_ptr());
                abort();
            }
        }
        pDroidInit = pDroidInit.offset(1);
        i = i.wrapping_add(1)
    }
    //	powerCalculated = TRUE;
    if NumberOfSkippedDroids != 0 {
        debug(LOG_ERROR,
              b"unitLoad: Bad Player number in %d unit(s)... assigned to the last player!\n\x00"
                  as *const u8 as *const libc::c_char, NumberOfSkippedDroids);
        abort();
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
unsafe extern "C" fn FindDroidTemplate(mut name: *mut STRING,
                                       mut player: UDWORD)
 -> *mut DROID_TEMPLATE {
    let mut TempPlayer: UDWORD = 0;
    let mut Template: *mut DROID_TEMPLATE = 0 as *mut DROID_TEMPLATE;
    let mut id: UDWORD = 0;
    /*#ifdef RESOURCE_NAMES

	//get the name from the resource associated with it
	if (!strresGetIDNum(psStringRes, name, &id))
	{
		DBERROR(("Cannot find resource for template - %s", name));
		return NULL;
	}
	//get the string from the id
	name = strresGetString(psStringRes, id);

#endif*/
    //get the name from the resource associated with it
    if strresGetIDNum(psStringRes, name, &mut id) == 0 {
        debug(LOG_ERROR,
              b"Cannot find resource for template - %s\x00" as *const u8 as
                  *const libc::c_char, name);
        abort();
    }
    //get the string from the id
    name = strresGetString(psStringRes, id);
    TempPlayer = 0 as libc::c_int as UDWORD;
    while TempPlayer < 8 as libc::c_int as libc::c_uint {
        Template = apsDroidTemplates[TempPlayer as usize];
        while !Template.is_null() {
            //if(strcmp(name,Template->pName)==0) {
            if strcmp(name, (*Template).aName.as_mut_ptr()) ==
                   0 as libc::c_int {
                //				DBPRINTF(("%s %d , %d\n",name,player,TempPlayer));
                return Template
            }
            Template = (*Template).psNext
        }
        TempPlayer = TempPlayer.wrapping_add(1)
    }
    return 0 as *mut DROID_TEMPLATE;
}
/* *
 * The code is reusing some pointers as normal integer values apparently. This
 * should be fixed!
 */
// -----------------------------------------------------------------------------------------
#[no_mangle]
pub unsafe extern "C" fn RemapPlayerNumber(mut OldNumber: UDWORD) -> UDWORD {
    return OldNumber;
}
// -----------------------------------------------------------------------------------------
/*This is *ALWAYS* called by a User Save Game */
unsafe extern "C" fn loadSaveDroid(mut pFileData: *mut libc::c_char,
                                   mut filesize: UDWORD,
                                   mut ppsCurrentDroidLists: *mut *mut DROID)
 -> BOOL {
    let mut psHeader: *mut DROID_SAVEHEADER = 0 as *mut DROID_SAVEHEADER;
    /* Check the file type */
    psHeader = pFileData as *mut DROID_SAVEHEADER;
    if (*psHeader).aFileType[0 as libc::c_int as usize] as libc::c_int !=
           'd' as i32 ||
           (*psHeader).aFileType[1 as libc::c_int as usize] as libc::c_int !=
               'r' as i32 ||
           (*psHeader).aFileType[2 as libc::c_int as usize] as libc::c_int !=
               'o' as i32 ||
           (*psHeader).aFileType[3 as libc::c_int as usize] as libc::c_int !=
               'd' as i32 {
        debug(LOG_ERROR,
              b"loadSaveUnit: Incorrect file type\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    /* DROID_SAVEHEADER */
    endian_udword(&mut (*psHeader).version);
    endian_udword(&mut (*psHeader).quantity);
    //increment to the start of the data
    pFileData = pFileData.offset(12 as libc::c_int as isize);
    /* Check the file version */
    if (*psHeader).version < 9 as libc::c_int as libc::c_uint {
        debug(LOG_ERROR,
              b"UnitLoad; unsupported save format version %d\x00" as *const u8
                  as *const libc::c_char, (*psHeader).version);
        abort();
    } else {
        if (*psHeader).version == 11 as libc::c_int as libc::c_uint {
            if loadSaveDroidV11(pFileData, filesize, (*psHeader).quantity,
                                (*psHeader).version, ppsCurrentDroidLists) ==
                   0 {
                return 0 as libc::c_int
            }
        } else if (*psHeader).version <= 19 as libc::c_int as libc::c_uint {
            //old save name size
            if loadSaveDroidV19(pFileData, filesize, (*psHeader).quantity,
                                (*psHeader).version, ppsCurrentDroidLists) ==
                   0 {
                return 0 as libc::c_int
            }
        } else if (*psHeader).version <= 33 as libc::c_int as libc::c_uint {
            if loadSaveDroidV(pFileData, filesize, (*psHeader).quantity,
                              (*psHeader).version, ppsCurrentDroidLists) == 0
               {
                return 0 as libc::c_int
            }
        } else {
            debug(LOG_ERROR,
                  b"UnitLoad: undefined save format version %d\x00" as
                      *const u8 as *const libc::c_char, (*psHeader).version);
            abort();
        }
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
#[no_mangle]
pub unsafe extern "C" fn buildDroidFromSaveDroidV11(mut psSaveDroid:
                                                        *mut SAVE_DROID_V11)
 -> *mut DROID {
    let mut psTemplate: *mut DROID_TEMPLATE = 0 as *mut DROID_TEMPLATE;
    let mut sTemplate: DROID_TEMPLATE =
        DROID_TEMPLATE{ref_0: 0,
                       pName: 0 as *mut STRING,
                       aName: [0; 60],
                       NameVersion: 0,
                       asParts: [0; 8],
                       buildPoints: 0,
                       powerPoints: 0,
                       storeCount: 0,
                       numWeaps: 0,
                       asWeaps: [0; 1],
                       droidType: DROID_WEAPON,
                       multiPlayerID: 0,
                       psNext: 0 as *mut _droid_template,};
    let mut psDroid: *mut DROID = 0 as *mut DROID;
    let mut found: BOOL = 0;
    let mut i: UDWORD = 0;
    let mut compInc: SDWORD = 0;
    let mut burnTime: UDWORD = 0;
    psTemplate = &mut sTemplate;
    //set up the template
	//copy the values across
    strncpy((*psTemplate).aName.as_mut_ptr(),
            (*psSaveDroid).name.as_mut_ptr(),
            60 as libc::c_int as libc::c_uint);
    (*psTemplate).aName[(60 as libc::c_int - 1 as libc::c_int) as usize] =
        0 as libc::c_int as STRING;
    //ignore the first comp - COMP_UNKNOWN
    found = 1 as libc::c_int;
    i = 1 as libc::c_int as UDWORD;
    while i <
              (COMP_NUMCOMPONENTS as libc::c_int - 1 as libc::c_int) as
                  libc::c_uint {
        compInc =
            getCompFromName(i,
                            (*psSaveDroid).asBits[i as
                                                      usize].name.as_mut_ptr());
        if compInc < 0 as libc::c_int {
            debug(LOG_ERROR,
                  b"This component no longer exists - %s, the droid will be deleted\x00"
                      as *const u8 as *const libc::c_char,
                  (*psSaveDroid).asBits[i as usize].name.as_mut_ptr());
            abort();
            //continue;
        } else {
            (*psTemplate).asParts[i as usize] = compInc as UDWORD as SDWORD;
            i = i.wrapping_add(1)
        }
    }
    if found == 0 {
        //ignore this record
        return 0 as *mut DROID
    }
    (*psTemplate).numWeaps = (*psSaveDroid).numWeaps;
    found = 1 as libc::c_int;
    i = 0 as libc::c_int as UDWORD;
    while i < (*psSaveDroid).numWeaps {
        (*psTemplate).asWeaps[i as usize] =
            getCompFromName(COMP_WEAPON as libc::c_int as UDWORD,
                            (*psSaveDroid).asWeaps[i as
                                                       usize].name.as_mut_ptr())
                as UDWORD;
        if (*psTemplate).asWeaps[i as usize] <
               0 as libc::c_int as libc::c_uint {
            debug(LOG_ERROR,
                  b"This component no longer exists - %s, the droid will be deleted\x00"
                      as *const u8 as *const libc::c_char,
                  (*psSaveDroid).asWeaps[i as usize].name.as_mut_ptr());
            abort();
        } else { i = i.wrapping_add(1) }
    }
    if found == 0 {
        //ignore this record
        return 0 as *mut DROID
    }
    (*psTemplate).buildPoints = calcTemplateBuild(psTemplate);
    (*psTemplate).powerPoints = calcTemplatePower(psTemplate);
    (*psTemplate).droidType = (*psSaveDroid).droidType as DROID_TYPE;
    /*create the Droid */
    // ignore brains for now
    (*psTemplate).asParts[COMP_BRAIN as libc::c_int as usize] =
        0 as libc::c_int;
    psDroid =
        buildDroid(psTemplate, (*psSaveDroid).x, (*psSaveDroid).y,
                   (*psSaveDroid).player, 0 as libc::c_int);
    //copy the droid's weapon stats
	//for (i=0; i < DROID_MAXWEAPS; i++)
    if (*psDroid).asWeaps[0 as libc::c_int as usize].nStat >
           0 as libc::c_int as libc::c_uint {
        //only one weapon now
        i = 0 as libc::c_int as UDWORD;
        (*psDroid).asWeaps[i as usize].hitPoints =
            (*psSaveDroid).asWeaps[i as usize].hitPoints;
        (*psDroid).asWeaps[i as usize].ammo =
            (*psSaveDroid).asWeaps[i as usize].ammo;
        (*psDroid).asWeaps[i as usize].lastFired =
            (*psSaveDroid).asWeaps[i as usize].lastFired
    }
    //copy the values across
    (*psDroid).id = (*psSaveDroid).id;
    //are these going to ever change from the values set up with?
//			psDroid->z = psSaveDroid->z;		// use the correct map height value
    (*psDroid).direction = (*psSaveDroid).direction as UWORD;
    (*psDroid).body = (*psSaveDroid).body;
    if (*psDroid).body > (*psDroid).originalBody {
        (*psDroid).body = (*psDroid).originalBody
    }
    (*psDroid).inFire = (*psSaveDroid).inFire;
    (*psDroid).burnDamage = (*psSaveDroid).burnDamage;
    burnTime = (*psSaveDroid).burnStart;
    (*psDroid).burnStart = burnTime;
    (*psDroid).numKills = (*psSaveDroid).numKills as UWORD;
    //version 11
    (*psDroid).turretRotation = (*psSaveDroid).turretRotation;
    (*psDroid).turretPitch = (*psSaveDroid).turretPitch;
    (*psDroid).psGroup = 0 as *mut _droid_group;
    (*psDroid).psGrpNext = 0 as *mut _droid;
    return psDroid;
}
// -----------------------------------------------------------------------------------------
#[no_mangle]
pub unsafe extern "C" fn buildDroidFromSaveDroidV19(mut psSaveDroid:
                                                        *mut SAVE_DROID_V18,
                                                    mut version: UDWORD)
 -> *mut DROID {
    let mut psTemplate: *mut DROID_TEMPLATE = 0 as *mut DROID_TEMPLATE;
    let mut sTemplate: DROID_TEMPLATE =
        DROID_TEMPLATE{ref_0: 0,
                       pName: 0 as *mut STRING,
                       aName: [0; 60],
                       NameVersion: 0,
                       asParts: [0; 8],
                       buildPoints: 0,
                       powerPoints: 0,
                       storeCount: 0,
                       numWeaps: 0,
                       asWeaps: [0; 1],
                       droidType: DROID_WEAPON,
                       multiPlayerID: 0,
                       psNext: 0 as *mut _droid_template,};
    let mut psDroid: *mut DROID = 0 as *mut DROID;
    let mut psSaveDroidV14: *mut SAVE_DROID_V14 = 0 as *mut SAVE_DROID_V14;
    let mut found: BOOL = 0;
    let mut i: UDWORD = 0;
    let mut id: UDWORD = 0;
    let mut compInc: SDWORD = 0;
    let mut burnTime: UDWORD = 0;
    psTemplate = &mut sTemplate;
    (*psTemplate).pName = 0 as *mut STRING;
    //set up the template
	//copy the values across
    strncpy((*psTemplate).aName.as_mut_ptr(),
            (*psSaveDroid).name.as_mut_ptr(),
            60 as libc::c_int as libc::c_uint);
    (*psTemplate).aName[(60 as libc::c_int - 1 as libc::c_int) as usize] =
        0 as libc::c_int as STRING;
    //ignore the first comp - COMP_UNKNOWN
    found = 1 as libc::c_int;
    i = 1 as libc::c_int as UDWORD;
    while i <
              (COMP_NUMCOMPONENTS as libc::c_int - 1 as libc::c_int) as
                  libc::c_uint {
        compInc =
            getCompFromName(i,
                            (*psSaveDroid).asBits[i as
                                                      usize].name.as_mut_ptr());
        if compInc < 0 as libc::c_int {
            debug(LOG_ERROR,
                  b"This component no longer exists - %s, the droid will be deleted\x00"
                      as *const u8 as *const libc::c_char,
                  (*psSaveDroid).asBits[i as usize].name.as_mut_ptr());
            abort();
            //continue;
        } else {
            (*psTemplate).asParts[i as usize] = compInc as UDWORD as SDWORD;
            i = i.wrapping_add(1)
        }
    }
    if found == 0 {
        //ignore this record
        if found != 0 {
        } else {
            debug(LOG_ERROR,
                  b"buildUnitFromSavedUnit; failed to find weapon\x00" as
                      *const u8 as *const libc::c_char);
        };
        if found != 0 {
        } else {
            debug(LOG_ERROR,
                  b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                      *const libc::c_char,
                  b"game.c\x00" as *const u8 as *const libc::c_char,
                  4872 as libc::c_int,
                  (*::std::mem::transmute::<&[u8; 27],
                                            &[libc::c_char; 27]>(b"buildDroidFromSaveDroidV19\x00")).as_ptr(),
                  b"found\x00" as *const u8 as *const libc::c_char);
        };
        return 0 as *mut DROID
    }
    (*psTemplate).numWeaps = (*psSaveDroid).numWeaps;
    found = 1 as libc::c_int;
    if (*psSaveDroid).numWeaps > 0 as libc::c_int as libc::c_uint {
        (*psTemplate).asWeaps[0 as libc::c_int as usize] =
            getCompFromName(COMP_WEAPON as libc::c_int as UDWORD,
                            (*psSaveDroid).asWeaps[0 as libc::c_int as
                                                       usize].name.as_mut_ptr())
                as UDWORD;
        if (*psTemplate).asWeaps[0 as libc::c_int as usize] <
               0 as libc::c_int as libc::c_uint {
            debug(LOG_ERROR,
                  b"This component no longer exists - %s, the droid will be deleted\x00"
                      as *const u8 as *const libc::c_char,
                  (*psSaveDroid).asWeaps[0 as libc::c_int as
                                             usize].name.as_mut_ptr());
            abort();
        }
    }
    if found == 0 {
        //ignore this record
        if found != 0 {
        } else {
            debug(LOG_ERROR,
                  b"buildUnitFromSavedUnit; failed to find weapon\x00" as
                      *const u8 as *const libc::c_char);
        };
        if found != 0 {
        } else {
            debug(LOG_ERROR,
                  b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                      *const libc::c_char,
                  b"game.c\x00" as *const u8 as *const libc::c_char,
                  4893 as libc::c_int,
                  (*::std::mem::transmute::<&[u8; 27],
                                            &[libc::c_char; 27]>(b"buildDroidFromSaveDroidV19\x00")).as_ptr(),
                  b"found\x00" as *const u8 as *const libc::c_char);
        };
        return 0 as *mut DROID
    }
    (*psTemplate).buildPoints = calcTemplateBuild(psTemplate);
    (*psTemplate).powerPoints = calcTemplatePower(psTemplate);
    (*psTemplate).droidType = (*psSaveDroid).droidType as DROID_TYPE;
    /*create the Droid */
    // ignore brains for now
	// not any *$&!!! more - JOHN
//	psTemplate->asParts[COMP_BRAIN] = 0;
    if (*psSaveDroid).x ==
           (512 as libc::c_int * 127 as libc::c_int) as libc::c_uint {
        psDroid =
            buildDroid(psTemplate, (*psSaveDroid).x, (*psSaveDroid).y,
                       (*psSaveDroid).player, 1 as libc::c_int)
    } else if (*psSaveDroid).saveType ==
                  DROID_ON_TRANSPORT as libc::c_int as libc::c_uint {
        psDroid =
            buildDroid(psTemplate, 0 as libc::c_int as UDWORD,
                       0 as libc::c_int as UDWORD, (*psSaveDroid).player,
                       1 as libc::c_int)
    } else {
        psDroid =
            buildDroid(psTemplate, (*psSaveDroid).x, (*psSaveDroid).y,
                       (*psSaveDroid).player, 0 as libc::c_int)
    }
    if psDroid.is_null() {
        if 0 as libc::c_int != 0 {
        } else {
            debug(LOG_ERROR,
                  b"buildUnitFromSavedUnit; failed to build unit\x00" as
                      *const u8 as *const libc::c_char);
        };
        if 0 as libc::c_int != 0 {
        } else {
            debug(LOG_ERROR,
                  b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                      *const libc::c_char,
                  b"game.c\x00" as *const u8 as *const libc::c_char,
                  4926 as libc::c_int,
                  (*::std::mem::transmute::<&[u8; 27],
                                            &[libc::c_char; 27]>(b"buildDroidFromSaveDroidV19\x00")).as_ptr(),
                  b"FALSE\x00" as *const u8 as *const libc::c_char);
        };
        return 0 as *mut DROID
    }
    //copy the droid's weapon stats
	//for (i=0; i < DROID_MAXWEAPS; i++)
    if (*psDroid).asWeaps[0 as libc::c_int as usize].nStat >
           0 as libc::c_int as libc::c_uint {
        (*psDroid).asWeaps[0 as libc::c_int as usize].hitPoints =
            (*psSaveDroid).asWeaps[0 as libc::c_int as usize].hitPoints;
        (*psDroid).asWeaps[0 as libc::c_int as usize].ammo =
            (*psSaveDroid).asWeaps[0 as libc::c_int as usize].ammo;
        (*psDroid).asWeaps[0 as libc::c_int as usize].lastFired =
            (*psSaveDroid).asWeaps[0 as libc::c_int as usize].lastFired
    }
    //copy the values across
    (*psDroid).id = (*psSaveDroid).id;
    //are these going to ever change from the values set up with?
//			psDroid->z = psSaveDroid->z;		// use the correct map height value
    (*psDroid).direction = (*psSaveDroid).direction as UWORD;
    (*psDroid).body = (*psSaveDroid).body;
    if (*psDroid).body > (*psDroid).originalBody {
        (*psDroid).body = (*psDroid).originalBody
    }
    (*psDroid).inFire = (*psSaveDroid).inFire;
    (*psDroid).burnDamage = (*psSaveDroid).burnDamage;
    burnTime = (*psSaveDroid).burnStart;
    (*psDroid).burnStart = burnTime;
    (*psDroid).numKills = (*psSaveDroid).numKills as UWORD;
    //version 14
    (*psDroid).resistance = droidResistance(psDroid);
    if version >= 11 as libc::c_int as libc::c_uint {
        //version 11
        (*psDroid).turretRotation = (*psSaveDroid).turretRotation;
        (*psDroid).turretPitch = (*psSaveDroid).turretPitch
    }
    if version >= 12 as libc::c_int as libc::c_uint {
        //version 12
        (*psDroid).order = (*psSaveDroid).order;
        (*psDroid).orderX = (*psSaveDroid).orderX;
        (*psDroid).orderY = (*psSaveDroid).orderY;
        (*psDroid).orderX2 = (*psSaveDroid).orderX2;
        (*psDroid).orderY2 = (*psSaveDroid).orderY2;
        (*psDroid).timeLastHit = (*psSaveDroid).timeLastHit;
        //rebuild the object pointer from the ID
        let mut __tmp: *mut UDWORD =
            &mut (*psDroid).psTarget as *mut *mut _base_object as *mut UDWORD;
        *__tmp = (*psSaveDroid).targetID;
        (*psDroid).secondaryOrder = (*psSaveDroid).secondaryOrder;
        (*psDroid).action = (*psSaveDroid).action;
        (*psDroid).actionX = (*psSaveDroid).actionX;
        (*psDroid).actionY = (*psSaveDroid).actionY;
        //rebuild the object pointer from the ID
        let mut __tmp_0: *mut UDWORD =
            &mut (*psDroid).psActionTarget as *mut *mut _base_object as
                *mut UDWORD;
        *__tmp_0 = (*psSaveDroid).actionTargetID;
        (*psDroid).actionStarted = (*psSaveDroid).actionStarted;
        (*psDroid).actionPoints = (*psSaveDroid).actionPoints;
        //actionHeight has been renamed to powerAccrued - AB 7/1/99
        //psDroid->actionHeight		= psSaveDroid->actionHeight;
        (*psDroid).powerAccrued = (*psSaveDroid).actionHeight;
        //added for V14
        (*psDroid).psGroup = 0 as *mut _droid_group;
        (*psDroid).psGrpNext = 0 as *mut _droid
    }
    if version >= 14 as libc::c_int as libc::c_uint &&
           version < 18 as libc::c_int as libc::c_uint {
        //version 14
        //warning V14 - v17 only
		//current Save Droid V18+ uses larger tarStatName
		//subsequent structure elements are not aligned between the two
        psSaveDroidV14 = psSaveDroid as *mut SAVE_DROID_V14;
        if (*psSaveDroidV14).tarStatName[0 as libc::c_int as usize] as
               libc::c_int == 0 as libc::c_int {
            (*psDroid).psTarStats = 0 as *mut _base_stats
        } else {
            id =
                getStructStatFromName((*psSaveDroidV14).tarStatName.as_mut_ptr())
                    as UDWORD;
            if id != -(1 as libc::c_int) as libc::c_uint {
                (*psDroid).psTarStats =
                    &mut *asStructureStats.offset(id as isize) as
                        *mut STRUCTURE_STATS as *mut BASE_STATS
            } else {
                if 0 as libc::c_int != 0 {
                } else {
                    debug(LOG_ERROR,
                          b"loadUnit TargetStat not found\x00" as *const u8 as
                              *const libc::c_char);
                };
                if 0 as libc::c_int != 0 {
                } else {
                    debug(LOG_ERROR,
                          b"Assert in Warzone: %s:%d : %s (%s)\x00" as
                              *const u8 as *const libc::c_char,
                          b"game.c\x00" as *const u8 as *const libc::c_char,
                          5011 as libc::c_int,
                          (*::std::mem::transmute::<&[u8; 27],
                                                    &[libc::c_char; 27]>(b"buildDroidFromSaveDroidV19\x00")).as_ptr(),
                          b"FALSE\x00" as *const u8 as *const libc::c_char);
                };
                (*psDroid).psTarStats = 0 as *mut _base_stats;
                orderDroid(psDroid, DORDER_STOP);
            }
        }
        let mut __tmp_1: *mut UDWORD =
            &mut (*psDroid).psBaseStruct as *mut *mut _structure as
                *mut UDWORD;
        *__tmp_1 = (*psSaveDroidV14).baseStructID;
        (*psDroid).group = (*psSaveDroidV14).group;
        (*psDroid).selected = (*psSaveDroidV14).selected;
        (*psDroid).died = (*psSaveDroidV14).died;
        (*psDroid).lastEmission = (*psSaveDroidV14).lastEmission;
        i = 0 as libc::c_int as UDWORD;
        while i < 8 as libc::c_int as libc::c_uint {
            (*psDroid).visible[i as usize] =
                (*psSaveDroidV14).visible[i as usize];
            i = i.wrapping_add(1)
        }
    } else if version >= 18 as libc::c_int as libc::c_uint {
        //warning V14 - v17 only
		//rebuild the object pointer from the ID
        //20feb		psDroid->cluster = psSaveDroidV14->cluster;
        //warning V14 - v17 only
        //version 18
        if (*psSaveDroid).tarStatName[0 as libc::c_int as usize] as
               libc::c_int == 0 as libc::c_int {
            (*psDroid).psTarStats = 0 as *mut _base_stats
        } else {
            id =
                getStructStatFromName((*psSaveDroid).tarStatName.as_mut_ptr())
                    as UDWORD;
            if id != -(1 as libc::c_int) as libc::c_uint {
                (*psDroid).psTarStats =
                    &mut *asStructureStats.offset(id as isize) as
                        *mut STRUCTURE_STATS as *mut BASE_STATS
            } else {
                if 0 as libc::c_int != 0 {
                } else {
                    debug(LOG_ERROR,
                          b"loadUnit TargetStat not found\x00" as *const u8 as
                              *const libc::c_char);
                };
                if 0 as libc::c_int != 0 {
                } else {
                    debug(LOG_ERROR,
                          b"Assert in Warzone: %s:%d : %s (%s)\x00" as
                              *const u8 as *const libc::c_char,
                          b"game.c\x00" as *const u8 as *const libc::c_char,
                          5047 as libc::c_int,
                          (*::std::mem::transmute::<&[u8; 27],
                                                    &[libc::c_char; 27]>(b"buildDroidFromSaveDroidV19\x00")).as_ptr(),
                          b"FALSE\x00" as *const u8 as *const libc::c_char);
                };
                (*psDroid).psTarStats = 0 as *mut _base_stats
            }
        }
        //rebuild the object pointer from the ID
        let mut __tmp_2: *mut UDWORD =
            &mut (*psDroid).psBaseStruct as *mut *mut _structure as
                *mut UDWORD;
        *__tmp_2 = (*psSaveDroid).baseStructID;
        (*psDroid).group = (*psSaveDroid).group;
        (*psDroid).selected = (*psSaveDroid).selected;
        //20feb		psDroid->cluster = psSaveDroid->cluster;
        (*psDroid).died = (*psSaveDroid).died;
        (*psDroid).lastEmission = (*psSaveDroid).lastEmission;
        i = 0 as libc::c_int as UDWORD;
        while i < 8 as libc::c_int as libc::c_uint {
            (*psDroid).visible[i as usize] =
                (*psSaveDroid).visible[i as usize];
            i = i.wrapping_add(1)
        }
    }
    return psDroid;
}
// -----------------------------------------------------------------------------------------
//version 20 + after names change
#[no_mangle]
pub unsafe extern "C" fn buildDroidFromSaveDroid(mut psSaveDroid:
                                                     *mut SAVE_DROID,
                                                 mut version: UDWORD)
 -> *mut DROID {
    let mut psTemplate: *mut DROID_TEMPLATE = 0 as *mut DROID_TEMPLATE;
    let mut sTemplate: DROID_TEMPLATE =
        DROID_TEMPLATE{ref_0: 0,
                       pName: 0 as *mut STRING,
                       aName: [0; 60],
                       NameVersion: 0,
                       asParts: [0; 8],
                       buildPoints: 0,
                       powerPoints: 0,
                       storeCount: 0,
                       numWeaps: 0,
                       asWeaps: [0; 1],
                       droidType: DROID_WEAPON,
                       multiPlayerID: 0,
                       psNext: 0 as *mut _droid_template,};
    let mut psDroid: *mut DROID = 0 as *mut DROID;
    let mut found: BOOL = 0;
    let mut i: UDWORD = 0;
    let mut id: UDWORD = 0;
    let mut compInc: SDWORD = 0;
    let mut burnTime: UDWORD = 0;
    //	version;
    psTemplate = &mut sTemplate;
    (*psTemplate).pName = 0 as *mut STRING;
    //set up the template
	//copy the values across
    strncpy((*psTemplate).aName.as_mut_ptr(),
            (*psSaveDroid).name.as_mut_ptr(),
            60 as libc::c_int as libc::c_uint);
    (*psTemplate).aName[(60 as libc::c_int - 1 as libc::c_int) as usize] =
        0 as libc::c_int as STRING;
    //ignore the first comp - COMP_UNKNOWN
    found = 1 as libc::c_int;
    i = 1 as libc::c_int as UDWORD;
    while i <
              (COMP_NUMCOMPONENTS as libc::c_int - 1 as libc::c_int) as
                  libc::c_uint {
        compInc =
            getCompFromName(i,
                            (*psSaveDroid).asBits[i as
                                                      usize].name.as_mut_ptr());
        //HACK to get the game to load when ECMs, Sensors or RepairUnits have been deleted
        if compInc < 0 as libc::c_int &&
               (i == COMP_ECM as libc::c_int as libc::c_uint ||
                    i == COMP_SENSOR as libc::c_int as libc::c_uint ||
                    i == COMP_REPAIRUNIT as libc::c_int as libc::c_uint) {
            //set the ECM to be the defaultECM ...
            if i == COMP_ECM as libc::c_int as libc::c_uint {
                compInc =
                    aDefaultECM[(*psSaveDroid).player as usize] as SDWORD
            } else if i == COMP_SENSOR as libc::c_int as libc::c_uint {
                compInc =
                    aDefaultSensor[(*psSaveDroid).player as usize] as SDWORD
            } else if i == COMP_REPAIRUNIT as libc::c_int as libc::c_uint {
                compInc =
                    aDefaultRepair[(*psSaveDroid).player as usize] as SDWORD
            }
        } else if compInc < 0 as libc::c_int {
            debug(LOG_ERROR,
                  b"This component no longer exists - %s, the droid will be deleted\x00"
                      as *const u8 as *const libc::c_char,
                  (*psSaveDroid).asBits[i as usize].name.as_mut_ptr());
            abort();
            //continue;
        }
        (*psTemplate).asParts[i as usize] = compInc as UDWORD as SDWORD;
        i = i.wrapping_add(1)
    }
    if found == 0 {
        //ignore this record
        if found != 0 {
        } else {
            debug(LOG_ERROR,
                  b"buildUnitFromSavedUnit; failed to find weapon\x00" as
                      *const u8 as *const libc::c_char);
        };
        if found != 0 {
        } else {
            debug(LOG_ERROR,
                  b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                      *const libc::c_char,
                  b"game.c\x00" as *const u8 as *const libc::c_char,
                  5127 as libc::c_int,
                  (*::std::mem::transmute::<&[u8; 24],
                                            &[libc::c_char; 24]>(b"buildDroidFromSaveDroid\x00")).as_ptr(),
                  b"found\x00" as *const u8 as *const libc::c_char);
        };
        return 0 as *mut DROID
    }
    (*psTemplate).numWeaps = (*psSaveDroid).numWeaps;
    found = 1 as libc::c_int;
    if (*psSaveDroid).numWeaps > 0 as libc::c_int as libc::c_uint {
        (*psTemplate).asWeaps[0 as libc::c_int as usize] =
            getCompFromName(COMP_WEAPON as libc::c_int as UDWORD,
                            (*psSaveDroid).asWeaps[0 as libc::c_int as
                                                       usize].name.as_mut_ptr())
                as UDWORD;
        if (*psTemplate).asWeaps[0 as libc::c_int as usize] <
               0 as libc::c_int as libc::c_uint {
            debug(LOG_ERROR,
                  b"This component no longer exists - %s, the droid will be deleted\x00"
                      as *const u8 as *const libc::c_char,
                  (*psSaveDroid).asWeaps[0 as libc::c_int as
                                             usize].name.as_mut_ptr());
            abort();
        }
    }
    if found == 0 {
        //ignore this record
        if found != 0 {
        } else {
            debug(LOG_ERROR,
                  b"buildUnitFromSavedUnit; failed to find weapon\x00" as
                      *const u8 as *const libc::c_char);
        };
        if found != 0 {
        } else {
            debug(LOG_ERROR,
                  b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                      *const libc::c_char,
                  b"game.c\x00" as *const u8 as *const libc::c_char,
                  5147 as libc::c_int,
                  (*::std::mem::transmute::<&[u8; 24],
                                            &[libc::c_char; 24]>(b"buildDroidFromSaveDroid\x00")).as_ptr(),
                  b"found\x00" as *const u8 as *const libc::c_char);
        };
        return 0 as *mut DROID
    }
    (*psTemplate).buildPoints = calcTemplateBuild(psTemplate);
    (*psTemplate).powerPoints = calcTemplatePower(psTemplate);
    (*psTemplate).droidType = (*psSaveDroid).droidType as DROID_TYPE;
    /*create the Droid */
    // ignore brains for now
	// not any *$&!!! more - JOHN
//	psTemplate->asParts[COMP_BRAIN] = 0;
    turnOffMultiMsg(1 as libc::c_int);
    if (*psSaveDroid).x ==
           (512 as libc::c_int * 127 as libc::c_int) as libc::c_uint {
        psDroid =
            buildDroid(psTemplate, (*psSaveDroid).x, (*psSaveDroid).y,
                       (*psSaveDroid).player, 1 as libc::c_int)
    } else if (*psSaveDroid).saveType ==
                  DROID_ON_TRANSPORT as libc::c_int as libc::c_uint {
        psDroid =
            buildDroid(psTemplate, 0 as libc::c_int as UDWORD,
                       0 as libc::c_int as UDWORD, (*psSaveDroid).player,
                       1 as libc::c_int)
    } else {
        psDroid =
            buildDroid(psTemplate, (*psSaveDroid).x, (*psSaveDroid).y,
                       (*psSaveDroid).player, 0 as libc::c_int)
    }
    if psDroid.is_null() {
        if 0 as libc::c_int != 0 {
        } else {
            debug(LOG_ERROR,
                  b"buildUnitFromSavedUnit; failed to build unit\x00" as
                      *const u8 as *const libc::c_char);
        };
        if 0 as libc::c_int != 0 {
        } else {
            debug(LOG_ERROR,
                  b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                      *const libc::c_char,
                  b"game.c\x00" as *const u8 as *const libc::c_char,
                  5182 as libc::c_int,
                  (*::std::mem::transmute::<&[u8; 24],
                                            &[libc::c_char; 24]>(b"buildDroidFromSaveDroid\x00")).as_ptr(),
                  b"FALSE\x00" as *const u8 as *const libc::c_char);
        };
        return 0 as *mut DROID
    }
    turnOffMultiMsg(0 as libc::c_int);
    //copy the droid's weapon stats
	//for (i=0; i < DROID_MAXWEAPS; i++)
    if (*psDroid).asWeaps[0 as libc::c_int as usize].nStat >
           0 as libc::c_int as libc::c_uint {
        (*psDroid).asWeaps[0 as libc::c_int as usize].hitPoints =
            (*psSaveDroid).asWeaps[0 as libc::c_int as usize].hitPoints;
        (*psDroid).asWeaps[0 as libc::c_int as usize].ammo =
            (*psSaveDroid).asWeaps[0 as libc::c_int as usize].ammo;
        (*psDroid).asWeaps[0 as libc::c_int as usize].lastFired =
            (*psSaveDroid).asWeaps[0 as libc::c_int as usize].lastFired
    }
    //copy the values across
    (*psDroid).id = (*psSaveDroid).id;
    //are these going to ever change from the values set up with?
//			psDroid->z = psSaveDroid->z;		// use the correct map height value
    (*psDroid).direction = (*psSaveDroid).direction as UWORD;
    (*psDroid).body = (*psSaveDroid).body;
    if (*psDroid).body > (*psDroid).originalBody {
        (*psDroid).body = (*psDroid).originalBody
    }
    (*psDroid).inFire = (*psSaveDroid).inFire;
    (*psDroid).burnDamage = (*psSaveDroid).burnDamage;
    burnTime = (*psSaveDroid).burnStart;
    (*psDroid).burnStart = burnTime;
    (*psDroid).numKills = (*psSaveDroid).numKills as UWORD;
    //version 14
    (*psDroid).resistance = droidResistance(psDroid);
    //version 11
    (*psDroid).turretRotation = (*psSaveDroid).turretRotation;
    (*psDroid).turretPitch = (*psSaveDroid).turretPitch;
    //version 12
    (*psDroid).order = (*psSaveDroid).order;
    (*psDroid).orderX = (*psSaveDroid).orderX;
    (*psDroid).orderY = (*psSaveDroid).orderY;
    (*psDroid).orderX2 = (*psSaveDroid).orderX2;
    (*psDroid).orderY2 = (*psSaveDroid).orderY2;
    (*psDroid).timeLastHit = (*psSaveDroid).timeLastHit;
    //rebuild the object pointer from the ID
    let mut __tmp: *mut UDWORD =
        &mut (*psDroid).psTarget as *mut *mut _base_object as *mut UDWORD;
    *__tmp = (*psSaveDroid).targetID;
    (*psDroid).secondaryOrder = (*psSaveDroid).secondaryOrder;
    (*psDroid).action = (*psSaveDroid).action;
    (*psDroid).actionX = (*psSaveDroid).actionX;
    (*psDroid).actionY = (*psSaveDroid).actionY;
    //rebuild the object pointer from the ID
    let mut __tmp_0: *mut UDWORD =
        &mut (*psDroid).psActionTarget as *mut *mut _base_object as
            *mut UDWORD;
    *__tmp_0 = (*psSaveDroid).actionTargetID;
    (*psDroid).actionStarted = (*psSaveDroid).actionStarted;
    (*psDroid).actionPoints = (*psSaveDroid).actionPoints;
    //actionHeight has been renamed to powerAccrued - AB 7/1/99
    //psDroid->actionHeight		= psSaveDroid->actionHeight;
    (*psDroid).powerAccrued = (*psSaveDroid).actionHeight;
    //added for V14
    //version 18
    if (*psSaveDroid).tarStatName[0 as libc::c_int as usize] as libc::c_int ==
           0 as libc::c_int {
        (*psDroid).psTarStats = 0 as *mut _base_stats
    } else {
        id =
            getStructStatFromName((*psSaveDroid).tarStatName.as_mut_ptr()) as
                UDWORD;
        if id != -(1 as libc::c_int) as libc::c_uint {
            (*psDroid).psTarStats =
                &mut *asStructureStats.offset(id as isize) as
                    *mut STRUCTURE_STATS as *mut BASE_STATS
        } else {
            if 0 as libc::c_int != 0 {
            } else {
                debug(LOG_ERROR,
                      b"loadUnit TargetStat not found\x00" as *const u8 as
                          *const libc::c_char);
            };
            if 0 as libc::c_int != 0 {
            } else {
                debug(LOG_ERROR,
                      b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8
                          as *const libc::c_char,
                      b"game.c\x00" as *const u8 as *const libc::c_char,
                      5259 as libc::c_int,
                      (*::std::mem::transmute::<&[u8; 24],
                                                &[libc::c_char; 24]>(b"buildDroidFromSaveDroid\x00")).as_ptr(),
                      b"FALSE\x00" as *const u8 as *const libc::c_char);
            };
            (*psDroid).psTarStats = 0 as *mut _base_stats
        }
    }
    //rebuild the object pointer from the ID
    let mut __tmp_1: *mut UDWORD =
        &mut (*psDroid).psBaseStruct as *mut *mut _structure as *mut UDWORD;
    *__tmp_1 = (*psSaveDroid).baseStructID;
    (*psDroid).group = (*psSaveDroid).group;
    (*psDroid).selected = (*psSaveDroid).selected;
    //20feb	psDroid->cluster = psSaveDroid->cluster;
    (*psDroid).died = (*psSaveDroid).died;
    (*psDroid).lastEmission = (*psSaveDroid).lastEmission;
    i = 0 as libc::c_int as UDWORD;
    while i < 8 as libc::c_int as libc::c_uint {
        (*psDroid).visible[i as usize] = (*psSaveDroid).visible[i as usize];
        i = i.wrapping_add(1)
    }
    if version >= 21 as libc::c_int as libc::c_uint {
        //version 21
        if (*psDroid).droidType as libc::c_uint !=
               DROID_TRANSPORTER as libc::c_int as libc::c_uint &&
               (*psDroid).droidType as libc::c_uint !=
                   DROID_COMMAND as libc::c_int as libc::c_uint {
            //rebuild group from command id in loadDroidSetPointers
            let mut __tmp_2: *mut UDWORD =
                &mut (*psDroid).psGroup as *mut *mut _droid_group as
                    *mut UDWORD;
            *__tmp_2 = (*psSaveDroid).commandId;
            let mut __tmp_3: *mut UDWORD =
                &mut (*psDroid).psGrpNext as *mut *mut _droid as *mut UDWORD;
            *__tmp_3 = 0xffffffff as libc::c_uint
        }
    } else if (*psDroid).droidType as libc::c_uint !=
                  DROID_TRANSPORTER as libc::c_int as libc::c_uint &&
                  (*psDroid).droidType as libc::c_uint !=
                      DROID_COMMAND as libc::c_int as libc::c_uint {
        //dont rebuild group from command id in loadDroidSetPointers
        (*psDroid).psGroup = 0 as *mut _droid_group;
        (*psDroid).psGrpNext = 0 as *mut _droid
    }
    if version >= 24 as libc::c_int as libc::c_uint {
        //version 24
        (*psDroid).resistance = (*psSaveDroid).resistance as SWORD;
        memcpy(&mut (*psDroid).sMove as *mut MOVE_CONTROL as
                   *mut libc::c_void,
               &mut (*psSaveDroid).sMove as *mut SAVE_MOVE_CONTROL as
                   *const libc::c_void,
               ::std::mem::size_of::<SAVE_MOVE_CONTROL>() as libc::c_ulong);
        (*psDroid).sMove.fz = (*psDroid).z as FRACT;
        if !(*psDroid).sMove.psFormation.is_null() {
            (*psDroid).sMove.psFormation = 0 as *mut _formation;
            //			psSaveDroid->formationDir;
//			psSaveDroid->formationX;
//			psSaveDroid->formationY;
			// join a formation if it exists at the destination
            if formationFind(&mut (*psDroid).sMove.psFormation,
                             (*psSaveDroid).formationX,
                             (*psSaveDroid).formationY) != 0 {
                formationJoin((*psDroid).sMove.psFormation,
                              psDroid as *mut BASE_OBJECT);
            } else if formationNew(&mut (*psDroid).sMove.psFormation, FT_LINE,
                                   (*psSaveDroid).formationX,
                                   (*psSaveDroid).formationY,
                                   (*psSaveDroid).formationDir as SDWORD) != 0
             {
                formationJoin((*psDroid).sMove.psFormation,
                              psDroid as *mut BASE_OBJECT);
            }
        }
    }
    return psDroid;
}
// no formation so create a new one
// -----------------------------------------------------------------------------------------
unsafe extern "C" fn loadDroidSetPointers() -> BOOL {
    let mut player: UDWORD = 0;
    let mut list: UDWORD = 0;
    let mut id: UDWORD = 0;
    let mut psDroid: *mut DROID = 0 as *mut DROID;
    let mut psCommander: *mut DROID = 0 as *mut DROID;
    let mut ppsDroidLists: [*mut *mut DROID; 3] = [0 as *mut *mut DROID; 3];
    ppsDroidLists[0 as libc::c_int as usize] = apsDroidLists.as_mut_ptr();
    ppsDroidLists[1 as libc::c_int as usize] =
        mission.apsDroidLists.as_mut_ptr();
    ppsDroidLists[2 as libc::c_int as usize] = apsLimboDroids.as_mut_ptr();
    list = 0 as libc::c_int as UDWORD;
    while list < 3 as libc::c_int as libc::c_uint {
        debug(LOG_NEVER, b"List %d\n\x00" as *const u8 as *const libc::c_char,
              list);
        player = 0 as libc::c_int as UDWORD;
        while player < 8 as libc::c_int as libc::c_uint {
            psDroid = *ppsDroidLists[list as usize].offset(player as isize);
            while !psDroid.is_null() {
                /*
			for(psDroid = ppsDroidLists[list][i]; psDroid; psDroid = psDroid->psNext)
			{
				id = (UDWORD)(psDroid->psTarget);
				psDroid->psTarget = (id==UDWORD_MAX ? NULL : getBaseObjFromId(id));
				id = (UDWORD)(psDroid->psActionTarget);
				psDroid->psActionTarget = ( id==UDWORD_MAX ? NULL : getBaseObjFromId(id));
				ASSERT( ((UDWORD)psDroid->psTarget)!=UDWORD_MAX,"Found invalid target" );
				ASSERT( ((UDWORD)psDroid->psActionTarget)!=UDWORD_MAX,"Found invalid action target" );
				DBPRINTF(("psDroid->psTarget = %d\n",psDroid->psTarget));
			}
			*/
                //Target rebuild the object pointer from the ID
                id = (*psDroid).psTarget as UDWORD;
                if id != 0xdddddddd as libc::c_uint {
                } else {
                    debug(LOG_ERROR,
                          b"LoadUnit found freed target\x00" as *const u8 as
                              *const libc::c_char);
                };
                if id != 0xdddddddd as libc::c_uint {
                } else {
                    debug(LOG_ERROR,
                          b"Assert in Warzone: %s:%d : %s (%s)\x00" as
                              *const u8 as *const libc::c_char,
                          b"game.c\x00" as *const u8 as *const libc::c_char,
                          5349 as libc::c_int,
                          (*::std::mem::transmute::<&[u8; 21],
                                                    &[libc::c_char; 21]>(b"loadDroidSetPointers\x00")).as_ptr(),
                          b"id != 0xdddddddd\x00" as *const u8 as
                              *const libc::c_char);
                };
                if id != 0xffffffff as libc::c_uint {
                    (*psDroid).psTarget = getBaseObjFromId(id);
                    if !(*psDroid).psTarget.is_null() {
                    } else {
                        debug(LOG_ERROR,
                              b"Saved Droid psTarget getBaseObjFromId() failed\x00"
                                  as *const u8 as *const libc::c_char);
                    };
                    if !(*psDroid).psTarget.is_null() {
                    } else {
                        debug(LOG_ERROR,
                              b"Assert in Warzone: %s:%d : %s (%s)\x00" as
                                  *const u8 as *const libc::c_char,
                              b"game.c\x00" as *const u8 as
                                  *const libc::c_char, 5353 as libc::c_int,
                              (*::std::mem::transmute::<&[u8; 21],
                                                        &[libc::c_char; 21]>(b"loadDroidSetPointers\x00")).as_ptr(),
                              b"psDroid->psTarget != NULL\x00" as *const u8 as
                                  *const libc::c_char);
                    };
                    if (*psDroid).psTarget.is_null() {
                        (*psDroid).order = DORDER_NONE as libc::c_int
                    }
                } else {
                    (*psDroid).psTarget = 0 as *mut _base_object
                    //psSaveDroid->targetID
                }
                //ActionTarget rebuild the object pointer from the ID
                id = (*psDroid).psActionTarget as UDWORD;
                if id != 0xdddddddd as libc::c_uint {
                } else {
                    debug(LOG_ERROR,
                          b"LoadUnit found freed action target\x00" as
                              *const u8 as *const libc::c_char);
                };
                if id != 0xdddddddd as libc::c_uint {
                } else {
                    debug(LOG_ERROR,
                          b"Assert in Warzone: %s:%d : %s (%s)\x00" as
                              *const u8 as *const libc::c_char,
                          b"game.c\x00" as *const u8 as *const libc::c_char,
                          5365 as libc::c_int,
                          (*::std::mem::transmute::<&[u8; 21],
                                                    &[libc::c_char; 21]>(b"loadDroidSetPointers\x00")).as_ptr(),
                          b"id != 0xdddddddd\x00" as *const u8 as
                              *const libc::c_char);
                };
                if id != 0xffffffff as libc::c_uint {
                    (*psDroid).psActionTarget = getBaseObjFromId(id);
                    if !(*psDroid).psActionTarget.is_null() {
                    } else {
                        debug(LOG_ERROR,
                              b"Saved Droid psActionTarget getBaseObjFromId() failed\x00"
                                  as *const u8 as *const libc::c_char);
                    };
                    if !(*psDroid).psActionTarget.is_null() {
                    } else {
                        debug(LOG_ERROR,
                              b"Assert in Warzone: %s:%d : %s (%s)\x00" as
                                  *const u8 as *const libc::c_char,
                              b"game.c\x00" as *const u8 as
                                  *const libc::c_char, 5369 as libc::c_int,
                              (*::std::mem::transmute::<&[u8; 21],
                                                        &[libc::c_char; 21]>(b"loadDroidSetPointers\x00")).as_ptr(),
                              b"psDroid->psActionTarget != NULL\x00" as
                                  *const u8 as *const libc::c_char);
                    };
                    if (*psDroid).psActionTarget.is_null() {
                        (*psDroid).action = DACTION_NONE as libc::c_int
                    }
                } else {
                    (*psDroid).psActionTarget = 0 as *mut _base_object
                    //psSaveDroid->targetID
                }
                //BaseStruct rebuild the object pointer from the ID
                id = (*psDroid).psBaseStruct as UDWORD;
                if id != 0xdddddddd as libc::c_uint {
                } else {
                    debug(LOG_ERROR,
                          b"LoadUnit found freed baseStruct\x00" as *const u8
                              as *const libc::c_char);
                };
                if id != 0xdddddddd as libc::c_uint {
                } else {
                    debug(LOG_ERROR,
                          b"Assert in Warzone: %s:%d : %s (%s)\x00" as
                              *const u8 as *const libc::c_char,
                          b"game.c\x00" as *const u8 as *const libc::c_char,
                          5381 as libc::c_int,
                          (*::std::mem::transmute::<&[u8; 21],
                                                    &[libc::c_char; 21]>(b"loadDroidSetPointers\x00")).as_ptr(),
                          b"id != 0xdddddddd\x00" as *const u8 as
                              *const libc::c_char);
                };
                if id != 0xffffffff as libc::c_uint {
                    (*psDroid).psBaseStruct =
                        getBaseObjFromId(id) as *mut STRUCTURE;
                    if !(*psDroid).psBaseStruct.is_null() {
                    } else {
                        debug(LOG_ERROR,
                              b"Saved Droid psBaseStruct getBaseObjFromId() failed\x00"
                                  as *const u8 as *const libc::c_char);
                    };
                    if !(*psDroid).psBaseStruct.is_null() {
                    } else {
                        debug(LOG_ERROR,
                              b"Assert in Warzone: %s:%d : %s (%s)\x00" as
                                  *const u8 as *const libc::c_char,
                              b"game.c\x00" as *const u8 as
                                  *const libc::c_char, 5385 as libc::c_int,
                              (*::std::mem::transmute::<&[u8; 21],
                                                        &[libc::c_char; 21]>(b"loadDroidSetPointers\x00")).as_ptr(),
                              b"psDroid->psBaseStruct != NULL\x00" as
                                  *const u8 as *const libc::c_char);
                    };
                    if (*psDroid).psBaseStruct.is_null() {
                        (*psDroid).action = DACTION_NONE as libc::c_int
                    }
                } else {
                    (*psDroid).psBaseStruct = 0 as *mut _structure
                    //psSaveDroid->targetID
                }
                if saveGameVersion > 20 as libc::c_int as libc::c_uint {
                    //rebuild group for droids in command group from the commander ID
                    if (*psDroid).psGrpNext as UDWORD ==
                           0xffffffff as libc::c_uint {
                        id = (*psDroid).psGroup as UDWORD;
                        (*psDroid).psGroup = 0 as *mut _droid_group;
                        (*psDroid).psGrpNext = 0 as *mut _droid;
                        if id != 0xdddddddd as libc::c_uint {
                        } else {
                            debug(LOG_ERROR,
                                  b"LoadUnit found freed commander\x00" as
                                      *const u8 as *const libc::c_char);
                        };
                        if id != 0xdddddddd as libc::c_uint {
                        } else {
                            debug(LOG_ERROR,
                                  b"Assert in Warzone: %s:%d : %s (%s)\x00" as
                                      *const u8 as *const libc::c_char,
                                  b"game.c\x00" as *const u8 as
                                      *const libc::c_char,
                                  5403 as libc::c_int,
                                  (*::std::mem::transmute::<&[u8; 21],
                                                            &[libc::c_char; 21]>(b"loadDroidSetPointers\x00")).as_ptr(),
                                  b"id != 0xdddddddd\x00" as *const u8 as
                                      *const libc::c_char);
                        };
                        if id != 0xffffffff as libc::c_uint {
                            psCommander = getBaseObjFromId(id) as *mut DROID;
                            if !psCommander.is_null() {
                            } else {
                                debug(LOG_ERROR,
                                      b"Saved Droid psCommander getBaseObjFromId() failed\x00"
                                          as *const u8 as
                                          *const libc::c_char);
                            };
                            if !psCommander.is_null() {
                            } else {
                                debug(LOG_ERROR,
                                      b"Assert in Warzone: %s:%d : %s (%s)\x00"
                                          as *const u8 as *const libc::c_char,
                                      b"game.c\x00" as *const u8 as
                                          *const libc::c_char,
                                      5407 as libc::c_int,
                                      (*::std::mem::transmute::<&[u8; 21],
                                                                &[libc::c_char; 21]>(b"loadDroidSetPointers\x00")).as_ptr(),
                                      b"psCommander != NULL\x00" as *const u8
                                          as *const libc::c_char);
                            };
                            if !psCommander.is_null() {
                                cmdDroidAddDroid(psCommander, psDroid);
                            }
                        }
                    }
                }
                psDroid = (*psDroid).psNext
            }
            player = player.wrapping_add(1)
        }
        list = list.wrapping_add(1)
    }
    /*
	for(player=0; player<MAX_PLAYERS; player++)
	{
		psDroid=(DROID *)apsDroidLists[player];
		while (psDroid)
		{
			//rebuild the object pointer from the ID
			id = (UDWORD)(psDroid->psTarget);
			if (id != UDWORD_MAX)
			{
				psDroid->psTarget			= getBaseObjFromId(id);
			}
			else
			{
				psDroid->psTarget			= NULL;//psSaveDroid->targetID
			}
			//rebuild the object pointer from the ID
			id = (UDWORD)(psDroid->psActionTarget);
			if (id != UDWORD_MAX)
			{
				psDroid->psActionTarget			= getBaseObjFromId(id);
			}
			else
			{
				psDroid->psActionTarget			= NULL;//psSaveDroid->targetID
			}
			psDroid = psDroid->psNext;
		}
	}
*/
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
/* code specific to version 11 of a save droid */
unsafe extern "C" fn loadSaveDroidV11(mut pFileData: *mut libc::c_char,
                                      mut filesize: UDWORD,
                                      mut numDroids: UDWORD,
                                      mut version: UDWORD,
                                      mut ppsCurrentDroidLists:
                                          *mut *mut DROID) -> BOOL {
    let mut psSaveDroid: *mut SAVE_DROID_V11 = 0 as *mut SAVE_DROID_V11;
    let mut sSaveDroid: SAVE_DROID_V11 =
        SAVE_DROID_V11{name: [0; 40],
                       id: 0,
                       x: 0,
                       y: 0,
                       z: 0,
                       direction: 0,
                       player: 0,
                       inFire: 0,
                       burnStart: 0,
                       burnDamage: 0,
                       asBits: [SAVE_COMPONENT_V19{name: [0; 40],}; 8],
                       body: 0,
                       droidType: 0,
                       saveType: 0,
                       numWeaps: 0,
                       asWeaps:
                           [SAVE_WEAPON_V19{name: [0; 40],
                                            hitPoints: 0,
                                            ammo: 0,
                                            lastFired: 0,}; 3],
                       numKills: 0,
                       turretRotation: 0,
                       turretPitch: 0,};
    //	DROID_TEMPLATE			*psTemplate, sTemplate;
    let mut psDroid: *mut DROID = 0 as *mut DROID;
    let mut psCurrentTransGroup: *mut DROID_GROUP = 0 as *mut DROID_GROUP;
    let mut count: UDWORD = 0;
    let mut NumberOfSkippedDroids: UDWORD = 0 as libc::c_int as UDWORD;
    let mut sizeOfSaveDroid: UDWORD = 0 as libc::c_int as UDWORD;
    let mut psGrp: *mut DROID_GROUP = 0 as *mut DROID_GROUP;
    let mut i: libc::c_int = 0;
    psCurrentTransGroup = 0 as *mut DROID_GROUP;
    psSaveDroid = &mut sSaveDroid;
    if version <= 10 as libc::c_int as libc::c_uint {
        sizeOfSaveDroid =
            ::std::mem::size_of::<SAVE_DROID_V9>() as libc::c_ulong
    } else if version == 11 as libc::c_int as libc::c_uint {
        sizeOfSaveDroid =
            ::std::mem::size_of::<SAVE_DROID_V11>() as libc::c_ulong
    } else if version <= 33 as libc::c_int as libc::c_uint {
        sizeOfSaveDroid =
            ::std::mem::size_of::<SAVE_DROID_V12>() as libc::c_ulong
    }
    if sizeOfSaveDroid.wrapping_mul(numDroids).wrapping_add(12 as libc::c_int
                                                                as
                                                                libc::c_uint)
           > filesize {
        debug(LOG_ERROR,
              b"unitLoad: unexpected end of file\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    /* Load in the droid data */
    count = 0 as libc::c_int as UDWORD;
    while count < numDroids {
        memcpy(psSaveDroid as *mut libc::c_void,
               pFileData as *const libc::c_void, sizeOfSaveDroid);
        /* DROID_SAVE_V11 includes OBJECT_SAVE_V19, SAVE_WEAPON_V19 */
        endian_udword(&mut (*psSaveDroid).body);
        endian_udword(&mut (*psSaveDroid).numWeaps);
        endian_udword(&mut (*psSaveDroid).numKills);
        endian_uword(&mut (*psSaveDroid).turretRotation);
        endian_uword(&mut (*psSaveDroid).turretPitch);
        /* OBJECT_SAVE_V19 */
        endian_udword(&mut (*psSaveDroid).id);
        endian_udword(&mut (*psSaveDroid).x);
        endian_udword(&mut (*psSaveDroid).y);
        endian_udword(&mut (*psSaveDroid).z);
        endian_udword(&mut (*psSaveDroid).direction);
        endian_udword(&mut (*psSaveDroid).player);
        endian_udword(&mut (*psSaveDroid).burnStart);
        endian_udword(&mut (*psSaveDroid).burnDamage);
        i = 0 as libc::c_int;
        while i < 3 as libc::c_int {
            /* SAVE_WEAPON_V19 */
            endian_udword(&mut (*(*psSaveDroid).asWeaps.as_mut_ptr().offset(i
                                                                                as
                                                                                isize)).hitPoints);
            endian_udword(&mut (*(*psSaveDroid).asWeaps.as_mut_ptr().offset(i
                                                                                as
                                                                                isize)).ammo);
            endian_udword(&mut (*(*psSaveDroid).asWeaps.as_mut_ptr().offset(i
                                                                                as
                                                                                isize)).lastFired);
            i += 1
        }
        // Here's a check that will allow us to load up save games on the playstation from the PC
		//  - It will skip data from any players after MAX_PLAYERS
        if (*psSaveDroid).player >= 8 as libc::c_int as libc::c_uint {
            NumberOfSkippedDroids = NumberOfSkippedDroids.wrapping_add(1);
            (*psSaveDroid).player =
                (8 as libc::c_int - 1 as libc::c_int) as UDWORD
            // now don't lose any droids ... force them to be the last player
        }
        psDroid = buildDroidFromSaveDroidV11(psSaveDroid);
        if psDroid.is_null() {
            debug(LOG_ERROR,
                  b"unitLoad: Template not found for unit\n\x00" as *const u8
                      as *const libc::c_char);
            abort();
        } else {
            if (*psSaveDroid).saveType as libc::c_int ==
                   DROID_ON_TRANSPORT as libc::c_int {
                //add the droid to the list
                (*psDroid).psTarget = 0 as *mut _base_object;
                (*psDroid).psActionTarget = 0 as *mut _base_object;
                (*psDroid).psBaseStruct = 0 as *mut _structure;
                if !psCurrentTransGroup.is_null() {
                } else {
                    debug(LOG_ERROR,
                          b"loadSaveUnitV9; Transporter unit without group \x00"
                              as *const u8 as *const libc::c_char);
                };
                if !psCurrentTransGroup.is_null() {
                } else {
                    debug(LOG_ERROR,
                          b"Assert in Warzone: %s:%d : %s (%s)\x00" as
                              *const u8 as *const libc::c_char,
                          b"game.c\x00" as *const u8 as *const libc::c_char,
                          5552 as libc::c_int,
                          (*::std::mem::transmute::<&[u8; 17],
                                                    &[libc::c_char; 17]>(b"loadSaveDroidV11\x00")).as_ptr(),
                          b"psCurrentTransGroup != NULL\x00" as *const u8 as
                              *const libc::c_char);
                };
                grpJoin(psCurrentTransGroup, psDroid);
            } else {
                //add the droid to the list
                addDroid(psDroid, ppsCurrentDroidLists);
            }
        }
        if !psDroid.is_null() {
            if (*psDroid).droidType as libc::c_uint ==
                   DROID_TRANSPORTER as libc::c_int as libc::c_uint {
                //set current TransPorter group
                if grpCreate(&mut psGrp) == 0 {
                    debug(LOG_NEVER,
                          b"unit build: unable to create group\n\x00" as
                              *const u8 as
                              *const libc::c_char); //ensure it always gets set
                    return 0 as libc::c_int
                }
                grpJoin(psGrp, psDroid);
                psCurrentTransGroup = (*psDroid).psGroup
            }
        }
        count = count.wrapping_add(1);
        pFileData = pFileData.offset(sizeOfSaveDroid as isize)
    }
    if NumberOfSkippedDroids > 0 as libc::c_int as libc::c_uint {
        debug(LOG_ERROR,
              b"unitLoad: Bad Player number in %d unit(s)... assigned to the last player!\n\x00"
                  as *const u8 as *const libc::c_char, NumberOfSkippedDroids);
        abort();
    }
    ppsCurrentDroidLists = 0 as *mut *mut DROID;
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
/* code specific all versions upto from 12 to 19*/
unsafe extern "C" fn loadSaveDroidV19(mut pFileData: *mut libc::c_char,
                                      mut filesize: UDWORD,
                                      mut numDroids: UDWORD,
                                      mut version: UDWORD,
                                      mut ppsCurrentDroidLists:
                                          *mut *mut DROID) -> BOOL {
    let mut psSaveDroid: *mut SAVE_DROID_V18 = 0 as *mut SAVE_DROID_V18;
    let mut sSaveDroid: SAVE_DROID_V18 =
        SAVE_DROID_V18{name: [0; 40],
                       id: 0,
                       x: 0,
                       y: 0,
                       z: 0,
                       direction: 0,
                       player: 0,
                       inFire: 0,
                       burnStart: 0,
                       burnDamage: 0,
                       asBits: [SAVE_COMPONENT_V19{name: [0; 40],}; 8],
                       body: 0,
                       droidType: 0,
                       saveType: 0,
                       numWeaps: 0,
                       asWeaps:
                           [SAVE_WEAPON_V19{name: [0; 40],
                                            hitPoints: 0,
                                            ammo: 0,
                                            lastFired: 0,}; 3],
                       numKills: 0,
                       turretRotation: 0,
                       turretPitch: 0,
                       order: 0,
                       orderX: 0,
                       orderY: 0,
                       orderX2: 0,
                       orderY2: 0,
                       timeLastHit: 0,
                       targetID: 0,
                       secondaryOrder: 0,
                       action: 0,
                       actionX: 0,
                       actionY: 0,
                       actionTargetID: 0,
                       actionStarted: 0,
                       actionPoints: 0,
                       actionHeight: 0,
                       tarStatName: [0; 40],
                       baseStructID: 0,
                       group: 0,
                       selected: 0,
                       cluster_unused: 0,
                       visible: [0; 8],
                       died: 0,
                       lastEmission: 0,};
    //	DROID_TEMPLATE			*psTemplate, sTemplate;
    let mut psDroid: *mut DROID = 0 as *mut DROID;
    let mut psCurrentTransGroup: *mut DROID_GROUP = 0 as *mut DROID_GROUP;
    let mut count: UDWORD = 0;
    let mut NumberOfSkippedDroids: UDWORD = 0 as libc::c_int as UDWORD;
    let mut sizeOfSaveDroid: UDWORD = 0 as libc::c_int as UDWORD;
    let mut psGrp: *mut DROID_GROUP = 0 as *mut DROID_GROUP;
    let mut i: libc::c_int = 0;
    psCurrentTransGroup = 0 as *mut DROID_GROUP;
    psSaveDroid = &mut sSaveDroid;
    if version <= 10 as libc::c_int as libc::c_uint {
        sizeOfSaveDroid =
            ::std::mem::size_of::<SAVE_DROID_V9>() as libc::c_ulong
    } else if version == 11 as libc::c_int as libc::c_uint {
        sizeOfSaveDroid =
            ::std::mem::size_of::<SAVE_DROID_V11>() as libc::c_ulong
    } else if version == 12 as libc::c_int as libc::c_uint {
        sizeOfSaveDroid =
            ::std::mem::size_of::<SAVE_DROID_V12>() as libc::c_ulong
    } else if version < 18 as libc::c_int as libc::c_uint {
        sizeOfSaveDroid =
            ::std::mem::size_of::<SAVE_DROID_V14>() as libc::c_ulong
    } else if version <= 33 as libc::c_int as libc::c_uint {
        sizeOfSaveDroid =
            ::std::mem::size_of::<SAVE_DROID_V18>() as libc::c_ulong
    }
    if sizeOfSaveDroid.wrapping_mul(numDroids).wrapping_add(12 as libc::c_int
                                                                as
                                                                libc::c_uint)
           > filesize {
        debug(LOG_ERROR,
              b"unitLoad: unexpected end of file\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    /* Load in the droid data */
    count = 0 as libc::c_int as UDWORD;
    while count < numDroids {
        memcpy(psSaveDroid as *mut libc::c_void,
               pFileData as *const libc::c_void, sizeOfSaveDroid);
        /* DROID_SAVE_V18 includes DROID_SAVE_V12*/
        endian_udword(&mut (*psSaveDroid).baseStructID);
        endian_udword(&mut (*psSaveDroid).died);
        endian_udword(&mut (*psSaveDroid).lastEmission);
        /* DROID_SAVE_V12 includes DROID_SAVE_V9 */
        endian_uword(&mut (*psSaveDroid).turretRotation);
        endian_uword(&mut (*psSaveDroid).turretPitch);
        endian_sdword(&mut (*psSaveDroid).order);
        endian_uword(&mut (*psSaveDroid).orderX);
        endian_uword(&mut (*psSaveDroid).orderY);
        endian_uword(&mut (*psSaveDroid).orderX2);
        endian_uword(&mut (*psSaveDroid).orderY2);
        endian_udword(&mut (*psSaveDroid).timeLastHit);
        endian_udword(&mut (*psSaveDroid).targetID);
        endian_udword(&mut (*psSaveDroid).secondaryOrder);
        endian_sdword(&mut (*psSaveDroid).action);
        endian_udword(&mut (*psSaveDroid).actionX);
        endian_udword(&mut (*psSaveDroid).actionY);
        endian_udword(&mut (*psSaveDroid).actionTargetID);
        endian_udword(&mut (*psSaveDroid).actionStarted);
        endian_udword(&mut (*psSaveDroid).actionPoints);
        endian_uword(&mut (*psSaveDroid).actionHeight);
        /* DROID_SAVE_V9 includes OBJECT_SAVE_V19, SAVE_WEAPON_V19 */
        endian_udword(&mut (*psSaveDroid).body);
        endian_udword(&mut (*psSaveDroid).saveType);
        endian_udword(&mut (*psSaveDroid).numWeaps);
        endian_udword(&mut (*psSaveDroid).numKills);
        /* OBJECT_SAVE_V19 */
        endian_udword(&mut (*psSaveDroid).id);
        endian_udword(&mut (*psSaveDroid).x);
        endian_udword(&mut (*psSaveDroid).y);
        endian_udword(&mut (*psSaveDroid).z);
        endian_udword(&mut (*psSaveDroid).direction);
        endian_udword(&mut (*psSaveDroid).player);
        endian_udword(&mut (*psSaveDroid).burnStart);
        endian_udword(&mut (*psSaveDroid).burnDamage);
        i = 0 as libc::c_int;
        while i < 3 as libc::c_int {
            /* SAVE_WEAPON_V19 */
            endian_udword(&mut (*(*psSaveDroid).asWeaps.as_mut_ptr().offset(i
                                                                                as
                                                                                isize)).hitPoints);
            endian_udword(&mut (*(*psSaveDroid).asWeaps.as_mut_ptr().offset(i
                                                                                as
                                                                                isize)).ammo);
            endian_udword(&mut (*(*psSaveDroid).asWeaps.as_mut_ptr().offset(i
                                                                                as
                                                                                isize)).lastFired);
            i += 1
        }
        // Here's a check that will allow us to load up save games on the playstation from the PC
		//  - It will skip data from any players after MAX_PLAYERS
        if (*psSaveDroid).player >= 8 as libc::c_int as libc::c_uint {
            NumberOfSkippedDroids = NumberOfSkippedDroids.wrapping_add(1);
            (*psSaveDroid).player =
                (8 as libc::c_int - 1 as libc::c_int) as UDWORD
            // now don't lose any droids ... force them to be the last player
        }
        psDroid = buildDroidFromSaveDroidV19(psSaveDroid, version);
        if psDroid.is_null() {
            if !psDroid.is_null() {
            } else {
                debug(LOG_ERROR,
                      b"unitLoad: Failed to build new unit\n\x00" as *const u8
                          as *const libc::c_char);
            };
            if !psDroid.is_null() {
            } else {
                debug(LOG_ERROR,
                      b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8
                          as *const libc::c_char,
                      b"game.c\x00" as *const u8 as *const libc::c_char,
                      5693 as libc::c_int,
                      (*::std::mem::transmute::<&[u8; 17],
                                                &[libc::c_char; 17]>(b"loadSaveDroidV19\x00")).as_ptr(),
                      b"psDroid != NULL\x00" as *const u8 as
                          *const libc::c_char);
            };
        } else if (*psSaveDroid).saveType ==
                      DROID_ON_TRANSPORT as libc::c_int as libc::c_uint {
            //add the droid to the list
            (*psDroid).order = DORDER_NONE as libc::c_int;
            (*psDroid).psTarget = 0 as *mut _base_object;
            (*psDroid).action = DACTION_NONE as libc::c_int;
            (*psDroid).psActionTarget = 0 as *mut _base_object;
            (*psDroid).psBaseStruct = 0 as *mut _structure;
            //add the droid to the list
            if !psCurrentTransGroup.is_null() {
            } else {
                debug(LOG_ERROR,
                      b"loadSaveUnitV9; Transporter unit without group \x00"
                          as *const u8 as *const libc::c_char);
            };
            if !psCurrentTransGroup.is_null() {
            } else {
                debug(LOG_ERROR,
                      b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8
                          as *const libc::c_char,
                      b"game.c\x00" as *const u8 as *const libc::c_char,
                      5704 as libc::c_int,
                      (*::std::mem::transmute::<&[u8; 17],
                                                &[libc::c_char; 17]>(b"loadSaveDroidV19\x00")).as_ptr(),
                      b"psCurrentTransGroup != NULL\x00" as *const u8 as
                          *const libc::c_char);
            };
            grpJoin(psCurrentTransGroup, psDroid);
        } else {
            //add the droid to the list
            addDroid(psDroid, ppsCurrentDroidLists);
        }
        if !psDroid.is_null() {
            if (*psDroid).droidType as libc::c_uint ==
                   DROID_TRANSPORTER as libc::c_int as libc::c_uint {
                //set current TransPorter group
                if grpCreate(&mut psGrp) == 0 {
                    debug(LOG_NEVER,
                          b"unit build: unable to create group\n\x00" as
                              *const u8 as
                              *const libc::c_char); //ensure it always gets set
                    return 0 as libc::c_int
                }
                grpJoin(psGrp, psDroid);
                psCurrentTransGroup = (*psDroid).psGroup
            }
        }
        count = count.wrapping_add(1);
        pFileData = pFileData.offset(sizeOfSaveDroid as isize)
    }
    if NumberOfSkippedDroids > 0 as libc::c_int as libc::c_uint {
        debug(LOG_ERROR,
              b"unitLoad: Bad Player number in %d unit(s)... assigned to the last player!\n\x00"
                  as *const u8 as *const libc::c_char, NumberOfSkippedDroids);
        abort();
    }
    ppsCurrentDroidLists = 0 as *mut *mut DROID;
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
/* code for all versions after save name change v19*/
unsafe extern "C" fn loadSaveDroidV(mut pFileData: *mut libc::c_char,
                                    mut filesize: UDWORD,
                                    mut numDroids: UDWORD,
                                    mut version: UDWORD,
                                    mut ppsCurrentDroidLists: *mut *mut DROID)
 -> BOOL {
    let mut psSaveDroid: *mut SAVE_DROID = 0 as *mut SAVE_DROID;
    let mut sSaveDroid: SAVE_DROID =
        SAVE_DROID{name: [0; 60],
                   id: 0,
                   x: 0,
                   y: 0,
                   z: 0,
                   direction: 0,
                   player: 0,
                   inFire: 0,
                   burnStart: 0,
                   burnDamage: 0,
                   asBits: [SAVE_COMPONENT{name: [0; 60],}; 8],
                   body: 0,
                   droidType: 0,
                   saveType: 0,
                   numWeaps: 0,
                   asWeaps:
                       [SAVE_WEAPON{name: [0; 60],
                                    hitPoints: 0,
                                    ammo: 0,
                                    lastFired: 0,}; 3],
                   numKills: 0,
                   turretRotation: 0,
                   turretPitch: 0,
                   order: 0,
                   orderX: 0,
                   orderY: 0,
                   orderX2: 0,
                   orderY2: 0,
                   timeLastHit: 0,
                   targetID: 0,
                   secondaryOrder: 0,
                   action: 0,
                   actionX: 0,
                   actionY: 0,
                   actionTargetID: 0,
                   actionStarted: 0,
                   actionPoints: 0,
                   actionHeight: 0,
                   tarStatName: [0; 60],
                   baseStructID: 0,
                   group: 0,
                   selected: 0,
                   cluster_unused: 0,
                   visible: [0; 8],
                   died: 0,
                   lastEmission: 0,
                   commandId: 0,
                   resistance: 0,
                   sMove:
                       SAVE_MOVE_CONTROL{Status: 0,
                                         Mask: 0,
                                         Position: 0,
                                         numPoints: 0,
                                         asPath:
                                             [PATH_POINT{x: 0, y: 0,}; 100],
                                         DestinationX: 0,
                                         DestinationY: 0,
                                         srcX: 0,
                                         srcY: 0,
                                         targetX: 0,
                                         targetY: 0,
                                         fx: 0.,
                                         fy: 0.,
                                         speed: 0.,
                                         boundX: 0,
                                         boundY: 0,
                                         dir: 0,
                                         bumpDir: 0,
                                         bumpTime: 0,
                                         lastBump: 0,
                                         pauseTime: 0,
                                         bumpX: 0,
                                         bumpY: 0,
                                         shuffleStart: 0,
                                         psFormation: 0 as *mut _formation,
                                         iVertSpeed: 0,
                                         iAttackRuns: 0,},
                   formationDir: 0,
                   formationX: 0,
                   formationY: 0,};
    //	DROID_TEMPLATE			*psTemplate, sTemplate;
    let mut psDroid: *mut DROID = 0 as *mut DROID;
    let mut psCurrentTransGroup: *mut DROID_GROUP = 0 as *mut DROID_GROUP;
    let mut count: UDWORD = 0;
    let mut NumberOfSkippedDroids: UDWORD = 0 as libc::c_int as UDWORD;
    let mut sizeOfSaveDroid: UDWORD = 0 as libc::c_int as UDWORD;
    //	DROID_GROUP				*psGrp;
    let mut i: libc::c_int = 0;
    psCurrentTransGroup = 0 as *mut DROID_GROUP;
    psSaveDroid = &mut sSaveDroid;
    if version <= 20 as libc::c_int as libc::c_uint {
        sizeOfSaveDroid =
            ::std::mem::size_of::<SAVE_DROID_V20>() as libc::c_ulong
    } else if version <= 23 as libc::c_int as libc::c_uint {
        sizeOfSaveDroid =
            ::std::mem::size_of::<SAVE_DROID_V21>() as libc::c_ulong
    } else if version <= 33 as libc::c_int as libc::c_uint {
        sizeOfSaveDroid = ::std::mem::size_of::<SAVE_DROID>() as libc::c_ulong
    }
    if sizeOfSaveDroid.wrapping_mul(numDroids).wrapping_add(12 as libc::c_int
                                                                as
                                                                libc::c_uint)
           > filesize {
        debug(LOG_ERROR,
              b"unitLoad: unexpected end of file\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    /* Load in the droid data */
    count = 0 as libc::c_int as UDWORD;
    while count < numDroids {
        memcpy(psSaveDroid as *mut libc::c_void,
               pFileData as *const libc::c_void, sizeOfSaveDroid);
        /* DROID_SAVE_V24 includes DROID_SAVE_V21,
		 * SAVE_MOVE_CONTROL */
        endian_sdword(&mut (*psSaveDroid).resistance);
        endian_sword(&mut (*psSaveDroid).formationDir);
        endian_sdword(&mut (*psSaveDroid).formationX);
        endian_sdword(&mut (*psSaveDroid).formationY);
        /* DROID_SAVE_V21 includes DROID_SAVE_V20 */
        endian_udword(&mut (*psSaveDroid).commandId);
        /* DROID_SAVE_V20 includes OBJECT_SAVE_V20, SAVE_WEAPON */
        endian_udword(&mut (*psSaveDroid).body);
        endian_udword(&mut (*psSaveDroid).saveType);
        endian_udword(&mut (*psSaveDroid).numWeaps);
        endian_udword(&mut (*psSaveDroid).numKills);
        endian_uword(&mut (*psSaveDroid).turretRotation);
        endian_uword(&mut (*psSaveDroid).turretPitch);
        endian_sdword(&mut (*psSaveDroid).order);
        endian_uword(&mut (*psSaveDroid).orderX);
        endian_uword(&mut (*psSaveDroid).orderY);
        endian_uword(&mut (*psSaveDroid).orderX2);
        endian_uword(&mut (*psSaveDroid).orderY2);
        endian_udword(&mut (*psSaveDroid).timeLastHit);
        endian_udword(&mut (*psSaveDroid).targetID);
        endian_udword(&mut (*psSaveDroid).secondaryOrder);
        endian_sdword(&mut (*psSaveDroid).action);
        endian_udword(&mut (*psSaveDroid).actionX);
        endian_udword(&mut (*psSaveDroid).actionY);
        endian_udword(&mut (*psSaveDroid).actionTargetID);
        endian_udword(&mut (*psSaveDroid).actionStarted);
        endian_udword(&mut (*psSaveDroid).actionPoints);
        endian_uword(&mut (*psSaveDroid).actionHeight);
        endian_udword(&mut (*psSaveDroid).baseStructID);
        endian_udword(&mut (*psSaveDroid).died);
        endian_udword(&mut (*psSaveDroid).lastEmission);
        /* OBJECT_SAVE_V20 */
        endian_udword(&mut (*psSaveDroid).id);
        endian_udword(&mut (*psSaveDroid).x);
        endian_udword(&mut (*psSaveDroid).y);
        endian_udword(&mut (*psSaveDroid).z);
        endian_udword(&mut (*psSaveDroid).direction);
        endian_udword(&mut (*psSaveDroid).player);
        endian_udword(&mut (*psSaveDroid).burnStart);
        endian_udword(&mut (*psSaveDroid).burnDamage);
        /* SAVE_MOVE_CONTROL */
        endian_sdword(&mut (*psSaveDroid).sMove.DestinationX);
        endian_sdword(&mut (*psSaveDroid).sMove.DestinationY);
        endian_sdword(&mut (*psSaveDroid).sMove.srcX);
        endian_sdword(&mut (*psSaveDroid).sMove.srcY);
        endian_sdword(&mut (*psSaveDroid).sMove.targetX);
        endian_sdword(&mut (*psSaveDroid).sMove.targetY);
        endian_sword(&mut (*psSaveDroid).sMove.boundX);
        endian_sword(&mut (*psSaveDroid).sMove.boundY);
        endian_sword(&mut (*psSaveDroid).sMove.dir);
        endian_sword(&mut (*psSaveDroid).sMove.bumpDir);
        endian_udword(&mut (*psSaveDroid).sMove.bumpTime);
        endian_uword(&mut (*psSaveDroid).sMove.lastBump);
        endian_uword(&mut (*psSaveDroid).sMove.pauseTime);
        endian_uword(&mut (*psSaveDroid).sMove.bumpX);
        endian_uword(&mut (*psSaveDroid).sMove.bumpY);
        endian_udword(&mut (*psSaveDroid).sMove.shuffleStart);
        endian_sword(&mut (*psSaveDroid).sMove.iVertSpeed);
        endian_uword(&mut (*psSaveDroid).sMove.iAttackRuns);
        i = 0 as libc::c_int;
        while i < 3 as libc::c_int {
            /* SAVE_WEAPON */
            endian_udword(&mut (*(*psSaveDroid).asWeaps.as_mut_ptr().offset(i
                                                                                as
                                                                                isize)).hitPoints);
            endian_udword(&mut (*(*psSaveDroid).asWeaps.as_mut_ptr().offset(i
                                                                                as
                                                                                isize)).ammo);
            endian_udword(&mut (*(*psSaveDroid).asWeaps.as_mut_ptr().offset(i
                                                                                as
                                                                                isize)).lastFired);
            i += 1
        }
        // Here's a check that will allow us to load up save games on the playstation from the PC
		//  - It will skip data from any players after MAX_PLAYERS
        if (*psSaveDroid).player >= 8 as libc::c_int as libc::c_uint {
            NumberOfSkippedDroids = NumberOfSkippedDroids.wrapping_add(1);
            (*psSaveDroid).player =
                (8 as libc::c_int - 1 as libc::c_int) as UDWORD
            // now don't lose any droids ... force them to be the last player
        }
        psDroid = buildDroidFromSaveDroid(psSaveDroid, version);
        if psDroid.is_null() {
            if !psDroid.is_null() {
            } else {
                debug(LOG_ERROR,
                      b"unitLoad: Failed to build new unit\n\x00" as *const u8
                          as *const libc::c_char);
            };
            if !psDroid.is_null() {
            } else {
                debug(LOG_ERROR,
                      b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8
                          as *const libc::c_char,
                      b"game.c\x00" as *const u8 as *const libc::c_char,
                      5862 as libc::c_int,
                      (*::std::mem::transmute::<&[u8; 15],
                                                &[libc::c_char; 15]>(b"loadSaveDroidV\x00")).as_ptr(),
                      b"psDroid != NULL\x00" as *const u8 as
                          *const libc::c_char);
            };
        } else if (*psSaveDroid).saveType ==
                      DROID_ON_TRANSPORT as libc::c_int as libc::c_uint {
            //add the droid to the list
            (*psDroid).order = DORDER_NONE as libc::c_int;
            (*psDroid).psTarget = 0 as *mut _base_object;
            (*psDroid).action = DACTION_NONE as libc::c_int;
            (*psDroid).psActionTarget = 0 as *mut _base_object;
            (*psDroid).psBaseStruct = 0 as *mut _structure;
            //add the droid to the list
            (*psDroid).psGroup = 0 as *mut _droid_group;
            (*psDroid).psGrpNext = 0 as *mut _droid;
            if !psCurrentTransGroup.is_null() {
            } else {
                debug(LOG_ERROR,
                      b"loadSaveUnitV9; Transporter unit without group \x00"
                          as *const u8 as *const libc::c_char);
            };
            if !psCurrentTransGroup.is_null() {
            } else {
                debug(LOG_ERROR,
                      b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8
                          as *const libc::c_char,
                      b"game.c\x00" as *const u8 as *const libc::c_char,
                      5875 as libc::c_int,
                      (*::std::mem::transmute::<&[u8; 15],
                                                &[libc::c_char; 15]>(b"loadSaveDroidV\x00")).as_ptr(),
                      b"psCurrentTransGroup != NULL\x00" as *const u8 as
                          *const libc::c_char);
            };
            grpJoin(psCurrentTransGroup, psDroid);
        } else if (*psDroid).droidType as libc::c_uint ==
                      DROID_TRANSPORTER as libc::c_int as libc::c_uint {
            //set current TransPorter group
/*set in build droid
				if (!grpCreate(&psGrp))
				{
					DBPRINTF(("droid build: unable to create group\n"));
					return FALSE;
				}
				psDroid->psGroup = NULL;
				grpJoin(psGrp, psDroid);
*/
            psCurrentTransGroup = (*psDroid).psGroup;
            addDroid(psDroid, ppsCurrentDroidLists);
        } else {
            //add the droid to the list
            addDroid(psDroid,
                     ppsCurrentDroidLists); //ensure it always gets set
        }
        count = count.wrapping_add(1);
        pFileData = pFileData.offset(sizeOfSaveDroid as isize)
    }
    if NumberOfSkippedDroids > 0 as libc::c_int as libc::c_uint {
        debug(LOG_ERROR,
              b"unitLoad: Bad Player number in %d unit(s)... assigned to the last player!\n\x00"
                  as *const u8 as *const libc::c_char, NumberOfSkippedDroids);
        abort();
    }
    ppsCurrentDroidLists = 0 as *mut *mut DROID;
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
#[no_mangle]
pub unsafe extern "C" fn buildSaveDroidFromDroid(mut psSaveDroid:
                                                     *mut SAVE_DROID,
                                                 mut psCurr: *mut DROID,
                                                 mut saveType:
                                                     DROID_SAVE_TYPE)
 -> BOOL {
    let mut i: UDWORD = 0;
    //			strcpy(psSaveDroid->name, psCurr->pName);
    /*want to store the resource ID string for compatibilty with
			different versions of save game - NOT HAPPENING - the name saved is
			the translated name - old versions of save games should load because
			templates are loaded from Access AND the save game so they should all
			still exist*/
    strcpy((*psSaveDroid).name.as_mut_ptr(), (*psCurr).aName.as_mut_ptr());
    //for (i=0; i < DROID_MAXCOMP; i++) not interested in first comp - COMP_UNKNOWN
    i = 1 as libc::c_int as UDWORD;
    while i <
              (COMP_NUMCOMPONENTS as libc::c_int - 1 as libc::c_int) as
                  libc::c_uint {
        if getNameFromComp(i,
                           (*psSaveDroid).asBits[i as
                                                     usize].name.as_mut_ptr(),
                           (*psCurr).asBits[i as usize].nStat as UDWORD) == 0
           {
            break ;
        }
        i = i.wrapping_add(1)
    }
    (*psSaveDroid).body = (*psCurr).body;
    //			psSaveDroid->activeWeapon = psCurr->activeWeapon;
			//psSaveDroid->numWeaps = psCurr->numWeaps;
			/*for (i=0; i < psCurr->numWeaps; i++)
			{
#ifdef HASH_NAMES
				if (!getHashFromComp(COMP_WEAPON, &psSaveDroid->asWeaps[i].NameHash, psCurr->asWeaps[i].nStat))
#else
				if (!getNameFromComp(COMP_WEAPON, psSaveDroid->asWeaps[i].name, psCurr->asWeaps[i].nStat))
#endif
				{
					//ignore this record
					//continue;
					break;
				}
				psSaveDroid->asWeaps[i].hitPoints = psCurr->asWeaps[i].hitPoints;
				psSaveDroid->asWeaps[i].ammo = psCurr->asWeaps[i].ammo;
				psSaveDroid->asWeaps[i].lastFired = psCurr->asWeaps[i].lastFired;
			}*/
    (*psSaveDroid).numWeaps = 0 as libc::c_int as UDWORD;
    if (*psCurr).asWeaps[0 as libc::c_int as usize].nStat >
           0 as libc::c_int as libc::c_uint {
        //there is only one weapon now
        (*psSaveDroid).numWeaps = 1 as libc::c_int as UDWORD;
        i = 0 as libc::c_int as UDWORD;
        if getNameFromComp(COMP_WEAPON as libc::c_int as UDWORD,
                           (*psSaveDroid).asWeaps[i as
                                                      usize].name.as_mut_ptr(),
                           (*psCurr).asWeaps[i as usize].nStat) != 0 {
            (*psSaveDroid).asWeaps[i as usize].hitPoints =
                (*psCurr).asWeaps[i as usize].hitPoints;
            (*psSaveDroid).asWeaps[i as usize].ammo =
                (*psCurr).asWeaps[i as usize].ammo;
            (*psSaveDroid).asWeaps[i as usize].lastFired =
                (*psCurr).asWeaps[i as usize].lastFired
        }
    } else {
        (*psSaveDroid).asWeaps[0 as libc::c_int as
                                   usize].name[0 as libc::c_int as usize] =
            '\u{0}' as i32 as STRING
    }
    //save out experience level
    (*psSaveDroid).numKills = (*psCurr).numKills as UDWORD;
    //version 11
    (*psSaveDroid).turretRotation = (*psCurr).turretRotation;
    (*psSaveDroid).turretPitch = (*psCurr).turretPitch;
    //version 12
    (*psSaveDroid).order = (*psCurr).order;
    (*psSaveDroid).orderX = (*psCurr).orderX;
    (*psSaveDroid).orderY = (*psCurr).orderY;
    (*psSaveDroid).orderX2 = (*psCurr).orderX2;
    (*psSaveDroid).orderY2 = (*psCurr).orderY2;
    (*psSaveDroid).timeLastHit = (*psCurr).timeLastHit;
    if !(*psCurr).psTarget.is_null() {
        if (*(*psCurr).psTarget).id != 0xdddddddd as libc::c_uint {
        } else {
            debug(LOG_ERROR,
                  b"SaveUnit found freed target\x00" as *const u8 as
                      *const libc::c_char);
        };
        if (*(*psCurr).psTarget).id != 0xdddddddd as libc::c_uint {
        } else {
            debug(LOG_ERROR,
                  b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                      *const libc::c_char,
                  b"game.c\x00" as *const u8 as *const libc::c_char,
                  5992 as libc::c_int,
                  (*::std::mem::transmute::<&[u8; 24],
                                            &[libc::c_char; 24]>(b"buildSaveDroidFromDroid\x00")).as_ptr(),
                  b"psCurr->psTarget->id != 0xdddddddd\x00" as *const u8 as
                      *const libc::c_char);
        };
        if (*(*psCurr).psTarget).died <= 1 as libc::c_int as libc::c_uint {
            (*psSaveDroid).targetID = (*(*psCurr).psTarget).id;
            if checkValidId((*psSaveDroid).targetID) == 0 {
                (*psSaveDroid).targetID = 0xffffffff as libc::c_uint
            }
        } else { (*psSaveDroid).targetID = 0xffffffff as libc::c_uint }
    } else { (*psSaveDroid).targetID = 0xffffffff as libc::c_uint }
    (*psSaveDroid).secondaryOrder = (*psCurr).secondaryOrder;
    (*psSaveDroid).action = (*psCurr).action;
    (*psSaveDroid).actionX = (*psCurr).actionX;
    (*psSaveDroid).actionY = (*psCurr).actionY;
    if !(*psCurr).psActionTarget.is_null() {
        if (*(*psCurr).psActionTarget).id != 0xdddddddd as libc::c_uint {
        } else {
            debug(LOG_ERROR,
                  b"SaveUnit found freed action target\x00" as *const u8 as
                      *const libc::c_char);
        };
        if (*(*psCurr).psActionTarget).id != 0xdddddddd as libc::c_uint {
        } else {
            debug(LOG_ERROR,
                  b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                      *const libc::c_char,
                  b"game.c\x00" as *const u8 as *const libc::c_char,
                  6016 as libc::c_int,
                  (*::std::mem::transmute::<&[u8; 24],
                                            &[libc::c_char; 24]>(b"buildSaveDroidFromDroid\x00")).as_ptr(),
                  b"psCurr->psActionTarget->id != 0xdddddddd\x00" as *const u8
                      as *const libc::c_char);
        };
        if (*(*psCurr).psActionTarget).died <=
               1 as libc::c_int as libc::c_uint {
            (*psSaveDroid).actionTargetID = (*(*psCurr).psActionTarget).id;
            if checkValidId((*psSaveDroid).actionTargetID) == 0 {
                (*psSaveDroid).actionTargetID = 0xffffffff as libc::c_uint
            }
        } else { (*psSaveDroid).actionTargetID = 0xffffffff as libc::c_uint }
    } else { (*psSaveDroid).actionTargetID = 0xffffffff as libc::c_uint }
    (*psSaveDroid).actionStarted = (*psCurr).actionStarted;
    (*psSaveDroid).actionPoints = (*psCurr).actionPoints;
    //actionHeight has been renamed to powerAccrued - AB 7/1/99
			//psSaveDroid->actionHeight	= psCurr->actionHeight;
    (*psSaveDroid).actionHeight = (*psCurr).powerAccrued;
    //version 14
    if !(*psCurr).psTarStats.is_null() {
        if strlen((*(*psCurr).psTarStats).pName) <
               60 as libc::c_int as libc::c_uint {
        } else {
            debug(LOG_ERROR,
                  b"writeUnitFile; psTarStat pName Error\x00" as *const u8 as
                      *const libc::c_char);
        };
        if strlen((*(*psCurr).psTarStats).pName) <
               60 as libc::c_int as libc::c_uint {
        } else {
            debug(LOG_ERROR,
                  b"Assert in Warzone: %s:%d : %s (%s)\x00" as *const u8 as
                      *const libc::c_char,
                  b"game.c\x00" as *const u8 as *const libc::c_char,
                  6044 as libc::c_int,
                  (*::std::mem::transmute::<&[u8; 24],
                                            &[libc::c_char; 24]>(b"buildSaveDroidFromDroid\x00")).as_ptr(),
                  b"strlen(psCurr->psTarStats->pName) < MAX_NAME_SIZE\x00" as
                      *const u8 as *const libc::c_char);
        };
        strcpy((*psSaveDroid).tarStatName.as_mut_ptr(),
               (*(*psCurr).psTarStats).pName);
    } else {
        strcpy((*psSaveDroid).tarStatName.as_mut_ptr(),
               b"\x00" as *const u8 as *const libc::c_char);
    }
    if !(*psCurr).psBaseStruct.is_null() &&
           (*psCurr).psBaseStruct as UDWORD != 0xffffffff as libc::c_uint {
        if (*(*psCurr).psBaseStruct).died <= 1 as libc::c_int as libc::c_uint
           {
            (*psSaveDroid).baseStructID = (*(*psCurr).psBaseStruct).id;
            if checkValidId((*psSaveDroid).baseStructID) == 0 {
                (*psSaveDroid).baseStructID = 0xffffffff as libc::c_uint
            }
        } else { (*psSaveDroid).baseStructID = 0xffffffff as libc::c_uint }
    } else { (*psSaveDroid).baseStructID = 0xffffffff as libc::c_uint }
    (*psSaveDroid).group = (*psCurr).group;
    (*psSaveDroid).selected = (*psCurr).selected;
    //20feb			psSaveDroid->cluster = psCurr->cluster;
    (*psSaveDroid).died = (*psCurr).died;
    (*psSaveDroid).lastEmission = (*psCurr).lastEmission;
    i = 0 as libc::c_int as UDWORD;
    while i < 8 as libc::c_int as libc::c_uint {
        (*psSaveDroid).visible[i as usize] = (*psCurr).visible[i as usize];
        i = i.wrapping_add(1)
    }
    //version 21
    if !(*psCurr).psGroup.is_null() &&
           (*psCurr).droidType as libc::c_uint !=
               DROID_COMMAND as libc::c_int as libc::c_uint {
        if (*(*psCurr).psGroup).type_0 as libc::c_int ==
               GT_COMMAND as libc::c_int {
            if (*(*(*psCurr).psGroup).psCommander).died <=
                   1 as libc::c_int as libc::c_uint {
                (*psSaveDroid).commandId =
                    (*(*(*psCurr).psGroup).psCommander).id;
                if checkValidId((*psSaveDroid).commandId) != 0 {
                } else {
                    debug(LOG_ERROR,
                          b"SaveUnit pcCommander not found\x00" as *const u8
                              as *const libc::c_char);
                };
                if checkValidId((*psSaveDroid).commandId) != 0 {
                } else {
                    debug(LOG_ERROR,
                          b"Assert in Warzone: %s:%d : %s (%s)\x00" as
                              *const u8 as *const libc::c_char,
                          b"game.c\x00" as *const u8 as *const libc::c_char,
                          6088 as libc::c_int,
                          (*::std::mem::transmute::<&[u8; 24],
                                                    &[libc::c_char; 24]>(b"buildSaveDroidFromDroid\x00")).as_ptr(),
                          b"checkValidId(psSaveDroid->commandId)\x00" as
                              *const u8 as *const libc::c_char);
                };
            } else {
                (*psSaveDroid).commandId = 0xffffffff as libc::c_uint;
                if 0 as libc::c_int != 0 {
                } else {
                    debug(LOG_ERROR,
                          b"SaveUnit pcCommander died\x00" as *const u8 as
                              *const libc::c_char);
                };
                if 0 as libc::c_int != 0 {
                } else {
                    debug(LOG_ERROR,
                          b"Assert in Warzone: %s:%d : %s (%s)\x00" as
                              *const u8 as *const libc::c_char,
                          b"game.c\x00" as *const u8 as *const libc::c_char,
                          6093 as libc::c_int,
                          (*::std::mem::transmute::<&[u8; 24],
                                                    &[libc::c_char; 24]>(b"buildSaveDroidFromDroid\x00")).as_ptr(),
                          b"FALSE\x00" as *const u8 as *const libc::c_char);
                };
            }
        } else { (*psSaveDroid).commandId = 0xffffffff as libc::c_uint }
    } else { (*psSaveDroid).commandId = 0xffffffff as libc::c_uint }
    //version 24
    (*psSaveDroid).resistance = (*psCurr).resistance as SDWORD;
    memcpy(&mut (*psSaveDroid).sMove as *mut SAVE_MOVE_CONTROL as
               *mut libc::c_void,
           &mut (*psCurr).sMove as *mut MOVE_CONTROL as *const libc::c_void,
           ::std::mem::size_of::<SAVE_MOVE_CONTROL>() as libc::c_ulong);
    if !(*psSaveDroid).sMove.psFormation.is_null() {
        (*psSaveDroid).formationDir = (*(*psCurr).sMove.psFormation).dir;
        (*psSaveDroid).formationX = (*(*psCurr).sMove.psFormation).x;
        (*psSaveDroid).formationY = (*(*psCurr).sMove.psFormation).y
    } else {
        (*psSaveDroid).formationDir = 0 as libc::c_int as SWORD;
        (*psSaveDroid).formationX = 0 as libc::c_int;
        (*psSaveDroid).formationY = 0 as libc::c_int
    }
    /*psSaveDroid->activeProg = psCurr->activeProg;
			psSaveDroid->numProgs = psCurr->numProgs;
			for (i=0; i < psCurr->numProgs; i++)
			{
#ifdef HASH_NAMES
				if (!getHashFromComp(COMP_PROGRAM, & psSaveDroid->HashProgs[i], psCurr->asProgs[i].psStats - asProgramStats))
#else
				if (!getNameFromComp(COMP_PROGRAM, psSaveDroid->asProgs[i], psCurr->asProgs[i].psStats - asProgramStats))
#endif
				{
					//ignore this record
					continue;
				}
			}*/
    //			psSaveDroid->sMove = psCurr->sMove;
//			psSaveDroid->sDisplay = psCurr->sDisplay;
    /* psSaveDroid->aiState = psCurr->sAI.state;
			if (psCurr->sAI.psTarget)
			{
				psSaveDroid->subjectID = psCurr->sAI.psTarget->id;
				psSaveDroid->subjectType = psCurr->sAI.psTarget->type;
				psSaveDroid->subjectPlayer = psCurr->sAI.psTarget->player;
			}
			else
			{
				psSaveDroid->subjectID = -1;
				psSaveDroid->subjectType = 0;
				psSaveDroid->subjectPlayer = 0;
			}
			if (psCurr->sAI.psSelectedWeapon)
			{
				psSaveDroid->weaponInc = psCurr->sAI.psSelectedWeapon->psStats->ref - REF_WEAPON_START;
			}
			else
			{
				psSaveDroid->weaponInc = 0;
			}
			if(psCurr->sAI.psStructToBuild)
			{
				psSaveDroid->structureInc = psCurr->sAI.psStructToBuild - asStructureStats;
			}
			else
			{
				psSaveDroid->structureInc = -1;
			}
			psSaveDroid->timeStarted = psCurr->sAI.timeStarted;
			psSaveDroid->pointsToAdd = psCurr->sAI.pointsToAdd; */
    (*psSaveDroid).id = (*psCurr).id; //identifies special load cases
    (*psSaveDroid).x = (*psCurr).x as UDWORD;
    (*psSaveDroid).y = (*psCurr).y as UDWORD;
    (*psSaveDroid).z = (*psCurr).z as UDWORD;
    (*psSaveDroid).direction = (*psCurr).direction as UDWORD;
    (*psSaveDroid).player = (*psCurr).player as UDWORD;
    (*psSaveDroid).inFire = (*psCurr).inFire;
    (*psSaveDroid).burnStart = (*psCurr).burnStart;
    (*psSaveDroid).burnDamage = (*psCurr).burnDamage;
    (*psSaveDroid).droidType = (*psCurr).droidType as UBYTE;
    (*psSaveDroid).saveType = saveType as UBYTE as UDWORD;
    /* SAVE_DROID is DROID_SAVE_V24 */
			/* DROID_SAVE_V24 includes DROID_SAVE_V21 */
    endian_sdword(&mut (*psSaveDroid).resistance);
    endian_sdword(&mut (*psSaveDroid).sMove.DestinationX);
    endian_sdword(&mut (*psSaveDroid).sMove.DestinationY);
    endian_sdword(&mut (*psSaveDroid).sMove.srcX);
    endian_sdword(&mut (*psSaveDroid).sMove.srcY);
    endian_sdword(&mut (*psSaveDroid).sMove.targetX);
    endian_sdword(&mut (*psSaveDroid).sMove.targetY);
    endian_fract(&mut (*psSaveDroid).sMove.fx);
    endian_fract(&mut (*psSaveDroid).sMove.fy);
    endian_fract(&mut (*psSaveDroid).sMove.speed);
    endian_sword(&mut (*psSaveDroid).sMove.boundX);
    endian_sword(&mut (*psSaveDroid).sMove.boundY);
    endian_sword(&mut (*psSaveDroid).sMove.dir);
    endian_sword(&mut (*psSaveDroid).sMove.bumpDir);
    endian_udword(&mut (*psSaveDroid).sMove.bumpTime);
    endian_uword(&mut (*psSaveDroid).sMove.lastBump);
    endian_uword(&mut (*psSaveDroid).sMove.pauseTime);
    endian_uword(&mut (*psSaveDroid).sMove.bumpX);
    endian_uword(&mut (*psSaveDroid).sMove.bumpY);
    /* I don't think this is necessary.
			if(psSaveDroid->sMove.psFormation) {
				endian_sword(&psSaveDroid->sMove.psFormation->refCount);
				endian_sword(&psSaveDroid->sMove.psFormation->size);
				endian_sword(&psSaveDroid->sMove.psFormation->rankDist);
				endian_sword(&psSaveDroid->sMove.psFormation->dir);
				endian_sdword(&psSaveDroid->sMove.psFormation->x);
				endian_sdword(&psSaveDroid->sMove.psFormation->y);
				for(i = 0; i < F_MAXLINES; i++) {
					endian_sword(&psSaveDroid->sMove.psFormation->asLines[i].xoffset);
					endian_sword(&psSaveDroid->sMove.psFormation->asLines[i].yoffset);
					endian_sword(&psSaveDroid->sMove.psFormation->asLines[i].dir);
				}
				endian_sword(&psSaveDroid->sMove.psFormation->numLines);
				for(i = 0; i < F_MAXMEMBERS; i++)
					endian_sword(&psSaveDroid->sMove.psFormation->asMembers[i].dist);
				endian_udword(&psSaveDroid->sMove.psFormation->iSpeed);
			}
*/
    endian_sword(&mut (*psSaveDroid).sMove.iVertSpeed);
    endian_uword(&mut (*psSaveDroid).sMove.iAttackRuns);
    endian_sword(&mut (*psSaveDroid).formationDir);
    endian_sdword(&mut (*psSaveDroid).formationX);
    endian_sdword(&mut (*psSaveDroid).formationY);
    /* DROID_SAVE_V21 includes DROID_SAVE_V20 */
    endian_udword(&mut (*psSaveDroid).commandId);
    /* DROID_SAVE_V20 includes OBJECT_SAVE_V20 */
    endian_udword(&mut (*psSaveDroid).body);
    endian_udword(&mut (*psSaveDroid).saveType);
    endian_udword(&mut (*psSaveDroid).numWeaps);
    i = 0 as libc::c_int as UDWORD;
    while i < 3 as libc::c_int as libc::c_uint {
        endian_udword(&mut (*(*psSaveDroid).asWeaps.as_mut_ptr().offset(i as
                                                                            isize)).hitPoints);
        endian_udword(&mut (*(*psSaveDroid).asWeaps.as_mut_ptr().offset(i as
                                                                            isize)).ammo);
        endian_udword(&mut (*(*psSaveDroid).asWeaps.as_mut_ptr().offset(i as
                                                                            isize)).lastFired);
        i = i.wrapping_add(1)
    }
    endian_udword(&mut (*psSaveDroid).numKills);
    endian_uword(&mut (*psSaveDroid).turretRotation);
    endian_uword(&mut (*psSaveDroid).turretPitch);
    endian_sdword(&mut (*psSaveDroid).order);
    endian_uword(&mut (*psSaveDroid).orderX);
    endian_uword(&mut (*psSaveDroid).orderY);
    endian_uword(&mut (*psSaveDroid).orderX2);
    endian_uword(&mut (*psSaveDroid).orderY2);
    endian_udword(&mut (*psSaveDroid).timeLastHit);
    endian_udword(&mut (*psSaveDroid).targetID);
    endian_udword(&mut (*psSaveDroid).secondaryOrder);
    endian_sdword(&mut (*psSaveDroid).action);
    endian_udword(&mut (*psSaveDroid).actionX);
    endian_udword(&mut (*psSaveDroid).actionY);
    endian_udword(&mut (*psSaveDroid).actionTargetID);
    endian_udword(&mut (*psSaveDroid).actionStarted);
    endian_udword(&mut (*psSaveDroid).actionPoints);
    endian_uword(&mut (*psSaveDroid).actionHeight);
    endian_udword(&mut (*psSaveDroid).baseStructID);
    endian_udword(&mut (*psSaveDroid).died);
    endian_udword(&mut (*psSaveDroid).lastEmission);
    /* OBJECT_SAVE_V20 */
    endian_udword(&mut (*psSaveDroid).id);
    endian_udword(&mut (*psSaveDroid).x);
    endian_udword(&mut (*psSaveDroid).y);
    endian_udword(&mut (*psSaveDroid).z);
    endian_udword(&mut (*psSaveDroid).direction);
    endian_udword(&mut (*psSaveDroid).player);
    endian_udword(&mut (*psSaveDroid).burnStart);
    endian_udword(&mut (*psSaveDroid).burnDamage);
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
/*
Writes the linked list of droids for each player to a file
*/
unsafe extern "C" fn writeDroidFile(mut pFileName: *mut STRING,
                                    mut ppsCurrentDroidLists: *mut *mut DROID)
 -> BOOL {
    let mut pFileData: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut fileSize: UDWORD = 0;
    let mut player: UDWORD = 0;
    let mut totalDroids: UDWORD = 0 as libc::c_int as UDWORD;
    let mut psCurr: *mut DROID = 0 as *mut DROID;
    let mut psTrans: *mut DROID = 0 as *mut DROID;
    let mut psHeader: *mut DROID_SAVEHEADER = 0 as *mut DROID_SAVEHEADER;
    let mut psSaveDroid: *mut SAVE_DROID = 0 as *mut SAVE_DROID;
    let mut status: BOOL = 1 as libc::c_int;
    //total all the droids in the world
    player = 0 as libc::c_int as UDWORD;
    while player < 8 as libc::c_int as libc::c_uint {
        psCurr = *ppsCurrentDroidLists.offset(player as isize);
        while !psCurr.is_null() {
            totalDroids = totalDroids.wrapping_add(1);
            // if transporter save any droids in the grp
            if (*psCurr).droidType as libc::c_uint ==
                   DROID_TRANSPORTER as libc::c_int as libc::c_uint {
                psTrans = (*(*psCurr).psGroup).psList;
                if (*psTrans).psGrpNext as UDWORD ==
                       0xcdcdcdcd as libc::c_uint {
                    debug(LOG_ERROR,
                          b"transporter ->psGrpNext not reset\x00" as
                              *const u8 as *const libc::c_char);
                    abort();
                } else {
                    psTrans = (*psTrans).psGrpNext;
                    while !psTrans.is_null() {
                        totalDroids = totalDroids.wrapping_add(1);
                        psTrans = (*psTrans).psGrpNext
                    }
                }
            }
            psCurr = (*psCurr).psNext
        }
        player = player.wrapping_add(1)
    }
    /* Allocate the data buffer */
    fileSize =
        (12 as libc::c_int as
             libc::c_uint).wrapping_add(totalDroids.wrapping_mul(::std::mem::size_of::<SAVE_DROID>()
                                                                     as
                                                                     libc::c_ulong));
    pFileData = memMallocRelease(fileSize) as *mut libc::c_char;
    if pFileData.is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        abort();
    }
    /* Put the file header on the file */
    psHeader = pFileData as *mut DROID_SAVEHEADER;
    (*psHeader).aFileType[0 as libc::c_int as usize] = 'd' as i32 as STRING;
    (*psHeader).aFileType[1 as libc::c_int as usize] = 'r' as i32 as STRING;
    (*psHeader).aFileType[2 as libc::c_int as usize] = 'o' as i32 as STRING;
    (*psHeader).aFileType[3 as libc::c_int as usize] = 'd' as i32 as STRING;
    (*psHeader).version = 33 as libc::c_int as UDWORD;
    (*psHeader).quantity = totalDroids;
    endian_udword(&mut (*psHeader).version);
    endian_udword(&mut (*psHeader).quantity);
    psSaveDroid =
        pFileData.offset(12 as libc::c_int as isize) as *mut SAVE_DROID;
    /* Put the droid data into the buffer */
    player = 0 as libc::c_int as UDWORD;
    while player < 8 as libc::c_int as libc::c_uint {
        psCurr = *ppsCurrentDroidLists.offset(player as isize);
        while !psCurr.is_null() {
            //always save transporter droids that are in the mission list with an INVALID_XY
            if (*psCurr).droidType as libc::c_uint ==
                   DROID_TRANSPORTER as libc::c_int as libc::c_uint &&
                   *ppsCurrentDroidLists.offset(player as isize) ==
                       mission.apsDroidLists[player as usize] {
                (*psCurr).x =
                    (512 as libc::c_int * 127 as libc::c_int) as UWORD;
                (*psCurr).y =
                    (512 as libc::c_int * 127 as libc::c_int) as UWORD
            }
            buildSaveDroidFromDroid(psSaveDroid, psCurr, DROID_NORMAL);
            psSaveDroid =
                (psSaveDroid as
                     *mut libc::c_char).offset(::std::mem::size_of::<SAVE_DROID>()
                                                   as libc::c_ulong as isize)
                    as *mut SAVE_DROID;
            // if transporter save any droids in the grp
            if (*psCurr).droidType as libc::c_uint ==
                   DROID_TRANSPORTER as libc::c_int as libc::c_uint {
                psTrans =
                    (*(*psCurr).psGroup).psList; //ensure it always gets set
                psTrans = (*(*psCurr).psGroup).psList;
                while !psTrans.is_null() {
                    if (*psTrans).droidType as libc::c_uint !=
                           DROID_TRANSPORTER as libc::c_int as libc::c_uint {
                        buildSaveDroidFromDroid(psSaveDroid, psTrans,
                                                DROID_ON_TRANSPORT);
                        psSaveDroid =
                            (psSaveDroid as
                                 *mut libc::c_char).offset(::std::mem::size_of::<SAVE_DROID>()
                                                               as
                                                               libc::c_ulong
                                                               as isize) as
                                *mut SAVE_DROID
                    }
                    psTrans = (*psTrans).psGrpNext
                }
            }
            psCurr = (*psCurr).psNext
        }
        player = player.wrapping_add(1)
    }
    ppsCurrentDroidLists = 0 as *mut *mut DROID;
    /* Write the data to the file */
    if !pFileData.is_null() {
        status = saveFile(pFileName, pFileData, fileSize);
        memFreeRelease(pFileData as *mut libc::c_void);
        pFileData = 0 as *mut libc::c_char;
        return status
    }
    return 0 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
unsafe extern "C" fn loadSaveStructure(mut pFileData: *mut libc::c_char,
                                       mut filesize: UDWORD) -> BOOL {
    let mut psHeader: *mut STRUCT_SAVEHEADER = 0 as *mut STRUCT_SAVEHEADER;
    /* Check the file type */
    psHeader = pFileData as *mut STRUCT_SAVEHEADER;
    if (*psHeader).aFileType[0 as libc::c_int as usize] as libc::c_int !=
           's' as i32 ||
           (*psHeader).aFileType[1 as libc::c_int as usize] as libc::c_int !=
               't' as i32 ||
           (*psHeader).aFileType[2 as libc::c_int as usize] as libc::c_int !=
               'r' as i32 ||
           (*psHeader).aFileType[3 as libc::c_int as usize] as libc::c_int !=
               'u' as i32 {
        debug(LOG_ERROR,
              b"loadSaveStructure: Incorrect file type\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    /* STRUCT_SAVEHEADER */
    endian_udword(&mut (*psHeader).version);
    endian_udword(&mut (*psHeader).quantity);
    //increment to the start of the data
    pFileData = pFileData.offset(12 as libc::c_int as isize);
    /* Check the file version */
    if (*psHeader).version < 7 as libc::c_int as libc::c_uint {
        debug(LOG_ERROR,
              b"StructLoad: unsupported save format version %d\x00" as
                  *const u8 as *const libc::c_char, (*psHeader).version);
        abort();
    } else {
        if (*psHeader).version < 9 as libc::c_int as libc::c_uint {
            if loadSaveStructureV7(pFileData, filesize, (*psHeader).quantity)
                   == 0 {
                return 0 as libc::c_int
            }
        } else if (*psHeader).version <= 19 as libc::c_int as libc::c_uint {
            if loadSaveStructureV19(pFileData, filesize, (*psHeader).quantity,
                                    (*psHeader).version) == 0 {
                return 0 as libc::c_int
            }
        } else if (*psHeader).version <= 33 as libc::c_int as libc::c_uint {
            if loadSaveStructureV(pFileData, filesize, (*psHeader).quantity,
                                  (*psHeader).version) == 0 {
                return 0 as libc::c_int
            }
        } else {
            debug(LOG_ERROR,
                  b"StructLoad: undefined save format version %d\x00" as
                      *const u8 as *const libc::c_char, (*psHeader).version);
            abort();
        }
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
/* code specific to version 7 of a save structure */
unsafe extern "C" fn loadSaveStructureV7(mut pFileData: *mut libc::c_char,
                                         mut filesize: UDWORD,
                                         mut numStructures: UDWORD) -> BOOL {
    let mut psSaveStructure: *mut SAVE_STRUCTURE_V2 =
        0 as *mut SAVE_STRUCTURE_V2;
    let mut sSaveStructure: SAVE_STRUCTURE_V2 =
        SAVE_STRUCTURE_V2{name: [0; 40],
                          id: 0,
                          x: 0,
                          y: 0,
                          z: 0,
                          direction: 0,
                          player: 0,
                          inFire: 0,
                          burnStart: 0,
                          burnDamage: 0,
                          status: 0,
                          currentBuildPts: 0,
                          body: 0,
                          armour: 0,
                          resistance: 0,
                          dummy1: 0,
                          subjectInc: 0,
                          timeStarted: 0,
                          output: 0,
                          capacity: 0,
                          quantity: 0,};
    let mut psStructure: *mut STRUCTURE = 0 as *mut STRUCTURE;
    let mut psRepair: *mut REPAIR_FACILITY = 0 as *mut REPAIR_FACILITY;
    let mut psStats: *mut STRUCTURE_STATS = 0 as *mut STRUCTURE_STATS;
    let mut count: UDWORD = 0;
    let mut statInc: UDWORD = 0;
    let mut found: BOOL = 0;
    let mut NumberOfSkippedStructures: UDWORD = 0 as libc::c_int as UDWORD;
    let mut burnTime: UDWORD = 0;
    psSaveStructure = &mut sSaveStructure;
    if (::std::mem::size_of::<SAVE_STRUCTURE_V2>() as
            libc::c_ulong).wrapping_mul(numStructures).wrapping_add(12 as
                                                                        libc::c_int
                                                                        as
                                                                        libc::c_uint)
           > filesize {
        debug(LOG_ERROR,
              b"structureLoad: unexpected end of file\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    /* Load in the structure data */
    count = 0 as libc::c_int as UDWORD;
    while count < numStructures {
        memcpy(psSaveStructure as *mut libc::c_void,
               pFileData as *const libc::c_void,
               ::std::mem::size_of::<SAVE_STRUCTURE_V2>() as libc::c_ulong);
        /* STRUCTURE_SAVE_V2 includes OBJECT_SAVE_V19 */
        endian_sdword(&mut (*psSaveStructure).currentBuildPts);
        endian_udword(&mut (*psSaveStructure).body);
        endian_udword(&mut (*psSaveStructure).armour);
        endian_udword(&mut (*psSaveStructure).resistance);
        endian_udword(&mut (*psSaveStructure).dummy1);
        endian_udword(&mut (*psSaveStructure).subjectInc);
        endian_udword(&mut (*psSaveStructure).timeStarted);
        endian_udword(&mut (*psSaveStructure).output);
        endian_udword(&mut (*psSaveStructure).capacity);
        endian_udword(&mut (*psSaveStructure).quantity);
        /* OBJECT_SAVE_V19 */
        endian_udword(&mut (*psSaveStructure).id);
        endian_udword(&mut (*psSaveStructure).x);
        endian_udword(&mut (*psSaveStructure).y);
        endian_udword(&mut (*psSaveStructure).z);
        endian_udword(&mut (*psSaveStructure).direction);
        endian_udword(&mut (*psSaveStructure).player);
        endian_udword(&mut (*psSaveStructure).burnStart);
        endian_udword(&mut (*psSaveStructure).burnDamage);
        (*psSaveStructure).player =
            RemapPlayerNumber((*psSaveStructure).player);
        if (*psSaveStructure).player >= 8 as libc::c_int as libc::c_uint {
            (*psSaveStructure).player =
                (8 as libc::c_int - 1 as libc::c_int) as UDWORD;
            NumberOfSkippedStructures =
                NumberOfSkippedStructures.wrapping_add(1)
        }
        //get the stats for this structure
        found = 0 as libc::c_int;
        if !(getSaveObjectName((*psSaveStructure).name.as_mut_ptr()) == 0) {
            statInc = 0 as libc::c_int as UDWORD;
            while statInc < numStructureStats {
                psStats = asStructureStats.offset(statInc as isize);
                //loop until find the same name
                if strcmp((*psStats).pName,
                          (*psSaveStructure).name.as_mut_ptr()) == 0 {
                    found = 1 as libc::c_int;
                    break ;
                } else { statInc = statInc.wrapping_add(1) }
            }
            //if haven't found the structure - ignore this record!
            if found == 0 {
                debug(LOG_ERROR,
                      b"This structure no longer exists - %s\x00" as *const u8
                          as *const libc::c_char,
                      getSaveStructNameV19(psSaveStructure as
                                               *mut SAVE_STRUCTURE_V17));
                abort();
            } else {
                /*create the Structure */
		//psStructure = buildStructure((asStructureStats + psSaveStructure->
		//	structureInc), psSaveStructure->x, psSaveStructure->y,
		//	psSaveStructure->player);
                //for modules - need to check the base structure exists
                if IsStatExpansionModule(psStats) != 0 {
                    psStructure =
                        getTileStructure((*psSaveStructure).x >>
                                             7 as libc::c_int,
                                         (*psSaveStructure).y >>
                                             7 as libc::c_int);
                    if psStructure.is_null() {
                        debug(LOG_ERROR,
                              b"No owning structure for module - %s for player - %d\x00"
                                  as *const u8 as *const libc::c_char,
                              getSaveStructNameV19(psSaveStructure as
                                                       *mut SAVE_STRUCTURE_V17),
                              (*psSaveStructure).player);
                        abort();
                    }
                }
                //check not too near the edge
        /*if (psSaveStructure->x <= TILE_UNITS OR psSaveStructure->y <= TILE_UNITS)
        {
			DBERROR(("Structure being built too near the edge of the map"));
            continue;
        }*/
                //check not trying to build too near the edge
                if ((*psSaveStructure).x >> 7 as libc::c_int) <
                       3 as libc::c_int as libc::c_uint ||
                       (*psSaveStructure).x >> 7 as libc::c_int >
                           mapWidth.wrapping_sub(3 as libc::c_int as
                                                     libc::c_uint) as SDWORD
                               as libc::c_uint {
                    debug(LOG_ERROR,
                          b"Structure %s, x coord too near the edge of the map. id - %d\x00"
                              as *const u8 as *const libc::c_char,
                          getSaveStructNameV19(psSaveStructure as
                                                   *mut SAVE_STRUCTURE_V17),
                          (*psSaveStructure).id);
                    abort();
                } else if ((*psSaveStructure).y >> 7 as libc::c_int) <
                              3 as libc::c_int as libc::c_uint ||
                              (*psSaveStructure).y >> 7 as libc::c_int >
                                  mapHeight.wrapping_sub(3 as libc::c_int as
                                                             libc::c_uint) as
                                      SDWORD as libc::c_uint {
                    debug(LOG_ERROR,
                          b"Structure %s, y coord too near the edge of the map. id - %d\x00"
                              as *const u8 as *const libc::c_char,
                          getSaveStructNameV19(psSaveStructure as
                                                   *mut SAVE_STRUCTURE_V17),
                          (*psSaveStructure).id);
                    abort();
                } else {
                    psStructure =
                        buildStructure(psStats, (*psSaveStructure).x,
                                       (*psSaveStructure).y,
                                       (*psSaveStructure).player,
                                       1 as libc::c_int);
                    if psStructure.is_null() {
                        if 0 as libc::c_int != 0 {
                        } else {
                            debug(LOG_ERROR,
                                  b"loadSaveStructure:Unable to create structure\x00"
                                      as *const u8 as *const libc::c_char);
                        };
                        if 0 as libc::c_int != 0 {
                        } else {
                            debug(LOG_ERROR,
                                  b"Assert in Warzone: %s:%d : %s (%s)\x00" as
                                      *const u8 as *const libc::c_char,
                                  b"game.c\x00" as *const u8 as
                                      *const libc::c_char,
                                  6574 as libc::c_int,
                                  (*::std::mem::transmute::<&[u8; 20],
                                                            &[libc::c_char; 20]>(b"loadSaveStructureV7\x00")).as_ptr(),
                                  b"FALSE\x00" as *const u8 as
                                      *const libc::c_char);
                        };
                        return 0 as libc::c_int
                    }
                    /*The original code here didn't work and so the scriptwriters worked
        round it by using the module ID - so making it work now will screw up
        the scripts -so in ALL CASES overwrite the ID!*/
		//don't copy the module's id etc
		//if (IsStatExpansionModule(psStats)==FALSE)
                    //copy the values across
                    (*psStructure).id = (*psSaveStructure).id;
                    (*psStructure).direction =
                        (*psSaveStructure).direction as UWORD;
                    (*psStructure).inFire = (*psSaveStructure).inFire;
                    (*psStructure).burnDamage = (*psSaveStructure).burnDamage;
                    burnTime = (*psSaveStructure).burnStart;
                    (*psStructure).burnStart = burnTime;
                    (*psStructure).status = (*psSaveStructure).status;
                    if (*psStructure).status as libc::c_int ==
                           SS_BUILT as libc::c_int {
                        buildingComplete(psStructure);
                    }
                    if !(gameType !=
                             GTYPE_SAVE_START as libc::c_int as libc::c_uint)
                       {
                        (*psStructure).currentBuildPts =
                            (*psSaveStructure).currentBuildPts as SWORD;
                        //are these going to ever change from the values set up with?
//			psStructure->z = (UWORD)psSaveStructure->z;
                        //		psStructure->body = psSaveStructure->body;
//		psStructure->armour = psSaveStructure->armour;
//		psStructure->resistance = psSaveStructure->resistance;
//		psStructure->repair = psSaveStructure->repair;
                        match (*(*psStructure).pStructureType).type_0 {
                            1 => {
                                //NOT DONE AT PRESENT
                                (*((*psStructure).pFunctionality as
                                       *mut FACTORY)).capacity =
                                    (*psSaveStructure).capacity as UBYTE;
                                //((FACTORY *)psStructure->pFunctionality)->productionOutput = psSaveStructure->
				//	output;
				//((FACTORY *)psStructure->pFunctionality)->quantity = psSaveStructure->
				//	quantity;
				//((FACTORY *)psStructure->pFunctionality)->timeStarted = gameTime -
				//	savedGameTime - (psSaveStructure->timeStarted);
				//((FACTORY*)psStructure->pFunctionality)->timeToBuild = ((DROID_TEMPLATE *)
				//	psSaveStructure->subjectInc)->buildPoints / ((FACTORY *)psStructure->pFunctionality)->
				//	productionOutput;
                                //adjust the module structures IMD
                                if (*psSaveStructure).capacity != 0 {
                                    (*psStructure).sDisplay.imd =
                                        factoryModuleIMDs[(*psSaveStructure).capacity.wrapping_sub(1
                                                                                                       as
                                                                                                       libc::c_int
                                                                                                       as
                                                                                                       libc::c_uint)
                                                              as
                                                              usize][0 as
                                                                         libc::c_int
                                                                         as
                                                                         usize]
                                }
                            }
                            10 => {
                                (*((*psStructure).pFunctionality as
                                       *mut RESEARCH_FACILITY)).capacity =
                                    (*psSaveStructure).capacity;
                                (*((*psStructure).pFunctionality as
                                       *mut RESEARCH_FACILITY)).researchPoints
                                    = (*psSaveStructure).output;
                                (*((*psStructure).pFunctionality as
                                       *mut RESEARCH_FACILITY)).timeStarted =
                                    (*psSaveStructure).timeStarted;
                                if (*psSaveStructure).subjectInc !=
                                       -(1 as libc::c_int) as libc::c_uint {
                                    let ref mut fresh0 =
                                        (*((*psStructure).pFunctionality as
                                               *mut RESEARCH_FACILITY)).psSubject;
                                    *fresh0 =
                                        asResearch.offset((*psSaveStructure).subjectInc
                                                              as isize) as
                                            *mut BASE_STATS;
                                    (*((*psStructure).pFunctionality as
                                           *mut RESEARCH_FACILITY)).timeToResearch
                                        =
                                        ((*asResearch.offset((*psSaveStructure).subjectInc
                                                                 as
                                                                 isize)).researchPoints
                                             as
                                             libc::c_uint).wrapping_div((*((*psStructure).pFunctionality
                                                                               as
                                                                               *mut RESEARCH_FACILITY)).researchPoints)
                                }
                                //adjust the module structures IMD
                                if (*psSaveStructure).capacity != 0 {
                                    (*psStructure).sDisplay.imd =
                                        researchModuleIMDs[(*psSaveStructure).capacity.wrapping_sub(1
                                                                                                        as
                                                                                                        libc::c_int
                                                                                                        as
                                                                                                        libc::c_uint)
                                                               as usize]
                                }
                            }
                            12 => {
                                //CODE THIS SOMETIME
                                psRepair =
                                    (*psStructure).pFunctionality as
                                        *mut REPAIR_FACILITY;
                                (*psRepair).psDeliveryPoint =
                                    0 as *mut FLAG_POSITION;
                                (*psRepair).psObj = 0 as *mut BASE_OBJECT;
                                (*psRepair).currentPtsAdded =
                                    0 as libc::c_int as UDWORD
                            }
                            _ => { }
                        }
                    }
                }
            }
        }
        //if not a save game, don't want to overwrite any of the stats so continue
        //ignore this module
        count = count.wrapping_add(1);
        pFileData =
            pFileData.offset(::std::mem::size_of::<SAVE_STRUCTURE_V2>() as
                                 libc::c_ulong as isize)
    }
    if NumberOfSkippedStructures > 0 as libc::c_int as libc::c_uint {
        debug(LOG_ERROR,
              b"structureLoad: invalid player number in %d structures ... assigned to the last player!\n\n\x00"
                  as *const u8 as *const libc::c_char,
              NumberOfSkippedStructures);
        abort();
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
//return id of a research topic based on the name
#[no_mangle]
pub unsafe extern "C" fn getResearchIdFromName(mut pName: *mut STRING)
 -> UDWORD {
    let mut inc: UDWORD = 0;
    inc = 0 as libc::c_int as UDWORD;
    while inc < numResearch {
        if strcmp((*asResearch.offset(inc as isize)).pName, pName) == 0 {
            return inc
        }
        inc = inc.wrapping_add(1)
    }
    debug(LOG_ERROR,
          b"Unknown research - %s\x00" as *const u8 as *const libc::c_char,
          pName);
    abort();
}
// -----------------------------------------------------------------------------------------
/* code for version upto 19of a save structure */
unsafe extern "C" fn loadSaveStructureV19(mut pFileData: *mut libc::c_char,
                                          mut filesize: UDWORD,
                                          mut numStructures: UDWORD,
                                          mut version: UDWORD) -> BOOL {
    let mut psSaveStructure: *mut SAVE_STRUCTURE_V17 =
        0 as *mut SAVE_STRUCTURE_V17;
    let mut sSaveStructure: SAVE_STRUCTURE_V17 =
        SAVE_STRUCTURE_V17{name: [0; 40],
                           id: 0,
                           x: 0,
                           y: 0,
                           z: 0,
                           direction: 0,
                           player: 0,
                           inFire: 0,
                           burnStart: 0,
                           burnDamage: 0,
                           status: 0,
                           currentBuildPts: 0,
                           body: 0,
                           armour: 0,
                           resistance: 0,
                           dummy1: 0,
                           subjectInc: 0,
                           timeStarted: 0,
                           output: 0,
                           capacity: 0,
                           quantity: 0,
                           factoryInc: 0,
                           loopsPerformed: 0,
                           powerAccrued: 0,
                           dummy2: 0,
                           droidTimeStarted: 0,
                           timeToBuild: 0,
                           timeStartHold: 0,
                           visible: [0; 8],
                           researchName: [0; 40],
                           currentPowerAccrued: 0,};
    let mut psStructure: *mut STRUCTURE = 0 as *mut STRUCTURE;
    let mut psFactory: *mut FACTORY = 0 as *mut FACTORY;
    let mut psResearch: *mut RESEARCH_FACILITY = 0 as *mut RESEARCH_FACILITY;
    let mut psRepair: *mut REPAIR_FACILITY = 0 as *mut REPAIR_FACILITY;
    let mut psStats: *mut STRUCTURE_STATS = 0 as *mut STRUCTURE_STATS;
    let mut psModule: *mut STRUCTURE_STATS = 0 as *mut STRUCTURE_STATS;
    let mut capacity: UDWORD = 0;
    let mut count: UDWORD = 0;
    let mut statInc: UDWORD = 0;
    let mut found: BOOL = 0;
    let mut NumberOfSkippedStructures: UDWORD = 0 as libc::c_int as UDWORD;
    let mut burnTime: UDWORD = 0;
    let mut i: UDWORD = 0;
    let mut sizeOfSaveStruture: UDWORD = 0;
    let mut researchId: UDWORD = 0;
    if version < 12 as libc::c_int as libc::c_uint {
        sizeOfSaveStruture =
            ::std::mem::size_of::<SAVE_STRUCTURE_V2>() as libc::c_ulong
    } else if version < 14 as libc::c_int as libc::c_uint {
        sizeOfSaveStruture =
            ::std::mem::size_of::<SAVE_STRUCTURE_V12>() as libc::c_ulong
    } else if version <= 14 as libc::c_int as libc::c_uint {
        sizeOfSaveStruture =
            ::std::mem::size_of::<SAVE_STRUCTURE_V14>() as libc::c_ulong
    } else if version <= 16 as libc::c_int as libc::c_uint {
        sizeOfSaveStruture =
            ::std::mem::size_of::<SAVE_STRUCTURE_V15>() as libc::c_ulong
    } else {
        sizeOfSaveStruture =
            ::std::mem::size_of::<SAVE_STRUCTURE_V17>() as libc::c_ulong
    }
    psSaveStructure = &mut sSaveStructure;
    if sizeOfSaveStruture.wrapping_mul(numStructures).wrapping_add(12 as
                                                                       libc::c_int
                                                                       as
                                                                       libc::c_uint)
           > filesize {
        debug(LOG_ERROR,
              b"structureLoad: unexpected end of file\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    /* Load in the structure data */
    count = 0 as libc::c_int as UDWORD;
    while count < numStructures {
        memcpy(psSaveStructure as *mut libc::c_void,
               pFileData as *const libc::c_void, sizeOfSaveStruture);
        /* SAVE_STRUCTURE_V17 is STRUCTURE_SAVE_V17 */
		/* STRUCTURE_SAVE_V17 includes STRUCTURE_SAVE_V15 */
        endian_sword(&mut (*psSaveStructure).currentPowerAccrued);
        /* STRUCTURE_SAVE_V15 includes STRUCTURE_SAVE_V14 */
		/* STRUCTURE_SAVE_V14 includes STRUCTURE_SAVE_V12 */
        endian_udword(&mut (*psSaveStructure).factoryInc);
        endian_udword(&mut (*psSaveStructure).powerAccrued);
        endian_udword(&mut (*psSaveStructure).dummy2);
        endian_udword(&mut (*psSaveStructure).droidTimeStarted);
        endian_udword(&mut (*psSaveStructure).timeToBuild);
        endian_udword(&mut (*psSaveStructure).timeStartHold);
        /* STRUCTURE_SAVE_V12 includes STRUCTURE_SAVE_V2 */
        endian_sdword(&mut (*psSaveStructure).currentBuildPts);
        endian_udword(&mut (*psSaveStructure).body);
        endian_udword(&mut (*psSaveStructure).armour);
        endian_udword(&mut (*psSaveStructure).resistance);
        endian_udword(&mut (*psSaveStructure).dummy1);
        endian_udword(&mut (*psSaveStructure).subjectInc);
        endian_udword(&mut (*psSaveStructure).timeStarted);
        endian_udword(&mut (*psSaveStructure).output);
        endian_udword(&mut (*psSaveStructure).capacity);
        /* STRUCTURE_SAVE_V2 includes OBJECT_SAVE_V19 */
        endian_udword(&mut (*psSaveStructure).id);
        endian_udword(&mut (*psSaveStructure).x);
        endian_udword(&mut (*psSaveStructure).y);
        endian_udword(&mut (*psSaveStructure).z);
        endian_udword(&mut (*psSaveStructure).direction);
        endian_udword(&mut (*psSaveStructure).player);
        endian_udword(&mut (*psSaveStructure).burnStart);
        endian_udword(&mut (*psSaveStructure).burnDamage);
        (*psSaveStructure).player =
            RemapPlayerNumber((*psSaveStructure).player);
        if (*psSaveStructure).player >= 8 as libc::c_int as libc::c_uint {
            (*psSaveStructure).player =
                (8 as libc::c_int - 1 as libc::c_int) as UDWORD;
            NumberOfSkippedStructures =
                NumberOfSkippedStructures.wrapping_add(1)
        }
        //get the stats for this structure
        found = 0 as libc::c_int;
        if !(getSaveObjectName((*psSaveStructure).name.as_mut_ptr()) == 0) {
            statInc = 0 as libc::c_int as UDWORD;
            while statInc < numStructureStats {
                psStats = asStructureStats.offset(statInc as isize);
                //loop until find the same name
                if strcmp((*psStats).pName,
                          (*psSaveStructure).name.as_mut_ptr()) == 0 {
                    found = 1 as libc::c_int;
                    break ;
                } else { statInc = statInc.wrapping_add(1) }
            }
            //if haven't found the structure - ignore this record!
            if found == 0 {
                debug(LOG_ERROR,
                      b"This structure no longer exists - %s\x00" as *const u8
                          as *const libc::c_char,
                      getSaveStructNameV19(psSaveStructure));
                abort();
            } else {
                /*create the Structure */
		//for modules - need to check the base structure exists
                if IsStatExpansionModule(psStats) != 0 {
                    psStructure =
                        getTileStructure((*psSaveStructure).x >>
                                             7 as libc::c_int,
                                         (*psSaveStructure).y >>
                                             7 as libc::c_int);
                    if psStructure.is_null() {
                        debug(LOG_ERROR,
                              b"No owning structure for module - %s for player - %d\x00"
                                  as *const u8 as *const libc::c_char,
                              getSaveStructNameV19(psSaveStructure),
                              (*psSaveStructure).player);
                        abort();
                    }
                }
                //check not too near the edge
        /*if (psSaveStructure->x <= TILE_UNITS OR psSaveStructure->y <= TILE_UNITS)
        {
			DBERROR(("Structure being built too near the edge of the map"));
            continue;
        }*/
        //check not trying to build too near the edge
                if ((*psSaveStructure).x >> 7 as libc::c_int) <
                       3 as libc::c_int as libc::c_uint ||
                       (*psSaveStructure).x >> 7 as libc::c_int >
                           mapWidth.wrapping_sub(3 as libc::c_int as
                                                     libc::c_uint) as SDWORD
                               as libc::c_uint {
                    debug(LOG_ERROR,
                          b"Structure %s, x coord too near the edge of the map. id - %d\x00"
                              as *const u8 as *const libc::c_char,
                          getSaveStructNameV19(psSaveStructure),
                          (*psSaveStructure).id);
                    abort();
                } else if ((*psSaveStructure).y >> 7 as libc::c_int) <
                              3 as libc::c_int as libc::c_uint ||
                              (*psSaveStructure).y >> 7 as libc::c_int >
                                  mapHeight.wrapping_sub(3 as libc::c_int as
                                                             libc::c_uint) as
                                      SDWORD as libc::c_uint {
                    debug(LOG_ERROR,
                          b"Structure %s, y coord too near the edge of the map. id - %d\x00"
                              as *const u8 as *const libc::c_char,
                          getSaveStructNameV19(psSaveStructure),
                          (*psSaveStructure).id);
                    abort();
                } else {
                    psStructure =
                        buildStructure(psStats, (*psSaveStructure).x,
                                       (*psSaveStructure).y,
                                       (*psSaveStructure).player,
                                       1 as libc::c_int);
                    if psStructure.is_null() {
                        if 0 as libc::c_int != 0 {
                        } else {
                            debug(LOG_ERROR,
                                  b"loadSaveStructure:Unable to create structure\x00"
                                      as *const u8 as *const libc::c_char);
                        };
                        if 0 as libc::c_int != 0 {
                        } else {
                            debug(LOG_ERROR,
                                  b"Assert in Warzone: %s:%d : %s (%s)\x00" as
                                      *const u8 as *const libc::c_char,
                                  b"game.c\x00" as *const u8 as
                                      *const libc::c_char,
                                  6861 as libc::c_int,
                                  (*::std::mem::transmute::<&[u8; 21],
                                                            &[libc::c_char; 21]>(b"loadSaveStructureV19\x00")).as_ptr(),
                                  b"FALSE\x00" as *const u8 as
                                      *const libc::c_char);
                        };
                        return 0 as libc::c_int
                    }
                    /*The original code here didn't work and so the scriptwriters worked
        round it by using the module ID - so making it work now will screw up
        the scripts -so in ALL CASES overwrite the ID!*/
		//don't copy the module's id etc
		//if (IsStatExpansionModule(psStats)==FALSE)
                    //copy the values across
                    (*psStructure).id = (*psSaveStructure).id;
                    (*psStructure).direction =
                        (*psSaveStructure).direction as UWORD;
                    (*psStructure).inFire = (*psSaveStructure).inFire;
                    (*psStructure).burnDamage = (*psSaveStructure).burnDamage;
                    burnTime = (*psSaveStructure).burnStart;
                    (*psStructure).burnStart = burnTime;
                    if version >= 14 as libc::c_int as libc::c_uint {
                        i = 0 as libc::c_int as UDWORD;
                        while i < 8 as libc::c_int as libc::c_uint {
                            (*psStructure).visible[i as usize] =
                                (*psSaveStructure).visible[i as usize];
                            //are these going to ever change from the values set up with?
//			psStructure->z = (UWORD)psSaveStructure->z;
                            //set the Tile flag if visible for the selectedPlayer
                            if i == selectedPlayer &&
                                   (*psStructure).visible[i as usize] as
                                       libc::c_int == 0xff as libc::c_int {
                                setStructTileDraw(psStructure);
                            }
                            i = i.wrapping_add(1)
                        }
                    }
                    (*psStructure).status = (*psSaveStructure).status;
                    if (*psStructure).status as libc::c_int ==
                           SS_BUILT as libc::c_int {
                        buildingComplete(psStructure);
                    }
                    if !(gameType !=
                             GTYPE_SAVE_START as libc::c_int as libc::c_uint
                             &&
                             gameType !=
                                 GTYPE_SAVE_MIDMISSION as libc::c_int as
                                     libc::c_uint) {
                        if version <= 16 as libc::c_int as libc::c_uint {
                            if (*psSaveStructure).currentBuildPts >
                                   0x7fff as libc::c_int {
                                //old MAX_BODY
                                (*psSaveStructure).currentBuildPts =
                                    0x7fff as libc::c_int
                            }
                            (*psStructure).currentBuildPts =
                                (*psSaveStructure).currentBuildPts as SWORD;
                            (*psStructure).currentPowerAccrued =
                                0 as libc::c_int as SWORD
                        } else {
                            (*psStructure).currentBuildPts =
                                (*psSaveStructure).currentBuildPts as SWORD;
                            (*psStructure).currentPowerAccrued =
                                (*psSaveStructure).currentPowerAccrued
                        }
                        //		psStructure->repair = (UWORD)psSaveStructure->repair;
                        match (*(*psStructure).pStructureType).type_0 {
                            1 | 17 | 16 => {
                                //if factory save the current build info
                                if version >=
                                       12 as libc::c_int as libc::c_uint {
                                    psFactory =
                                        (*psStructure).pFunctionality as
                                            *mut FACTORY; //capacity reset during module build (UBYTE)psSaveStructure->capacity;
                                    (*psFactory).capacity =
                                        0 as libc::c_int as UBYTE;
                                    //this is set up during module build - if the stats have changed it will also set up with the latest value
					//psFactory->productionOutput = (UBYTE)psSaveStructure->output;
                                    (*psFactory).quantity =
                                        (*psSaveStructure).quantity as UBYTE;
                                    (*psFactory).timeStarted =
                                        (*psSaveStructure).droidTimeStarted;
                                    (*psFactory).powerAccrued =
                                        (*psSaveStructure).powerAccrued;
                                    (*psFactory).timeToBuild =
                                        (*psSaveStructure).timeToBuild;
                                    (*psFactory).timeStartHold =
                                        (*psSaveStructure).timeStartHold;
                                    //adjust the module structures IMD
                                    if (*psSaveStructure).capacity != 0 {
                                        psModule = getModuleStat(psStructure);
                                        capacity =
                                            (*psSaveStructure).capacity;
                                        //build the appropriate number of modules
                                        while capacity != 0 {
                                            buildStructure(psModule,
                                                           (*psStructure).x as
                                                               UDWORD,
                                                           (*psStructure).y as
                                                               UDWORD,
                                                           (*psStructure).player
                                                               as UDWORD,
                                                           0 as libc::c_int);
                                            capacity =
                                                capacity.wrapping_sub(1)
                                        }
                                    }
                                    // imd set by building modules
				//	psStructure->sDisplay.imd = factoryModuleIMDs[psSaveStructure->capacity-1][0];
                                    //if factory reset the delivery points
					//this trashes the flag pos pointer but flag pos list is cleared when flags load
					//assemblyCheck
                                    let mut __tmp: *mut UDWORD =
                                        &mut (*psFactory).psAssemblyPoint as
                                            *mut *mut FLAG_POSITION as
                                            *mut UDWORD;
                                    *__tmp = (*psSaveStructure).factoryInc;
                                    //if factory was building find the template from the unique ID
                                    if (*psSaveStructure).subjectInc ==
                                           0xffffffff as libc::c_uint {
                                        (*psFactory).psSubject =
                                            0 as *mut BASE_STATS
                                    } else {
                                        (*psFactory).psSubject =
                                            getTemplateFromMultiPlayerID((*psSaveStructure).subjectInc)
                                                as *mut BASE_STATS;
                                        //if the build has started set the powerAccrued =
                        //powerRequired to sync the interface
                                        if (*psFactory).timeStarted !=
                                               0 as libc::c_int as
                                                   libc::c_uint &&
                                               !(*psFactory).psSubject.is_null()
                                           {
                                            (*psFactory).powerAccrued =
                                                (*((*psFactory).psSubject as
                                                       *mut DROID_TEMPLATE)).powerPoints
                                        }
                                    }
                                }
                            }
                            10 => {
                                psResearch =
                                    (*psStructure).pFunctionality as
                                        *mut RESEARCH_FACILITY; //capacity set when module loaded psSaveStructure->capacity;
                                (*psResearch).capacity =
                                    0 as libc::c_int as UDWORD;
                                //this is set up during module build - if the stats have changed it will also set up with the latest value
                //psResearch->researchPoints = psSaveStructure->output;
                                (*psResearch).powerAccrued =
                                    (*psSaveStructure).powerAccrued;
                                //clear subject
                                (*psResearch).psSubject =
                                    0 as *mut _base_stats;
                                (*psResearch).timeToResearch =
                                    0 as libc::c_int as UDWORD;
                                (*psResearch).timeStarted =
                                    0 as libc::c_int as UDWORD;
                                //set the subject
                                if saveGameVersion >=
                                       15 as libc::c_int as libc::c_uint {
                                    if (*psSaveStructure).subjectInc !=
                                           0xffffffff as libc::c_uint {
                                        researchId =
                                            getResearchIdFromName((*psSaveStructure).researchName.as_mut_ptr());
                                        if researchId !=
                                               0xffffffff as libc::c_uint {
                                            (*psResearch).psSubject =
                                                asResearch.offset(researchId
                                                                      as
                                                                      isize)
                                                    as *mut BASE_STATS;
                                            (*psResearch).timeToResearch =
                                                ((*asResearch.offset(researchId
                                                                         as
                                                                         isize)).researchPoints
                                                     as
                                                     libc::c_uint).wrapping_div((*psResearch).researchPoints);
                                            (*psResearch).timeStarted =
                                                (*psSaveStructure).timeStarted
                                        }
                                    } else {
                                        (*psResearch).psSubject =
                                            0 as *mut _base_stats;
                                        (*psResearch).timeToResearch =
                                            0 as libc::c_int as UDWORD;
                                        (*psResearch).timeStarted =
                                            0 as libc::c_int as UDWORD
                                    }
                                } else {
                                    (*psResearch).timeStarted =
                                        (*psSaveStructure).timeStarted;
                                    if (*psSaveStructure).subjectInc !=
                                           0xffffffff as libc::c_uint {
                                        (*psResearch).psSubject =
                                            asResearch.offset((*psSaveStructure).subjectInc
                                                                  as isize) as
                                                *mut BASE_STATS;
                                        (*psResearch).timeToResearch =
                                            ((*asResearch.offset((*psSaveStructure).subjectInc
                                                                     as
                                                                     isize)).researchPoints
                                                 as
                                                 libc::c_uint).wrapping_div((*psResearch).researchPoints)
                                    }
                                }
                                //if started research, set powerAccrued = powerRequired
                                if (*psResearch).timeStarted !=
                                       0 as libc::c_int as libc::c_uint &&
                                       !(*psResearch).psSubject.is_null() {
                                    (*psResearch).powerAccrued =
                                        (*((*psResearch).psSubject as
                                               *mut RESEARCH)).researchPower
                                }
                                //adjust the module structures IMD
                                if (*psSaveStructure).capacity != 0 {
                                    psModule = getModuleStat(psStructure);
                                    capacity = (*psSaveStructure).capacity;
                                    //					psStructure->sDisplay.imd = researchModuleIMDs[psSaveStructure->capacity-1];
                                    buildStructure(psModule,
                                                   (*psStructure).x as UDWORD,
                                                   (*psStructure).y as UDWORD,
                                                   (*psStructure).player as
                                                       UDWORD,
                                                   0 as libc::c_int);
                                }
                            }
                            3 => {
                                //build the appropriate number of modules
                                //adjust the module structures IMD
                                if (*psSaveStructure).capacity != 0 {
                                    psModule = getModuleStat(psStructure);
                                    capacity = (*psSaveStructure).capacity;
                                    //					psStructure->sDisplay.imd = powerModuleIMDs[psSaveStructure->capacity-1];
                                    buildStructure(psModule,
                                                   (*psStructure).x as UDWORD,
                                                   (*psStructure).y as UDWORD,
                                                   (*psStructure).player as
                                                       UDWORD,
                                                   0 as libc::c_int);
                                }
                            }
                            5 => {
                                (*((*psStructure).pFunctionality as
                                       *mut RES_EXTRACTOR)).power =
                                    (*psSaveStructure).output;
                                //build the appropriate number of modules
                                //if run out of power, then the res_extractor should be inactive
                                if (*psSaveStructure).output ==
                                       0 as libc::c_int as libc::c_uint {
                                    (*((*psStructure).pFunctionality as
                                           *mut RES_EXTRACTOR)).active =
                                        0 as libc::c_int
                                }
                            }
                            12 => {
                                //CODE THIS SOMETIME
                                if version >=
                                       19 as libc::c_int as libc::c_uint {
                                    psRepair =
                                        (*psStructure).pFunctionality as
                                            *mut REPAIR_FACILITY;
                                    (*psRepair).power =
                                        (*(*(*(*psStructure).pStructureType).asFuncList.offset(0
                                                                                                   as
                                                                                                   libc::c_int
                                                                                                   as
                                                                                                   isize)
                                               as
                                               *mut REPAIR_DROID_FUNCTION)).repairPoints;
                                    (*psRepair).timeStarted =
                                        (*psSaveStructure).droidTimeStarted;
                                    (*psRepair).powerAccrued =
                                        (*psSaveStructure).powerAccrued;
                                    (*psRepair).currentPtsAdded =
                                        0 as libc::c_int as UDWORD;
                                    //if repair facility reset the delivery points
					//this trashes the flag pos pointer but flag pos list is cleared when flags load
					//assemblyCheck
                                    (*psRepair).psDeliveryPoint =
                                        0 as *mut FLAG_POSITION;
                                    //if factory was building find the template from the unique ID
                                    if (*psSaveStructure).subjectInc ==
                                           0xffffffff as libc::c_uint {
                                        (*psRepair).psObj =
                                            0 as *mut BASE_OBJECT
                                    } else {
                                        (*psRepair).psObj =
                                            getBaseObjFromId((*psSaveStructure).subjectInc);
                                        //if the build has started set the powerAccrued =
                        //powerRequired to sync the interface
                                        if (*psRepair).timeStarted !=
                                               0 as libc::c_int as
                                                   libc::c_uint &&
                                               !(*psRepair).psObj.is_null() {
                                            (*psRepair).powerAccrued =
                                                powerReqForDroidRepair((*psRepair).psObj
                                                                           as
                                                                           *mut DROID)
                                                    as UDWORD
                                        }
                                    }
                                } else {
                                    psRepair =
                                        (*psStructure).pFunctionality as
                                            *mut REPAIR_FACILITY;
                                    //init so setAssemplyPoint check will re-allocate one
                                    (*psRepair).psObj = 0 as *mut BASE_OBJECT;
                                    (*psRepair).psDeliveryPoint =
                                        0 as *mut FLAG_POSITION
                                }
                            }
                            _ => { }
                        }
                        //get the base body points
                        (*psStructure).body =
                            structureBody(psStructure) as UWORD;
                        if (*psSaveStructure).body <
                               (*psStructure).body as libc::c_uint {
                            (*psStructure).body =
                                (*psSaveStructure).body as UWORD
                        }
                        //set the build status from the build points
                        (*psStructure).currentBuildPts =
                            (*(*psStructure).pStructureType).buildPoints as
                                SWORD;
                        if (*psSaveStructure).currentBuildPts <
                               (*psStructure).currentBuildPts as libc::c_int {
                            (*psStructure).currentBuildPts =
                                (*psSaveStructure).currentBuildPts as SWORD;
                            (*psStructure).status =
                                SS_BEING_BUILT as libc::c_int as UBYTE
                        } else {
                            (*psStructure).status =
                                SS_BUILT as libc::c_int as UBYTE;
                            //            buildingComplete(psStructure);//replaced by following switch
                            match (*(*psStructure).pStructureType).type_0 {
                                3 => {
                                    checkForResExtractors(psStructure);
                                    if selectedPlayer ==
                                           (*psStructure).player as
                                               libc::c_uint {
                                        audio_PlayObjStaticTrack(psStructure
                                                                     as
                                                                     *mut libc::c_void,
                                                                 ID_SOUND_POWER_HUM
                                                                     as
                                                                     libc::c_int);
                                    }
                                }
                                5 => {
                                    //only try and connect if power left in
                                    if (*((*psStructure).pFunctionality as
                                              *mut RES_EXTRACTOR)).power !=
                                           0 as libc::c_int as libc::c_uint {
                                        checkForPowerGen(psStructure);
                                        /* GJ HACK! - add anim to deriks */
                                        if (*psStructure).psCurAnim.is_null()
                                           {
                                            (*psStructure).psCurAnim =
                                                animObj_Add(psStructure as
                                                                *mut libc::c_void,
                                                            5 as libc::c_int,
                                                            0 as libc::c_int
                                                                as UDWORD,
                                                            0 as libc::c_int
                                                                as UWORD)
                                        }
                                    }
                                }
                                10 => { }
                                _ => { }
                            }
                        }
                    }
                }
            }
        }
        //if not a save game, don't want to overwrite any of the stats so continue
        //ignore this module
        count = count.wrapping_add(1);
        pFileData = pFileData.offset(sizeOfSaveStruture as isize)
    }
    if NumberOfSkippedStructures > 0 as libc::c_int as libc::c_uint {
        debug(LOG_ERROR,
              b"structureLoad: invalid player number in %d structures ... assigned to the last player!\n\n\x00"
                  as *const u8 as *const libc::c_char,
              NumberOfSkippedStructures);
        abort();
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
/* code for versions after version 20 of a save structure */
unsafe extern "C" fn loadSaveStructureV(mut pFileData: *mut libc::c_char,
                                        mut filesize: UDWORD,
                                        mut numStructures: UDWORD,
                                        mut version: UDWORD) -> BOOL {
    let mut psSaveStructure: *mut SAVE_STRUCTURE = 0 as *mut SAVE_STRUCTURE;
    let mut sSaveStructure: SAVE_STRUCTURE =
        SAVE_STRUCTURE{name: [0; 60],
                       id: 0,
                       x: 0,
                       y: 0,
                       z: 0,
                       direction: 0,
                       player: 0,
                       inFire: 0,
                       burnStart: 0,
                       burnDamage: 0,
                       status: 0,
                       currentBuildPts: 0,
                       body: 0,
                       armour: 0,
                       resistance: 0,
                       dummy1: 0,
                       subjectInc: 0,
                       timeStarted: 0,
                       output: 0,
                       capacity: 0,
                       quantity: 0,
                       factoryInc: 0,
                       loopsPerformed: 0,
                       powerAccrued: 0,
                       dummy2: 0,
                       droidTimeStarted: 0,
                       timeToBuild: 0,
                       timeStartHold: 0,
                       visible: [0; 8],
                       researchName: [0; 60],
                       currentPowerAccrued: 0,
                       commandId: 0,};
    let mut psStructure: *mut STRUCTURE = 0 as *mut STRUCTURE;
    let mut psFactory: *mut FACTORY = 0 as *mut FACTORY;
    let mut psResearch: *mut RESEARCH_FACILITY = 0 as *mut RESEARCH_FACILITY;
    let mut psRepair: *mut REPAIR_FACILITY = 0 as *mut REPAIR_FACILITY;
    let mut psReArmPad: *mut REARM_PAD = 0 as *mut REARM_PAD;
    let mut psStats: *mut STRUCTURE_STATS = 0 as *mut STRUCTURE_STATS;
    let mut psModule: *mut STRUCTURE_STATS = 0 as *mut STRUCTURE_STATS;
    let mut capacity: UDWORD = 0;
    let mut count: UDWORD = 0;
    let mut statInc: UDWORD = 0;
    let mut found: BOOL = 0;
    let mut NumberOfSkippedStructures: UDWORD = 0 as libc::c_int as UDWORD;
    let mut burnTime: UDWORD = 0;
    let mut i: UDWORD = 0;
    let mut sizeOfSaveStructure: UDWORD = 0 as libc::c_int as UDWORD;
    let mut researchId: UDWORD = 0;
    if version <= 20 as libc::c_int as libc::c_uint {
        sizeOfSaveStructure =
            ::std::mem::size_of::<SAVE_STRUCTURE_V20>() as libc::c_ulong
    } else if version <= 33 as libc::c_int as libc::c_uint {
        sizeOfSaveStructure =
            ::std::mem::size_of::<SAVE_STRUCTURE>() as libc::c_ulong
    }
    psSaveStructure = &mut sSaveStructure;
    if sizeOfSaveStructure.wrapping_mul(numStructures).wrapping_add(12 as
                                                                        libc::c_int
                                                                        as
                                                                        libc::c_uint)
           > filesize {
        debug(LOG_ERROR,
              b"structureLoad: unexpected end of file\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    /* Load in the structure data */
    count = 0 as libc::c_int as UDWORD;
    while count < numStructures {
        memcpy(psSaveStructure as *mut libc::c_void,
               pFileData as *const libc::c_void, sizeOfSaveStructure);
        /* SAVE_STRUCTURE is STRUCTURE_SAVE_V21 */
		/* STRUCTURE_SAVE_V21 includes STRUCTURE_SAVE_V20 */
        endian_udword(&mut (*psSaveStructure).commandId);
        /* STRUCTURE_SAVE_V20 includes OBJECT_SAVE_V20 */
        endian_sdword(&mut (*psSaveStructure).currentBuildPts);
        endian_udword(&mut (*psSaveStructure).body);
        endian_udword(&mut (*psSaveStructure).armour);
        endian_udword(&mut (*psSaveStructure).resistance);
        endian_udword(&mut (*psSaveStructure).dummy1);
        endian_udword(&mut (*psSaveStructure).subjectInc);
        endian_udword(&mut (*psSaveStructure).timeStarted);
        endian_udword(&mut (*psSaveStructure).output);
        endian_udword(&mut (*psSaveStructure).capacity);
        endian_udword(&mut (*psSaveStructure).quantity);
        endian_udword(&mut (*psSaveStructure).factoryInc);
        endian_udword(&mut (*psSaveStructure).powerAccrued);
        endian_udword(&mut (*psSaveStructure).dummy2);
        endian_udword(&mut (*psSaveStructure).droidTimeStarted);
        endian_udword(&mut (*psSaveStructure).timeToBuild);
        endian_udword(&mut (*psSaveStructure).timeStartHold);
        endian_sword(&mut (*psSaveStructure).currentPowerAccrued);
        /* OBJECT_SAVE_V20 */
        endian_udword(&mut (*psSaveStructure).id);
        endian_udword(&mut (*psSaveStructure).x);
        endian_udword(&mut (*psSaveStructure).y);
        endian_udword(&mut (*psSaveStructure).z);
        endian_udword(&mut (*psSaveStructure).direction);
        endian_udword(&mut (*psSaveStructure).player);
        endian_udword(&mut (*psSaveStructure).burnStart);
        endian_udword(&mut (*psSaveStructure).burnDamage);
        (*psSaveStructure).player =
            RemapPlayerNumber((*psSaveStructure).player);
        if (*psSaveStructure).player >= 8 as libc::c_int as libc::c_uint {
            (*psSaveStructure).player =
                (8 as libc::c_int - 1 as libc::c_int) as UDWORD;
            NumberOfSkippedStructures =
                NumberOfSkippedStructures.wrapping_add(1)
        }
        //get the stats for this structure
        found = 0 as libc::c_int;
        if !(getSaveObjectName((*psSaveStructure).name.as_mut_ptr()) == 0) {
            statInc = 0 as libc::c_int as UDWORD;
            while statInc < numStructureStats {
                psStats = asStructureStats.offset(statInc as isize);
                //loop until find the same name
                if strcmp((*psStats).pName,
                          (*psSaveStructure).name.as_mut_ptr()) == 0 {
                    found = 1 as libc::c_int;
                    break ;
                } else { statInc = statInc.wrapping_add(1) }
            }
            //if haven't found the structure - ignore this record!
            if found == 0 {
                debug(LOG_ERROR,
                      b"This structure no longer exists - %s\x00" as *const u8
                          as *const libc::c_char,
                      getSaveStructNameV(psSaveStructure));
                abort();
            } else {
                /*create the Structure */
		//for modules - need to check the base structure exists
                if IsStatExpansionModule(psStats) != 0 {
                    psStructure =
                        getTileStructure((*psSaveStructure).x >>
                                             7 as libc::c_int,
                                         (*psSaveStructure).y >>
                                             7 as libc::c_int);
                    if psStructure.is_null() {
                        debug(LOG_ERROR,
                              b"No owning structure for module - %s for player - %d\x00"
                                  as *const u8 as *const libc::c_char,
                              getSaveStructNameV(psSaveStructure),
                              (*psSaveStructure).player);
                        abort();
                    }
                }
                //check not too near the edge
        /*if (psSaveStructure->x <= TILE_UNITS OR psSaveStructure->y <= TILE_UNITS)
        {
			DBERROR(("Structure being built too near the edge of the map"));
            continue;
        }*/
        //check not trying to build too near the edge
                if ((*psSaveStructure).x >> 7 as libc::c_int) <
                       3 as libc::c_int as libc::c_uint ||
                       (*psSaveStructure).x >> 7 as libc::c_int >
                           mapWidth.wrapping_sub(3 as libc::c_int as
                                                     libc::c_uint) as SDWORD
                               as libc::c_uint {
                    debug(LOG_ERROR,
                          b"Structure %s, x coord too near the edge of the map. id - %d\x00"
                              as *const u8 as *const libc::c_char,
                          getSaveStructNameV(psSaveStructure),
                          (*psSaveStructure).id);
                    abort();
                } else if ((*psSaveStructure).y >> 7 as libc::c_int) <
                              3 as libc::c_int as libc::c_uint ||
                              (*psSaveStructure).y >> 7 as libc::c_int >
                                  mapHeight.wrapping_sub(3 as libc::c_int as
                                                             libc::c_uint) as
                                      SDWORD as libc::c_uint {
                    debug(LOG_ERROR,
                          b"Structure %s, y coord too near the edge of the map. id - %d\x00"
                              as *const u8 as *const libc::c_char,
                          getSaveStructNameV(psSaveStructure),
                          (*psSaveStructure).id);
                    abort();
                } else {
                    psStructure =
                        buildStructure(psStats, (*psSaveStructure).x,
                                       (*psSaveStructure).y,
                                       (*psSaveStructure).player,
                                       1 as libc::c_int);
                    if psStructure.is_null() {
                        if 0 as libc::c_int != 0 {
                        } else {
                            debug(LOG_ERROR,
                                  b"loadSaveStructure:Unable to create structure\x00"
                                      as *const u8 as *const libc::c_char);
                        };
                        if 0 as libc::c_int != 0 {
                        } else {
                            debug(LOG_ERROR,
                                  b"Assert in Warzone: %s:%d : %s (%s)\x00" as
                                      *const u8 as *const libc::c_char,
                                  b"game.c\x00" as *const u8 as
                                      *const libc::c_char,
                                  7309 as libc::c_int,
                                  (*::std::mem::transmute::<&[u8; 19],
                                                            &[libc::c_char; 19]>(b"loadSaveStructureV\x00")).as_ptr(),
                                  b"FALSE\x00" as *const u8 as
                                      *const libc::c_char);
                        };
                        return 0 as libc::c_int
                    }
                    /*The original code here didn't work and so the scriptwriters worked
        round it by using the module ID - so making it work now will screw up
        the scripts -so in ALL CASES overwrite the ID!*/
		//don't copy the module's id etc
		//if (IsStatExpansionModule(psStats)==FALSE)
                    //copy the values across
                    (*psStructure).id = (*psSaveStructure).id;
                    (*psStructure).direction =
                        (*psSaveStructure).direction as UWORD;
                    (*psStructure).inFire = (*psSaveStructure).inFire;
                    (*psStructure).burnDamage = (*psSaveStructure).burnDamage;
                    burnTime = (*psSaveStructure).burnStart;
                    (*psStructure).burnStart = burnTime;
                    i = 0 as libc::c_int as UDWORD;
                    while i < 8 as libc::c_int as libc::c_uint {
                        (*psStructure).visible[i as usize] =
                            (*psSaveStructure).visible[i as usize];
                        //are these going to ever change from the values set up with?
//			psStructure->z = (UWORD)psSaveStructure->z;
                        //set the Tile flag if visible for the selectedPlayer
                        if i == selectedPlayer &&
                               (*psStructure).visible[i as usize] as
                                   libc::c_int == 0xff as libc::c_int {
                            setStructTileDraw(psStructure);
                        }
                        i = i.wrapping_add(1)
                    }
                    (*psStructure).status = (*psSaveStructure).status;
                    if (*psStructure).status as libc::c_int ==
                           SS_BUILT as libc::c_int {
                        buildingComplete(psStructure);
                    }
                    if !(gameType !=
                             GTYPE_SAVE_START as libc::c_int as libc::c_uint
                             &&
                             gameType !=
                                 GTYPE_SAVE_MIDMISSION as libc::c_int as
                                     libc::c_uint) {
                        (*psStructure).currentBuildPts =
                            (*psSaveStructure).currentBuildPts as SWORD;
                        (*psStructure).currentPowerAccrued =
                            (*psSaveStructure).currentPowerAccrued;
                        (*psStructure).resistance =
                            (*psSaveStructure).resistance as SWORD;
                        //armour not ever adjusted...
                        //		psStructure->repair = (UWORD)psSaveStructure->repair;
                        match (*(*psStructure).pStructureType).type_0 {
                            1 | 17 | 16 => {
                                //if factory save the current build info
                                psFactory =
                                    (*psStructure).pFunctionality as
                                        *mut FACTORY; //capacity reset during module build (UBYTE)psSaveStructure->capacity;
                                (*psFactory).capacity =
                                    0 as libc::c_int as UBYTE;
                                //this is set up during module build - if the stats have changed it will also set up with the latest value
				//psFactory->productionOutput = (UBYTE)psSaveStructure->output;
                                (*psFactory).quantity =
                                    (*psSaveStructure).quantity as UBYTE;
                                (*psFactory).timeStarted =
                                    (*psSaveStructure).droidTimeStarted;
                                (*psFactory).powerAccrued =
                                    (*psSaveStructure).powerAccrued;
                                (*psFactory).timeToBuild =
                                    (*psSaveStructure).timeToBuild;
                                (*psFactory).timeStartHold =
                                    (*psSaveStructure).timeStartHold;
                                //adjust the module structures IMD
                                if (*psSaveStructure).capacity != 0 {
                                    psModule = getModuleStat(psStructure);
                                    capacity = (*psSaveStructure).capacity;
                                    //build the appropriate number of modules
                                    while capacity != 0 {
                                        buildStructure(psModule,
                                                       (*psStructure).x as
                                                           UDWORD,
                                                       (*psStructure).y as
                                                           UDWORD,
                                                       (*psStructure).player
                                                           as UDWORD,
                                                       0 as libc::c_int);
                                        capacity = capacity.wrapping_sub(1)
                                    }
                                }
                                // imd set by building modules
			//	psStructure->sDisplay.imd = factoryModuleIMDs[psSaveStructure->capacity-1][0];
                                //if factory reset the delivery points
				//this trashes the flag pos pointer but flag pos list is cleared when flags load
				//assemblyCheck
                                let mut __tmp: *mut UDWORD =
                                    &mut (*psFactory).psAssemblyPoint as
                                        *mut *mut FLAG_POSITION as
                                        *mut UDWORD;
                                *__tmp = (*psSaveStructure).factoryInc;
                                //if factory was building find the template from the unique ID
                                if (*psSaveStructure).subjectInc ==
                                       0xffffffff as libc::c_uint {
                                    (*psFactory).psSubject =
                                        0 as *mut BASE_STATS
                                } else {
                                    (*psFactory).psSubject =
                                        getTemplateFromMultiPlayerID((*psSaveStructure).subjectInc)
                                            as *mut BASE_STATS;
                                    //if the build has started set the powerAccrued =
                    //powerRequired to sync the interface
                                    if (*psFactory).timeStarted !=
                                           0 as libc::c_int as libc::c_uint &&
                                           !(*psFactory).psSubject.is_null() {
                                        (*psFactory).powerAccrued =
                                            (*((*psFactory).psSubject as
                                                   *mut DROID_TEMPLATE)).powerPoints
                                    }
                                }
                                if version >=
                                       21 as libc::c_int as libc::c_uint {
                                    //version 21
                                    //reset command id in loadStructSetPointers
                                    let mut __tmp_0: *mut UDWORD =
                                        &mut (*psFactory).psCommander as
                                            *mut *mut _droid as *mut UDWORD;
                                    *__tmp_0 = (*psSaveStructure).commandId
                                }
                                //secondary order added - AB 22/04/99
                                if version >=
                                       32 as libc::c_int as libc::c_uint {
                                    (*psFactory).secondaryOrder =
                                        (*psSaveStructure).dummy2
                                }
                            }
                            10 => {
                                psResearch =
                                    (*psStructure).pFunctionality as
                                        *mut RESEARCH_FACILITY; //capacity set when module loaded psSaveStructure->capacity;
                                (*psResearch).capacity =
                                    0 as libc::c_int as UDWORD;
                                //adjust the module structures IMD
                                if (*psSaveStructure).capacity != 0 {
                                    psModule = getModuleStat(psStructure);
                                    capacity = (*psSaveStructure).capacity;
                                    //build the appropriate number of modules
                                    buildStructure(psModule,
                                                   (*psStructure).x as UDWORD,
                                                   (*psStructure).y as UDWORD,
                                                   (*psStructure).player as
                                                       UDWORD,
                                                   0 as libc::c_int);
                                }
                                //this is set up during module build - if the stats have changed it will also set up with the latest value
                                (*psResearch).powerAccrued =
                                    (*psSaveStructure).powerAccrued;
                                //clear subject
                                (*psResearch).psSubject =
                                    0 as *mut _base_stats;
                                (*psResearch).timeToResearch =
                                    0 as libc::c_int as UDWORD;
                                (*psResearch).timeStarted =
                                    0 as libc::c_int as UDWORD;
                                (*psResearch).timeStartHold =
                                    0 as libc::c_int as UDWORD;
                                //set the subject
                                if (*psSaveStructure).subjectInc !=
                                       0xffffffff as libc::c_uint {
                                    researchId =
                                        getResearchIdFromName((*psSaveStructure).researchName.as_mut_ptr());
                                    if researchId !=
                                           0xffffffff as libc::c_uint {
                                        (*psResearch).psSubject =
                                            asResearch.offset(researchId as
                                                                  isize) as
                                                *mut BASE_STATS;
                                        (*psResearch).timeToResearch =
                                            ((*asResearch.offset(researchId as
                                                                     isize)).researchPoints
                                                 as
                                                 libc::c_uint).wrapping_div((*psResearch).researchPoints);
                                        (*psResearch).timeStarted =
                                            (*psSaveStructure).timeStarted;
                                        if saveGameVersion >=
                                               20 as libc::c_int as
                                                   libc::c_uint {
                                            (*psResearch).timeStartHold =
                                                (*psSaveStructure).timeStartHold
                                        }
                                    }
                                }
                                //if started research, set powerAccrued = powerRequired
                                if (*psResearch).timeStarted !=
                                       0 as libc::c_int as libc::c_uint &&
                                       !(*psResearch).psSubject.is_null() {
                                    (*psResearch).powerAccrued =
                                        (*((*psResearch).psSubject as
                                               *mut RESEARCH)).researchPower
                                }
                            }
                            3 => {
                                //adjust the module structures IMD
                                if (*psSaveStructure).capacity != 0 {
                                    psModule = getModuleStat(psStructure);
                                    capacity = (*psSaveStructure).capacity;
                                    //					psStructure->sDisplay.imd = powerModuleIMDs[psSaveStructure->capacity-1];
                                    buildStructure(psModule,
                                                   (*psStructure).x as UDWORD,
                                                   (*psStructure).y as UDWORD,
                                                   (*psStructure).player as
                                                       UDWORD,
                                                   0 as libc::c_int);
                                }
                            }
                            5 => {
                                (*((*psStructure).pFunctionality as
                                       *mut RES_EXTRACTOR)).power =
                                    (*psSaveStructure).output;
                                //build the appropriate number of modules
                                //if run out of power, then the res_extractor should be inactive
                                if (*psSaveStructure).output ==
                                       0 as libc::c_int as libc::c_uint {
                                    (*((*psStructure).pFunctionality as
                                           *mut RES_EXTRACTOR)).active =
                                        0 as libc::c_int
                                }
                            }
                            12 => {
                                //CODE THIS SOMETIME
                                /*
	// The group the droids to be repaired by this facility belong to
	struct _droid_group		*psGroup;
	struct _droid			*psGrpNext;
*/
                                psRepair =
                                    (*psStructure).pFunctionality as
                                        *mut REPAIR_FACILITY;
                                (*psRepair).power =
                                    (*(*(*(*psStructure).pStructureType).asFuncList.offset(0
                                                                                               as
                                                                                               libc::c_int
                                                                                               as
                                                                                               isize)
                                           as
                                           *mut REPAIR_DROID_FUNCTION)).repairPoints;
                                (*psRepair).timeStarted =
                                    (*psSaveStructure).droidTimeStarted;
                                (*psRepair).powerAccrued =
                                    (*psSaveStructure).powerAccrued;
                                //if repair facility reset the delivery points
				//this trashes the flag pos pointer but flag pos list is cleared when flags load
				//assemblyCheck
                                (*psRepair).psDeliveryPoint =
                                    0 as *mut FLAG_POSITION;
                                //if  repair facility was  repairing find the object later
                                let mut __tmp_1: *mut UDWORD =
                                    &mut (*psRepair).psObj as
                                        *mut *mut BASE_OBJECT as *mut UDWORD;
                                *__tmp_1 = (*psSaveStructure).subjectInc;
                                if version < 27 as libc::c_int as libc::c_uint
                                   {
                                    (*psRepair).currentPtsAdded =
                                        0 as libc::c_int as UDWORD
                                } else {
                                    (*psRepair).currentPtsAdded =
                                        (*psSaveStructure).dummy2
                                }
                            }
                            19 => {
                                if version >=
                                       26 as libc::c_int as libc::c_uint {
                                    //version 26
                                    psReArmPad =
                                        (*psStructure).pFunctionality as
                                            *mut REARM_PAD; //set in build structure ?
                                    (*psReArmPad).reArmPoints =
                                        (*psSaveStructure).output;
                                    (*psReArmPad).timeStarted =
                                        (*psSaveStructure).droidTimeStarted;
                                    //if  ReArm Pad was  rearming find the object later
                                    let mut __tmp_2: *mut UDWORD =
                                        &mut (*psReArmPad).psObj as
                                            *mut *mut BASE_OBJECT as
                                            *mut UDWORD;
                                    *__tmp_2 = (*psSaveStructure).subjectInc;
                                    if version <
                                           28 as libc::c_int as libc::c_uint {
                                        (*psReArmPad).currentPtsAdded =
                                            0 as libc::c_int as UDWORD
                                    } else {
                                        (*psReArmPad).currentPtsAdded =
                                            (*psSaveStructure).dummy2
                                    }
                                } else {
                                    psReArmPad =
                                        (*psStructure).pFunctionality as
                                            *mut REARM_PAD;
                                    (*psReArmPad).timeStarted =
                                        0 as libc::c_int as UDWORD
                                }
                            }
                            _ => { }
                        }
                        //get the base body points
                        (*psStructure).body =
                            structureBody(psStructure) as UWORD;
                        if (*psSaveStructure).body <
                               (*psStructure).body as libc::c_uint {
                            (*psStructure).body =
                                (*psSaveStructure).body as UWORD
                        }
                        //set the build status from the build points
                        (*psStructure).currentPowerAccrued =
                            (*psSaveStructure).currentPowerAccrued; //22feb
                        (*psStructure).currentBuildPts =
                            (*(*psStructure).pStructureType).buildPoints as
                                SWORD;
                        if (*psSaveStructure).currentBuildPts <
                               (*psStructure).currentBuildPts as libc::c_int {
                            (*psStructure).currentBuildPts =
                                (*psSaveStructure).currentBuildPts as SWORD;
                            (*psStructure).status =
                                SS_BEING_BUILT as libc::c_int as UBYTE
                        } else {
                            (*psStructure).status =
                                SS_BUILT as libc::c_int as UBYTE;
                            //            buildingComplete(psStructure);//replaced by following switch
                            match (*(*psStructure).pStructureType).type_0 {
                                3 => {
                                    checkForResExtractors(psStructure);
                                    if selectedPlayer ==
                                           (*psStructure).player as
                                               libc::c_uint {
                                        audio_PlayObjStaticTrack(psStructure
                                                                     as
                                                                     *mut libc::c_void,
                                                                 ID_SOUND_POWER_HUM
                                                                     as
                                                                     libc::c_int);
                                    }
                                }
                                5 => {
                                    //only try and connect if power left in
                                    if (*((*psStructure).pFunctionality as
                                              *mut RES_EXTRACTOR)).power !=
                                           0 as libc::c_int as libc::c_uint {
                                        checkForPowerGen(psStructure);
                                        /* GJ HACK! - add anim to deriks */
                                        if (*psStructure).psCurAnim.is_null()
                                           {
                                            (*psStructure).psCurAnim =
                                                animObj_Add(psStructure as
                                                                *mut libc::c_void,
                                                            5 as libc::c_int,
                                                            0 as libc::c_int
                                                                as UDWORD,
                                                            0 as libc::c_int
                                                                as UWORD)
                                        }
                                    }
                                }
                                10 => { }
                                _ => { }
                            }
                        }
                    }
                }
            }
        }
        //if not a save game, don't want to overwrite any of the stats so continue
        //ignore this module
        count = count.wrapping_add(1);
        pFileData = pFileData.offset(sizeOfSaveStructure as isize)
    }
    if NumberOfSkippedStructures > 0 as libc::c_int as libc::c_uint {
        debug(LOG_ERROR,
              b"structureLoad: invalid player number in %d structures ... assigned to the last player!\n\n\x00"
                  as *const u8 as *const libc::c_char,
              NumberOfSkippedStructures);
        abort();
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
/*
Writes the linked list of structure for each player to a file
*/
unsafe extern "C" fn writeStructFile(mut pFileName: *mut STRING) -> BOOL {
    let mut pFileData: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut fileSize: UDWORD = 0;
    let mut player: UDWORD = 0;
    let mut i: UDWORD = 0;
    let mut totalStructs: UDWORD = 0 as libc::c_int as UDWORD;
    let mut psCurr: *mut STRUCTURE = 0 as *mut STRUCTURE;
    let mut psSubjectTemplate: *mut DROID_TEMPLATE = 0 as *mut DROID_TEMPLATE;
    let mut psFactory: *mut FACTORY = 0 as *mut FACTORY;
    let mut psRepair: *mut REPAIR_FACILITY = 0 as *mut REPAIR_FACILITY;
    let mut psReArmPad: *mut REARM_PAD = 0 as *mut REARM_PAD;
    let mut psHeader: *mut STRUCT_SAVEHEADER = 0 as *mut STRUCT_SAVEHEADER;
    let mut psSaveStruct: *mut SAVE_STRUCTURE = 0 as *mut SAVE_STRUCTURE;
    let mut psFlag: *mut FLAG_POSITION = 0 as *mut FLAG_POSITION;
    let mut researchId: UDWORD = 0;
    let mut status: BOOL = 1 as libc::c_int;
    //total all the structures in the world
    player = 0 as libc::c_int as UDWORD;
    while player < 8 as libc::c_int as libc::c_uint {
        psCurr = apsStructLists[player as usize];
        while !psCurr.is_null() {
            totalStructs = totalStructs.wrapping_add(1);
            psCurr = (*psCurr).psNext
        }
        player = player.wrapping_add(1)
    }
    /* Allocate the data buffer */
    fileSize =
        (12 as libc::c_int as
             libc::c_uint).wrapping_add(totalStructs.wrapping_mul(::std::mem::size_of::<SAVE_STRUCTURE>()
                                                                      as
                                                                      libc::c_ulong));
    pFileData = memMallocRelease(fileSize) as *mut libc::c_char;
    if pFileData.is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        abort();
    }
    /* Put the file header on the file */
    psHeader = pFileData as *mut STRUCT_SAVEHEADER;
    (*psHeader).aFileType[0 as libc::c_int as usize] = 's' as i32 as STRING;
    (*psHeader).aFileType[1 as libc::c_int as usize] = 't' as i32 as STRING;
    (*psHeader).aFileType[2 as libc::c_int as usize] = 'r' as i32 as STRING;
    (*psHeader).aFileType[3 as libc::c_int as usize] = 'u' as i32 as STRING;
    (*psHeader).version = 33 as libc::c_int as UDWORD;
    (*psHeader).quantity = totalStructs;
    endian_udword(&mut (*psHeader).version);
    endian_udword(&mut (*psHeader).quantity);
    psSaveStruct =
        pFileData.offset(12 as libc::c_int as isize) as *mut SAVE_STRUCTURE;
    /* Put the structure data into the buffer */
    player = 0 as libc::c_int as UDWORD;
    while player < 8 as libc::c_int as libc::c_uint {
        psCurr = apsStructLists[player as usize];
        while !psCurr.is_null() {
            strcpy((*psSaveStruct).name.as_mut_ptr(),
                   (*(*psCurr).pStructureType).pName);
            (*psSaveStruct).id = (*psCurr).id;
            (*psSaveStruct).x = (*psCurr).x as UDWORD;
            (*psSaveStruct).y = (*psCurr).y as UDWORD;
            (*psSaveStruct).z = (*psCurr).z as UDWORD;
            (*psSaveStruct).direction = (*psCurr).direction as UDWORD;
            (*psSaveStruct).player = (*psCurr).player as UDWORD;
            (*psSaveStruct).inFire = (*psCurr).inFire;
            (*psSaveStruct).burnStart = (*psCurr).burnStart;
            (*psSaveStruct).burnDamage = (*psCurr).burnDamage;
            //version 14
            i = 0 as libc::c_int as UDWORD;
            while i < 8 as libc::c_int as libc::c_uint {
                (*psSaveStruct).visible[i as usize] =
                    (*psCurr).visible[i as usize];
                i = i.wrapping_add(1)
            }
            //psSaveStruct->structureInc = psCurr->pStructureType - asStructureStats;
            (*psSaveStruct).status = (*psCurr).status;
            //check if body at max
            if (*psCurr).body as libc::c_uint >= structureBody(psCurr) {
                (*psSaveStruct).body = 0x7fff as libc::c_int as UDWORD
            } else { (*psSaveStruct).body = (*psCurr).body as UDWORD }
            //check if buildpts at max
            if (*psCurr).currentBuildPts as libc::c_int >=
                   (*(*psCurr).pStructureType).buildPoints as SWORD as
                       libc::c_int {
                (*psSaveStruct).currentBuildPts = 0x7fff as libc::c_int
            } else {
                (*psSaveStruct).currentBuildPts =
                    (*psCurr).currentBuildPts as SDWORD
            }
            // no need to check power at max because it would be being built
            (*psSaveStruct).currentPowerAccrued =
                (*psCurr).currentPowerAccrued;
            (*psSaveStruct).armour = (*psCurr).armour as UDWORD;
            (*psSaveStruct).resistance = (*psCurr).resistance as UDWORD;
            (*psSaveStruct).subjectInc = 0xffffffff as libc::c_uint;
            (*psSaveStruct).timeStarted = 0 as libc::c_int as UDWORD;
            (*psSaveStruct).output = 0 as libc::c_int as UDWORD;
            (*psSaveStruct).capacity = 0 as libc::c_int as UDWORD;
            (*psSaveStruct).quantity = 0 as libc::c_int as UDWORD;
            if !(*psCurr).pFunctionality.is_null() {
                match (*(*psCurr).pStructureType).type_0 {
                    1 | 16 | 17 => {
                        psFactory = (*psCurr).pFunctionality as *mut FACTORY;
                        (*psSaveStruct).capacity =
                            (*psFactory).capacity as UDWORD;
                        //don't need to save this - it gets set up
					//psSaveStruct->output			= psFactory->productionOutput;
                        (*psSaveStruct).quantity =
                            (*psFactory).quantity as UDWORD;
                        (*psSaveStruct).droidTimeStarted =
                            (*psFactory).timeStarted;
                        (*psSaveStruct).powerAccrued =
                            (*psFactory).powerAccrued;
                        (*psSaveStruct).timeToBuild =
                            (*psFactory).timeToBuild;
                        (*psSaveStruct).timeStartHold =
                            (*psFactory).timeStartHold;
                        if !(*psFactory).psSubject.is_null() {
                            psSubjectTemplate =
                                (*psFactory).psSubject as *mut DROID_TEMPLATE;
                            (*psSaveStruct).subjectInc =
                                (*psSubjectTemplate).multiPlayerID
                        } else {
                            (*psSaveStruct).subjectInc =
                                0xffffffff as libc::c_uint
                        }
                        psFlag =
                            (*((*psCurr).pFunctionality as
                                   *mut FACTORY)).psAssemblyPoint;
                        if !psFlag.is_null() {
                            (*psSaveStruct).factoryInc =
                                (*psFlag).factoryInc as UDWORD
                        } else {
                            (*psSaveStruct).factoryInc =
                                0xffffffff as libc::c_uint
                        }
                        //version 21
                        if !(*psFactory).psCommander.is_null() {
                            (*psSaveStruct).commandId =
                                (*(*psFactory).psCommander).id
                        } else {
                            (*psSaveStruct).commandId =
                                0xffffffff as libc::c_uint
                        }
                        //secondary order added - AB 22/04/99
                        (*psSaveStruct).dummy2 = (*psFactory).secondaryOrder
                    }
                    10 => {
                        (*psSaveStruct).capacity =
                            (*((*psCurr).pFunctionality as
                                   *mut RESEARCH_FACILITY)).capacity;
                        //don't need to save this - it gets set up
					//psSaveStruct->output = ((RESEARCH_FACILITY *)psCurr->
					//	pFunctionality)->researchPoints;
                        (*psSaveStruct).powerAccrued =
                            (*((*psCurr).pFunctionality as
                                   *mut RESEARCH_FACILITY)).powerAccrued;
                        (*psSaveStruct).timeStartHold =
                            (*((*psCurr).pFunctionality as
                                   *mut RESEARCH_FACILITY)).timeStartHold;
                        if !(*((*psCurr).pFunctionality as
                                   *mut RESEARCH_FACILITY)).psSubject.is_null()
                           {
                            (*psSaveStruct).subjectInc =
                                0 as libc::c_int as UDWORD;
                            researchId =
                                (*(*((*psCurr).pFunctionality as
                                         *mut RESEARCH_FACILITY)).psSubject).ref_0.wrapping_sub(0xb0000
                                                                                                    as
                                                                                                    libc::c_int
                                                                                                    as
                                                                                                    libc::c_uint);
                            if strlen((*asResearch.offset(researchId as
                                                              isize)).pName) <
                                   60 as libc::c_int as libc::c_uint {
                            } else {
                                debug(LOG_ERROR,
                                      b"writeStructData: research name too long\x00"
                                          as *const u8 as
                                          *const libc::c_char);
                            };
                            if strlen((*asResearch.offset(researchId as
                                                              isize)).pName) <
                                   60 as libc::c_int as libc::c_uint {
                            } else {
                                debug(LOG_ERROR,
                                      b"Assert in Warzone: %s:%d : %s (%s)\x00"
                                          as *const u8 as *const libc::c_char,
                                      b"game.c\x00" as *const u8 as
                                          *const libc::c_char,
                                      7768 as libc::c_int,
                                      (*::std::mem::transmute::<&[u8; 16],
                                                                &[libc::c_char; 16]>(b"writeStructFile\x00")).as_ptr(),
                                      b"strlen(asResearch[researchId].pName)<MAX_NAME_SIZE\x00"
                                          as *const u8 as
                                          *const libc::c_char);
                            };
                            strcpy((*psSaveStruct).researchName.as_mut_ptr(),
                                   (*asResearch.offset(researchId as
                                                           isize)).pName);
                            (*psSaveStruct).timeStarted =
                                (*((*psCurr).pFunctionality as
                                       *mut RESEARCH_FACILITY)).timeStarted
                        } else {
                            (*psSaveStruct).subjectInc =
                                0xffffffff as libc::c_uint;
                            (*psSaveStruct).researchName[0 as libc::c_int as
                                                             usize] =
                                0 as libc::c_int as libc::c_char;
                            (*psSaveStruct).timeStarted =
                                0 as libc::c_int as UDWORD
                        }
                        (*psSaveStruct).timeToBuild =
                            0 as libc::c_int as UDWORD
                    }
                    3 => {
                        (*psSaveStruct).capacity =
                            (*((*psCurr).pFunctionality as
                                   *mut POWER_GEN)).capacity
                    }
                    5 => {
                        (*psSaveStruct).output =
                            (*((*psCurr).pFunctionality as
                                   *mut RES_EXTRACTOR)).power
                    }
                    12 => {
                        //CODE THIS SOMETIME
                        psRepair =
                            (*psCurr).pFunctionality as *mut REPAIR_FACILITY;
                        (*psSaveStruct).droidTimeStarted =
                            (*psRepair).timeStarted;
                        (*psSaveStruct).powerAccrued =
                            (*psRepair).powerAccrued;
                        (*psSaveStruct).dummy2 = (*psRepair).currentPtsAdded;
                        if !(*psRepair).psObj.is_null() {
                            (*psSaveStruct).subjectInc =
                                (*(*psRepair).psObj).id
                        } else {
                            (*psSaveStruct).subjectInc =
                                0xffffffff as libc::c_uint
                        }
                        psFlag = (*psRepair).psDeliveryPoint;
                        if !psFlag.is_null() {
                            (*psSaveStruct).factoryInc =
                                (*psFlag).factoryInc as UDWORD
                        } else {
                            (*psSaveStruct).factoryInc =
                                0xffffffff as libc::c_uint
                        }
                    }
                    19 => {
                        psReArmPad =
                            (*psCurr).pFunctionality as *mut REARM_PAD;
                        (*psSaveStruct).output = (*psReArmPad).reArmPoints;
                        (*psSaveStruct).droidTimeStarted =
                            (*psReArmPad).timeStarted;
                        (*psSaveStruct).dummy2 =
                            (*psReArmPad).currentPtsAdded;
                        if !(*psReArmPad).psObj.is_null() {
                            (*psSaveStruct).subjectInc =
                                (*(*psReArmPad).psObj).id
                        } else {
                            (*psSaveStruct).subjectInc =
                                0xffffffff as libc::c_uint
                        }
                    }
                    _ => {
                        //CODE THIS SOMETIME
                        if 0 as libc::c_int != 0 {
                        } else {
                            debug(LOG_ERROR,
                                  b"Structure facility not saved\x00" as
                                      *const u8 as *const libc::c_char);
                        };
                        if 0 as libc::c_int != 0 {
                        } else {
                            debug(LOG_ERROR,
                                  b"Assert in Warzone: %s:%d : %s (%s)\x00" as
                                      *const u8 as *const libc::c_char,
                                  b"game.c\x00" as *const u8 as
                                      *const libc::c_char,
                                  7829 as libc::c_int,
                                  (*::std::mem::transmute::<&[u8; 16],
                                                            &[libc::c_char; 16]>(b"writeStructFile\x00")).as_ptr(),
                                  b"FALSE\x00" as *const u8 as
                                      *const libc::c_char);
                        };
                    }
                }
            }
            /* SAVE_STRUCTURE is STRUCTURE_SAVE_V21 */
			/* STRUCTURE_SAVE_V21 includes STRUCTURE_SAVE_V20 */
            endian_udword(&mut (*psSaveStruct).commandId);
            /* STRUCTURE_SAVE_V20 includes OBJECT_SAVE_V20 */
            endian_sdword(&mut (*psSaveStruct).currentBuildPts);
            endian_udword(&mut (*psSaveStruct).body);
            endian_udword(&mut (*psSaveStruct).armour);
            endian_udword(&mut (*psSaveStruct).resistance);
            endian_udword(&mut (*psSaveStruct).dummy1);
            endian_udword(&mut (*psSaveStruct).subjectInc);
            endian_udword(&mut (*psSaveStruct).timeStarted);
            endian_udword(&mut (*psSaveStruct).output);
            endian_udword(&mut (*psSaveStruct).capacity);
            endian_udword(&mut (*psSaveStruct).quantity);
            endian_udword(&mut (*psSaveStruct).factoryInc);
            endian_udword(&mut (*psSaveStruct).powerAccrued);
            endian_udword(&mut (*psSaveStruct).dummy2);
            endian_udword(&mut (*psSaveStruct).droidTimeStarted);
            endian_udword(&mut (*psSaveStruct).timeToBuild);
            endian_udword(&mut (*psSaveStruct).timeStartHold);
            endian_sword(&mut (*psSaveStruct).currentPowerAccrued);
            /* OBJECT_SAVE_V20 */
            endian_udword(&mut (*psSaveStruct).id);
            endian_udword(&mut (*psSaveStruct).x);
            endian_udword(&mut (*psSaveStruct).y);
            endian_udword(&mut (*psSaveStruct).z);
            endian_udword(&mut (*psSaveStruct).direction);
            endian_udword(&mut (*psSaveStruct).player);
            endian_udword(&mut (*psSaveStruct).burnStart);
            endian_udword(&mut (*psSaveStruct).burnDamage);
            psSaveStruct =
                (psSaveStruct as
                     *mut libc::c_char).offset(::std::mem::size_of::<SAVE_STRUCTURE>()
                                                   as libc::c_ulong as isize)
                    as *mut SAVE_STRUCTURE;
            psCurr = (*psCurr).psNext
        }
        player = player.wrapping_add(1)
    }
    /* Write the data to the file */
    if !pFileData.is_null() {
        status = saveFile(pFileName, pFileData, fileSize);
        memFreeRelease(pFileData as *mut libc::c_void);
        pFileData = 0 as *mut libc::c_char;
        return status
    }
    return 0 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
unsafe extern "C" fn loadStructSetPointers() -> BOOL {
    let mut player: UDWORD = 0;
    let mut list: UDWORD = 0;
    let mut psFactory: *mut FACTORY = 0 as *mut FACTORY;
    let mut psRepair: *mut REPAIR_FACILITY = 0 as *mut REPAIR_FACILITY;
    let mut psReArmPad: *mut REARM_PAD = 0 as *mut REARM_PAD;
    let mut psStruct: *mut STRUCTURE = 0 as *mut STRUCTURE;
    let mut psCommander: *mut DROID = 0 as *mut DROID;
    let mut ppsStructLists: [*mut *mut STRUCTURE; 2] =
        [0 as *mut *mut STRUCTURE; 2];
    ppsStructLists[0 as libc::c_int as usize] = apsStructLists.as_mut_ptr();
    ppsStructLists[1 as libc::c_int as usize] =
        mission.apsStructLists.as_mut_ptr();
    list = 0 as libc::c_int as UDWORD;
    while list < 2 as libc::c_int as libc::c_uint {
        player = 0 as libc::c_int as UDWORD;
        while player < 8 as libc::c_int as libc::c_uint {
            psStruct = *ppsStructLists[list as usize].offset(player as isize);
            while !psStruct.is_null() {
                if !(*psStruct).pFunctionality.is_null() {
                    match (*(*psStruct).pStructureType).type_0 {
                        1 | 16 | 17 => {
                            psFactory =
                                (*psStruct).pFunctionality as *mut FACTORY;
                            //there is a commander then has been temporarily removed
						//so put it back
                            if (*psFactory).psCommander as UDWORD !=
                                   0xffffffff as libc::c_uint {
                                psCommander =
                                    getBaseObjFromId((*psFactory).psCommander
                                                         as UDWORD) as
                                        *mut DROID;
                                (*psFactory).psCommander = 0 as *mut _droid;
                                if !psCommander.is_null() {
                                } else {
                                    debug(LOG_ERROR,
                                          b"loadStructSetPointers psCommander getBaseObjFromId() failed\x00"
                                              as *const u8 as
                                              *const libc::c_char);
                                };
                                if !psCommander.is_null() {
                                } else {
                                    debug(LOG_ERROR,
                                          b"Assert in Warzone: %s:%d : %s (%s)\x00"
                                              as *const u8 as
                                              *const libc::c_char,
                                          b"game.c\x00" as *const u8 as
                                              *const libc::c_char,
                                          7913 as libc::c_int,
                                          (*::std::mem::transmute::<&[u8; 22],
                                                                    &[libc::c_char; 22]>(b"loadStructSetPointers\x00")).as_ptr(),
                                          b"psCommander != NULL\x00" as
                                              *const u8 as
                                              *const libc::c_char);
                                };
                                if psCommander.is_null() {
                                    (*psFactory).psCommander =
                                        0 as *mut _droid
                                } else if list ==
                                              1 as libc::c_int as libc::c_uint
                                 {
                                    //ie offWorld
                                    //don't need to worry about the Flag
                                    let ref mut fresh1 =
                                        (*((*psStruct).pFunctionality as
                                               *mut FACTORY)).psCommander;
                                    *fresh1 = psCommander
                                } else {
                                    assignFactoryCommandDroid(psStruct,
                                                              psCommander);
                                }
                            } else {
                                (*psFactory).psCommander = 0 as *mut _droid
                            }
                        }
                        12 => {
                            psRepair =
                                (*psStruct).pFunctionality as
                                    *mut REPAIR_FACILITY;
                            if (*psRepair).psObj as UDWORD ==
                                   0xffffffff as libc::c_uint {
                                (*psRepair).psObj = 0 as *mut BASE_OBJECT
                            } else {
                                (*psRepair).psObj =
                                    getBaseObjFromId((*psRepair).psObj as
                                                         UDWORD);
                                //if the build has started set the powerAccrued =
							//powerRequired to sync the interface
                                if (*psRepair).timeStarted !=
                                       0 as libc::c_int as libc::c_uint &&
                                       !(*psRepair).psObj.is_null() {
                                    (*psRepair).powerAccrued =
                                        powerReqForDroidRepair((*psRepair).psObj
                                                                   as
                                                                   *mut DROID)
                                            as UDWORD
                                }
                            }
                        }
                        19 => {
                            psReArmPad =
                                (*psStruct).pFunctionality as *mut REARM_PAD;
                            if saveGameVersion >=
                                   26 as libc::c_int as libc::c_uint {
                                //version 26
                                if (*psReArmPad).psObj as UDWORD ==
                                       0xffffffff as libc::c_uint {
                                    (*psReArmPad).psObj =
                                        0 as *mut BASE_OBJECT
                                } else {
                                    (*psReArmPad).psObj =
                                        getBaseObjFromId((*psReArmPad).psObj
                                                             as UDWORD)
                                }
                            } else {
                                (*psReArmPad).psObj = 0 as *mut BASE_OBJECT
                            }
                        }
                        _ => { }
                    }
                }
                psStruct = (*psStruct).psNext
            }
            player = player.wrapping_add(1)
        }
        list = list.wrapping_add(1)
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
unsafe extern "C" fn loadSaveFeature(mut pFileData: *mut libc::c_char,
                                     mut filesize: UDWORD) -> BOOL {
    let mut psHeader: *mut FEATURE_SAVEHEADER = 0 as *mut FEATURE_SAVEHEADER;
    /* Check the file type */
    psHeader = pFileData as *mut FEATURE_SAVEHEADER;
    if (*psHeader).aFileType[0 as libc::c_int as usize] as libc::c_int !=
           'f' as i32 ||
           (*psHeader).aFileType[1 as libc::c_int as usize] as libc::c_int !=
               'e' as i32 ||
           (*psHeader).aFileType[2 as libc::c_int as usize] as libc::c_int !=
               'a' as i32 ||
           (*psHeader).aFileType[3 as libc::c_int as usize] as libc::c_int !=
               't' as i32 {
        debug(LOG_ERROR,
              b"loadSaveFeature: Incorrect file type\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    /* FEATURE_SAVEHEADER */
    endian_udword(&mut (*psHeader).version);
    endian_udword(&mut (*psHeader).quantity);
    //increment to the start of the data
    pFileData = pFileData.offset(12 as libc::c_int as isize);
    /* Check the file version */
    if (*psHeader).version < 7 as libc::c_int as libc::c_uint {
        debug(LOG_ERROR,
              b"FeatLoad: unsupported save format version %d\x00" as *const u8
                  as *const libc::c_char, (*psHeader).version);
        abort();
    } else {
        if (*psHeader).version <= 19 as libc::c_int as libc::c_uint {
            if loadSaveFeatureV14(pFileData, filesize, (*psHeader).quantity,
                                  (*psHeader).version) == 0 {
                return 0 as libc::c_int
            }
        } else if (*psHeader).version <= 33 as libc::c_int as libc::c_uint {
            if loadSaveFeatureV(pFileData, filesize, (*psHeader).quantity,
                                (*psHeader).version) == 0 {
                return 0 as libc::c_int
            }
        } else {
            debug(LOG_ERROR,
                  b"FeatLoad: undefined save format version %d\x00" as
                      *const u8 as *const libc::c_char, (*psHeader).version);
            abort();
        }
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
//ALLOWOLDSAVEGAMES
// -----------------------------------------------------------------------------------------
/* code for all version 8 - 14 save features */
unsafe extern "C" fn loadSaveFeatureV14(mut pFileData: *mut libc::c_char,
                                        mut filesize: UDWORD,
                                        mut numFeatures: UDWORD,
                                        mut version: UDWORD) -> BOOL {
    let mut psSaveFeature: *mut SAVE_FEATURE_V14 = 0 as *mut SAVE_FEATURE_V14;
    let mut pFeature: *mut FEATURE = 0 as *mut FEATURE;
    let mut count: UDWORD = 0;
    let mut i: UDWORD = 0;
    let mut statInc: UDWORD = 0;
    let mut psStats: *mut FEATURE_STATS = 0 as *mut FEATURE_STATS;
    let mut found: BOOL = 0;
    let mut sizeOfSaveFeature: UDWORD = 0;
    if version < 14 as libc::c_int as libc::c_uint {
        sizeOfSaveFeature =
            ::std::mem::size_of::<SAVE_FEATURE_V2>() as libc::c_ulong
    } else {
        sizeOfSaveFeature =
            ::std::mem::size_of::<SAVE_FEATURE_V14>() as libc::c_ulong
    }
    if sizeOfSaveFeature.wrapping_mul(numFeatures).wrapping_add(12 as
                                                                    libc::c_int
                                                                    as
                                                                    libc::c_uint)
           > filesize {
        debug(LOG_ERROR,
              b"featureLoad: unexpected end of file\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    /* Load in the feature data */
    count = 0 as libc::c_int as UDWORD;
    while count < numFeatures {
        psSaveFeature = pFileData as *mut SAVE_FEATURE_V14;
        /* FEATURE_SAVE_V14 is FEATURE_SAVE_V2 */
		/* FEATURE_SAVE_V2 is OBJECT_SAVE_V19 */
		/* OBJECT_SAVE_V19 */
        endian_udword(&mut (*psSaveFeature).id);
        endian_udword(&mut (*psSaveFeature).x);
        endian_udword(&mut (*psSaveFeature).y);
        endian_udword(&mut (*psSaveFeature).z);
        endian_udword(&mut (*psSaveFeature).direction);
        endian_udword(&mut (*psSaveFeature).player);
        endian_udword(&mut (*psSaveFeature).burnStart);
        endian_udword(&mut (*psSaveFeature).burnDamage);
        /*if (psSaveFeature->featureInc > numFeatureStats)
		{
			DBERROR(("Invalid Feature Type - unable to load save game"));
			goto error;
		}*/
		//get the stats for this feature
        found = 0 as libc::c_int;
        if !(getSaveObjectName((*psSaveFeature).name.as_mut_ptr()) == 0) {
            statInc = 0 as libc::c_int as UDWORD;
            while statInc < numFeatureStats {
                psStats = asFeatureStats.offset(statInc as isize);
                //loop until find the same name
                if strcmp((*psStats).pName,
                          (*psSaveFeature).name.as_mut_ptr()) == 0 {
                    found = 1 as libc::c_int;
                    break ;
                } else { statInc = statInc.wrapping_add(1) }
            }
            //if haven't found the feature - ignore this record!
            if found == 0 {
                debug(LOG_ERROR,
                      b"This feature no longer exists - %s\x00" as *const u8
                          as *const libc::c_char,
                      (*psSaveFeature).name.as_mut_ptr());
                abort();
            } else {
                //create the Feature
		//buildFeature(asFeatureStats + psSaveFeature->featureInc,
		//	psSaveFeature->x, psSaveFeature->y);
                pFeature =
                    buildFeature(psStats, (*psSaveFeature).x,
                                 (*psSaveFeature).y, 1 as libc::c_int);
                //will be added to the top of the linked list
		//pFeature = apsFeatureLists[0];
                if pFeature.is_null() {
                    if 0 as libc::c_int != 0 {
                    } else {
                        debug(LOG_ERROR,
                              b"loadSaveFeature:Unable to create feature\x00"
                                  as *const u8 as *const libc::c_char);
                    };
                    if 0 as libc::c_int != 0 {
                    } else {
                        debug(LOG_ERROR,
                              b"Assert in Warzone: %s:%d : %s (%s)\x00" as
                                  *const u8 as *const libc::c_char,
                              b"game.c\x00" as *const u8 as
                                  *const libc::c_char, 8240 as libc::c_int,
                              (*::std::mem::transmute::<&[u8; 19],
                                                        &[libc::c_char; 19]>(b"loadSaveFeatureV14\x00")).as_ptr(),
                              b"FALSE\x00" as *const u8 as
                                  *const libc::c_char);
                    };
                    return 0 as libc::c_int
                }
                //DBPRINTF(("Loaded feature - id = %d @ %p\n",psSaveFeature->id,pFeature);
		//restore values
                (*pFeature).id = (*psSaveFeature).id;
                (*pFeature).direction = (*psSaveFeature).direction as UWORD;
                (*pFeature).inFire = (*psSaveFeature).inFire;
                (*pFeature).burnDamage = (*psSaveFeature).burnDamage;
                if version >= 14 as libc::c_int as libc::c_uint {
                    i = 0 as libc::c_int as UDWORD;
                    while i < 8 as libc::c_int as libc::c_uint {
                        (*pFeature).visible[i as usize] =
                            (*psSaveFeature).visible[i as usize];
                        //set the Tile flag if visible for the selectedPlayer
                        if i == selectedPlayer &&
                               (*pFeature).visible[i as usize] as libc::c_int
                                   == 0xff as libc::c_int {
                            setFeatTileDraw(pFeature);
                        }
                        i = i.wrapping_add(1)
                    }
                }
            }
        }
        count = count.wrapping_add(1);
        pFileData = pFileData.offset(sizeOfSaveFeature as isize)
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
/* code for all post version 7 save features */
unsafe extern "C" fn loadSaveFeatureV(mut pFileData: *mut libc::c_char,
                                      mut filesize: UDWORD,
                                      mut numFeatures: UDWORD,
                                      mut version: UDWORD) -> BOOL {
    let mut psSaveFeature: *mut SAVE_FEATURE = 0 as *mut SAVE_FEATURE;
    let mut pFeature: *mut FEATURE = 0 as *mut FEATURE;
    let mut count: UDWORD = 0;
    let mut i: UDWORD = 0;
    let mut statInc: UDWORD = 0;
    let mut psStats: *mut FEATURE_STATS = 0 as *mut FEATURE_STATS;
    let mut found: BOOL = 0;
    let mut sizeOfSaveFeature: UDWORD = 0;
    //	version;
    sizeOfSaveFeature =
        ::std::mem::size_of::<SAVE_FEATURE>() as libc::c_ulong;
    if sizeOfSaveFeature.wrapping_mul(numFeatures).wrapping_add(12 as
                                                                    libc::c_int
                                                                    as
                                                                    libc::c_uint)
           > filesize {
        debug(LOG_ERROR,
              b"featureLoad: unexpected end of file\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    /* Load in the feature data */
    count = 0 as libc::c_int as UDWORD;
    while count < numFeatures {
        psSaveFeature = pFileData as *mut SAVE_FEATURE;
        /* FEATURE_SAVE is FEATURE_SAVE_V20 */
		/* FEATURE_SAVE_V20 is OBJECT_SAVE_V20 */
		/* OBJECT_SAVE_V20 */
        endian_udword(&mut (*psSaveFeature).id);
        endian_udword(&mut (*psSaveFeature).x);
        endian_udword(&mut (*psSaveFeature).y);
        endian_udword(&mut (*psSaveFeature).z);
        endian_udword(&mut (*psSaveFeature).direction);
        endian_udword(&mut (*psSaveFeature).player);
        endian_udword(&mut (*psSaveFeature).burnStart);
        endian_udword(&mut (*psSaveFeature).burnDamage);
        /*if (psSaveFeature->featureInc > numFeatureStats)
		{
			DBERROR(("Invalid Feature Type - unable to load save game"));
			goto error;
		}*/
		//get the stats for this feature
        found = 0 as libc::c_int;
        if !(getSaveObjectName((*psSaveFeature).name.as_mut_ptr()) == 0) {
            statInc = 0 as libc::c_int as UDWORD;
            while statInc < numFeatureStats {
                psStats = asFeatureStats.offset(statInc as isize);
                //loop until find the same name
                if strcmp((*psStats).pName,
                          (*psSaveFeature).name.as_mut_ptr()) == 0 {
                    found = 1 as libc::c_int;
                    break ;
                } else { statInc = statInc.wrapping_add(1) }
            }
            //if haven't found the feature - ignore this record!
            if found == 0 {
                debug(LOG_ERROR,
                      b"This feature no longer exists - %s\x00" as *const u8
                          as *const libc::c_char,
                      (*psSaveFeature).name.as_mut_ptr());
                abort();
            } else {
                //create the Feature
		//buildFeature(asFeatureStats + psSaveFeature->featureInc,
		//	psSaveFeature->x, psSaveFeature->y);
                pFeature =
                    buildFeature(psStats, (*psSaveFeature).x,
                                 (*psSaveFeature).y, 1 as libc::c_int);
                //will be added to the top of the linked list
		//pFeature = apsFeatureLists[0];
                if pFeature.is_null() {
                    if 0 as libc::c_int != 0 {
                    } else {
                        debug(LOG_ERROR,
                              b"loadSaveFeature:Unable to create feature\x00"
                                  as *const u8 as *const libc::c_char);
                    };
                    if 0 as libc::c_int != 0 {
                    } else {
                        debug(LOG_ERROR,
                              b"Assert in Warzone: %s:%d : %s (%s)\x00" as
                                  *const u8 as *const libc::c_char,
                              b"game.c\x00" as *const u8 as
                                  *const libc::c_char, 8350 as libc::c_int,
                              (*::std::mem::transmute::<&[u8; 17],
                                                        &[libc::c_char; 17]>(b"loadSaveFeatureV\x00")).as_ptr(),
                              b"FALSE\x00" as *const u8 as
                                  *const libc::c_char);
                    };
                    return 0 as libc::c_int
                }
                //DBPRINTF(("Loaded feature - id = %d @ %p\n",psSaveFeature->id,pFeature);
		//restore values
                (*pFeature).id = (*psSaveFeature).id;
                (*pFeature).direction = (*psSaveFeature).direction as UWORD;
                (*pFeature).inFire = (*psSaveFeature).inFire;
                (*pFeature).burnDamage = (*psSaveFeature).burnDamage;
                i = 0 as libc::c_int as UDWORD;
                while i < 8 as libc::c_int as libc::c_uint {
                    (*pFeature).visible[i as usize] =
                        (*psSaveFeature).visible[i as usize];
                    //set the Tile flag if visible for the selectedPlayer
                    if i == selectedPlayer &&
                           (*pFeature).visible[i as usize] as libc::c_int ==
                               0xff as libc::c_int {
                        setFeatTileDraw(pFeature);
                    }
                    i = i.wrapping_add(1)
                }
            }
        }
        count = count.wrapping_add(1);
        pFileData = pFileData.offset(sizeOfSaveFeature as isize)
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
/*
Writes the linked list of features to a file
*/
unsafe extern "C" fn writeFeatureFile(mut pFileName: *mut STRING) -> BOOL {
    let mut pFileData: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut fileSize: UDWORD = 0;
    let mut i: UDWORD = 0;
    let mut totalFeatures: UDWORD = 0 as libc::c_int as UDWORD;
    let mut psCurr: *mut FEATURE = 0 as *mut FEATURE;
    let mut psHeader: *mut FEATURE_SAVEHEADER = 0 as *mut FEATURE_SAVEHEADER;
    let mut psSaveFeature: *mut SAVE_FEATURE = 0 as *mut SAVE_FEATURE;
    let mut status: BOOL = 1 as libc::c_int;
    //total all the features in the world
    psCurr = apsFeatureLists[0 as libc::c_int as usize];
    while !psCurr.is_null() {
        totalFeatures = totalFeatures.wrapping_add(1);
        psCurr = (*psCurr).psNext
    }
    /* Allocate the data buffer */
    fileSize =
        (12 as libc::c_int as
             libc::c_uint).wrapping_add(totalFeatures.wrapping_mul(::std::mem::size_of::<SAVE_FEATURE>()
                                                                       as
                                                                       libc::c_ulong));
    pFileData = memMallocRelease(fileSize) as *mut libc::c_char;
    if pFileData.is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        abort();
    }
    /* Put the file header on the file */
    psHeader = pFileData as *mut FEATURE_SAVEHEADER;
    (*psHeader).aFileType[0 as libc::c_int as usize] = 'f' as i32 as STRING;
    (*psHeader).aFileType[1 as libc::c_int as usize] = 'e' as i32 as STRING;
    (*psHeader).aFileType[2 as libc::c_int as usize] = 'a' as i32 as STRING;
    (*psHeader).aFileType[3 as libc::c_int as usize] = 't' as i32 as STRING;
    (*psHeader).version = 33 as libc::c_int as UDWORD;
    (*psHeader).quantity = totalFeatures;
    psSaveFeature =
        pFileData.offset(12 as libc::c_int as isize) as *mut SAVE_FEATURE;
    /* Put the feature data into the buffer */
    psCurr = apsFeatureLists[0 as libc::c_int as usize];
    while !psCurr.is_null() {
        strcpy((*psSaveFeature).name.as_mut_ptr(),
               (*(*psCurr).psStats).pName);
        (*psSaveFeature).id = (*psCurr).id;
        //		psSaveFeature->x = psCurr->x - psCurr->psStats->baseWidth * TILE_UNITS / 2;
//		psSaveFeature->y = psCurr->y - psCurr->psStats->baseBreadth * TILE_UNITS / 2;
//		psSaveFeature->z = psCurr->z;
        (*psSaveFeature).x = (*psCurr).x as UDWORD;
        (*psSaveFeature).y = (*psCurr).y as UDWORD;
        (*psSaveFeature).z = (*psCurr).z as UDWORD;
        (*psSaveFeature).direction = (*psCurr).direction as UDWORD;
        (*psSaveFeature).inFire = (*psCurr).inFire;
        (*psSaveFeature).burnDamage = (*psCurr).burnDamage;
        i = 0 as libc::c_int as UDWORD;
        while i < 8 as libc::c_int as libc::c_uint {
            (*psSaveFeature).visible[i as usize] =
                (*psCurr).visible[i as usize];
            i = i.wrapping_add(1)
        }
        //		psSaveFeature->featureInc = psCurr->psStats - asFeatureStats;
        /* SAVE_FEATURE is FEATURE_SAVE_V20 */
		/* FEATURE_SAVE_V20 includes OBJECT_SAVE_V20 */
		/* OBJECT_SAVE_V20 */
        endian_udword(&mut (*psSaveFeature).id);
        endian_udword(&mut (*psSaveFeature).x);
        endian_udword(&mut (*psSaveFeature).y);
        endian_udword(&mut (*psSaveFeature).z);
        endian_udword(&mut (*psSaveFeature).direction);
        endian_udword(&mut (*psSaveFeature).player);
        endian_udword(&mut (*psSaveFeature).burnStart);
        endian_udword(&mut (*psSaveFeature).burnDamage);
        psSaveFeature =
            (psSaveFeature as
                 *mut libc::c_char).offset(::std::mem::size_of::<SAVE_FEATURE>()
                                               as libc::c_ulong as isize) as
                *mut SAVE_FEATURE;
        psCurr = (*psCurr).psNext
    }
    /* FEATURE_SAVEHEADER */
    endian_udword(&mut (*psHeader).version);
    endian_udword(&mut (*psHeader).quantity);
    /* Write the data to the file */
    if !pFileData.is_null() {
        status = saveFile(pFileName, pFileData, fileSize);
        memFreeRelease(pFileData as *mut libc::c_void);
        pFileData = 0 as *mut libc::c_char;
        return status
    }
    return 0 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
unsafe extern "C" fn loadSaveTemplate(mut pFileData: *mut libc::c_char,
                                      mut filesize: UDWORD) -> BOOL {
    let mut psHeader: *mut TEMPLATE_SAVEHEADER =
        0 as *mut TEMPLATE_SAVEHEADER;
    /* Check the file type */
    psHeader = pFileData as *mut TEMPLATE_SAVEHEADER;
    if (*psHeader).aFileType[0 as libc::c_int as usize] as libc::c_int !=
           't' as i32 ||
           (*psHeader).aFileType[1 as libc::c_int as usize] as libc::c_int !=
               'e' as i32 ||
           (*psHeader).aFileType[2 as libc::c_int as usize] as libc::c_int !=
               'm' as i32 ||
           (*psHeader).aFileType[3 as libc::c_int as usize] as libc::c_int !=
               'p' as i32 {
        debug(LOG_ERROR,
              b"loadSaveTemplate: Incorrect file type\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    /* TEMPLATE_SAVEHEADER */
    endian_udword(&mut (*psHeader).version);
    endian_udword(&mut (*psHeader).quantity);
    //increment to the start of the data
    pFileData = pFileData.offset(12 as libc::c_int as isize);
    /* Check the file version */
    if (*psHeader).version < 7 as libc::c_int as libc::c_uint {
        debug(LOG_ERROR,
              b"TemplateLoad: unsupported save format version %d\x00" as
                  *const u8 as *const libc::c_char, (*psHeader).version);
        abort();
    } else {
        if (*psHeader).version < 14 as libc::c_int as libc::c_uint {
            if loadSaveTemplateV7(pFileData, filesize, (*psHeader).quantity)
                   == 0 {
                return 0 as libc::c_int
            }
        } else if (*psHeader).version <= 19 as libc::c_int as libc::c_uint {
            if loadSaveTemplateV14(pFileData, filesize, (*psHeader).quantity)
                   == 0 {
                return 0 as libc::c_int
            }
        } else if (*psHeader).version <= 33 as libc::c_int as libc::c_uint {
            if loadSaveTemplateV(pFileData, filesize, (*psHeader).quantity) ==
                   0 {
                return 0 as libc::c_int
            }
        } else {
            debug(LOG_ERROR,
                  b"TemplateLoad: undefined save format version %d\x00" as
                      *const u8 as *const libc::c_char, (*psHeader).version);
            abort();
        }
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
/* code specific to version 7 of a save template */
unsafe extern "C" fn loadSaveTemplateV7(mut pFileData: *mut libc::c_char,
                                        mut filesize: UDWORD,
                                        mut numTemplates: UDWORD) -> BOOL {
    let mut psSaveTemplate: *mut SAVE_TEMPLATE_V2 =
        0 as *mut SAVE_TEMPLATE_V2;
    let mut sSaveTemplate: SAVE_TEMPLATE_V2 =
        SAVE_TEMPLATE_V2{name: [0; 40],
                         ref_0: 0,
                         player: 0,
                         droidType: 0,
                         asParts: [[0; 40]; 8],
                         numWeaps: 0,
                         asWeaps: [[0; 40]; 3],
                         numProgs: 0,
                         asProgs: [[0; 40]; 3],};
    let mut psTemplate: *mut DROID_TEMPLATE = 0 as *mut DROID_TEMPLATE;
    let mut count: UDWORD = 0;
    let mut i: UDWORD = 0;
    let mut compInc: SDWORD = 0;
    let mut found: BOOL = 0;
    psSaveTemplate = &mut sSaveTemplate;
    if (::std::mem::size_of::<SAVE_TEMPLATE_V2>() as
            libc::c_ulong).wrapping_mul(numTemplates).wrapping_add(12 as
                                                                       libc::c_int
                                                                       as
                                                                       libc::c_uint)
           > filesize {
        debug(LOG_ERROR,
              b"templateLoad: unexpected end of file\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    /* Load in the template data */
    count = 0 as libc::c_int as UDWORD;
    while count < numTemplates {
        memcpy(psSaveTemplate as *mut libc::c_void,
               pFileData as *const libc::c_void,
               ::std::mem::size_of::<SAVE_TEMPLATE_V2>() as libc::c_ulong);
        /* SAVE_TEMPLATE_V2 is TEMPLATE_SAVE_V2 */
		/* TEMPLATE_SAVE_V2 */
        endian_udword(&mut (*psSaveTemplate).ref_0);
        endian_udword(&mut (*psSaveTemplate).player);
        endian_udword(&mut (*psSaveTemplate).numWeaps);
        endian_udword(&mut (*psSaveTemplate).numProgs);
        if !((*psSaveTemplate).player != 0 as libc::c_int as libc::c_uint) {
            //create the Template
            if heapAlloc(psTemplateHeap,
                         &mut psTemplate as *mut *mut DROID_TEMPLATE as
                             *mut libc::c_void as *mut *mut libc::c_void) == 0
               {
                debug(LOG_ERROR,
                      b"Out of memory\x00" as *const u8 as
                          *const libc::c_char);
                abort();
            } else {
                //copy the values across
                (*psTemplate).pName = 0 as *mut STRING;
                strncpy((*psTemplate).aName.as_mut_ptr(),
                        (*psSaveTemplate).name.as_mut_ptr(),
                        60 as libc::c_int as libc::c_uint);
                (*psTemplate).aName[(60 as libc::c_int - 1 as libc::c_int) as
                                        usize] = 0 as libc::c_int as STRING;
                (*psTemplate).ref_0 = (*psSaveTemplate).ref_0;
                (*psTemplate).droidType =
                    (*psSaveTemplate).droidType as DROID_TYPE;
                found = 1 as libc::c_int;
                //for (i=0; i < DROID_MAXCOMP; i++) - not intestested in the first comp - COMP_UNKNOWN
                i = 1 as libc::c_int as UDWORD;
                while i <
                          (COMP_NUMCOMPONENTS as libc::c_int -
                               1 as libc::c_int) as libc::c_uint {
                    //DROID_MAXCOMP has changed to remove COMP_PROGRAM so hack here to load old save games!
                    if i == 8 as libc::c_int as libc::c_uint { break ; }
                    compInc =
                        getCompFromName(i,
                                        (*psSaveTemplate).asParts[i as
                                                                      usize].as_mut_ptr());
                    if compInc < 0 as libc::c_int {
                        debug(LOG_ERROR,
                              b"This component no longer exists - %s, the template will be deleted\x00"
                                  as *const u8 as *const libc::c_char,
                              (*psSaveTemplate).asParts[i as
                                                            usize].as_mut_ptr());
                        abort();
                    } else {
                        (*psTemplate).asParts[i as usize] =
                            compInc as UDWORD as SDWORD;
                        i = i.wrapping_add(1)
                    }
                }
                if found == 0 {
                    //ignore this record
                    heapFree(psTemplateHeap, psTemplate as *mut libc::c_void);
                } else {
                    (*psTemplate).numWeaps = (*psSaveTemplate).numWeaps;
                    found = 1 as libc::c_int;
                    i = 0 as libc::c_int as UDWORD;
                    while i < (*psTemplate).numWeaps {
                        compInc =
                            getCompFromName(COMP_WEAPON as libc::c_int as
                                                UDWORD,
                                            (*psSaveTemplate).asWeaps[i as
                                                                          usize].as_mut_ptr());
                        if compInc < 0 as libc::c_int {
                            debug(LOG_ERROR,
                                  b"This weapon no longer exists - %s, the template will be deleted\x00"
                                      as *const u8 as *const libc::c_char,
                                  (*psSaveTemplate).asWeaps[i as
                                                                usize].as_mut_ptr());
                            abort();
                        } else {
                            (*psTemplate).asWeaps[i as usize] =
                                compInc as UDWORD;
                            i = i.wrapping_add(1)
                        }
                    }
                    if found == 0 {
                        //ignore this record
                        heapFree(psTemplateHeap,
                                 psTemplate as *mut libc::c_void);
                    } else {
                        // ignore brains and programs for now
                        (*psTemplate).asParts[COMP_BRAIN as libc::c_int as
                                                  usize] = 0 as libc::c_int;
                        //calculate the total build points
                        (*psTemplate).buildPoints =
                            calcTemplateBuild(psTemplate);
                        (*psTemplate).powerPoints =
                            calcTemplatePower(psTemplate);
                        //store it in the apropriate player' list
                        (*psTemplate).psNext =
                            apsDroidTemplates[(*psSaveTemplate).player as
                                                  usize];
                        apsDroidTemplates[(*psSaveTemplate).player as usize] =
                            psTemplate
                    }
                }
            }
        }
        // only load player 0 templates - the rest come from stats
        count = count.wrapping_add(1);
        pFileData =
            pFileData.offset(::std::mem::size_of::<SAVE_TEMPLATE_V2>() as
                                 libc::c_ulong as isize)
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
/* none specific version of a save template */
unsafe extern "C" fn loadSaveTemplateV14(mut pFileData: *mut libc::c_char,
                                         mut filesize: UDWORD,
                                         mut numTemplates: UDWORD) -> BOOL {
    let mut psSaveTemplate: *mut SAVE_TEMPLATE_V14 =
        0 as *mut SAVE_TEMPLATE_V14;
    let mut sSaveTemplate: SAVE_TEMPLATE_V14 =
        SAVE_TEMPLATE_V14{name: [0; 40],
                          ref_0: 0,
                          player: 0,
                          droidType: 0,
                          asParts: [[0; 40]; 8],
                          numWeaps: 0,
                          asWeaps: [[0; 40]; 3],
                          multiPlayerID: 0,};
    let mut psTemplate: *mut DROID_TEMPLATE = 0 as *mut DROID_TEMPLATE;
    let mut psDestTemplate: *mut DROID_TEMPLATE = 0 as *mut DROID_TEMPLATE;
    let mut count: UDWORD = 0;
    let mut i: UDWORD = 0;
    let mut compInc: SDWORD = 0;
    let mut found: BOOL = 0;
    psSaveTemplate = &mut sSaveTemplate;
    if (::std::mem::size_of::<SAVE_TEMPLATE_V14>() as
            libc::c_ulong).wrapping_mul(numTemplates).wrapping_add(12 as
                                                                       libc::c_int
                                                                       as
                                                                       libc::c_uint)
           > filesize {
        debug(LOG_ERROR,
              b"templateLoad: unexpected end of file\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    /* Load in the template data */
    count = 0 as libc::c_int as UDWORD;
    while count < numTemplates {
        memcpy(psSaveTemplate as *mut libc::c_void,
               pFileData as *const libc::c_void,
               ::std::mem::size_of::<SAVE_TEMPLATE_V14>() as libc::c_ulong);
        /* SAVE_TEMPLATE_V14 is TEMPLATE_SAVE_V14 */
        endian_udword(&mut (*psSaveTemplate).ref_0);
        endian_udword(&mut (*psSaveTemplate).player);
        endian_udword(&mut (*psSaveTemplate).numWeaps);
        endian_udword(&mut (*psSaveTemplate).multiPlayerID);
        //AT SOME POINT CHECK THE multiPlayerID TO SEE IF ALREADY EXISTS - IGNORE IF IT DOES
        if !((*psSaveTemplate).player != 0 as libc::c_int as libc::c_uint) {
            //create the Template
            if heapAlloc(psTemplateHeap,
                         &mut psTemplate as *mut *mut DROID_TEMPLATE as
                             *mut libc::c_void as *mut *mut libc::c_void) == 0
               {
                debug(LOG_ERROR,
                      b"Out of memory\x00" as *const u8 as
                          *const libc::c_char);
                abort();
            } else {
                //copy the values across
                (*psTemplate).pName = 0 as *mut STRING;
                strncpy((*psTemplate).aName.as_mut_ptr(),
                        (*psSaveTemplate).name.as_mut_ptr(),
                        60 as libc::c_int as libc::c_uint);
                (*psTemplate).aName[(60 as libc::c_int - 1 as libc::c_int) as
                                        usize] = 0 as libc::c_int as STRING;
                (*psTemplate).ref_0 = (*psSaveTemplate).ref_0;
                (*psTemplate).droidType =
                    (*psSaveTemplate).droidType as DROID_TYPE;
                (*psTemplate).multiPlayerID = (*psSaveTemplate).multiPlayerID;
                found = 1 as libc::c_int;
                //for (i=0; i < DROID_MAXCOMP; i++) - not intestested in the first comp - COMP_UNKNOWN
                i = 1 as libc::c_int as UDWORD;
                while i <
                          (COMP_NUMCOMPONENTS as libc::c_int -
                               1 as libc::c_int) as libc::c_uint {
                    //DROID_MAXCOMP has changed to remove COMP_PROGRAM so hack here to load old save games!
                    if i == 8 as libc::c_int as libc::c_uint { break ; }
                    compInc =
                        getCompFromName(i,
                                        (*psSaveTemplate).asParts[i as
                                                                      usize].as_mut_ptr());
                    if compInc < 0 as libc::c_int {
                        debug(LOG_ERROR,
                              b"This component no longer exists - %s, the template will be deleted\x00"
                                  as *const u8 as *const libc::c_char,
                              (*psSaveTemplate).asParts[i as
                                                            usize].as_mut_ptr());
                        abort();
                    } else {
                        (*psTemplate).asParts[i as usize] =
                            compInc as UDWORD as SDWORD;
                        i = i.wrapping_add(1)
                    }
                }
                if found == 0 {
                    //ignore this record
                    heapFree(psTemplateHeap, psTemplate as *mut libc::c_void);
                } else {
                    (*psTemplate).numWeaps = (*psSaveTemplate).numWeaps;
                    found = 1 as libc::c_int;
                    i = 0 as libc::c_int as UDWORD;
                    while i < (*psTemplate).numWeaps {
                        compInc =
                            getCompFromName(COMP_WEAPON as libc::c_int as
                                                UDWORD,
                                            (*psSaveTemplate).asWeaps[i as
                                                                          usize].as_mut_ptr());
                        if compInc < 0 as libc::c_int {
                            debug(LOG_ERROR,
                                  b"This weapon no longer exists - %s, the template will be deleted\x00"
                                      as *const u8 as *const libc::c_char,
                                  (*psSaveTemplate).asWeaps[i as
                                                                usize].as_mut_ptr());
                            abort();
                        } else {
                            (*psTemplate).asWeaps[i as usize] =
                                compInc as UDWORD;
                            i = i.wrapping_add(1)
                        }
                    }
                    if found == 0 {
                        //ignore this record
                        heapFree(psTemplateHeap,
                                 psTemplate as *mut libc::c_void);
                    } else {
                        // ignore brains and programs for now
                        (*psTemplate).asParts[COMP_BRAIN as libc::c_int as
                                                  usize] = 0 as libc::c_int;
                        //calculate the total build points
                        (*psTemplate).buildPoints =
                            calcTemplateBuild(psTemplate);
                        (*psTemplate).powerPoints =
                            calcTemplatePower(psTemplate);
                        //store it in the apropriate player' list
		//if a template with the same multiplayerID exists overwrite it
		//else add this template to the top of the list
                        psDestTemplate =
                            apsDroidTemplates[(*psSaveTemplate).player as
                                                  usize]; //preserve the list
                        while !psDestTemplate.is_null() {
                            if (*psTemplate).multiPlayerID ==
                                   (*psDestTemplate).multiPlayerID {
                                break ;
                            }
                            psDestTemplate = (*psDestTemplate).psNext
                        }
                        if !psDestTemplate.is_null() {
                            (*psTemplate).psNext = (*psDestTemplate).psNext;
                            memcpy(psDestTemplate as *mut libc::c_void,
                                   psTemplate as *const libc::c_void,
                                   ::std::mem::size_of::<DROID_TEMPLATE>() as
                                       libc::c_ulong);
                        } else {
                            //add it to the top of the list
                            (*psTemplate).psNext =
                                apsDroidTemplates[(*psSaveTemplate).player as
                                                      usize];
                            apsDroidTemplates[(*psSaveTemplate).player as
                                                  usize] = psTemplate
                        }
                    }
                }
            }
        }
        // only load player 0 templates - the rest come from stats
        count = count.wrapping_add(1);
        pFileData =
            pFileData.offset(::std::mem::size_of::<SAVE_TEMPLATE_V14>() as
                                 libc::c_ulong as isize)
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
/* none specific version of a save template */
unsafe extern "C" fn loadSaveTemplateV(mut pFileData: *mut libc::c_char,
                                       mut filesize: UDWORD,
                                       mut numTemplates: UDWORD) -> BOOL {
    let mut psSaveTemplate: *mut SAVE_TEMPLATE = 0 as *mut SAVE_TEMPLATE;
    let mut sSaveTemplate: SAVE_TEMPLATE =
        SAVE_TEMPLATE{name: [0; 60],
                      ref_0: 0,
                      player: 0,
                      droidType: 0,
                      asParts: [[0; 60]; 8],
                      numWeaps: 0,
                      asWeaps: [[0; 60]; 3],
                      multiPlayerID: 0,};
    let mut psTemplate: *mut DROID_TEMPLATE = 0 as *mut DROID_TEMPLATE;
    let mut psDestTemplate: *mut DROID_TEMPLATE = 0 as *mut DROID_TEMPLATE;
    let mut count: UDWORD = 0;
    let mut i: UDWORD = 0;
    let mut compInc: SDWORD = 0;
    let mut found: BOOL = 0;
    psSaveTemplate = &mut sSaveTemplate;
    if (::std::mem::size_of::<SAVE_TEMPLATE>() as
            libc::c_ulong).wrapping_mul(numTemplates).wrapping_add(12 as
                                                                       libc::c_int
                                                                       as
                                                                       libc::c_uint)
           > filesize {
        debug(LOG_ERROR,
              b"templateLoad: unexpected end of file\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    /* Load in the template data */
    count = 0 as libc::c_int as UDWORD;
    while count < numTemplates {
        memcpy(psSaveTemplate as *mut libc::c_void,
               pFileData as *const libc::c_void,
               ::std::mem::size_of::<SAVE_TEMPLATE>() as libc::c_ulong);
        /* SAVE_TEMPLATE is TEMPLATE_SAVE_V20 */
		/* TEMPLATE_SAVE_V20 */
        endian_udword(&mut (*psSaveTemplate).ref_0);
        endian_udword(&mut (*psSaveTemplate).player);
        endian_udword(&mut (*psSaveTemplate).numWeaps);
        endian_udword(&mut (*psSaveTemplate).multiPlayerID);
        //AT SOME POINT CHECK THE multiPlayerID TO SEE IF ALREADY EXISTS - IGNORE IF IT DOES
        if !((*psSaveTemplate).player != 0 as libc::c_int as libc::c_uint &&
                 bMultiPlayer == 0) {
            //create the Template
            if heapAlloc(psTemplateHeap,
                         &mut psTemplate as *mut *mut DROID_TEMPLATE as
                             *mut libc::c_void as *mut *mut libc::c_void) == 0
               {
                debug(LOG_ERROR,
                      b"Out of memory\x00" as *const u8 as
                          *const libc::c_char);
                abort();
            } else {
                //copy the values across
                (*psTemplate).pName = 0 as *mut STRING;
                strncpy((*psTemplate).aName.as_mut_ptr(),
                        (*psSaveTemplate).name.as_mut_ptr(),
                        60 as libc::c_int as libc::c_uint);
                (*psTemplate).aName[(60 as libc::c_int - 1 as libc::c_int) as
                                        usize] = 0 as libc::c_int as STRING;
                (*psTemplate).ref_0 = (*psSaveTemplate).ref_0;
                (*psTemplate).droidType =
                    (*psSaveTemplate).droidType as DROID_TYPE;
                (*psTemplate).multiPlayerID = (*psSaveTemplate).multiPlayerID;
                found = 1 as libc::c_int;
                //for (i=0; i < DROID_MAXCOMP; i++) - not intestested in the first comp - COMP_UNKNOWN
                i = 1 as libc::c_int as UDWORD;
                while i <
                          (COMP_NUMCOMPONENTS as libc::c_int -
                               1 as libc::c_int) as libc::c_uint {
                    //DROID_MAXCOMP has changed to remove COMP_PROGRAM so hack here to load old save games!
                    if i == 8 as libc::c_int as libc::c_uint { break ; }
                    compInc =
                        getCompFromName(i,
                                        (*psSaveTemplate).asParts[i as
                                                                      usize].as_mut_ptr());
                    //HACK to get the game to load when ECMs, Sensors or RepairUnits have been deleted
                    if compInc < 0 as libc::c_int &&
                           (i == COMP_ECM as libc::c_int as libc::c_uint ||
                                i ==
                                    COMP_SENSOR as libc::c_int as libc::c_uint
                                ||
                                i ==
                                    COMP_REPAIRUNIT as libc::c_int as
                                        libc::c_uint) {
                        //set the ECM to be the defaultECM ...
                        if i == COMP_ECM as libc::c_int as libc::c_uint {
                            compInc =
                                aDefaultECM[(*psSaveTemplate).player as usize]
                                    as SDWORD
                        } else if i ==
                                      COMP_SENSOR as libc::c_int as
                                          libc::c_uint {
                            compInc =
                                aDefaultSensor[(*psSaveTemplate).player as
                                                   usize] as SDWORD
                        } else if i ==
                                      COMP_REPAIRUNIT as libc::c_int as
                                          libc::c_uint {
                            compInc =
                                aDefaultRepair[(*psSaveTemplate).player as
                                                   usize] as SDWORD
                        }
                    } else if compInc < 0 as libc::c_int {
                        debug(LOG_ERROR,
                              b"This component no longer exists - %s, the template will be deleted\x00"
                                  as *const u8 as *const libc::c_char,
                              (*psSaveTemplate).asParts[i as
                                                            usize].as_mut_ptr());
                        abort();
                    }
                    (*psTemplate).asParts[i as usize] =
                        compInc as UDWORD as SDWORD;
                    i = i.wrapping_add(1)
                }
                if found == 0 {
                    //ignore this record
                    heapFree(psTemplateHeap, psTemplate as *mut libc::c_void);
                } else {
                    (*psTemplate).numWeaps = (*psSaveTemplate).numWeaps;
                    found = 1 as libc::c_int;
                    i = 0 as libc::c_int as UDWORD;
                    while i < (*psTemplate).numWeaps {
                        compInc =
                            getCompFromName(COMP_WEAPON as libc::c_int as
                                                UDWORD,
                                            (*psSaveTemplate).asWeaps[i as
                                                                          usize].as_mut_ptr());
                        if compInc < 0 as libc::c_int {
                            debug(LOG_ERROR,
                                  b"This weapon no longer exists - %s, the template will be deleted\x00"
                                      as *const u8 as *const libc::c_char,
                                  (*psSaveTemplate).asWeaps[i as
                                                                usize].as_mut_ptr());
                            abort();
                        } else {
                            (*psTemplate).asWeaps[i as usize] =
                                compInc as UDWORD;
                            i = i.wrapping_add(1)
                        }
                    }
                    if found == 0 {
                        //ignore this record
                        heapFree(psTemplateHeap,
                                 psTemplate as *mut libc::c_void);
                    } else {
                        //no! put brains back in 10Feb //ignore brains and programs for now
		//psTemplate->asParts[COMP_BRAIN] = 0;
                        //calculate the total build points
                        (*psTemplate).buildPoints =
                            calcTemplateBuild(psTemplate);
                        (*psTemplate).powerPoints =
                            calcTemplatePower(psTemplate);
                        //store it in the apropriate player' list
		//if a template with the same multiplayerID exists overwrite it
		//else add this template to the top of the list
                        psDestTemplate =
                            apsDroidTemplates[(*psSaveTemplate).player as
                                                  usize]; //preserve the list
                        while !psDestTemplate.is_null() {
                            if (*psTemplate).multiPlayerID ==
                                   (*psDestTemplate).multiPlayerID {
                                break ;
                            }
                            psDestTemplate = (*psDestTemplate).psNext
                        }
                        if !psDestTemplate.is_null() {
                            (*psTemplate).psNext = (*psDestTemplate).psNext;
                            memcpy(psDestTemplate as *mut libc::c_void,
                                   psTemplate as *const libc::c_void,
                                   ::std::mem::size_of::<DROID_TEMPLATE>() as
                                       libc::c_ulong);
                        } else {
                            //add it to the top of the list
                            (*psTemplate).psNext =
                                apsDroidTemplates[(*psSaveTemplate).player as
                                                      usize];
                            apsDroidTemplates[(*psSaveTemplate).player as
                                                  usize] = psTemplate
                        }
                    }
                }
            }
        }
        // only load player 0 templates - the rest come from stats
        count = count.wrapping_add(1);
        pFileData =
            pFileData.offset(::std::mem::size_of::<SAVE_TEMPLATE>() as
                                 libc::c_ulong as isize)
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
/*
Writes the linked list of templates for each player to a file
*/
unsafe extern "C" fn writeTemplateFile(mut pFileName: *mut STRING) -> BOOL {
    let mut pFileData: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut fileSize: UDWORD = 0;
    let mut player: UDWORD = 0;
    let mut totalTemplates: UDWORD = 0 as libc::c_int as UDWORD;
    let mut psCurr: *mut DROID_TEMPLATE = 0 as *mut DROID_TEMPLATE;
    let mut psHeader: *mut TEMPLATE_SAVEHEADER =
        0 as *mut TEMPLATE_SAVEHEADER;
    let mut psSaveTemplate: *mut SAVE_TEMPLATE = 0 as *mut SAVE_TEMPLATE;
    let mut i: UDWORD = 0;
    let mut status: BOOL = 1 as libc::c_int;
    //total all the droids in the world
    player = 0 as libc::c_int as UDWORD;
    while player < 8 as libc::c_int as libc::c_uint {
        psCurr = apsDroidTemplates[player as usize];
        while !psCurr.is_null() {
            totalTemplates = totalTemplates.wrapping_add(1);
            psCurr = (*psCurr).psNext
        }
        player = player.wrapping_add(1)
    }
    /* Allocate the data buffer */
    fileSize =
        (12 as libc::c_int as
             libc::c_uint).wrapping_add(totalTemplates.wrapping_mul(::std::mem::size_of::<SAVE_TEMPLATE>()
                                                                        as
                                                                        libc::c_ulong));
    pFileData = memMallocRelease(fileSize) as *mut libc::c_char;
    if pFileData.is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        abort();
    }
    /* Put the file header on the file */
    psHeader = pFileData as *mut TEMPLATE_SAVEHEADER;
    (*psHeader).aFileType[0 as libc::c_int as usize] = 't' as i32 as STRING;
    (*psHeader).aFileType[1 as libc::c_int as usize] = 'e' as i32 as STRING;
    (*psHeader).aFileType[2 as libc::c_int as usize] = 'm' as i32 as STRING;
    (*psHeader).aFileType[3 as libc::c_int as usize] = 'p' as i32 as STRING;
    (*psHeader).version = 33 as libc::c_int as UDWORD;
    (*psHeader).quantity = totalTemplates;
    psSaveTemplate =
        pFileData.offset(12 as libc::c_int as isize) as *mut SAVE_TEMPLATE;
    /* Put the template data into the buffer */
    player = 0 as libc::c_int as UDWORD;
    while player < 8 as libc::c_int as libc::c_uint {
        psCurr = apsDroidTemplates[player as usize];
        while !psCurr.is_null() {
            //strcpy(psSaveTemplate->name, psCurr->pName);
            strcpy((*psSaveTemplate).name.as_mut_ptr(),
                   (*psCurr).aName.as_mut_ptr());
            (*psSaveTemplate).ref_0 = (*psCurr).ref_0;
            (*psSaveTemplate).player = player;
            (*psSaveTemplate).droidType = (*psCurr).droidType as UBYTE;
            (*psSaveTemplate).multiPlayerID = (*psCurr).multiPlayerID;
            //for (i=0; i < DROID_MAXCOMP; i++) not interested in first comp - COMP_UNKNOWN
            i = 1 as libc::c_int as UDWORD;
            while i <
                      (COMP_NUMCOMPONENTS as libc::c_int - 1 as libc::c_int)
                          as libc::c_uint {
                if getNameFromComp(i,
                                   (*psSaveTemplate).asParts[i as
                                                                 usize].as_mut_ptr(),
                                   (*psCurr).asParts[i as usize] as UDWORD) ==
                       0 {
                    break ;
                    //continue;
                } else { i = i.wrapping_add(1) }
            }
            (*psSaveTemplate).numWeaps = (*psCurr).numWeaps;
            i = 0 as libc::c_int as UDWORD;
            while i < (*psCurr).numWeaps {
                if getNameFromComp(COMP_WEAPON as libc::c_int as UDWORD,
                                   (*psSaveTemplate).asWeaps[i as
                                                                 usize].as_mut_ptr(),
                                   (*psCurr).asWeaps[i as usize]) == 0 {
                    break ;
                }
                i = i.wrapping_add(1)
            }
            /* SAVE_TEMPLATE is TEMPLATE_SAVE_V20 */
			/* TEMPLATE_SAVE_V20 */
            endian_udword(&mut (*psSaveTemplate).ref_0);
            endian_udword(&mut (*psSaveTemplate).player);
            endian_udword(&mut (*psSaveTemplate).numWeaps);
            endian_udword(&mut (*psSaveTemplate).multiPlayerID);
            psSaveTemplate =
                (psSaveTemplate as
                     *mut libc::c_char).offset(::std::mem::size_of::<SAVE_TEMPLATE>()
                                                   as libc::c_ulong as isize)
                    as *mut SAVE_TEMPLATE;
            psCurr = (*psCurr).psNext
        }
        player = player.wrapping_add(1)
    }
    /* TEMPLATE_SAVEHEADER */
    endian_udword(&mut (*psHeader).version);
    endian_udword(&mut (*psHeader).quantity);
    /* Write the data to the file */
    if !pFileData.is_null() {
        status = saveFile(pFileName, pFileData, fileSize);
        memFreeRelease(pFileData as *mut libc::c_void);
        pFileData = 0 as *mut libc::c_char;
        return status
    }
    return 0 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
// load up a terrain tile type map file
#[no_mangle]
pub unsafe extern "C" fn loadTerrainTypeMap(mut pFileData: *mut libc::c_char,
                                            mut filesize: UDWORD) -> BOOL {
    let mut psHeader: *mut TILETYPE_SAVEHEADER =
        0 as *mut TILETYPE_SAVEHEADER;
    let mut i: UDWORD = 0;
    let mut pType: *mut UWORD = 0 as *mut UWORD;
    if filesize < 12 as libc::c_int as libc::c_uint {
        debug(LOG_ERROR,
              b"loadTerrainTypeMap: file too small\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    // Check the header
    psHeader = pFileData as *mut TILETYPE_SAVEHEADER;
    if (*psHeader).aFileType[0 as libc::c_int as usize] as libc::c_int !=
           't' as i32 ||
           (*psHeader).aFileType[1 as libc::c_int as usize] as libc::c_int !=
               't' as i32 ||
           (*psHeader).aFileType[2 as libc::c_int as usize] as libc::c_int !=
               'y' as i32 ||
           (*psHeader).aFileType[3 as libc::c_int as usize] as libc::c_int !=
               'p' as i32 {
        debug(LOG_ERROR,
              b"loadTerrainTypeMap: Incorrect file type\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    /* TILETYPE_SAVEHEADER */
    endian_udword(&mut (*psHeader).version);
    endian_udword(&mut (*psHeader).quantity);
    /*	Version doesn't matter for now
	if (psHeader->version != VERSION_2)
	{
		DBERROR(("loadTerrainTypeMap: Incorrect file version"));
		return FALSE;
	}*/
    // reset the terrain table
    memset(terrainTypes.as_mut_ptr() as *mut libc::c_void, 0 as libc::c_int,
           ::std::mem::size_of::<[UBYTE; 255]>() as libc::c_ulong);
    // Load the terrain type mapping
    pType = pFileData.offset(12 as libc::c_int as isize) as *mut UWORD;
    endian_uword(pType);
    i = 0 as libc::c_int as UDWORD;
    while i < (*psHeader).quantity {
        if i >= 255 as libc::c_int as libc::c_uint {
            debug(LOG_ERROR,
                  b"loadTerrainTypeMap: too many types\x00" as *const u8 as
                      *const libc::c_char);
            abort();
        }
        if *pType as libc::c_int > TER_MAX as libc::c_int {
            debug(LOG_ERROR,
                  b"loadTerrainTypeMap: terrain type out of range\x00" as
                      *const u8 as *const libc::c_char);
            abort();
        }
        terrainTypes[i as usize] = *pType as UBYTE;
        pType = pType.offset(1 as libc::c_int as isize);
        endian_uword(pType);
        i = i.wrapping_add(1)
    }
    return 1 as libc::c_int;
}
// now used in gamepsx.c aswell
// -----------------------------------------------------------------------------------------
// Write out the terrain type map
unsafe extern "C" fn writeTerrainTypeMapFile(mut pFileName: *mut STRING)
 -> BOOL {
    let mut psHeader: *mut TILETYPE_SAVEHEADER =
        0 as *mut TILETYPE_SAVEHEADER;
    let mut pFileData: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut fileSize: UDWORD = 0;
    let mut i: UDWORD = 0;
    let mut pType: *mut UWORD = 0 as *mut UWORD;
    // Calculate the file size
    fileSize =
        (12 as libc::c_int as
             libc::c_uint).wrapping_add((::std::mem::size_of::<UWORD>() as
                                             libc::c_ulong).wrapping_mul(255
                                                                             as
                                                                             libc::c_int
                                                                             as
                                                                             libc::c_uint));
    pFileData = memMallocRelease(fileSize) as *mut libc::c_char;
    if pFileData.is_null() {
        debug(LOG_ERROR,
              b"writeTerrainTypeMapFile: Out of memory\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    // Put the file header on the file
    psHeader = pFileData as *mut TILETYPE_SAVEHEADER;
    (*psHeader).aFileType[0 as libc::c_int as usize] = 't' as i32 as STRING;
    (*psHeader).aFileType[1 as libc::c_int as usize] = 't' as i32 as STRING;
    (*psHeader).aFileType[2 as libc::c_int as usize] = 'y' as i32 as STRING;
    (*psHeader).aFileType[3 as libc::c_int as usize] = 'p' as i32 as STRING;
    (*psHeader).version = 33 as libc::c_int as UDWORD;
    (*psHeader).quantity = 255 as libc::c_int as UDWORD;
    pType = pFileData.offset(12 as libc::c_int as isize) as *mut UWORD;
    i = 0 as libc::c_int as UDWORD;
    while i < 255 as libc::c_int as libc::c_uint {
        *pType = terrainTypes[i as usize] as UWORD;
        endian_uword(pType);
        pType = pType.offset(1 as libc::c_int as isize);
        i = i.wrapping_add(1)
    }
    /* TILETYPE_SAVEHEADER */
    endian_udword(&mut (*psHeader).version);
    endian_udword(&mut (*psHeader).quantity);
    if saveFile(pFileName, pFileData, fileSize) == 0 {
        return 0 as libc::c_int
    }
    memFreeRelease(pFileData as *mut libc::c_void);
    pFileData = 0 as *mut libc::c_char;
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
// load up component list file
unsafe extern "C" fn loadSaveCompList(mut pFileData: *mut libc::c_char,
                                      mut filesize: UDWORD) -> BOOL {
    let mut psHeader: *mut COMPLIST_SAVEHEADER =
        0 as *mut COMPLIST_SAVEHEADER;
    /* Check the file type */
    psHeader = pFileData as *mut COMPLIST_SAVEHEADER;
    if (*psHeader).aFileType[0 as libc::c_int as usize] as libc::c_int !=
           'c' as i32 ||
           (*psHeader).aFileType[1 as libc::c_int as usize] as libc::c_int !=
               'm' as i32 ||
           (*psHeader).aFileType[2 as libc::c_int as usize] as libc::c_int !=
               'p' as i32 ||
           (*psHeader).aFileType[3 as libc::c_int as usize] as libc::c_int !=
               'l' as i32 {
        debug(LOG_ERROR,
              b"loadSaveCompList: Incorrect file type\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    /* COMPLIST_SAVEHEADER */
    endian_udword(&mut (*psHeader).version);
    endian_udword(&mut (*psHeader).quantity);
    //increment to the start of the data
    pFileData = pFileData.offset(12 as libc::c_int as isize);
    /* Check the file version */
    if (*psHeader).version < 7 as libc::c_int as libc::c_uint {
        debug(LOG_ERROR,
              b"CompLoad: unsupported save format version %d\x00" as *const u8
                  as *const libc::c_char, (*psHeader).version);
        abort();
    } else {
        if (*psHeader).version <= 19 as libc::c_int as libc::c_uint {
            if loadSaveCompListV9(pFileData, filesize, (*psHeader).quantity,
                                  (*psHeader).version) == 0 {
                return 0 as libc::c_int
            }
        } else if (*psHeader).version <= 33 as libc::c_int as libc::c_uint {
            if loadSaveCompListV(pFileData, filesize, (*psHeader).quantity,
                                 (*psHeader).version) == 0 {
                return 0 as libc::c_int
            }
        } else {
            debug(LOG_ERROR,
                  b"CompLoad: undefined save format version %d\x00" as
                      *const u8 as *const libc::c_char, (*psHeader).version);
            abort();
        }
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
unsafe extern "C" fn loadSaveCompListV9(mut pFileData: *mut libc::c_char,
                                        mut filesize: UDWORD,
                                        mut numRecords: UDWORD,
                                        mut version: UDWORD) -> BOOL {
    let mut psSaveCompList: *mut SAVE_COMPLIST_V6 =
        0 as *mut SAVE_COMPLIST_V6;
    let mut i: UDWORD = 0;
    let mut compInc: SDWORD = 0;
    if (::std::mem::size_of::<SAVE_COMPLIST_V6>() as
            libc::c_ulong).wrapping_mul(numRecords).wrapping_add(12 as
                                                                     libc::c_int
                                                                     as
                                                                     libc::c_uint)
           > filesize {
        debug(LOG_ERROR,
              b"CompListLoad: unexpected end of file\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    let mut current_block_11: u64;
    // Load the data
    i = 0 as libc::c_int as UDWORD;
    while i < numRecords {
        psSaveCompList = pFileData as *mut SAVE_COMPLIST_V6;
        if version < 9 as libc::c_int as libc::c_uint {
            //DROID_MAXCOMP has changed to remove COMP_PROGRAM so hack here to load old save games!
            if (*psSaveCompList).type_0 as libc::c_int == 8 as libc::c_int {
                //ignore this record
                current_block_11 = 6483416627284290920;
            } else {
                if (*psSaveCompList).type_0 as libc::c_int == 9 as libc::c_int
                   {
                    //this typeNum has to be reset for lack of COMP_PROGRAM
                    (*psSaveCompList).type_0 =
                        COMP_WEAPON as libc::c_int as UBYTE
                }
                current_block_11 = 12349973810996921269;
            }
        } else { current_block_11 = 12349973810996921269; }
        match current_block_11 {
            12349973810996921269 => {
                if !((*psSaveCompList).type_0 as libc::c_int >
                         COMP_NUMCOMPONENTS as libc::c_int) {
                    compInc =
                        getCompFromName((*psSaveCompList).type_0 as UDWORD,
                                        (*psSaveCompList).name.as_mut_ptr());
                    if !(compInc < 0 as libc::c_int) {
                        if !((*psSaveCompList).state as libc::c_int !=
                                 0x2 as libc::c_int &&
                                 (*psSaveCompList).state as libc::c_int !=
                                     0x1 as libc::c_int &&
                                 (*psSaveCompList).state as libc::c_int !=
                                     0x4 as libc::c_int) {
                            if !((*psSaveCompList).player as libc::c_int >
                                     8 as libc::c_int) {
                                //date is valid so set the state
                                *apCompLists[(*psSaveCompList).player as
                                                 usize][(*psSaveCompList).type_0
                                                            as
                                                            usize].offset(compInc
                                                                              as
                                                                              isize)
                                    = (*psSaveCompList).state
                            }
                        }
                    }
                }
            }
            _ => { }
        }
        //ignore this record
        i = i.wrapping_add(1);
        pFileData =
            pFileData.offset(::std::mem::size_of::<SAVE_COMPLIST_V6>() as
                                 libc::c_ulong as isize)
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
unsafe extern "C" fn loadSaveCompListV(mut pFileData: *mut libc::c_char,
                                       mut filesize: UDWORD,
                                       mut numRecords: UDWORD,
                                       mut version: UDWORD) -> BOOL {
    let mut psSaveCompList: *mut SAVE_COMPLIST = 0 as *mut SAVE_COMPLIST;
    let mut i: UDWORD = 0;
    let mut compInc: SDWORD = 0;
    //	version;
    if (::std::mem::size_of::<SAVE_COMPLIST>() as
            libc::c_ulong).wrapping_mul(numRecords).wrapping_add(12 as
                                                                     libc::c_int
                                                                     as
                                                                     libc::c_uint)
           > filesize {
        debug(LOG_ERROR,
              b"CompListLoad: unexpected end of file\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    // Load the data
    i = 0 as libc::c_int as UDWORD;
    while i < numRecords {
        psSaveCompList = pFileData as *mut SAVE_COMPLIST;
        if !((*psSaveCompList).type_0 as libc::c_int >
                 COMP_NUMCOMPONENTS as libc::c_int) {
            compInc =
                getCompFromName((*psSaveCompList).type_0 as UDWORD,
                                (*psSaveCompList).name.as_mut_ptr());
            if !(compInc < 0 as libc::c_int) {
                if !((*psSaveCompList).state as libc::c_int !=
                         0x2 as libc::c_int &&
                         (*psSaveCompList).state as libc::c_int !=
                             0x1 as libc::c_int &&
                         (*psSaveCompList).state as libc::c_int !=
                             0x4 as libc::c_int) {
                    if !((*psSaveCompList).player as libc::c_int >
                             8 as libc::c_int) {
                        //date is valid so set the state
                        *apCompLists[(*psSaveCompList).player as
                                         usize][(*psSaveCompList).type_0 as
                                                    usize].offset(compInc as
                                                                      isize) =
                            (*psSaveCompList).state
                    }
                }
            }
        }
        //ignore this record
        i = i.wrapping_add(1);
        pFileData =
            pFileData.offset(::std::mem::size_of::<SAVE_COMPLIST>() as
                                 libc::c_ulong as isize)
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
// Write out the current state of the Comp lists per player
unsafe extern "C" fn writeCompListFile(mut pFileName: *mut STRING) -> BOOL {
    let mut psHeader: *mut COMPLIST_SAVEHEADER =
        0 as *mut COMPLIST_SAVEHEADER;
    let mut pFileData: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut psSaveCompList: *mut SAVE_COMPLIST = 0 as *mut SAVE_COMPLIST;
    let mut fileSize: UDWORD = 0;
    let mut totalComp: UDWORD = 0;
    let mut player: UDWORD = 0;
    let mut i: UDWORD = 0;
    let mut psStats: *mut COMP_BASE_STATS = 0 as *mut COMP_BASE_STATS;
    // Calculate the file size
    totalComp =
        numBodyStats.wrapping_add(numWeaponStats).wrapping_add(numConstructStats).wrapping_add(numECMStats).wrapping_add(numPropulsionStats).wrapping_add(numSensorStats).wrapping_add(numRepairStats).wrapping_add(numBrainStats).wrapping_add(numProgramStats).wrapping_mul(8
                                                                                                                                                                                                                                                                                  as
                                                                                                                                                                                                                                                                                  libc::c_int
                                                                                                                                                                                                                                                                                  as
                                                                                                                                                                                                                                                                                  libc::c_uint);
    fileSize =
        (12 as libc::c_int as
             libc::c_uint).wrapping_add((::std::mem::size_of::<SAVE_COMPLIST>()
                                             as
                                             libc::c_ulong).wrapping_mul(totalComp));
    //allocate the buffer space
    pFileData = memMallocRelease(fileSize) as *mut libc::c_char;
    if pFileData.is_null() {
        debug(LOG_ERROR,
              b"writeCompListFile: Out of memory\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    // Put the file header on the file
    psHeader = pFileData as *mut COMPLIST_SAVEHEADER;
    (*psHeader).aFileType[0 as libc::c_int as usize] = 'c' as i32 as STRING;
    (*psHeader).aFileType[1 as libc::c_int as usize] = 'm' as i32 as STRING;
    (*psHeader).aFileType[2 as libc::c_int as usize] = 'p' as i32 as STRING;
    (*psHeader).aFileType[3 as libc::c_int as usize] = 'l' as i32 as STRING;
    (*psHeader).version = 33 as libc::c_int as UDWORD;
    (*psHeader).quantity = totalComp;
    psSaveCompList =
        pFileData.offset(12 as libc::c_int as isize) as *mut SAVE_COMPLIST;
    //save each type of comp
    player = 0 as libc::c_int as UDWORD;
    while player < 8 as libc::c_int as libc::c_uint {
        i = 0 as libc::c_int as UDWORD;
        while i < numBodyStats {
            psStats = asBodyStats.offset(i as isize) as *mut COMP_BASE_STATS;
            strcpy((*psSaveCompList).name.as_mut_ptr(), (*psStats).pName);
            (*psSaveCompList).type_0 = COMP_BODY as libc::c_int as UBYTE;
            (*psSaveCompList).player = player as UBYTE;
            (*psSaveCompList).state =
                *apCompLists[player as
                                 usize][COMP_BODY as libc::c_int as
                                            usize].offset(i as isize);
            psSaveCompList =
                (psSaveCompList as
                     *mut libc::c_char).offset(::std::mem::size_of::<SAVE_COMPLIST>()
                                                   as libc::c_ulong as isize)
                    as *mut SAVE_COMPLIST;
            i = i.wrapping_add(1)
        }
        i = 0 as libc::c_int as UDWORD;
        while i < numWeaponStats {
            psStats =
                asWeaponStats.offset(i as isize) as *mut COMP_BASE_STATS;
            strcpy((*psSaveCompList).name.as_mut_ptr(), (*psStats).pName);
            (*psSaveCompList).type_0 = COMP_WEAPON as libc::c_int as UBYTE;
            (*psSaveCompList).player = player as UBYTE;
            (*psSaveCompList).state =
                *apCompLists[player as
                                 usize][COMP_WEAPON as libc::c_int as
                                            usize].offset(i as isize);
            psSaveCompList =
                (psSaveCompList as
                     *mut libc::c_char).offset(::std::mem::size_of::<SAVE_COMPLIST>()
                                                   as libc::c_ulong as isize)
                    as *mut SAVE_COMPLIST;
            i = i.wrapping_add(1)
        }
        i = 0 as libc::c_int as UDWORD;
        while i < numConstructStats {
            psStats =
                asConstructStats.offset(i as isize) as *mut COMP_BASE_STATS;
            strcpy((*psSaveCompList).name.as_mut_ptr(), (*psStats).pName);
            (*psSaveCompList).type_0 = COMP_CONSTRUCT as libc::c_int as UBYTE;
            (*psSaveCompList).player = player as UBYTE;
            (*psSaveCompList).state =
                *apCompLists[player as
                                 usize][COMP_CONSTRUCT as libc::c_int as
                                            usize].offset(i as isize);
            psSaveCompList =
                (psSaveCompList as
                     *mut libc::c_char).offset(::std::mem::size_of::<SAVE_COMPLIST>()
                                                   as libc::c_ulong as isize)
                    as *mut SAVE_COMPLIST;
            i = i.wrapping_add(1)
        }
        i = 0 as libc::c_int as UDWORD;
        while i < numECMStats {
            psStats = asECMStats.offset(i as isize) as *mut COMP_BASE_STATS;
            strcpy((*psSaveCompList).name.as_mut_ptr(), (*psStats).pName);
            (*psSaveCompList).type_0 = COMP_ECM as libc::c_int as UBYTE;
            (*psSaveCompList).player = player as UBYTE;
            (*psSaveCompList).state =
                *apCompLists[player as
                                 usize][COMP_ECM as libc::c_int as
                                            usize].offset(i as isize);
            psSaveCompList =
                (psSaveCompList as
                     *mut libc::c_char).offset(::std::mem::size_of::<SAVE_COMPLIST>()
                                                   as libc::c_ulong as isize)
                    as *mut SAVE_COMPLIST;
            i = i.wrapping_add(1)
        }
        i = 0 as libc::c_int as UDWORD;
        while i < numPropulsionStats {
            psStats =
                asPropulsionStats.offset(i as isize) as *mut COMP_BASE_STATS;
            strcpy((*psSaveCompList).name.as_mut_ptr(), (*psStats).pName);
            (*psSaveCompList).type_0 =
                COMP_PROPULSION as libc::c_int as UBYTE;
            (*psSaveCompList).player = player as UBYTE;
            (*psSaveCompList).state =
                *apCompLists[player as
                                 usize][COMP_PROPULSION as libc::c_int as
                                            usize].offset(i as isize);
            psSaveCompList =
                (psSaveCompList as
                     *mut libc::c_char).offset(::std::mem::size_of::<SAVE_COMPLIST>()
                                                   as libc::c_ulong as isize)
                    as *mut SAVE_COMPLIST;
            i = i.wrapping_add(1)
        }
        i = 0 as libc::c_int as UDWORD;
        while i < numSensorStats {
            psStats =
                asSensorStats.offset(i as isize) as *mut COMP_BASE_STATS;
            strcpy((*psSaveCompList).name.as_mut_ptr(), (*psStats).pName);
            (*psSaveCompList).type_0 = COMP_SENSOR as libc::c_int as UBYTE;
            (*psSaveCompList).player = player as UBYTE;
            (*psSaveCompList).state =
                *apCompLists[player as
                                 usize][COMP_SENSOR as libc::c_int as
                                            usize].offset(i as isize);
            psSaveCompList =
                (psSaveCompList as
                     *mut libc::c_char).offset(::std::mem::size_of::<SAVE_COMPLIST>()
                                                   as libc::c_ulong as isize)
                    as *mut SAVE_COMPLIST;
            i = i.wrapping_add(1)
        }
        i = 0 as libc::c_int as UDWORD;
        while i < numRepairStats {
            psStats =
                asRepairStats.offset(i as isize) as *mut COMP_BASE_STATS;
            strcpy((*psSaveCompList).name.as_mut_ptr(), (*psStats).pName);
            (*psSaveCompList).type_0 =
                COMP_REPAIRUNIT as libc::c_int as UBYTE;
            (*psSaveCompList).player = player as UBYTE;
            (*psSaveCompList).state =
                *apCompLists[player as
                                 usize][COMP_REPAIRUNIT as libc::c_int as
                                            usize].offset(i as isize);
            psSaveCompList =
                (psSaveCompList as
                     *mut libc::c_char).offset(::std::mem::size_of::<SAVE_COMPLIST>()
                                                   as libc::c_ulong as isize)
                    as *mut SAVE_COMPLIST;
            i = i.wrapping_add(1)
        }
        i = 0 as libc::c_int as UDWORD;
        while i < numBrainStats {
            psStats = asBrainStats.offset(i as isize) as *mut COMP_BASE_STATS;
            strcpy((*psSaveCompList).name.as_mut_ptr(), (*psStats).pName);
            (*psSaveCompList).type_0 = COMP_BRAIN as libc::c_int as UBYTE;
            (*psSaveCompList).player = player as UBYTE;
            (*psSaveCompList).state =
                *apCompLists[player as
                                 usize][COMP_BRAIN as libc::c_int as
                                            usize].offset(i as isize);
            psSaveCompList =
                (psSaveCompList as
                     *mut libc::c_char).offset(::std::mem::size_of::<SAVE_COMPLIST>()
                                                   as libc::c_ulong as isize)
                    as *mut SAVE_COMPLIST;
            i = i.wrapping_add(1)
        }
        player = player.wrapping_add(1)
        /*for(i = 0; i < numProgramStats; i++)
		{
			psStats = (COMP_BASE_STATS *)(asProgramStats + i);
#ifdef HASH_NAMES
			psSaveCompList->NameHash=psStats->NameHash;
#else
			strcpy(psSaveCompList->name, psStats->pName);
#endif
			psSaveCompList->type = COMP_PROGRAM;
			psSaveCompList->player = (UBYTE)player;
			psSaveCompList->state = apCompLists[player][COMP_PROGRAM][i];
			psSaveCompList = (SAVE_COMPLIST *)((char *)psSaveCompList + sizeof(SAVE_COMPLIST));
		}*/
    }
    /* COMPLIST_SAVEHEADER */
    endian_udword(&mut (*psHeader).version);
    endian_udword(&mut (*psHeader).quantity);
    if saveFile(pFileName, pFileData, fileSize) == 0 {
        return 0 as libc::c_int
    }
    memFreeRelease(pFileData as *mut libc::c_void);
    pFileData = 0 as *mut libc::c_char;
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
// load up structure type list file
unsafe extern "C" fn loadSaveStructTypeList(mut pFileData: *mut libc::c_char,
                                            mut filesize: UDWORD) -> BOOL {
    let mut psHeader: *mut STRUCTLIST_SAVEHEADER =
        0 as *mut STRUCTLIST_SAVEHEADER;
    /* Check the file type */
    psHeader = pFileData as *mut STRUCTLIST_SAVEHEADER;
    if (*psHeader).aFileType[0 as libc::c_int as usize] as libc::c_int !=
           's' as i32 ||
           (*psHeader).aFileType[1 as libc::c_int as usize] as libc::c_int !=
               't' as i32 ||
           (*psHeader).aFileType[2 as libc::c_int as usize] as libc::c_int !=
               'r' as i32 ||
           (*psHeader).aFileType[3 as libc::c_int as usize] as libc::c_int !=
               'l' as i32 {
        debug(LOG_ERROR,
              b"loadSaveStructTypeList: Incorrect file type\x00" as *const u8
                  as *const libc::c_char);
        abort();
    }
    /* STRUCTLIST_SAVEHEADER */
    endian_udword(&mut (*psHeader).version);
    endian_udword(&mut (*psHeader).quantity);
    //increment to the start of the data
    pFileData = pFileData.offset(12 as libc::c_int as isize);
    /* Check the file version */
    if (*psHeader).version < 7 as libc::c_int as libc::c_uint {
        debug(LOG_ERROR,
              b"StructTypeLoad: unsupported save format version %d\x00" as
                  *const u8 as *const libc::c_char, (*psHeader).version);
        abort();
    } else {
        if (*psHeader).version <= 19 as libc::c_int as libc::c_uint {
            if loadSaveStructTypeListV7(pFileData, filesize,
                                        (*psHeader).quantity) == 0 {
                return 0 as libc::c_int
            }
        } else if (*psHeader).version <= 33 as libc::c_int as libc::c_uint {
            if loadSaveStructTypeListV(pFileData, filesize,
                                       (*psHeader).quantity) == 0 {
                return 0 as libc::c_int
            }
        } else {
            debug(LOG_ERROR,
                  b"StructTypeLoad: undefined save format version %d\x00" as
                      *const u8 as *const libc::c_char, (*psHeader).version);
            abort();
        }
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
unsafe extern "C" fn loadSaveStructTypeListV7(mut pFileData:
                                                  *mut libc::c_char,
                                              mut filesize: UDWORD,
                                              mut numRecords: UDWORD)
 -> BOOL {
    let mut psSaveStructList: *mut SAVE_STRUCTLIST_V6 =
        0 as *mut SAVE_STRUCTLIST_V6;
    let mut i: UDWORD = 0;
    let mut statInc: UDWORD = 0;
    let mut psStats: *mut STRUCTURE_STATS = 0 as *mut STRUCTURE_STATS;
    let mut found: BOOL = 0;
    if (::std::mem::size_of::<SAVE_STRUCTLIST_V6>() as
            libc::c_ulong).wrapping_mul(numRecords).wrapping_add(12 as
                                                                     libc::c_int
                                                                     as
                                                                     libc::c_uint)
           > filesize {
        debug(LOG_ERROR,
              b"StructListLoad: unexpected end of file\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    // Load the data
    i = 0 as libc::c_int as UDWORD;
    while i < numRecords {
        psSaveStructList = pFileData as *mut SAVE_STRUCTLIST_V6;
        found = 0 as libc::c_int;
        statInc = 0 as libc::c_int as UDWORD;
        while statInc < numStructureStats {
            psStats = asStructureStats.offset(statInc as isize);
            //loop until find the same name
            if strcmp((*psStats).pName, (*psSaveStructList).name.as_mut_ptr())
                   == 0 {
                found = 1 as libc::c_int;
                break ;
            } else { statInc = statInc.wrapping_add(1) }
        }
        if !(found == 0) {
            if !((*psSaveStructList).state as libc::c_int !=
                     0x2 as libc::c_int &&
                     (*psSaveStructList).state as libc::c_int !=
                         0x1 as libc::c_int &&
                     (*psSaveStructList).state as libc::c_int !=
                         0x4 as libc::c_int) {
                if !((*psSaveStructList).player as libc::c_int >
                         8 as libc::c_int) {
                    //date is valid so set the state
                    *apStructTypeLists[(*psSaveStructList).player as
                                           usize].offset(statInc as isize) =
                        (*psSaveStructList).state
                }
            }
        }
        //ignore this record
        i = i.wrapping_add(1);
        pFileData =
            pFileData.offset(::std::mem::size_of::<SAVE_STRUCTLIST_V6>() as
                                 libc::c_ulong as isize)
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
unsafe extern "C" fn loadSaveStructTypeListV(mut pFileData: *mut libc::c_char,
                                             mut filesize: UDWORD,
                                             mut numRecords: UDWORD) -> BOOL {
    let mut psSaveStructList: *mut SAVE_STRUCTLIST =
        0 as *mut SAVE_STRUCTLIST;
    let mut i: UDWORD = 0;
    let mut statInc: UDWORD = 0;
    let mut psStats: *mut STRUCTURE_STATS = 0 as *mut STRUCTURE_STATS;
    let mut found: BOOL = 0;
    if (::std::mem::size_of::<SAVE_STRUCTLIST>() as
            libc::c_ulong).wrapping_mul(numRecords).wrapping_add(12 as
                                                                     libc::c_int
                                                                     as
                                                                     libc::c_uint)
           > filesize {
        debug(LOG_ERROR,
              b"StructListLoad: unexpected end of file\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    // Load the data
    i = 0 as libc::c_int as UDWORD;
    while i < numRecords {
        psSaveStructList = pFileData as *mut SAVE_STRUCTLIST;
        found = 0 as libc::c_int;
        statInc = 0 as libc::c_int as UDWORD;
        while statInc < numStructureStats {
            psStats = asStructureStats.offset(statInc as isize);
            //loop until find the same name
            if strcmp((*psStats).pName, (*psSaveStructList).name.as_mut_ptr())
                   == 0 {
                found = 1 as libc::c_int;
                break ;
            } else { statInc = statInc.wrapping_add(1) }
        }
        if !(found == 0) {
            if !((*psSaveStructList).state as libc::c_int !=
                     0x2 as libc::c_int &&
                     (*psSaveStructList).state as libc::c_int !=
                         0x1 as libc::c_int &&
                     (*psSaveStructList).state as libc::c_int !=
                         0x4 as libc::c_int) {
                if !((*psSaveStructList).player as libc::c_int >
                         8 as libc::c_int) {
                    //date is valid so set the state
                    *apStructTypeLists[(*psSaveStructList).player as
                                           usize].offset(statInc as isize) =
                        (*psSaveStructList).state
                }
            }
        }
        //ignore this record
        i = i.wrapping_add(1);
        pFileData =
            pFileData.offset(::std::mem::size_of::<SAVE_STRUCTLIST>() as
                                 libc::c_ulong as isize)
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
// Write out the current state of the Struct Type List per player
unsafe extern "C" fn writeStructTypeListFile(mut pFileName: *mut STRING)
 -> BOOL {
    let mut psHeader: *mut STRUCTLIST_SAVEHEADER =
        0 as *mut STRUCTLIST_SAVEHEADER;
    let mut psSaveStructList: *mut SAVE_STRUCTLIST =
        0 as *mut SAVE_STRUCTLIST;
    let mut pFileData: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut fileSize: UDWORD = 0;
    let mut player: UDWORD = 0;
    let mut i: UDWORD = 0;
    let mut psStats: *mut STRUCTURE_STATS = 0 as *mut STRUCTURE_STATS;
    // Calculate the file size
    fileSize =
        (12 as libc::c_int as
             libc::c_uint).wrapping_add((::std::mem::size_of::<SAVE_STRUCTLIST>()
                                             as
                                             libc::c_ulong).wrapping_mul(numStructureStats).wrapping_mul(8
                                                                                                             as
                                                                                                             libc::c_int
                                                                                                             as
                                                                                                             libc::c_uint));
    //allocate the buffer space
    pFileData = memMallocRelease(fileSize) as *mut libc::c_char;
    if pFileData.is_null() {
        debug(LOG_ERROR,
              b"writeStructTypeListFile: Out of memory\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    // Put the file header on the file
    psHeader = pFileData as *mut STRUCTLIST_SAVEHEADER;
    (*psHeader).aFileType[0 as libc::c_int as usize] = 's' as i32 as STRING;
    (*psHeader).aFileType[1 as libc::c_int as usize] = 't' as i32 as STRING;
    (*psHeader).aFileType[2 as libc::c_int as usize] = 'r' as i32 as STRING;
    (*psHeader).aFileType[3 as libc::c_int as usize] = 'l' as i32 as STRING;
    (*psHeader).version = 33 as libc::c_int as UDWORD;
    (*psHeader).quantity =
        numStructureStats.wrapping_mul(8 as libc::c_int as libc::c_uint);
    psSaveStructList =
        pFileData.offset(12 as libc::c_int as isize) as *mut SAVE_STRUCTLIST;
    //save each type of struct type
    player = 0 as libc::c_int as UDWORD;
    while player < 8 as libc::c_int as libc::c_uint {
        psStats = asStructureStats;
        i = 0 as libc::c_int as UDWORD;
        while i < numStructureStats {
            strcpy((*psSaveStructList).name.as_mut_ptr(), (*psStats).pName);
            (*psSaveStructList).state =
                *apStructTypeLists[player as usize].offset(i as isize);
            (*psSaveStructList).player = player as UBYTE;
            psSaveStructList =
                (psSaveStructList as
                     *mut libc::c_char).offset(::std::mem::size_of::<SAVE_STRUCTLIST>()
                                                   as libc::c_ulong as isize)
                    as *mut SAVE_STRUCTLIST;
            i = i.wrapping_add(1);
            psStats = psStats.offset(1)
        }
        player = player.wrapping_add(1)
    }
    /* STRUCT_SAVEHEADER */
    endian_udword(&mut (*psHeader).version);
    endian_udword(&mut (*psHeader).quantity);
    if saveFile(pFileName, pFileData, fileSize) == 0 {
        return 0 as libc::c_int
    }
    memFreeRelease(pFileData as *mut libc::c_void);
    pFileData = 0 as *mut libc::c_char;
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
// load up saved research file
unsafe extern "C" fn loadSaveResearch(mut pFileData: *mut libc::c_char,
                                      mut filesize: UDWORD) -> BOOL {
    let mut psHeader: *mut RESEARCH_SAVEHEADER =
        0 as *mut RESEARCH_SAVEHEADER;
    /* Check the file type */
    psHeader = pFileData as *mut RESEARCH_SAVEHEADER;
    if (*psHeader).aFileType[0 as libc::c_int as usize] as libc::c_int !=
           'r' as i32 ||
           (*psHeader).aFileType[1 as libc::c_int as usize] as libc::c_int !=
               'e' as i32 ||
           (*psHeader).aFileType[2 as libc::c_int as usize] as libc::c_int !=
               's' as i32 ||
           (*psHeader).aFileType[3 as libc::c_int as usize] as libc::c_int !=
               'h' as i32 {
        debug(LOG_ERROR,
              b"loadSaveResearch: Incorrect file type\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    /* RESEARCH_SAVEHEADER */
    endian_udword(&mut (*psHeader).version);
    endian_udword(&mut (*psHeader).quantity);
    //increment to the start of the data
    pFileData = pFileData.offset(12 as libc::c_int as isize);
    /* Check the file version */
    if (*psHeader).version < 8 as libc::c_int as libc::c_uint {
        debug(LOG_ERROR,
              b"ResearchLoad: unsupported save format version %d\x00" as
                  *const u8 as *const libc::c_char, (*psHeader).version);
        abort();
    } else {
        if (*psHeader).version <= 19 as libc::c_int as libc::c_uint {
            if loadSaveResearchV8(pFileData, filesize, (*psHeader).quantity)
                   == 0 {
                return 0 as libc::c_int
            }
        } else if (*psHeader).version <= 33 as libc::c_int as libc::c_uint {
            if loadSaveResearchV(pFileData, filesize, (*psHeader).quantity) ==
                   0 {
                return 0 as libc::c_int
            }
        } else {
            debug(LOG_ERROR,
                  b"ResearchLoad: undefined save format version %d\x00" as
                      *const u8 as *const libc::c_char, (*psHeader).version);
            abort();
        }
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
unsafe extern "C" fn loadSaveResearchV8(mut pFileData: *mut libc::c_char,
                                        mut filesize: UDWORD,
                                        mut numRecords: UDWORD) -> BOOL {
    let mut psSaveResearch: *mut SAVE_RESEARCH_V8 =
        0 as *mut SAVE_RESEARCH_V8;
    let mut i: UDWORD = 0;
    let mut statInc: UDWORD = 0;
    let mut psStats: *mut RESEARCH = 0 as *mut RESEARCH;
    let mut found: BOOL = 0;
    let mut playerInc: UBYTE = 0;
    if (::std::mem::size_of::<SAVE_RESEARCH_V8>() as
            libc::c_ulong).wrapping_mul(numRecords).wrapping_add(12 as
                                                                     libc::c_int
                                                                     as
                                                                     libc::c_uint)
           > filesize {
        debug(LOG_ERROR,
              b"loadSaveResearch: unexpected end of file\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    // Load the data
    i = 0 as libc::c_int as UDWORD;
    while i < numRecords {
        psSaveResearch = pFileData as *mut SAVE_RESEARCH_V8;
        /* SAVE_RESEARCH_V8 is RESEARCH_SAVE_V8 */
		/* RESEARCH_SAVE_V8 */
        playerInc = 0 as libc::c_int as UBYTE;
        while (playerInc as libc::c_int) < 8 as libc::c_int {
            endian_udword(&mut *(*psSaveResearch).currentPoints.as_mut_ptr().offset(playerInc
                                                                                        as
                                                                                        isize));
            playerInc = playerInc.wrapping_add(1)
        }
        found = 0 as libc::c_int;
        statInc = 0 as libc::c_int as UDWORD;
        while statInc < numResearch {
            psStats = asResearch.offset(statInc as isize);
            //loop until find the same name
            if strcmp((*psStats).pName, (*psSaveResearch).name.as_mut_ptr())
                   == 0 {
                found = 1 as libc::c_int;
                break ;
            } else { statInc = statInc.wrapping_add(1) }
        }
        if !(found == 0) {
            playerInc = 0 as libc::c_int as UBYTE;
            while (playerInc as libc::c_int) < 8 as libc::c_int {
                /* what did this do then ?
			if (psSaveResearch->researched[playerInc] != 0 AND
				psSaveResearch->researched[playerInc] != STARTED_RESEARCH AND
				psSaveResearch->researched[playerInc] != CANCELLED_RESEARCH AND
				psSaveResearch->researched[playerInc] != RESEARCHED)
			{
				//ignore this record
				continue; //to next player
			}
*/
                let mut psPlRes: *mut PLAYER_RESEARCH =
                    0 as *mut PLAYER_RESEARCH;
                psPlRes =
                    &mut *(*asPlayerResList.as_mut_ptr().offset(playerInc as
                                                                    isize)).offset(statInc
                                                                                       as
                                                                                       isize)
                        as *mut PLAYER_RESEARCH;
                // Copy the research status
                (*psPlRes).ResearchStatus =
                    ((*psSaveResearch).researched[playerInc as usize] as
                         libc::c_int &
                         (0x1 as libc::c_int | 0x2 as libc::c_int |
                              0x4 as libc::c_int)) as UBYTE;
                if (*psSaveResearch).possible[playerInc as usize] as
                       libc::c_int != 0 as libc::c_int {
                    (*psPlRes).ResearchStatus =
                        ((*psPlRes).ResearchStatus as libc::c_int |
                             0x80 as libc::c_int) as UBYTE
                }
                (*psPlRes).currentPoints =
                    (*psSaveResearch).currentPoints[playerInc as usize];
                //for any research that has been completed - perform so that upgrade values are set up
                if (*psSaveResearch).researched[playerInc as usize] as
                       libc::c_int == 0x4 as libc::c_int {
                    researchResult(statInc, playerInc, 0 as libc::c_int);
                }
                playerInc = playerInc.wrapping_add(1)
            }
        }
        //ignore this record
        i = i.wrapping_add(1);
        pFileData =
            pFileData.offset(::std::mem::size_of::<SAVE_RESEARCH_V8>() as
                                 libc::c_ulong as isize)
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
unsafe extern "C" fn loadSaveResearchV(mut pFileData: *mut libc::c_char,
                                       mut filesize: UDWORD,
                                       mut numRecords: UDWORD) -> BOOL {
    let mut psSaveResearch: *mut SAVE_RESEARCH = 0 as *mut SAVE_RESEARCH;
    let mut i: UDWORD = 0;
    let mut statInc: UDWORD = 0;
    let mut psStats: *mut RESEARCH = 0 as *mut RESEARCH;
    let mut found: BOOL = 0;
    let mut playerInc: UBYTE = 0;
    if (::std::mem::size_of::<SAVE_RESEARCH>() as
            libc::c_ulong).wrapping_mul(numRecords).wrapping_add(12 as
                                                                     libc::c_int
                                                                     as
                                                                     libc::c_uint)
           > filesize {
        debug(LOG_ERROR,
              b"loadSaveResearch: unexpected end of file\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    // Load the data
    i = 0 as libc::c_int as UDWORD;
    while i < numRecords {
        psSaveResearch = pFileData as *mut SAVE_RESEARCH;
        /* SAVE_RESEARCH is RESEARCH_SAVE_V20 */
		/* RESEARCH_SAVE_V20 */
        playerInc = 0 as libc::c_int as UBYTE;
        while (playerInc as libc::c_int) < 8 as libc::c_int {
            endian_udword(&mut *(*psSaveResearch).currentPoints.as_mut_ptr().offset(playerInc
                                                                                        as
                                                                                        isize));
            playerInc = playerInc.wrapping_add(1)
        }
        found = 0 as libc::c_int;
        statInc = 0 as libc::c_int as UDWORD;
        while statInc < numResearch {
            psStats = asResearch.offset(statInc as isize);
            //loop until find the same name
            if strcmp((*psStats).pName, (*psSaveResearch).name.as_mut_ptr())
                   == 0 {
                found = 1 as libc::c_int;
                break ;
            } else { statInc = statInc.wrapping_add(1) }
        }
        if !(found == 0) {
            playerInc = 0 as libc::c_int as UBYTE;
            while (playerInc as libc::c_int) < 8 as libc::c_int {
                let mut psPlRes: *mut PLAYER_RESEARCH =
                    0 as *mut PLAYER_RESEARCH;
                psPlRes =
                    &mut *(*asPlayerResList.as_mut_ptr().offset(playerInc as
                                                                    isize)).offset(statInc
                                                                                       as
                                                                                       isize)
                        as *mut PLAYER_RESEARCH;
                // Copy the research status
                (*psPlRes).ResearchStatus =
                    ((*psSaveResearch).researched[playerInc as usize] as
                         libc::c_int &
                         (0x1 as libc::c_int | 0x2 as libc::c_int |
                              0x4 as libc::c_int)) as UBYTE;
                if (*psSaveResearch).possible[playerInc as usize] as
                       libc::c_int != 0 as libc::c_int {
                    (*psPlRes).ResearchStatus =
                        ((*psPlRes).ResearchStatus as libc::c_int |
                             0x80 as libc::c_int) as UBYTE
                }
                (*psPlRes).currentPoints =
                    (*psSaveResearch).currentPoints[playerInc as usize];
                //for any research that has been completed - perform so that upgrade values are set up
                if (*psSaveResearch).researched[playerInc as usize] as
                       libc::c_int == 0x4 as libc::c_int {
                    researchResult(statInc, playerInc, 0 as libc::c_int);
                }
                playerInc = playerInc.wrapping_add(1)
            }
        }
        //ignore this record
        i = i.wrapping_add(1);
        pFileData =
            pFileData.offset(::std::mem::size_of::<SAVE_RESEARCH>() as
                                 libc::c_ulong as isize)
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
// Write out the current state of the Research per player
unsafe extern "C" fn writeResearchFile(mut pFileName: *mut STRING) -> BOOL {
    let mut psHeader: *mut RESEARCH_SAVEHEADER =
        0 as *mut RESEARCH_SAVEHEADER;
    let mut psSaveResearch: *mut SAVE_RESEARCH = 0 as *mut SAVE_RESEARCH;
    let mut pFileData: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut fileSize: UDWORD = 0;
    let mut player: UDWORD = 0;
    let mut i: UDWORD = 0;
    let mut psStats: *mut RESEARCH = 0 as *mut RESEARCH;
    // Calculate the file size
    fileSize =
        (12 as libc::c_int as
             libc::c_uint).wrapping_add((::std::mem::size_of::<SAVE_RESEARCH>()
                                             as
                                             libc::c_ulong).wrapping_mul(numResearch));
    //allocate the buffer space
    pFileData = memMallocRelease(fileSize) as *mut libc::c_char;
    if pFileData.is_null() {
        debug(LOG_ERROR,
              b"writeResearchFile: Out of memory\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    // Put the file header on the file
    psHeader = pFileData as *mut RESEARCH_SAVEHEADER;
    (*psHeader).aFileType[0 as libc::c_int as usize] = 'r' as i32 as STRING;
    (*psHeader).aFileType[1 as libc::c_int as usize] = 'e' as i32 as STRING;
    (*psHeader).aFileType[2 as libc::c_int as usize] = 's' as i32 as STRING;
    (*psHeader).aFileType[3 as libc::c_int as usize] = 'h' as i32 as STRING;
    (*psHeader).version = 33 as libc::c_int as UDWORD;
    (*psHeader).quantity = numResearch;
    endian_udword(&mut (*psHeader).version);
    endian_udword(&mut (*psHeader).quantity);
    psSaveResearch =
        pFileData.offset(12 as libc::c_int as isize) as *mut SAVE_RESEARCH;
    //save each type of reesearch
    psStats = asResearch;
    i = 0 as libc::c_int as UDWORD;
    while i < numResearch {
        strcpy((*psSaveResearch).name.as_mut_ptr(), (*psStats).pName);
        player = 0 as libc::c_int as UDWORD;
        while player < 8 as libc::c_int as libc::c_uint {
            (*psSaveResearch).possible[player as usize] =
                ((*asPlayerResList[player as
                                       usize].offset(i as
                                                         isize)).ResearchStatus
                     as libc::c_int & 0x80 as libc::c_int) as UBYTE;
            (*psSaveResearch).researched[player as usize] =
                ((*asPlayerResList[player as
                                       usize].offset(i as
                                                         isize)).ResearchStatus
                     as libc::c_int &
                     (0x1 as libc::c_int | 0x2 as libc::c_int |
                          0x4 as libc::c_int)) as UBYTE;
            (*psSaveResearch).currentPoints[player as usize] =
                (*asPlayerResList[player as
                                      usize].offset(i as
                                                        isize)).currentPoints;
            player = player.wrapping_add(1)
        }
        player = 0 as libc::c_int as UDWORD;
        while player < 8 as libc::c_int as libc::c_uint {
            endian_udword(&mut *(*psSaveResearch).currentPoints.as_mut_ptr().offset(player
                                                                                        as
                                                                                        isize));
            player = player.wrapping_add(1)
        }
        psSaveResearch =
            (psSaveResearch as
                 *mut libc::c_char).offset(::std::mem::size_of::<SAVE_RESEARCH>()
                                               as libc::c_ulong as isize) as
                *mut SAVE_RESEARCH;
        i = i.wrapping_add(1);
        psStats = psStats.offset(1)
    }
    if saveFile(pFileName, pFileData, fileSize) == 0 {
        return 0 as libc::c_int
    }
    memFreeRelease(pFileData as *mut libc::c_void);
    pFileData = 0 as *mut libc::c_char;
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
//#ifdef NEW_SAVE //V11 Save
// load up saved message file
unsafe extern "C" fn loadSaveMessage(mut pFileData: *mut libc::c_char,
                                     mut filesize: UDWORD,
                                     mut levelType: SWORD) -> BOOL {
    let mut psHeader: *mut MESSAGE_SAVEHEADER = 0 as *mut MESSAGE_SAVEHEADER;
    /* Check the file type */
    psHeader = pFileData as *mut MESSAGE_SAVEHEADER;
    if (*psHeader).aFileType[0 as libc::c_int as usize] as libc::c_int !=
           'm' as i32 ||
           (*psHeader).aFileType[1 as libc::c_int as usize] as libc::c_int !=
               'e' as i32 ||
           (*psHeader).aFileType[2 as libc::c_int as usize] as libc::c_int !=
               's' as i32 ||
           (*psHeader).aFileType[3 as libc::c_int as usize] as libc::c_int !=
               's' as i32 {
        debug(LOG_ERROR,
              b"loadSaveMessage: Incorrect file type\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    /* MESSAGE_SAVEHEADER */
    endian_udword(&mut (*psHeader).version);
    endian_udword(&mut (*psHeader).quantity);
    //increment to the start of the data
    pFileData = pFileData.offset(12 as libc::c_int as isize);
    /* Check the file version */
    if loadSaveMessageV(pFileData, filesize, (*psHeader).quantity,
                        (*psHeader).version, levelType) == 0 {
        return 0 as libc::c_int
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
unsafe extern "C" fn loadSaveMessageV(mut pFileData: *mut libc::c_char,
                                      mut filesize: UDWORD,
                                      mut numMessages: UDWORD,
                                      mut version: UDWORD,
                                      mut levelType: SWORD) -> BOOL {
    let mut psSaveMessage: *mut SAVE_MESSAGE = 0 as *mut SAVE_MESSAGE;
    let mut psMessage: *mut MESSAGE = 0 as *mut MESSAGE;
    let mut psViewData: *mut VIEWDATA = 0 as *mut VIEWDATA;
    let mut i: UDWORD = 0;
    let mut height_0: UDWORD = 0;
    //clear any messages put in during level loads
	//freeMessages();
    //only clear the messages if its a mid save game
    if gameType == GTYPE_SAVE_MIDMISSION as libc::c_int as libc::c_uint {
        freeMessages();
    } else if gameType == GTYPE_SAVE_START as libc::c_int as libc::c_uint {
        //if we're loading in a CamStart or a CamChange then we're not interested in any saved messages
        if levelType as libc::c_int == LDS_CAMSTART as libc::c_int ||
               levelType as libc::c_int == LDS_CAMCHANGE as libc::c_int {
            return 1 as libc::c_int
        }
    }
    //check file
    if (::std::mem::size_of::<SAVE_MESSAGE>() as
            libc::c_ulong).wrapping_mul(numMessages).wrapping_add(12 as
                                                                      libc::c_int
                                                                      as
                                                                      libc::c_uint)
           > filesize {
        debug(LOG_ERROR,
              b"loadSaveMessage: unexpected end of file\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    let mut current_block_43: u64;
    // Load the data
    i = 0 as libc::c_int as UDWORD;
    while i < numMessages {
        psSaveMessage = pFileData as *mut SAVE_MESSAGE;
        /* SAVE_MESSAGE */
        endian_sdword(&mut (*psSaveMessage).type_0 as *mut MESSAGE_TYPE as
                          *mut SDWORD); /* FIXME: enum may not be this type! */
        endian_udword(&mut (*psSaveMessage).objId);
        endian_udword(&mut (*psSaveMessage).player);
        if (*psSaveMessage).type_0 as libc::c_uint ==
               MSG_PROXIMITY as libc::c_int as libc::c_uint {
            //only load proximity if a mid-mission save game
            if gameType ==
                   GTYPE_SAVE_MIDMISSION as libc::c_int as libc::c_uint {
                if (*psSaveMessage).bObj != 0 {
                    //proximity object so create get the obj from saved idy
                    psMessage =
                        addMessage((*psSaveMessage).type_0 as UDWORD,
                                   1 as libc::c_int, (*psSaveMessage).player);
                    if !psMessage.is_null() {
                        (*psMessage).pViewData =
                            getBaseObjFromId((*psSaveMessage).objId) as
                                *mut MSG_VIEWDATA
                    }
                } else {
                    //proximity position so get viewdata pointer from the name
                    psMessage =
                        addMessage((*psSaveMessage).type_0 as UDWORD,
                                   0 as libc::c_int, (*psSaveMessage).player);
                    if !psMessage.is_null() {
                        psViewData =
                            getViewData((*psSaveMessage).name.as_mut_ptr());
                        if psViewData.is_null() {
                            current_block_43 = 12599329904712511516;
                        } else {
                            (*psMessage).pViewData =
                                psViewData as *mut MSG_VIEWDATA;
                            current_block_43 = 17281240262373992796;
                        }
                    } else { current_block_43 = 17281240262373992796; }
                    match current_block_43 {
                        12599329904712511516 => { }
                        _ => {
                            //check the z value is at least the height of the terrain
                            height_0 =
                                map_Height((*((*psViewData).pData as
                                                  *mut VIEW_PROXIMITY)).x,
                                           (*((*psViewData).pData as
                                                  *mut VIEW_PROXIMITY)).y) as
                                    UDWORD;
                            if (*((*psViewData).pData as
                                      *mut VIEW_PROXIMITY)).z < height_0 {
                                (*((*psViewData).pData as
                                       *mut VIEW_PROXIMITY)).z = height_0
                            }
                        }
                    }
                }
            }
        } else if (*psSaveMessage).type_0 as libc::c_uint ==
                      MSG_CAMPAIGN as libc::c_int as libc::c_uint ||
                      (*psSaveMessage).type_0 as libc::c_uint ==
                          MSG_MISSION as libc::c_int as libc::c_uint {
            if gameType ==
                   GTYPE_SAVE_MIDMISSION as libc::c_int as libc::c_uint {
                //only load Campaign/Mission if a mid-mission save game
                // Research message // Campaign message // Mission Report messages
                psMessage =
                    addMessage((*psSaveMessage).type_0 as UDWORD,
                               0 as libc::c_int, (*psSaveMessage).player);
                if !psMessage.is_null() {
                    (*psMessage).pViewData =
                        getViewData((*psSaveMessage).name.as_mut_ptr()) as
                            *mut MSG_VIEWDATA
                }
            }
        } else {
            // Research message
            psMessage =
                addMessage((*psSaveMessage).type_0 as UDWORD,
                           0 as libc::c_int, (*psSaveMessage).player);
            if !psMessage.is_null() {
                (*psMessage).pViewData =
                    getViewData((*psSaveMessage).name.as_mut_ptr()) as
                        *mut MSG_VIEWDATA
            }
        }
        //skip this message
        i = i.wrapping_add(1);
        pFileData =
            pFileData.offset(::std::mem::size_of::<SAVE_MESSAGE>() as
                                 libc::c_ulong as isize)
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
// Write out the current messages per player
unsafe extern "C" fn writeMessageFile(mut pFileName: *mut STRING) -> BOOL {
    let mut psHeader: *mut MESSAGE_SAVEHEADER = 0 as *mut MESSAGE_SAVEHEADER;
    let mut psSaveMessage: *mut SAVE_MESSAGE = 0 as *mut SAVE_MESSAGE;
    let mut pFileData: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut fileSize: UDWORD = 0;
    let mut player: UDWORD = 0;
    let mut psMessage: *mut MESSAGE = 0 as *mut MESSAGE;
    let mut psProx: *mut PROXIMITY_DISPLAY = 0 as *mut PROXIMITY_DISPLAY;
    let mut psObj: *mut BASE_OBJECT = 0 as *mut BASE_OBJECT;
    let mut numMessages: UDWORD = 0 as libc::c_int as UDWORD;
    let mut pViewData: *mut VIEWDATA = 0 as *mut VIEWDATA;
    // Calculate the file size
    player = 0 as libc::c_int as UDWORD;
    while player < 8 as libc::c_int as libc::c_uint {
        psMessage = apsMessages[player as usize];
        while !psMessage.is_null() {
            numMessages = numMessages.wrapping_add(1);
            psMessage = (*psMessage).psNext
        }
        player = player.wrapping_add(1)
    }
    fileSize =
        (12 as libc::c_int as
             libc::c_uint).wrapping_add((::std::mem::size_of::<SAVE_MESSAGE>()
                                             as
                                             libc::c_ulong).wrapping_mul(numMessages));
    //allocate the buffer space
    pFileData = memMallocRelease(fileSize) as *mut libc::c_char;
    if pFileData.is_null() {
        debug(LOG_ERROR,
              b"writeMessageFile: Out of memory\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    // Put the file header on the file
    psHeader = pFileData as *mut MESSAGE_SAVEHEADER;
    (*psHeader).aFileType[0 as libc::c_int as usize] = 'm' as i32 as STRING;
    (*psHeader).aFileType[1 as libc::c_int as usize] = 'e' as i32 as STRING;
    (*psHeader).aFileType[2 as libc::c_int as usize] = 's' as i32 as STRING;
    (*psHeader).aFileType[3 as libc::c_int as usize] = 's' as i32 as STRING;
    (*psHeader).version = 33 as libc::c_int as UDWORD;
    (*psHeader).quantity = numMessages;
    psSaveMessage =
        pFileData.offset(12 as libc::c_int as isize) as *mut SAVE_MESSAGE;
    //save each type of reesearch
    player = 0 as libc::c_int as UDWORD; //The type of message
    while player < 8 as libc::c_int as libc::c_uint {
        psMessage = apsMessages[player as usize];
        psMessage = apsMessages[player as usize];
        while !psMessage.is_null() {
            (*psSaveMessage).type_0 = (*psMessage).type_0;
            if (*psMessage).type_0 as libc::c_uint ==
                   MSG_PROXIMITY as libc::c_int as libc::c_uint {
                //get the matching proximity message
                psProx = apsProxDisp[player as usize];
                while !psProx.is_null() {
                    //compare the pointers
                    if (*psProx).psMessage == psMessage { break ; }
                    psProx = (*psProx).psNext
                }
                if !psProx.is_null() {
                } else {
                    debug(LOG_ERROR,
                          b"Save message; proximity display not found for message\x00"
                              as *const u8 as *const libc::c_char);
                };
                if !psProx.is_null() {
                } else {
                    debug(LOG_ERROR,
                          b"Assert in Warzone: %s:%d : %s (%s)\x00" as
                              *const u8 as *const libc::c_char,
                          b"game.c\x00" as *const u8 as *const libc::c_char,
                          10292 as libc::c_int,
                          (*::std::mem::transmute::<&[u8; 17],
                                                    &[libc::c_char; 17]>(b"writeMessageFile\x00")).as_ptr(),
                          b"psProx != NULL\x00" as *const u8 as
                              *const libc::c_char);
                };
                if (*psProx).type_0 as libc::c_uint ==
                       POS_PROXDATA as libc::c_int as libc::c_uint {
                    //message has viewdata so store the name
                    (*psSaveMessage).bObj = 0 as libc::c_int;
                    pViewData = (*psMessage).pViewData as *mut VIEWDATA;
                    if strlen((*pViewData).pName) <
                           20 as libc::c_int as libc::c_uint {
                    } else {
                        debug(LOG_ERROR,
                              b"writeMessageFile; viewdata pName Error\x00" as
                                  *const u8 as *const libc::c_char);
                    };
                    if strlen((*pViewData).pName) <
                           20 as libc::c_int as libc::c_uint {
                    } else {
                        debug(LOG_ERROR,
                              b"Assert in Warzone: %s:%d : %s (%s)\x00" as
                                  *const u8 as *const libc::c_char,
                              b"game.c\x00" as *const u8 as
                                  *const libc::c_char, 10299 as libc::c_int,
                              (*::std::mem::transmute::<&[u8; 17],
                                                        &[libc::c_char; 17]>(b"writeMessageFile\x00")).as_ptr(),
                              b"strlen(pViewData->pName) < MAX_STR_SIZE\x00"
                                  as *const u8 as *const libc::c_char);
                    };
                    strcpy((*psSaveMessage).name.as_mut_ptr(),
                           (*pViewData).pName);
                    //Pointer to view data - if any - should be some!
                } else {
                    //message has object so store ObjectId
                    (*psSaveMessage).bObj = 1 as libc::c_int;
                    psObj = (*psMessage).pViewData as *mut BASE_OBJECT;
                    (*psSaveMessage).objId = (*psObj).id
                    //should be unique for these objects
                }
            } else {
                (*psSaveMessage).bObj = 0 as libc::c_int;
                pViewData = (*psMessage).pViewData as *mut VIEWDATA;
                if strlen((*pViewData).pName) <
                       20 as libc::c_int as libc::c_uint {
                } else {
                    debug(LOG_ERROR,
                          b"writeMessageFile; viewdata pName Error\x00" as
                              *const u8 as *const libc::c_char);
                };
                if strlen((*pViewData).pName) <
                       20 as libc::c_int as libc::c_uint {
                } else {
                    debug(LOG_ERROR,
                          b"Assert in Warzone: %s:%d : %s (%s)\x00" as
                              *const u8 as *const libc::c_char,
                          b"game.c\x00" as *const u8 as *const libc::c_char,
                          10314 as libc::c_int,
                          (*::std::mem::transmute::<&[u8; 17],
                                                    &[libc::c_char; 17]>(b"writeMessageFile\x00")).as_ptr(),
                          b"strlen(pViewData->pName) < MAX_STR_SIZE\x00" as
                              *const u8 as *const libc::c_char);
                };
                strcpy((*psSaveMessage).name.as_mut_ptr(),
                       (*pViewData).pName);
                //Pointer to view data - if any - should be some!
            } //flag to indicate whether message has been read
            (*psSaveMessage).read =
                (*psMessage).read; //which player this message belongs to
            (*psSaveMessage).player =
                (*psMessage).player; /* FIXME: enum may be different type! */
            endian_sdword(&mut (*psSaveMessage).type_0 as *mut MESSAGE_TYPE as
                              *mut SDWORD);
            endian_udword(&mut (*psSaveMessage).objId);
            endian_udword(&mut (*psSaveMessage).player);
            psSaveMessage =
                (psSaveMessage as
                     *mut libc::c_char).offset(::std::mem::size_of::<SAVE_MESSAGE>()
                                                   as libc::c_ulong as isize)
                    as *mut SAVE_MESSAGE;
            psMessage = (*psMessage).psNext
        }
        player = player.wrapping_add(1)
    }
    /* MESSAGE_SAVEHEADER */
    endian_udword(&mut (*psHeader).version);
    endian_udword(&mut (*psHeader).quantity);
    if saveFile(pFileName, pFileData, fileSize) == 0 {
        return 0 as libc::c_int
    }
    memFreeRelease(pFileData as *mut libc::c_void);
    pFileData = 0 as *mut libc::c_char;
    return 1 as libc::c_int;
}
//#endif
// -----------------------------------------------------------------------------------------
//V14 Save this is not done because all messages are rebuilt
// -----------------------------------------------------------------------------------------
//#ifdef NEW_SAVE //V11 Save
// load up saved flag file
unsafe extern "C" fn loadSaveFlag(mut pFileData: *mut libc::c_char,
                                  mut filesize: UDWORD) -> BOOL {
    let mut psHeader: *mut FLAG_SAVEHEADER = 0 as *mut FLAG_SAVEHEADER;
    /* Check the file type */
    psHeader = pFileData as *mut FLAG_SAVEHEADER;
    if (*psHeader).aFileType[0 as libc::c_int as usize] as libc::c_int !=
           'f' as i32 ||
           (*psHeader).aFileType[1 as libc::c_int as usize] as libc::c_int !=
               'l' as i32 ||
           (*psHeader).aFileType[2 as libc::c_int as usize] as libc::c_int !=
               'a' as i32 ||
           (*psHeader).aFileType[3 as libc::c_int as usize] as libc::c_int !=
               'g' as i32 {
        debug(LOG_ERROR,
              b"loadSaveflag: Incorrect file type\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    /* FLAG_SAVEHEADER */
    endian_udword(&mut (*psHeader).version);
    endian_udword(&mut (*psHeader).quantity);
    //increment to the start of the data
    pFileData = pFileData.offset(12 as libc::c_int as isize);
    /* Check the file version */
    if loadSaveFlagV(pFileData, filesize, (*psHeader).quantity,
                     (*psHeader).version) == 0 {
        return 0 as libc::c_int
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
unsafe extern "C" fn loadSaveFlagV(mut pFileData: *mut libc::c_char,
                                   mut filesize: UDWORD, mut numflags: UDWORD,
                                   mut version: UDWORD) -> BOOL {
    let mut psSaveflag: *mut SAVE_FLAG = 0 as *mut SAVE_FLAG;
    let mut psflag: *mut FLAG_POSITION = 0 as *mut FLAG_POSITION;
    let mut i: UDWORD = 0;
    let mut psStruct: *mut STRUCTURE = 0 as *mut STRUCTURE;
    let mut factoryToFind: UDWORD = 0 as libc::c_int as UDWORD;
    let mut sizeOfSaveFlag: UDWORD = 0;
    //	version;//unreferenced
    //clear any flags put in during level loads
    freeAllFlagPositions(); //clear the factory masks, we will find the factories from their assembly points
    initFactoryNumFlag();
    //check file
    if version <= 18 as libc::c_int as libc::c_uint {
        sizeOfSaveFlag =
            ::std::mem::size_of::<SAVE_FLAG_V18>() as libc::c_ulong
    } else {
        sizeOfSaveFlag = ::std::mem::size_of::<SAVE_FLAG>() as libc::c_ulong
    }
    if sizeOfSaveFlag.wrapping_mul(numflags).wrapping_add(12 as libc::c_int as
                                                              libc::c_uint) >
           filesize {
        debug(LOG_ERROR,
              b"loadSaveflag: unexpected end of file\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    // Load the data
    i = 0 as libc::c_int as UDWORD;
    while i < numflags {
        psSaveflag = pFileData as *mut SAVE_FLAG;
        /* SAVE_FLAG */
        endian_sdword(&mut (*psSaveflag).type_0 as *mut POSITION_TYPE as
                          *mut SDWORD); /* FIXME: enum may not be this type! */
        endian_udword(&mut (*psSaveflag).frameNumber); //The type of flag
        endian_udword(&mut (*psSaveflag).screenX); //when the Position was last drawn
        endian_udword(&mut (*psSaveflag).screenY); //screen coords and radius of Position imd
        endian_udword(&mut (*psSaveflag).screenR); //which player the Position belongs to
        endian_udword(&mut (*psSaveflag).player); //flag to indicate whether the Position
        endian_sdword(&mut (*psSaveflag).coords.x); //the world coords of the Position
        endian_sdword(&mut (*psSaveflag).coords.y); //indicates whether the first, second etc factory
        endian_sdword(&mut (*psSaveflag).coords.z); //indicates whether standard, cyborg or vtol factory
        endian_udword(&mut (*psSaveflag).repairId);
        createFlagPosition(&mut psflag, (*psSaveflag).player);
        (*psflag).type_0 = (*psSaveflag).type_0;
        (*psflag).frameNumber = (*psSaveflag).frameNumber;
        (*psflag).screenX = (*psSaveflag).screenX;
        (*psflag).screenY = (*psSaveflag).screenY;
        (*psflag).screenR = (*psSaveflag).screenR;
        (*psflag).player = (*psSaveflag).player;
        (*psflag).selected = (*psSaveflag).selected;
        (*psflag).coords = (*psSaveflag).coords;
        (*psflag).factoryInc = (*psSaveflag).factoryInc;
        (*psflag).factoryType = (*psSaveflag).factoryType;
        if (*psflag).type_0 as libc::c_uint ==
               POS_DELIVERY as libc::c_int as libc::c_uint ||
               (*psflag).type_0 as libc::c_uint ==
                   POS_TEMPDELIVERY as libc::c_int as libc::c_uint {
            if (*psflag).factoryType as libc::c_int == 0 as libc::c_int {
                factoryToFind = REF_FACTORY as libc::c_int as UDWORD
            } else if (*psflag).factoryType as libc::c_int == 1 as libc::c_int
             {
                factoryToFind = REF_CYBORG_FACTORY as libc::c_int as UDWORD
            } else if (*psflag).factoryType as libc::c_int == 2 as libc::c_int
             {
                factoryToFind = REF_VTOL_FACTORY as libc::c_int as UDWORD
            } else if (*psflag).factoryType as libc::c_int == 3 as libc::c_int
             {
                factoryToFind = REF_REPAIR_FACILITY as libc::c_int as UDWORD
            } else {
                if 0 as libc::c_int != 0 {
                } else {
                    debug(LOG_ERROR,
                          b"loadSaveFlagV delivery flag type not recognised?\x00"
                              as *const u8 as *const libc::c_char);
                };
                if 0 as libc::c_int != 0 {
                } else {
                    debug(LOG_ERROR,
                          b"Assert in Warzone: %s:%d : %s (%s)\x00" as
                              *const u8 as *const libc::c_char,
                          b"game.c\x00" as *const u8 as *const libc::c_char,
                          10637 as libc::c_int,
                          (*::std::mem::transmute::<&[u8; 14],
                                                    &[libc::c_char; 14]>(b"loadSaveFlagV\x00")).as_ptr(),
                          b"FALSE\x00" as *const u8 as *const libc::c_char);
                };
            }
            if factoryToFind ==
                   REF_REPAIR_FACILITY as libc::c_int as libc::c_uint {
                if version > 18 as libc::c_int as libc::c_uint {
                    psStruct =
                        getBaseObjFromId((*psSaveflag).repairId) as
                            *mut STRUCTURE;
                    if !psStruct.is_null() {
                        if (*psStruct).type_0 as libc::c_uint !=
                               OBJ_STRUCTURE as libc::c_int as libc::c_uint {
                            if 0 as libc::c_int != 0 {
                            } else {
                                debug(LOG_ERROR,
                                      b"loadFlag found duplicate Id for repair facility\x00"
                                          as *const u8 as
                                          *const libc::c_char);
                            };
                            if 0 as libc::c_int != 0 {
                            } else {
                                debug(LOG_ERROR,
                                      b"Assert in Warzone: %s:%d : %s (%s)\x00"
                                          as *const u8 as *const libc::c_char,
                                      b"game.c\x00" as *const u8 as
                                          *const libc::c_char,
                                      10649 as libc::c_int,
                                      (*::std::mem::transmute::<&[u8; 14],
                                                                &[libc::c_char; 14]>(b"loadSaveFlagV\x00")).as_ptr(),
                                      b"FALSE\x00" as *const u8 as
                                          *const libc::c_char);
                            };
                        } else if (*(*psStruct).pStructureType).type_0 ==
                                      REF_REPAIR_FACILITY as libc::c_int as
                                          libc::c_uint {
                            if !(*psStruct).pFunctionality.is_null() {
                                //this is the one so set it
                                let ref mut fresh2 =
                                    (*((*psStruct).pFunctionality as
                                           *mut REPAIR_FACILITY)).psDeliveryPoint;
                                *fresh2 = psflag
                            }
                        }
                    }
                }
            } else {
                //okay find the player factory with this inc and set this as the assembly point
                psStruct = apsStructLists[(*psflag).player as usize];
                while !psStruct.is_null() {
                    if (*(*psStruct).pStructureType).type_0 == factoryToFind {
                        if (*((*psStruct).pFunctionality as
                                  *mut FACTORY)).psAssemblyPoint as UDWORD ==
                               (*psflag).factoryInc as libc::c_uint {
                            //this is the one so set it
                            let ref mut fresh3 =
                                (*((*psStruct).pFunctionality as
                                       *mut FACTORY)).psAssemblyPoint;
                            *fresh3 = psflag
                        }
                    }
                    psStruct = (*psStruct).psNext
                }
            }
        }
        if (*psflag).type_0 as libc::c_uint ==
               POS_DELIVERY as libc::c_int as libc::c_uint {
            //dont add POS_TEMPDELIVERYs
            addFlagPosition(psflag);
        } else if (*psflag).type_0 as libc::c_uint ==
                      POS_TEMPDELIVERY as libc::c_int as libc::c_uint {
            //but make them real flags
            (*psflag).type_0 = POS_DELIVERY
        } //set the new numbers into the masks
        i = i.wrapping_add(1);
        pFileData = pFileData.offset(sizeOfSaveFlag as isize)
    }
    resetFactoryNumFlag();
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
// Write out the current flags per player
unsafe extern "C" fn writeFlagFile(mut pFileName: *mut STRING) -> BOOL {
    let mut psHeader: *mut FLAG_SAVEHEADER = 0 as *mut FLAG_SAVEHEADER;
    let mut psSaveflag: *mut SAVE_FLAG = 0 as *mut SAVE_FLAG;
    let mut psStruct: *mut STRUCTURE = 0 as *mut STRUCTURE;
    let mut psFactory: *mut FACTORY = 0 as *mut FACTORY;
    let mut pFileData: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut fileSize: UDWORD = 0;
    let mut player: UDWORD = 0;
    let mut psflag: *mut FLAG_POSITION = 0 as *mut FLAG_POSITION;
    let mut numflags: UDWORD = 0 as libc::c_int as UDWORD;
    // Calculate the file size
    player = 0 as libc::c_int as UDWORD;
    while player < 8 as libc::c_int as libc::c_uint {
        psflag = apsFlagPosLists[player as usize];
        while !psflag.is_null() {
            numflags = numflags.wrapping_add(1);
            psflag = (*psflag).psNext
        }
        player = player.wrapping_add(1)
    }
    //and add the delivery points not in the list
    player = 0 as libc::c_int as UDWORD;
    while player < 8 as libc::c_int as libc::c_uint {
        psStruct = apsStructLists[player as usize];
        while !psStruct.is_null() {
            if !(*psStruct).pFunctionality.is_null() {
                match (*(*psStruct).pStructureType).type_0 {
                    1 | 16 | 17 => {
                        psFactory =
                            (*psStruct).pFunctionality as *mut FACTORY;
                        //if there is a commander then has been temporarily removed
					//so put it back
                        if !(*psFactory).psCommander.is_null() {
                            psflag = (*psFactory).psAssemblyPoint;
                            if !psflag.is_null() {
                                numflags = numflags.wrapping_add(1)
                            }
                        }
                    }
                    _ => { }
                }
            }
            psStruct = (*psStruct).psNext
        }
        player = player.wrapping_add(1)
    }
    fileSize =
        (12 as libc::c_int as
             libc::c_uint).wrapping_add((::std::mem::size_of::<SAVE_FLAG>() as
                                             libc::c_ulong).wrapping_mul(numflags));
    //allocate the buffer space
    pFileData = memMallocRelease(fileSize) as *mut libc::c_char;
    if pFileData.is_null() {
        debug(LOG_ERROR,
              b"writeflagFile: Out of memory\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    // Put the file header on the file
    psHeader = pFileData as *mut FLAG_SAVEHEADER;
    (*psHeader).aFileType[0 as libc::c_int as usize] = 'f' as i32 as STRING;
    (*psHeader).aFileType[1 as libc::c_int as usize] = 'l' as i32 as STRING;
    (*psHeader).aFileType[2 as libc::c_int as usize] = 'a' as i32 as STRING;
    (*psHeader).aFileType[3 as libc::c_int as usize] = 'g' as i32 as STRING;
    (*psHeader).version = 33 as libc::c_int as UDWORD;
    (*psHeader).quantity = numflags;
    psSaveflag =
        pFileData.offset(12 as libc::c_int as isize) as *mut SAVE_FLAG;
    //save each type of reesearch
    player = 0 as libc::c_int as UDWORD; //The type of flag
    while player < 8 as libc::c_int as libc::c_uint {
        psflag =
            apsFlagPosLists[player as
                                usize]; //when the Position was last drawn
        psflag =
            apsFlagPosLists[player as
                                usize]; //screen coords and radius of Position imd
        while !psflag.is_null() {
            (*psSaveflag).type_0 =
                (*psflag).type_0; //which player the Position belongs to
            (*psSaveflag).frameNumber =
                (*psflag).frameNumber; //flag to indicate whether the Position
            (*psSaveflag).screenX =
                (*psflag).screenX; //the world coords of the Position
            (*psSaveflag).screenY =
                (*psflag).screenY; //indicates whether the first, second etc factory
            (*psSaveflag).screenR =
                (*psflag).screenR; //indicates whether standard, cyborg or vtol factory
            (*psSaveflag).player = (*psflag).player;
            (*psSaveflag).selected = (*psflag).selected;
            (*psSaveflag).coords = (*psflag).coords;
            (*psSaveflag).factoryInc = (*psflag).factoryInc;
            (*psSaveflag).factoryType = (*psflag).factoryType;
            if (*psflag).factoryType as libc::c_int == 3 as libc::c_int {
                //get repair facility id
                (*psSaveflag).repairId = getRepairIdFromFlag(psflag)
            }
            /* SAVE_FLAG */
            endian_sdword(&mut (*psSaveflag).type_0 as *mut POSITION_TYPE as
                              *mut SDWORD); /* FIXME: enum may be different type! */
            endian_udword(&mut (*psSaveflag).frameNumber);
            endian_udword(&mut (*psSaveflag).screenX);
            endian_udword(&mut (*psSaveflag).screenY);
            endian_udword(&mut (*psSaveflag).screenR);
            endian_udword(&mut (*psSaveflag).player);
            endian_sdword(&mut (*psSaveflag).coords.x);
            endian_sdword(&mut (*psSaveflag).coords.y);
            endian_sdword(&mut (*psSaveflag).coords.z);
            endian_udword(&mut (*psSaveflag).repairId);
            psSaveflag =
                (psSaveflag as
                     *mut libc::c_char).offset(::std::mem::size_of::<SAVE_FLAG>()
                                                   as libc::c_ulong as isize)
                    as *mut SAVE_FLAG;
            psflag = (*psflag).psNext
        }
        player = player.wrapping_add(1)
    }
    //and add the delivery points not in the list
    player = 0 as libc::c_int as UDWORD;
    while player < 8 as libc::c_int as libc::c_uint {
        psStruct = apsStructLists[player as usize];
        while !psStruct.is_null() {
            if !(*psStruct).pFunctionality.is_null() {
                match (*(*psStruct).pStructureType).type_0 {
                    1 | 16 | 17 => {
                        psFactory =
                            (*psStruct).pFunctionality as *mut FACTORY;
                        //if there is a commander then has been temporarily removed
					//so put it back
                        if !(*psFactory).psCommander.is_null() {
                            psflag =
                                (*psFactory).psAssemblyPoint; //The type of flag
                            if !psflag.is_null() {
                                (*psSaveflag).type_0 =
                                    POS_TEMPDELIVERY; //when the Position was last drawn
                                (*psSaveflag).frameNumber =
                                    (*psflag).frameNumber; //screen coords and radius of Position imd
                                (*psSaveflag).screenX =
                                    (*psflag).screenX; //which player the Position belongs to
                                (*psSaveflag).screenY =
                                    (*psflag).screenY; //flag to indicate whether the Position
                                (*psSaveflag).screenR =
                                    (*psflag).screenR; //the world coords of the Position
                                (*psSaveflag).player =
                                    (*psflag).player; //indicates whether the first, second etc factory
                                (*psSaveflag).selected =
                                    (*psflag).selected; //indicates whether standard, cyborg or vtol factory
                                (*psSaveflag).coords = (*psflag).coords;
                                (*psSaveflag).factoryInc =
                                    (*psflag).factoryInc;
                                (*psSaveflag).factoryType =
                                    (*psflag).factoryType;
                                if (*psflag).factoryType as libc::c_int ==
                                       3 as libc::c_int {
                                    //get repair facility id
                                    (*psSaveflag).repairId =
                                        getRepairIdFromFlag(psflag)
                                }
                                /* SAVE_FLAG */
                                endian_sdword(&mut (*psSaveflag).type_0 as
                                                  *mut POSITION_TYPE as
                                                  *mut SDWORD); /* FIXME: enum may be different type! */
                                endian_udword(&mut (*psSaveflag).frameNumber);
                                endian_udword(&mut (*psSaveflag).screenX);
                                endian_udword(&mut (*psSaveflag).screenY);
                                endian_udword(&mut (*psSaveflag).screenR);
                                endian_udword(&mut (*psSaveflag).player);
                                endian_sdword(&mut (*psSaveflag).coords.x);
                                endian_sdword(&mut (*psSaveflag).coords.y);
                                endian_sdword(&mut (*psSaveflag).coords.z);
                                endian_udword(&mut (*psSaveflag).repairId);
                                psSaveflag =
                                    (psSaveflag as
                                         *mut libc::c_char).offset(::std::mem::size_of::<SAVE_FLAG>()
                                                                       as
                                                                       libc::c_ulong
                                                                       as
                                                                       isize)
                                        as *mut SAVE_FLAG
                            }
                        }
                    }
                    _ => { }
                }
            }
            psStruct = (*psStruct).psNext
        }
        player = player.wrapping_add(1)
    }
    /* FLAG_SAVEHEADER */
    endian_udword(&mut (*psHeader).version);
    endian_udword(&mut (*psHeader).quantity);
    if saveFile(pFileName, pFileData, fileSize) == 0 {
        return 0 as libc::c_int
    }
    memFreeRelease(pFileData as *mut libc::c_void);
    pFileData = 0 as *mut libc::c_char;
    return 1 as libc::c_int;
}
//#endif
// -----------------------------------------------------------------------------------------
//#ifdef PRODUCTION
unsafe extern "C" fn loadSaveProduction(mut pFileData: *mut libc::c_char,
                                        mut filesize: UDWORD) -> BOOL {
    let mut psHeader: *mut PRODUCTION_SAVEHEADER =
        0 as *mut PRODUCTION_SAVEHEADER;
    /* Check the file type */
    psHeader = pFileData as *mut PRODUCTION_SAVEHEADER;
    if (*psHeader).aFileType[0 as libc::c_int as usize] as libc::c_int !=
           'p' as i32 ||
           (*psHeader).aFileType[1 as libc::c_int as usize] as libc::c_int !=
               'r' as i32 ||
           (*psHeader).aFileType[2 as libc::c_int as usize] as libc::c_int !=
               'o' as i32 ||
           (*psHeader).aFileType[3 as libc::c_int as usize] as libc::c_int !=
               'd' as i32 {
        debug(LOG_ERROR,
              b"loadSaveProduction: Incorrect file type\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    /* PRODUCTION_SAVEHEADER */
    endian_udword(&mut (*psHeader).version);
    //increment to the start of the data
    pFileData = pFileData.offset(8 as libc::c_int as isize);
    /* Check the file version */
    if loadSaveProductionV(pFileData, filesize, (*psHeader).version) == 0 {
        return 0 as libc::c_int
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
unsafe extern "C" fn loadSaveProductionV(mut pFileData: *mut libc::c_char,
                                         mut filesize: UDWORD,
                                         mut version: UDWORD) -> BOOL {
    let mut psSaveProduction: *mut SAVE_PRODUCTION =
        0 as *mut SAVE_PRODUCTION;
    let mut psCurrentProd: *mut PRODUCTION_RUN = 0 as *mut PRODUCTION_RUN;
    let mut factoryType: UDWORD = 0;
    let mut factoryNum: UDWORD = 0;
    let mut runNum: UDWORD = 0;
    //	version;//unreferenced
    //check file
    if (::std::mem::size_of::<SAVE_PRODUCTION>() as
            libc::c_ulong).wrapping_mul(3 as libc::c_int as
                                            libc::c_uint).wrapping_mul(5 as
                                                                           libc::c_int
                                                                           as
                                                                           libc::c_uint).wrapping_mul(20
                                                                                                          as
                                                                                                          libc::c_int
                                                                                                          as
                                                                                                          libc::c_uint).wrapping_add(8
                                                                                                                                         as
                                                                                                                                         libc::c_int
                                                                                                                                         as
                                                                                                                                         libc::c_uint)
           > filesize {
        debug(LOG_ERROR,
              b"loadSaveProduction: unexpected end of file\x00" as *const u8
                  as *const libc::c_char);
        abort();
    }
    //save each production run
    factoryType = 0 as libc::c_int as UDWORD;
    while factoryType < 3 as libc::c_int as libc::c_uint {
        factoryNum = 0 as libc::c_int as UDWORD;
        while factoryNum < 5 as libc::c_int as libc::c_uint {
            runNum = 0 as libc::c_int as UDWORD;
            while runNum < 20 as libc::c_int as libc::c_uint {
                psSaveProduction = pFileData as *mut SAVE_PRODUCTION;
                psCurrentProd =
                    &mut *(*(*asProductionRun.as_mut_ptr().offset(factoryType
                                                                      as
                                                                      isize)).as_mut_ptr().offset(factoryNum
                                                                                                      as
                                                                                                      isize)).as_mut_ptr().offset(runNum
                                                                                                                                      as
                                                                                                                                      isize)
                        as *mut PRODUCTION_RUN;
                /* SAVE_PRODUCTION */
                endian_udword(&mut (*psSaveProduction).multiPlayerID);
                (*psCurrentProd).quantity = (*psSaveProduction).quantity;
                (*psCurrentProd).built = (*psSaveProduction).built;
                if (*psSaveProduction).multiPlayerID !=
                       0xffffffff as libc::c_uint {
                    (*psCurrentProd).psTemplate =
                        getTemplateFromMultiPlayerID((*psSaveProduction).multiPlayerID)
                } else {
                    (*psCurrentProd).psTemplate = 0 as *mut _droid_template
                }
                pFileData =
                    pFileData.offset(::std::mem::size_of::<SAVE_PRODUCTION>()
                                         as libc::c_ulong as isize);
                runNum = runNum.wrapping_add(1)
            }
            factoryNum = factoryNum.wrapping_add(1)
        }
        factoryType = factoryType.wrapping_add(1)
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
// Write out the current production figures for factories
unsafe extern "C" fn writeProductionFile(mut pFileName: *mut STRING) -> BOOL {
    let mut psHeader: *mut PRODUCTION_SAVEHEADER =
        0 as *mut PRODUCTION_SAVEHEADER;
    let mut psSaveProduction: *mut SAVE_PRODUCTION =
        0 as *mut SAVE_PRODUCTION;
    let mut pFileData: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut fileSize: UDWORD = 0;
    let mut psCurrentProd: *mut PRODUCTION_RUN = 0 as *mut PRODUCTION_RUN;
    let mut factoryType: UDWORD = 0;
    let mut factoryNum: UDWORD = 0;
    let mut runNum: UDWORD = 0;
    //PRODUCTION_RUN		asProductionRun[NUM_FACTORY_TYPES][MAX_FACTORY][MAX_PROD_RUN];
    fileSize =
        (8 as libc::c_int as
             libc::c_uint).wrapping_add((::std::mem::size_of::<SAVE_PRODUCTION>()
                                             as
                                             libc::c_ulong).wrapping_mul(3 as
                                                                             libc::c_int
                                                                             as
                                                                             libc::c_uint).wrapping_mul(5
                                                                                                            as
                                                                                                            libc::c_int
                                                                                                            as
                                                                                                            libc::c_uint).wrapping_mul(20
                                                                                                                                           as
                                                                                                                                           libc::c_int
                                                                                                                                           as
                                                                                                                                           libc::c_uint));
    //allocate the buffer space
    pFileData = memMallocRelease(fileSize) as *mut libc::c_char;
    if pFileData.is_null() {
        debug(LOG_ERROR,
              b"writeProductionFile: Out of memory\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    // Put the file header on the file
    psHeader = pFileData as *mut PRODUCTION_SAVEHEADER;
    (*psHeader).aFileType[0 as libc::c_int as usize] = 'p' as i32 as STRING;
    (*psHeader).aFileType[1 as libc::c_int as usize] = 'r' as i32 as STRING;
    (*psHeader).aFileType[2 as libc::c_int as usize] = 'o' as i32 as STRING;
    (*psHeader).aFileType[3 as libc::c_int as usize] = 'd' as i32 as STRING;
    (*psHeader).version = 33 as libc::c_int as UDWORD;
    psSaveProduction =
        pFileData.offset(8 as libc::c_int as isize) as *mut SAVE_PRODUCTION;
    //save each production run
    factoryType = 0 as libc::c_int as UDWORD;
    while factoryType < 3 as libc::c_int as libc::c_uint {
        factoryNum = 0 as libc::c_int as UDWORD;
        while factoryNum < 5 as libc::c_int as libc::c_uint {
            runNum = 0 as libc::c_int as UDWORD;
            while runNum < 20 as libc::c_int as libc::c_uint {
                psCurrentProd =
                    &mut *(*(*asProductionRun.as_mut_ptr().offset(factoryType
                                                                      as
                                                                      isize)).as_mut_ptr().offset(factoryNum
                                                                                                      as
                                                                                                      isize)).as_mut_ptr().offset(runNum
                                                                                                                                      as
                                                                                                                                      isize)
                        as *mut PRODUCTION_RUN;
                (*psSaveProduction).quantity = (*psCurrentProd).quantity;
                (*psSaveProduction).built = (*psCurrentProd).built;
                (*psSaveProduction).multiPlayerID =
                    0xffffffff as libc::c_uint;
                if !(*psCurrentProd).psTemplate.is_null() {
                    (*psSaveProduction).multiPlayerID =
                        (*(*psCurrentProd).psTemplate).multiPlayerID
                }
                /* SAVE_PRODUCTION */
                endian_udword(&mut (*psSaveProduction).multiPlayerID);
                psSaveProduction =
                    (psSaveProduction as
                         *mut libc::c_char).offset(::std::mem::size_of::<SAVE_PRODUCTION>()
                                                       as libc::c_ulong as
                                                       isize) as
                        *mut SAVE_PRODUCTION;
                runNum = runNum.wrapping_add(1)
            }
            factoryNum = factoryNum.wrapping_add(1)
        }
        factoryType = factoryType.wrapping_add(1)
    }
    /* PRODUCTION_SAVEHEADER */
    endian_udword(&mut (*psHeader).version);
    if saveFile(pFileName, pFileData, fileSize) == 0 {
        return 0 as libc::c_int
    }
    memFreeRelease(pFileData as *mut libc::c_void);
    pFileData = 0 as *mut libc::c_char;
    return 1 as libc::c_int;
}
//#endif
// -----------------------------------------------------------------------------------------
unsafe extern "C" fn loadSaveStructLimits(mut pFileData: *mut libc::c_char,
                                          mut filesize: UDWORD) -> BOOL {
    let mut psHeader: *mut STRUCTLIMITS_SAVEHEADER =
        0 as *mut STRUCTLIMITS_SAVEHEADER;
    // Check the file type
    psHeader = pFileData as *mut STRUCTLIMITS_SAVEHEADER;
    if (*psHeader).aFileType[0 as libc::c_int as usize] as libc::c_int !=
           'l' as i32 ||
           (*psHeader).aFileType[1 as libc::c_int as usize] as libc::c_int !=
               'm' as i32 ||
           (*psHeader).aFileType[2 as libc::c_int as usize] as libc::c_int !=
               't' as i32 ||
           (*psHeader).aFileType[3 as libc::c_int as usize] as libc::c_int !=
               's' as i32 {
        debug(LOG_ERROR,
              b"loadSaveStructLimits: Incorrect file type\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    //increment to the start of the data
    pFileData = pFileData.offset(12 as libc::c_int as isize);
    /* STRUCTLIMITS_SAVEHEADER */
    endian_udword(&mut (*psHeader).version);
    endian_udword(&mut (*psHeader).quantity);
    // Check the file version
    if (*psHeader).version >= 15 as libc::c_int as libc::c_uint &&
           (*psHeader).version <= 19 as libc::c_int as libc::c_uint {
        if loadSaveStructLimitsV19(pFileData, filesize, (*psHeader).quantity)
               == 0 {
            return 0 as libc::c_int
        }
    } else if (*psHeader).version <= 33 as libc::c_int as libc::c_uint {
        if loadSaveStructLimitsV(pFileData, filesize, (*psHeader).quantity) ==
               0 {
            return 0 as libc::c_int
        }
    } else {
        debug(LOG_ERROR,
              b"loadSaveStructLimits: Incorrect file format version\x00" as
                  *const u8 as *const libc::c_char);
        abort();
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
// !?**@?!
/* code specific to version 2 of saveStructLimits */
unsafe extern "C" fn loadSaveStructLimitsV19(mut pFileData: *mut libc::c_char,
                                             mut filesize: UDWORD,
                                             mut numLimits: UDWORD) -> BOOL {
    let mut psSaveLimits: *mut SAVE_STRUCTLIMITS_V2 =
        0 as *mut SAVE_STRUCTLIMITS_V2;
    let mut count: UDWORD = 0;
    let mut statInc: UDWORD = 0;
    let mut found: BOOL = 0;
    let mut psStats: *mut STRUCTURE_STATS = 0 as *mut STRUCTURE_STATS;
    let mut SkippedRecords: libc::c_int = 0 as libc::c_int;
    psSaveLimits =
        memMallocRelease(::std::mem::size_of::<SAVE_STRUCTLIMITS_V2>() as
                             libc::c_ulong) as *mut SAVE_STRUCTLIMITS_V2;
    if psSaveLimits.is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        abort();
    }
    if (::std::mem::size_of::<SAVE_STRUCTLIMITS_V2>() as
            libc::c_ulong).wrapping_mul(numLimits).wrapping_add(12 as
                                                                    libc::c_int
                                                                    as
                                                                    libc::c_uint)
           > filesize {
        debug(LOG_ERROR,
              b"loadSaveStructLimits: unexpected end of file\x00" as *const u8
                  as *const libc::c_char);
        abort();
    }
    // Load in the data
    count = 0 as libc::c_int as UDWORD;
    while count < numLimits {
        memcpy(psSaveLimits as *mut libc::c_void,
               pFileData as *const libc::c_void,
               ::std::mem::size_of::<SAVE_STRUCTLIMITS_V2>() as
                   libc::c_ulong);
        //get the stats for this structure
        found = 0 as libc::c_int;
        statInc = 0 as libc::c_int as UDWORD;
        while statInc < numStructureStats {
            psStats = asStructureStats.offset(statInc as isize);
            //loop until find the same name
            if strcmp((*psStats).pName, (*psSaveLimits).name.as_mut_ptr()) ==
                   0 {
                found = 1 as libc::c_int;
                break ;
            } else { statInc = statInc.wrapping_add(1) }
        }
        //if haven't found the structure - ignore this record!
        if found == 0 {
            debug(LOG_ERROR,
                  b"The structure no longer exists. The limits have not been set! - %s\x00"
                      as *const u8 as *const libc::c_char,
                  (*psSaveLimits).name.as_mut_ptr());
            abort();
        } else {
            if ((*psSaveLimits).player as libc::c_int) < 8 as libc::c_int {
                (*asStructLimits[(*psSaveLimits).player as
                                     usize].offset(statInc as isize)).limit =
                    (*psSaveLimits).limit
            } else { SkippedRecords += 1 }
            count = count.wrapping_add(1);
            pFileData =
                pFileData.offset(::std::mem::size_of::<SAVE_STRUCTLIMITS_V2>()
                                     as libc::c_ulong as isize)
        }
    }
    if SkippedRecords > 0 as libc::c_int {
        debug(LOG_ERROR,
              b"Skipped %d records in structure limits due to bad player number\n\x00"
                  as *const u8 as *const libc::c_char, SkippedRecords);
        abort();
    }
    memFreeRelease(psSaveLimits as *mut libc::c_void);
    psSaveLimits = 0 as *mut SAVE_STRUCTLIMITS_V2;
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
unsafe extern "C" fn loadSaveStructLimitsV(mut pFileData: *mut libc::c_char,
                                           mut filesize: UDWORD,
                                           mut numLimits: UDWORD) -> BOOL {
    let mut psSaveLimits: *mut SAVE_STRUCTLIMITS =
        0 as *mut SAVE_STRUCTLIMITS;
    let mut count: UDWORD = 0;
    let mut statInc: UDWORD = 0;
    let mut found: BOOL = 0;
    let mut psStats: *mut STRUCTURE_STATS = 0 as *mut STRUCTURE_STATS;
    let mut SkippedRecords: libc::c_int = 0 as libc::c_int;
    psSaveLimits =
        memMallocRelease(::std::mem::size_of::<SAVE_STRUCTLIMITS>() as
                             libc::c_ulong) as *mut SAVE_STRUCTLIMITS;
    if psSaveLimits.is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        abort();
    }
    if (::std::mem::size_of::<SAVE_STRUCTLIMITS>() as
            libc::c_ulong).wrapping_mul(numLimits).wrapping_add(12 as
                                                                    libc::c_int
                                                                    as
                                                                    libc::c_uint)
           > filesize {
        debug(LOG_ERROR,
              b"loadSaveStructLimits: unexpected end of file\x00" as *const u8
                  as *const libc::c_char);
        abort();
    }
    // Load in the data
    count = 0 as libc::c_int as UDWORD;
    while count < numLimits {
        memcpy(psSaveLimits as *mut libc::c_void,
               pFileData as *const libc::c_void,
               ::std::mem::size_of::<SAVE_STRUCTLIMITS>() as libc::c_ulong);
        //get the stats for this structure
        found = 0 as libc::c_int;
        statInc = 0 as libc::c_int as UDWORD;
        while statInc < numStructureStats {
            psStats = asStructureStats.offset(statInc as isize);
            //loop until find the same name
            if strcmp((*psStats).pName, (*psSaveLimits).name.as_mut_ptr()) ==
                   0 {
                found = 1 as libc::c_int;
                break ;
            } else { statInc = statInc.wrapping_add(1) }
        }
        //if haven't found the structure - ignore this record!
        if found == 0 {
            debug(LOG_ERROR,
                  b"The structure no longer exists. The limits have not been set! - %s\x00"
                      as *const u8 as *const libc::c_char,
                  (*psSaveLimits).name.as_mut_ptr());
            abort();
        } else {
            if ((*psSaveLimits).player as libc::c_int) < 8 as libc::c_int {
                (*asStructLimits[(*psSaveLimits).player as
                                     usize].offset(statInc as isize)).limit =
                    (*psSaveLimits).limit
            } else { SkippedRecords += 1 }
            count = count.wrapping_add(1);
            pFileData =
                pFileData.offset(::std::mem::size_of::<SAVE_STRUCTLIMITS>() as
                                     libc::c_ulong as isize)
        }
    }
    if SkippedRecords > 0 as libc::c_int {
        debug(LOG_ERROR,
              b"Skipped %d records in structure limits due to bad player number\n\x00"
                  as *const u8 as *const libc::c_char, SkippedRecords);
        abort();
    }
    memFreeRelease(psSaveLimits as *mut libc::c_void);
    psSaveLimits = 0 as *mut SAVE_STRUCTLIMITS;
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
/*
Writes the list of structure limits to a file
*/
unsafe extern "C" fn writeStructLimitsFile(mut pFileName: *mut STRING)
 -> BOOL {
    let mut pFileData: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut fileSize: UDWORD = 0;
    let mut totalLimits: UDWORD = 0 as libc::c_int as UDWORD;
    let mut i: UDWORD = 0;
    let mut player: UDWORD = 0;
    let mut psHeader: *mut STRUCTLIMITS_SAVEHEADER =
        0 as *mut STRUCTLIMITS_SAVEHEADER;
    let mut psSaveLimit: *mut SAVE_STRUCTLIMITS = 0 as *mut SAVE_STRUCTLIMITS;
    let mut psStructStats: *mut STRUCTURE_STATS = 0 as *mut STRUCTURE_STATS;
    let mut status: BOOL = 1 as libc::c_int;
    totalLimits =
        numStructureStats.wrapping_mul(8 as libc::c_int as libc::c_uint);
    // Allocate the data buffer
    fileSize =
        (12 as libc::c_int as
             libc::c_uint).wrapping_add(totalLimits.wrapping_mul(::std::mem::size_of::<SAVE_STRUCTLIMITS>()
                                                                     as
                                                                     libc::c_ulong));
    pFileData = memMallocRelease(fileSize) as *mut libc::c_char;
    if pFileData.is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        abort();
    }
    // Put the file header on the file
    psHeader = pFileData as *mut STRUCTLIMITS_SAVEHEADER;
    (*psHeader).aFileType[0 as libc::c_int as usize] = 'l' as i32 as STRING;
    (*psHeader).aFileType[1 as libc::c_int as usize] = 'm' as i32 as STRING;
    (*psHeader).aFileType[2 as libc::c_int as usize] = 't' as i32 as STRING;
    (*psHeader).aFileType[3 as libc::c_int as usize] = 's' as i32 as STRING;
    (*psHeader).version = 33 as libc::c_int as UDWORD;
    (*psHeader).quantity = totalLimits;
    psSaveLimit =
        pFileData.offset(12 as libc::c_int as isize) as
            *mut SAVE_STRUCTLIMITS;
    // Put the data into the buffer
    player = 0 as libc::c_int as UDWORD;
    while player < 8 as libc::c_int as libc::c_uint {
        psStructStats = asStructureStats;
        i = 0 as libc::c_int as UDWORD;
        while i < numStructureStats {
            strcpy((*psSaveLimit).name.as_mut_ptr(), (*psStructStats).pName);
            (*psSaveLimit).limit =
                (*asStructLimits[player as usize].offset(i as isize)).limit;
            (*psSaveLimit).player = player as UBYTE;
            psSaveLimit =
                (psSaveLimit as
                     *mut libc::c_char).offset(::std::mem::size_of::<SAVE_STRUCTLIMITS>()
                                                   as libc::c_ulong as isize)
                    as *mut SAVE_STRUCTLIMITS;
            i = i.wrapping_add(1);
            psStructStats = psStructStats.offset(1)
        }
        player = player.wrapping_add(1)
    }
    /* STRUCTLIMITS_SAVEHEADER */
    endian_udword(&mut (*psHeader).version);
    endian_udword(&mut (*psHeader).quantity);
    // Write the data to the file
    if !pFileData.is_null() {
        status = saveFile(pFileName, pFileData, fileSize);
        memFreeRelease(pFileData as *mut libc::c_void);
        pFileData = 0 as *mut libc::c_char;
        return status
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn loadSaveCommandLists(mut pFileData: *mut libc::c_char,
                                          mut filesize: UDWORD) -> BOOL {
    let mut psHeader: *mut COMMAND_SAVEHEADER = 0 as *mut COMMAND_SAVEHEADER;
    // Check the file type
    psHeader = pFileData as *mut COMMAND_SAVEHEADER;
    if (*psHeader).aFileType[0 as libc::c_int as usize] as libc::c_int !=
           'c' as i32 ||
           (*psHeader).aFileType[1 as libc::c_int as usize] as libc::c_int !=
               'm' as i32 ||
           (*psHeader).aFileType[2 as libc::c_int as usize] as libc::c_int !=
               'n' as i32 ||
           (*psHeader).aFileType[3 as libc::c_int as usize] as libc::c_int !=
               'd' as i32 {
        debug(LOG_ERROR,
              b"loadSaveCommandList: Incorrect file type\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    /* COMMAND_SAVEHEADER */
    endian_udword(&mut (*psHeader).version);
    endian_udword(&mut (*psHeader).quantity);
    //increment to the start of the data
    pFileData = pFileData.offset(12 as libc::c_int as isize);
    // Check the file version
    if (*psHeader).version <= 33 as libc::c_int as libc::c_uint {
        if loadSaveCommandListsV(pFileData, filesize, (*psHeader).quantity) ==
               0 {
            return 0 as libc::c_int
        }
    } else {
        debug(LOG_ERROR,
              b"loadSaveCommandLists: Incorrect file format version\x00" as
                  *const u8 as *const libc::c_char);
        abort();
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
unsafe extern "C" fn loadSaveCommandListsV(mut pFileData: *mut libc::c_char,
                                           mut filesize: UDWORD,
                                           mut numDroids: UDWORD) -> BOOL {
    let mut psSaveCommand: *mut SAVE_COMMAND = 0 as *mut SAVE_COMMAND;
    let mut psDroid: *mut DROID = 0 as *mut DROID;
    let mut count: UDWORD = 0;
    if (::std::mem::size_of::<SAVE_COMMAND>() as
            libc::c_ulong).wrapping_mul(numDroids).wrapping_add(12 as
                                                                    libc::c_int
                                                                    as
                                                                    libc::c_uint)
           > filesize {
        debug(LOG_ERROR,
              b"loadSaveCommand: unexpected end of file\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    psSaveCommand = pFileData as *mut SAVE_COMMAND;
    // Load in the data
    count = 0 as libc::c_int as UDWORD;
    while count < numDroids {
        /* SAVE_COMMAND is COMMAND_SAVE_V20 */
		/* COMMAND_SAVE_V20 */
        endian_udword(&mut (*psSaveCommand.offset(count as isize)).droidID);
        if (*psSaveCommand.offset(count as isize)).droidID !=
               0xffffffff as libc::c_uint {
            psDroid =
                getBaseObjFromId((*psSaveCommand.offset(count as
                                                            isize)).droidID)
                    as *mut DROID;
            cmdDroidSetDesignator(psDroid);
        }
        count = count.wrapping_add(1)
    }
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
/*
Writes the command lists to a file
*/
unsafe extern "C" fn writeCommandLists(mut pFileName: *mut STRING) -> BOOL {
    let mut pFileData: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut psDroid: *mut DROID = 0 as *mut DROID;
    let mut fileSize: UDWORD = 0;
    let mut totalDroids: UDWORD = 0 as libc::c_int as UDWORD;
    let mut player: UDWORD = 0;
    let mut psHeader: *mut COMMAND_SAVEHEADER = 0 as *mut COMMAND_SAVEHEADER;
    let mut psSaveCommand: *mut SAVE_COMMAND = 0 as *mut SAVE_COMMAND;
    let mut status: BOOL = 1 as libc::c_int;
    /*not list
	//total all the droids in the commndlists
	for (player = 0; player < MAX_PLAYERS; player++)
	{
		for (psDroid = apsCmdDesignator[player]; psDroid != NULL; psDroid = psDroid->psNext)
		{
			totalDroids++;
		}
	}
*/
    totalDroids = 8 as libc::c_int as UDWORD;
    // Allocate the data buffer
    fileSize =
        (12 as libc::c_int as
             libc::c_uint).wrapping_add(totalDroids.wrapping_mul(::std::mem::size_of::<SAVE_COMMAND>()
                                                                     as
                                                                     libc::c_ulong));
    pFileData = memMallocRelease(fileSize) as *mut libc::c_char;
    if pFileData.is_null() {
        debug(LOG_ERROR,
              b"Out of memory\x00" as *const u8 as *const libc::c_char);
        abort();
    }
    // Put the file header on the file
    psHeader = pFileData as *mut COMMAND_SAVEHEADER;
    (*psHeader).aFileType[0 as libc::c_int as usize] = 'c' as i32 as STRING;
    (*psHeader).aFileType[1 as libc::c_int as usize] = 'm' as i32 as STRING;
    (*psHeader).aFileType[2 as libc::c_int as usize] = 'n' as i32 as STRING;
    (*psHeader).aFileType[3 as libc::c_int as usize] = 'd' as i32 as STRING;
    (*psHeader).version = 33 as libc::c_int as UDWORD;
    (*psHeader).quantity = totalDroids;
    psSaveCommand =
        pFileData.offset(12 as libc::c_int as isize) as *mut SAVE_COMMAND;
    // Put the data into the buffer
    player = 0 as libc::c_int as UDWORD;
    while player < 8 as libc::c_int as libc::c_uint {
        /*not list
		for (psDroid = apsCmdDesignation[player]; psDroid != NULL; psDroid = psDroid->psNext)
		{
			psSaveCommand->droidID = psDroid->id;
			psSaveCommand = (SAVE_COMMAND*)((char *)psSaveCommand + sizeof(SAVE_COMMAND));
		}
*/
        psDroid = cmdDroidGetDesignator(player);
        if !psDroid.is_null() {
            (*psSaveCommand).droidID = (*psDroid).id
        } else { (*psSaveCommand).droidID = 0xffffffff as libc::c_uint }
        /* SAVE_COMMAND is COMMAND_SAVE_V20 */
		/* COMMAND_SAVE_V20 */
        endian_udword(&mut (*psSaveCommand).droidID);
        psSaveCommand =
            (psSaveCommand as
                 *mut libc::c_char).offset(::std::mem::size_of::<SAVE_COMMAND>()
                                               as libc::c_ulong as isize) as
                *mut SAVE_COMMAND;
        player = player.wrapping_add(1)
    }
    /* COMMAND_SAVEHEADER */
    endian_udword(&mut (*psHeader).version);
    endian_udword(&mut (*psHeader).quantity);
    // Write the data to the file
    if !pFileData.is_null() {
        status = saveFile(pFileName, pFileData, fileSize);
        memFreeRelease(pFileData as *mut libc::c_void);
        pFileData = 0 as *mut libc::c_char;
        return status
    }
    return 0 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
// write the event state to a file on disk
unsafe extern "C" fn writeScriptState(mut pFileName: *mut STRING) -> BOOL {
    let mut pBuffer: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut fileSize: UDWORD = 0;
    if eventSaveState(3 as libc::c_int, &mut pBuffer, &mut fileSize) == 0 {
        return 0 as libc::c_int
    }
    if saveFile(pFileName, pBuffer, fileSize) == 0 { return 0 as libc::c_int }
    memFreeRelease(pBuffer as *mut libc::c_void);
    pBuffer = 0 as *mut libc::c_char;
    return 1 as libc::c_int;
}
// load the script state given a .gam name
// -----------------------------------------------------------------------------------------
// load the script state given a .gam name
#[no_mangle]
pub unsafe extern "C" fn loadScriptState(mut pFileName: *mut STRING) -> BOOL {
    let mut pFileData: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut fileSize: UDWORD = 0;
    let mut bHashed: BOOL = 0 as libc::c_int;
    // change the file extension
    *pFileName.offset(strlen(pFileName).wrapping_sub(4 as libc::c_int as
                                                         libc::c_uint) as
                          isize) = 0 as libc::c_int as libc::c_char;
    strcat(pFileName, b".es\x00" as *const u8 as *const libc::c_char);
    pFileData = DisplayBuffer;
    if loadFileToBuffer(pFileName, pFileData, displayBufferSize,
                        &mut fileSize) == 0 {
        debug(LOG_ERROR,
              b"loadScriptState: couldn\'t load %s\x00" as *const u8 as
                  *const libc::c_char, pFileName);
        abort();
    }
    if saveGameVersion > 12 as libc::c_int as libc::c_uint {
        bHashed = 1 as libc::c_int
    }
    if eventLoadState(pFileData, fileSize, bHashed) == 0 {
        return 0 as libc::c_int
    }
    return 1 as libc::c_int;
}
/* set the global scroll values to use for the save game */
// -----------------------------------------------------------------------------------------
/* set the global scroll values to use for the save game */
unsafe extern "C" fn setMapScroll() {
    //if loading in a pre version5 then scroll values will not have been set up so set to max poss
    if width == 0 as libc::c_int as libc::c_uint &&
           height == 0 as libc::c_int as libc::c_uint {
        scrollMinX = 0 as libc::c_int;
        scrollMaxX = mapWidth as SDWORD;
        scrollMinY = 0 as libc::c_int;
        scrollMaxY = mapHeight as SDWORD;
        return
    }
    scrollMinX = startX;
    scrollMinY = startY;
    scrollMaxX = (startX as libc::c_uint).wrapping_add(width) as SDWORD;
    scrollMaxY = (startY as libc::c_uint).wrapping_add(height) as SDWORD;
    //check not going beyond width/height of map
    if scrollMaxX > mapWidth as SDWORD {
        scrollMaxX = mapWidth as SDWORD;
        debug(LOG_NEVER,
              b"scrollMaxX was too big It has been set to map width\x00" as
                  *const u8 as *const libc::c_char);
    }
    if scrollMaxY > mapHeight as SDWORD {
        scrollMaxY = mapHeight as SDWORD;
        debug(LOG_NEVER,
              b"scrollMaxY was too big It has been set to map height\x00" as
                  *const u8 as *const libc::c_char);
    };
}
//adjust the name depending on type of save game and whether resourceNames are used
// -----------------------------------------------------------------------------------------
unsafe extern "C" fn getSaveObjectName(mut pName: *mut STRING) -> BOOL {
    return 1 as libc::c_int;
}
/*returns the current type of save game being loaded*/
// -----------------------------------------------------------------------------------------
/*returns the current type of save game being loaded*/
#[no_mangle]
pub unsafe extern "C" fn getSaveGameType() -> UDWORD { return gameType; }
// -----------------------------------------------------------------------------------------
#[no_mangle]
pub unsafe extern "C" fn getCompFromNamePreV7(mut compType: UDWORD,
                                              mut pName: *mut STRING)
 -> SDWORD {
    let mut psStats: *mut BASE_STATS = 0 as *mut BASE_STATS;
    let mut numStats: UDWORD = 0 as libc::c_int as UDWORD;
    let mut count: UDWORD = 0;
    let mut statSize: UDWORD = 0 as libc::c_int as UDWORD;
    let mut id: UDWORD = 0;
    let mut pTranslatedName: *mut STRING = 0 as *mut STRING;
    match compType {
        1 => {
            psStats = asBodyStats as *mut BASE_STATS;
            numStats = numBodyStats;
            statSize = ::std::mem::size_of::<BODY_STATS>() as libc::c_ulong
        }
        2 => {
            psStats = asBrainStats as *mut BASE_STATS;
            numStats = numBrainStats;
            statSize = ::std::mem::size_of::<BRAIN_STATS>() as libc::c_ulong
        }
        3 => {
            psStats = asPropulsionStats as *mut BASE_STATS;
            numStats = numPropulsionStats;
            statSize =
                ::std::mem::size_of::<PROPULSION_STATS>() as libc::c_ulong
        }
        4 => {
            psStats = asRepairStats as *mut BASE_STATS;
            numStats = numRepairStats;
            statSize = ::std::mem::size_of::<REPAIR_STATS>() as libc::c_ulong
        }
        5 => {
            psStats = asECMStats as *mut BASE_STATS;
            numStats = numECMStats;
            statSize = ::std::mem::size_of::<ECM_STATS>() as libc::c_ulong
        }
        6 => {
            psStats = asSensorStats as *mut BASE_STATS;
            numStats = numSensorStats;
            statSize = ::std::mem::size_of::<SENSOR_STATS>() as libc::c_ulong
        }
        7 => {
            psStats = asConstructStats as *mut BASE_STATS;
            numStats = numConstructStats;
            statSize =
                ::std::mem::size_of::<CONSTRUCT_STATS>() as libc::c_ulong
        }
        8 => {
            /*case COMP_PROGRAM:
		psStats = (BASE_STATS*)asProgramStats;
		numStats = numProgramStats;
		statSize = sizeof(PROGRAM_STATS);
		break;*/
            psStats = asWeaponStats as *mut BASE_STATS;
            numStats = numWeaponStats;
            statSize = ::std::mem::size_of::<WEAPON_STATS>() as libc::c_ulong
        }
        _ => {
            //COMP_UNKNOWN should be an error
            debug(LOG_ERROR,
                  b"Invalid component type - game.c\x00" as *const u8 as
                      *const libc::c_char);
            abort();
        }
    }
    //find the stat with the same name
    count = 0 as libc::c_int as UDWORD;
    while count < numStats {
        //get the translated name from the stat
        if strresGetIDNum(psStringRes, (*psStats).pName, &mut id) == 0 {
            debug(LOG_ERROR,
                  b"Unable to find string resource for %s\x00" as *const u8 as
                      *const libc::c_char,
                  getStatName(psStats as *mut libc::c_void));
            abort();
        }
        //get the string from the id
        pTranslatedName = strresGetString(psStringRes, id);
        if strcmp(pTranslatedName, pName) == 0 { return count as SDWORD }
        psStats =
            (psStats as UDWORD).wrapping_add(statSize) as *mut BASE_STATS;
        count = count.wrapping_add(1)
    }
    //return -1 if record not found or an invalid component type is passed in
    return -(1 as libc::c_int);
}
// -----------------------------------------------------------------------------------------
#[no_mangle]
pub unsafe extern "C" fn getStatFromNamePreV7(mut isFeature: BOOL,
                                              mut pName: *mut STRING)
 -> SDWORD {
    let mut psStats: *mut BASE_STATS = 0 as *mut BASE_STATS;
    let mut numStats: UDWORD = 0 as libc::c_int as UDWORD;
    let mut count: UDWORD = 0;
    let mut statSize: UDWORD = 0;
    let mut id: UDWORD = 0;
    let mut pTranslatedName: *mut STRING = 0 as *mut STRING;
    if isFeature != 0 {
        psStats = asFeatureStats as *mut BASE_STATS;
        numStats = numFeatureStats;
        statSize = ::std::mem::size_of::<FEATURE_STATS>() as libc::c_ulong
    } else {
        psStats = asStructureStats as *mut BASE_STATS;
        numStats = numStructureStats;
        statSize = ::std::mem::size_of::<STRUCTURE_STATS>() as libc::c_ulong
    }
    //find the stat with the same name
    count = 0 as libc::c_int as UDWORD;
    while count < numStats {
        //get the translated name from the stat
        if strresGetIDNum(psStringRes, (*psStats).pName, &mut id) == 0 {
            debug(LOG_ERROR,
                  b"Unable to find string resource for %s\x00" as *const u8 as
                      *const libc::c_char,
                  getStatName(psStats as *mut libc::c_void));
            abort();
        }
        //get the string from the id
        pTranslatedName = strresGetString(psStringRes, id);
        if strcmp(pTranslatedName, pName) == 0 { return count as SDWORD }
        psStats =
            (psStats as UDWORD).wrapping_add(statSize) as *mut BASE_STATS;
        count = count.wrapping_add(1)
    }
    //return -1 if record not found or an invalid component type is passed in
    return -(1 as libc::c_int);
}
// -----------------------------------------------------------------------------------------
//copies a Stat name into a destination string for a given stat type and index
unsafe extern "C" fn getNameFromComp(mut compType: UDWORD,
                                     mut pDest: *mut STRING,
                                     mut compIndex: UDWORD) -> BOOL {
    let mut psStats: *mut BASE_STATS = 0 as *mut BASE_STATS;
    //allocate the stats pointer
    match compType {
        1 => {
            psStats =
                asBodyStats.offset(compIndex as isize) as *mut BASE_STATS
        }
        2 => {
            psStats =
                asBrainStats.offset(compIndex as isize) as *mut BASE_STATS
        }
        3 => {
            psStats =
                asPropulsionStats.offset(compIndex as isize) as
                    *mut BASE_STATS
        }
        4 => {
            psStats =
                asRepairStats.offset(compIndex as isize) as *mut BASE_STATS
        }
        5 => {
            psStats = asECMStats.offset(compIndex as isize) as *mut BASE_STATS
        }
        6 => {
            psStats =
                asSensorStats.offset(compIndex as isize) as *mut BASE_STATS
        }
        7 => {
            psStats =
                asConstructStats.offset(compIndex as isize) as *mut BASE_STATS
        }
        8 => {
            /*case COMP_PROGRAM:
		psStats = (BASE_STATS*)(asProgramStats + compIndex);
		break;*/
            psStats =
                asWeaponStats.offset(compIndex as isize) as *mut BASE_STATS
        }
        _ => {
            debug(LOG_ERROR,
                  b"Invalid component type - game.c\x00" as *const u8 as
                      *const libc::c_char);
            abort();
        }
    }
    //copy the name into the destination string
    strcpy(pDest, (*psStats).pName);
    return 1 as libc::c_int;
}
// -----------------------------------------------------------------------------------------
// END
// draws the structures onto a completed map preview sprite.
#[no_mangle]
pub unsafe extern "C" fn plotStructurePreview(mut backDropSprite:
                                                  *mut iSprite,
                                              mut scale: UBYTE,
                                              mut offX: UDWORD,
                                              mut offY: UDWORD) -> BOOL {
    let mut sSave: SAVE_STRUCTURE =
        SAVE_STRUCTURE{name: [0; 60],
                       id: 0,
                       x: 0,
                       y: 0,
                       z: 0,
                       direction: 0,
                       player: 0,
                       inFire: 0,
                       burnStart: 0,
                       burnDamage: 0,
                       status: 0,
                       currentBuildPts: 0,
                       body: 0,
                       armour: 0,
                       resistance: 0,
                       dummy1: 0,
                       subjectInc: 0,
                       timeStarted: 0,
                       output: 0,
                       capacity: 0,
                       quantity: 0,
                       factoryInc: 0,
                       loopsPerformed: 0,
                       powerAccrued: 0,
                       dummy2: 0,
                       droidTimeStarted: 0,
                       timeToBuild: 0,
                       timeStartHold: 0,
                       visible: [0; 8],
                       researchName: [0; 60],
                       currentPowerAccrued: 0,
                       commandId: 0,}; // close eyes now.
    let mut psSaveStructure: *mut SAVE_STRUCTURE =
        &mut sSave; // assumes save_struct is larger than all previous ones...
    let mut psSaveStructure2: *mut SAVE_STRUCTURE_V2 =
        &mut sSave as *mut SAVE_STRUCTURE as *mut SAVE_STRUCTURE_V2;
    let mut psSaveStructure12: *mut SAVE_STRUCTURE_V12 =
        &mut sSave as *mut SAVE_STRUCTURE as *mut SAVE_STRUCTURE_V12;
    let mut psSaveStructure14: *mut SAVE_STRUCTURE_V14 =
        &mut sSave as *mut SAVE_STRUCTURE as *mut SAVE_STRUCTURE_V14;
    let mut psSaveStructure15: *mut SAVE_STRUCTURE_V15 =
        &mut sSave as *mut SAVE_STRUCTURE as *mut SAVE_STRUCTURE_V15;
    let mut psSaveStructure17: *mut SAVE_STRUCTURE_V17 =
        &mut sSave as *mut SAVE_STRUCTURE as *mut SAVE_STRUCTURE_V17;
    let mut psSaveStructure20: *mut SAVE_STRUCTURE_V20 =
        &mut sSave as *mut SAVE_STRUCTURE as *mut SAVE_STRUCTURE_V20;
    // ok you can open them again..
    let mut psHeader: *mut STRUCT_SAVEHEADER = 0 as *mut STRUCT_SAVEHEADER;
    let mut aFileName: [STRING; 256] = [0; 256];
    let mut xx: UDWORD = 0;
    let mut yy: UDWORD = 0;
    let mut x: UDWORD = 0;
    let mut y: UDWORD = 0;
    let mut count: UDWORD = 0;
    let mut fileSize: UDWORD = 0;
    let mut sizeOfSaveStruture: UDWORD = 0;
    let mut pFileData: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut psLevel: *mut LEVEL_DATASET = 0 as *mut LEVEL_DATASET;
    levFindDataSet(game.map.as_mut_ptr(), &mut psLevel);
    strcpy(aFileName.as_mut_ptr(),
           (*psLevel).apDataFiles[0 as libc::c_int as usize]);
    aFileName[strlen(aFileName.as_mut_ptr()).wrapping_sub(4 as libc::c_int as
                                                              libc::c_uint) as
                  usize] = '\u{0}' as i32 as STRING;
    strcat(aFileName.as_mut_ptr(),
           b"\\struct.bjo\x00" as *const u8 as *const libc::c_char);
    pFileData = DisplayBuffer;
    if loadFileToBuffer(aFileName.as_mut_ptr(), pFileData, displayBufferSize,
                        &mut fileSize) == 0 {
        debug(LOG_NEVER,
              b"plotStructurePreview: Fail1\n\x00" as *const u8 as
                  *const libc::c_char);
    }
    /* Check the file type */
    psHeader = pFileData as *mut STRUCT_SAVEHEADER;
    if (*psHeader).aFileType[0 as libc::c_int as usize] as libc::c_int !=
           's' as i32 ||
           (*psHeader).aFileType[1 as libc::c_int as usize] as libc::c_int !=
               't' as i32 ||
           (*psHeader).aFileType[2 as libc::c_int as usize] as libc::c_int !=
               'r' as i32 ||
           (*psHeader).aFileType[3 as libc::c_int as usize] as libc::c_int !=
               'u' as i32 {
        debug(LOG_ERROR,
              b"plotStructurePreview: Incorrect file type\x00" as *const u8 as
                  *const libc::c_char);
        abort();
    }
    /* STRUCT_SAVEHEADER */
    endian_udword(&mut (*psHeader).version);
    endian_udword(&mut (*psHeader).quantity);
    //increment to the start of the data
    pFileData = pFileData.offset(12 as libc::c_int as isize);
    if (*psHeader).version < 12 as libc::c_int as libc::c_uint {
        sizeOfSaveStruture =
            ::std::mem::size_of::<SAVE_STRUCTURE_V2>() as libc::c_ulong
    } else if (*psHeader).version < 14 as libc::c_int as libc::c_uint {
        sizeOfSaveStruture =
            ::std::mem::size_of::<SAVE_STRUCTURE_V12>() as libc::c_ulong
    } else if (*psHeader).version <= 14 as libc::c_int as libc::c_uint {
        sizeOfSaveStruture =
            ::std::mem::size_of::<SAVE_STRUCTURE_V14>() as libc::c_ulong
    } else if (*psHeader).version <= 16 as libc::c_int as libc::c_uint {
        sizeOfSaveStruture =
            ::std::mem::size_of::<SAVE_STRUCTURE_V15>() as libc::c_ulong
    } else if (*psHeader).version <= 19 as libc::c_int as libc::c_uint {
        sizeOfSaveStruture =
            ::std::mem::size_of::<SAVE_STRUCTURE_V17>() as libc::c_ulong
    } else if (*psHeader).version <= 20 as libc::c_int as libc::c_uint {
        sizeOfSaveStruture =
            ::std::mem::size_of::<SAVE_STRUCTURE_V20>() as libc::c_ulong
    } else {
        sizeOfSaveStruture =
            ::std::mem::size_of::<SAVE_STRUCTURE>() as libc::c_ulong
    }
    /* Load in the structure data */
    count = 0 as libc::c_int as UDWORD;
    while count < (*psHeader).quantity {
        if (*psHeader).version < 12 as libc::c_int as libc::c_uint {
            memcpy(psSaveStructure2 as *mut libc::c_void,
                   pFileData as *const libc::c_void, sizeOfSaveStruture);
            xx = (*psSaveStructure2).x >> 7 as libc::c_int;
            yy = (*psSaveStructure2).y >> 7 as libc::c_int
        } else if (*psHeader).version < 14 as libc::c_int as libc::c_uint {
            memcpy(psSaveStructure12 as *mut libc::c_void,
                   pFileData as *const libc::c_void, sizeOfSaveStruture);
            xx = (*psSaveStructure12).x >> 7 as libc::c_int;
            yy = (*psSaveStructure12).y >> 7 as libc::c_int
        } else if (*psHeader).version <= 14 as libc::c_int as libc::c_uint {
            memcpy(psSaveStructure14 as *mut libc::c_void,
                   pFileData as *const libc::c_void, sizeOfSaveStruture);
            xx = (*psSaveStructure14).x >> 7 as libc::c_int;
            yy = (*psSaveStructure14).y >> 7 as libc::c_int
        } else if (*psHeader).version <= 16 as libc::c_int as libc::c_uint {
            memcpy(psSaveStructure15 as *mut libc::c_void,
                   pFileData as *const libc::c_void, sizeOfSaveStruture);
            xx = (*psSaveStructure15).x >> 7 as libc::c_int;
            yy = (*psSaveStructure15).y >> 7 as libc::c_int
        } else if (*psHeader).version <= 19 as libc::c_int as libc::c_uint {
            memcpy(psSaveStructure17 as *mut libc::c_void,
                   pFileData as *const libc::c_void, sizeOfSaveStruture);
            xx = (*psSaveStructure17).x >> 7 as libc::c_int;
            yy = (*psSaveStructure17).y >> 7 as libc::c_int
        } else if (*psHeader).version <= 20 as libc::c_int as libc::c_uint {
            memcpy(psSaveStructure20 as *mut libc::c_void,
                   pFileData as *const libc::c_void, sizeOfSaveStruture);
            xx = (*psSaveStructure20).x >> 7 as libc::c_int;
            yy = (*psSaveStructure20).y >> 7 as libc::c_int
        } else {
            memcpy(psSaveStructure as *mut libc::c_void,
                   pFileData as *const libc::c_void, sizeOfSaveStruture);
            xx = (*psSaveStructure).x >> 7 as libc::c_int;
            yy = (*psSaveStructure).y >> 7 as libc::c_int
        }
        x = xx.wrapping_mul(scale as libc::c_uint);
        while x <
                  xx.wrapping_mul(scale as
                                      libc::c_uint).wrapping_add(scale as
                                                                     libc::c_uint)
              {
            y = yy.wrapping_mul(scale as libc::c_uint);
            while y <
                      yy.wrapping_mul(scale as
                                          libc::c_uint).wrapping_add(scale as
                                                                         libc::c_uint)
                  {
                *(*backDropSprite).bmp.offset(offY.wrapping_add(y).wrapping_mul(640
                                                                                    as
                                                                                    libc::c_int
                                                                                    as
                                                                                    libc::c_uint).wrapping_add(x).wrapping_add(offX)
                                                  as isize) =
                    *colours.as_mut_ptr().offset(4 as libc::c_int as isize);
                y = y.wrapping_add(1)
            }
            x = x.wrapping_add(1)
        }
        count = count.wrapping_add(1);
        pFileData = pFileData.offset(sizeOfSaveStruture as isize)
    }
    return 1 as libc::c_int;
}
//======================================================
//draws stuff into our newer bitmap.
#[no_mangle]
pub unsafe extern "C" fn plotStructurePreview16(mut backDropSprite:
                                                    *mut libc::c_uchar,
                                                mut scale: UBYTE,
                                                mut offX: UDWORD,
                                                mut offY: UDWORD) -> BOOL {
    let mut sSave: SAVE_STRUCTURE =
        SAVE_STRUCTURE{name: [0; 60],
                       id: 0,
                       x: 0,
                       y: 0,
                       z: 0,
                       direction: 0,
                       player: 0,
                       inFire: 0,
                       burnStart: 0,
                       burnDamage: 0,
                       status: 0,
                       currentBuildPts: 0,
                       body: 0,
                       armour: 0,
                       resistance: 0,
                       dummy1: 0,
                       subjectInc: 0,
                       timeStarted: 0,
                       output: 0,
                       capacity: 0,
                       quantity: 0,
                       factoryInc: 0,
                       loopsPerformed: 0,
                       powerAccrued: 0,
                       dummy2: 0,
                       droidTimeStarted: 0,
                       timeToBuild: 0,
                       timeStartHold: 0,
                       visible: [0; 8],
                       researchName: [0; 60],
                       currentPowerAccrued: 0,
                       commandId: 0,}; // close eyes now.
    let mut psSaveStructure: *mut SAVE_STRUCTURE =
        &mut sSave; // assumes save_struct is larger than all previous ones...
    let mut psSaveStructure2: *mut SAVE_STRUCTURE_V2 =
        &mut sSave as *mut SAVE_STRUCTURE as *mut SAVE_STRUCTURE_V2;
    let mut psSaveStructure12: *mut SAVE_STRUCTURE_V12 =
        &mut sSave as *mut SAVE_STRUCTURE as *mut SAVE_STRUCTURE_V12;
    let mut psSaveStructure14: *mut SAVE_STRUCTURE_V14 =
        &mut sSave as *mut SAVE_STRUCTURE as *mut SAVE_STRUCTURE_V14;
    let mut psSaveStructure15: *mut SAVE_STRUCTURE_V15 =
        &mut sSave as *mut SAVE_STRUCTURE as *mut SAVE_STRUCTURE_V15;
    let mut psSaveStructure17: *mut SAVE_STRUCTURE_V17 =
        &mut sSave as *mut SAVE_STRUCTURE as *mut SAVE_STRUCTURE_V17;
    let mut psSaveStructure20: *mut SAVE_STRUCTURE_V20 =
        &mut sSave as *mut SAVE_STRUCTURE as *mut SAVE_STRUCTURE_V20;
    // ok you can open them again..
    let mut psHeader: *mut STRUCT_SAVEHEADER = 0 as *mut STRUCT_SAVEHEADER;
    let mut aFileName: [STRING; 256] = [0; 256];
    let mut xx: UDWORD = 0;
    let mut yy: UDWORD = 0;
    let mut x: UDWORD = 0;
    let mut y: UDWORD = 0;
    let mut count: UDWORD = 0;
    let mut fileSize: UDWORD = 0;
    let mut sizeOfSaveStruture: UDWORD = 0;
    let mut pFileData: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut psLevel: *mut LEVEL_DATASET = 0 as *mut LEVEL_DATASET;
    levFindDataSet(game.map.as_mut_ptr(), &mut psLevel);
    strcpy(aFileName.as_mut_ptr(),
           (*psLevel).apDataFiles[0 as libc::c_int as usize]);
    aFileName[strlen(aFileName.as_mut_ptr()).wrapping_sub(4 as libc::c_int as
                                                              libc::c_uint) as
                  usize] = '\u{0}' as i32 as STRING;
    strcat(aFileName.as_mut_ptr(),
           b"\\struct.bjo\x00" as *const u8 as *const libc::c_char);
    pFileData = DisplayBuffer;
    if loadFileToBuffer(aFileName.as_mut_ptr(), pFileData, displayBufferSize,
                        &mut fileSize) == 0 {
        debug(LOG_NEVER,
              b"plotStructurePreview16: Fail1\n\x00" as *const u8 as
                  *const libc::c_char);
    }
    /* Check the file type */
    psHeader = pFileData as *mut STRUCT_SAVEHEADER;
    if (*psHeader).aFileType[0 as libc::c_int as usize] as libc::c_int !=
           's' as i32 ||
           (*psHeader).aFileType[1 as libc::c_int as usize] as libc::c_int !=
               't' as i32 ||
           (*psHeader).aFileType[2 as libc::c_int as usize] as libc::c_int !=
               'r' as i32 ||
           (*psHeader).aFileType[3 as libc::c_int as usize] as libc::c_int !=
               'u' as i32 {
        debug(LOG_ERROR,
              b"plotStructurePreview16: Incorrect file type\x00" as *const u8
                  as *const libc::c_char);
        abort();
    }
    /* STRUCT_SAVEHEADER */
    endian_udword(&mut (*psHeader).version);
    endian_udword(&mut (*psHeader).quantity);
    //increment to the start of the data
    pFileData = pFileData.offset(12 as libc::c_int as isize);
    if (*psHeader).version < 12 as libc::c_int as libc::c_uint {
        sizeOfSaveStruture =
            ::std::mem::size_of::<SAVE_STRUCTURE_V2>() as libc::c_ulong
    } else if (*psHeader).version < 14 as libc::c_int as libc::c_uint {
        sizeOfSaveStruture =
            ::std::mem::size_of::<SAVE_STRUCTURE_V12>() as libc::c_ulong
    } else if (*psHeader).version <= 14 as libc::c_int as libc::c_uint {
        sizeOfSaveStruture =
            ::std::mem::size_of::<SAVE_STRUCTURE_V14>() as libc::c_ulong
    } else if (*psHeader).version <= 16 as libc::c_int as libc::c_uint {
        sizeOfSaveStruture =
            ::std::mem::size_of::<SAVE_STRUCTURE_V15>() as libc::c_ulong
    } else if (*psHeader).version <= 19 as libc::c_int as libc::c_uint {
        sizeOfSaveStruture =
            ::std::mem::size_of::<SAVE_STRUCTURE_V17>() as libc::c_ulong
    } else if (*psHeader).version <= 20 as libc::c_int as libc::c_uint {
        sizeOfSaveStruture =
            ::std::mem::size_of::<SAVE_STRUCTURE_V20>() as libc::c_ulong
    } else {
        sizeOfSaveStruture =
            ::std::mem::size_of::<SAVE_STRUCTURE>() as libc::c_ulong
    }
    /* Load in the structure data */
    count = 0 as libc::c_int as UDWORD;
    while count < (*psHeader).quantity {
        if (*psHeader).version < 12 as libc::c_int as libc::c_uint {
            memcpy(psSaveStructure2 as *mut libc::c_void,
                   pFileData as *const libc::c_void, sizeOfSaveStruture);
            /* STRUCTURE_SAVE_V2 includes OBJECT_SAVE_V19 */
            endian_sdword(&mut (*psSaveStructure2).currentBuildPts);
            endian_udword(&mut (*psSaveStructure2).body);
            endian_udword(&mut (*psSaveStructure2).armour);
            endian_udword(&mut (*psSaveStructure2).resistance);
            endian_udword(&mut (*psSaveStructure2).dummy1);
            endian_udword(&mut (*psSaveStructure2).subjectInc);
            endian_udword(&mut (*psSaveStructure2).timeStarted);
            endian_udword(&mut (*psSaveStructure2).output);
            endian_udword(&mut (*psSaveStructure2).capacity);
            endian_udword(&mut (*psSaveStructure2).quantity);
            /* OBJECT_SAVE_V19 */
            endian_udword(&mut (*psSaveStructure2).id);
            endian_udword(&mut (*psSaveStructure2).x);
            endian_udword(&mut (*psSaveStructure2).y);
            endian_udword(&mut (*psSaveStructure2).z);
            endian_udword(&mut (*psSaveStructure2).direction);
            endian_udword(&mut (*psSaveStructure2).player);
            endian_udword(&mut (*psSaveStructure2).burnStart);
            endian_udword(&mut (*psSaveStructure2).burnDamage);
            xx = (*psSaveStructure2).x >> 7 as libc::c_int;
            yy = (*psSaveStructure2).y >> 7 as libc::c_int
        } else if (*psHeader).version < 14 as libc::c_int as libc::c_uint {
            memcpy(psSaveStructure12 as *mut libc::c_void,
                   pFileData as *const libc::c_void, sizeOfSaveStruture);
            /* STRUCTURE_SAVE_V12 includes STRUCTURE_SAVE_V2 */
            endian_udword(&mut (*psSaveStructure12).factoryInc);
            endian_udword(&mut (*psSaveStructure12).powerAccrued);
            endian_udword(&mut (*psSaveStructure12).droidTimeStarted);
            endian_udword(&mut (*psSaveStructure12).timeToBuild);
            endian_udword(&mut (*psSaveStructure12).timeStartHold);
            /* STRUCTURE_SAVE_V2 includes OBJECT_SAVE_V19 */
            endian_sdword(&mut (*psSaveStructure12).currentBuildPts);
            endian_udword(&mut (*psSaveStructure12).body);
            endian_udword(&mut (*psSaveStructure12).armour);
            endian_udword(&mut (*psSaveStructure12).resistance);
            endian_udword(&mut (*psSaveStructure12).dummy1);
            endian_udword(&mut (*psSaveStructure12).subjectInc);
            endian_udword(&mut (*psSaveStructure12).timeStarted);
            endian_udword(&mut (*psSaveStructure12).output);
            endian_udword(&mut (*psSaveStructure12).capacity);
            endian_udword(&mut (*psSaveStructure12).quantity);
            /* OBJECT_SAVE_V19 */
            endian_udword(&mut (*psSaveStructure12).id);
            endian_udword(&mut (*psSaveStructure12).x);
            endian_udword(&mut (*psSaveStructure12).y);
            endian_udword(&mut (*psSaveStructure12).z);
            endian_udword(&mut (*psSaveStructure12).direction);
            endian_udword(&mut (*psSaveStructure12).player);
            endian_udword(&mut (*psSaveStructure12).burnStart);
            endian_udword(&mut (*psSaveStructure12).burnDamage);
            xx = (*psSaveStructure12).x >> 7 as libc::c_int;
            yy = (*psSaveStructure12).y >> 7 as libc::c_int
        } else if (*psHeader).version <= 14 as libc::c_int as libc::c_uint {
            memcpy(psSaveStructure14 as *mut libc::c_void,
                   pFileData as *const libc::c_void, sizeOfSaveStruture);
            /* STRUCTURE_SAVE_V14 includes STRUCTURE_SAVE_V12 */
			/* STRUCTURE_SAVE_V12 includes STRUCTURE_SAVE_V2 */
            endian_udword(&mut (*psSaveStructure14).factoryInc);
            endian_udword(&mut (*psSaveStructure14).powerAccrued);
            endian_udword(&mut (*psSaveStructure14).droidTimeStarted);
            endian_udword(&mut (*psSaveStructure14).timeToBuild);
            endian_udword(&mut (*psSaveStructure14).timeStartHold);
            /* STRUCTURE_SAVE_V2 includes OBJECT_SAVE_V19 */
            endian_sdword(&mut (*psSaveStructure14).currentBuildPts);
            endian_udword(&mut (*psSaveStructure14).body);
            endian_udword(&mut (*psSaveStructure14).armour);
            endian_udword(&mut (*psSaveStructure14).resistance);
            endian_udword(&mut (*psSaveStructure14).dummy1);
            endian_udword(&mut (*psSaveStructure14).subjectInc);
            endian_udword(&mut (*psSaveStructure14).timeStarted);
            endian_udword(&mut (*psSaveStructure14).output);
            endian_udword(&mut (*psSaveStructure14).capacity);
            endian_udword(&mut (*psSaveStructure14).quantity);
            /* OBJECT_SAVE_V19 */
            endian_udword(&mut (*psSaveStructure14).id);
            endian_udword(&mut (*psSaveStructure14).x);
            endian_udword(&mut (*psSaveStructure14).y);
            endian_udword(&mut (*psSaveStructure14).z);
            endian_udword(&mut (*psSaveStructure14).direction);
            endian_udword(&mut (*psSaveStructure14).player);
            endian_udword(&mut (*psSaveStructure14).burnStart);
            endian_udword(&mut (*psSaveStructure14).burnDamage);
            xx = (*psSaveStructure14).x >> 7 as libc::c_int;
            yy = (*psSaveStructure14).y >> 7 as libc::c_int
        } else if (*psHeader).version <= 16 as libc::c_int as libc::c_uint {
            memcpy(psSaveStructure15 as *mut libc::c_void,
                   pFileData as *const libc::c_void, sizeOfSaveStruture);
            /* STRUCTURE_SAVE_V15 includes STRUCTURE_SAVE_V14 */
			/* STRUCTURE_SAVE_V14 includes STRUCTURE_SAVE_V12 */
			/* STRUCTURE_SAVE_V12 includes STRUCTURE_SAVE_V2 */
            endian_udword(&mut (*psSaveStructure15).factoryInc);
            endian_udword(&mut (*psSaveStructure15).powerAccrued);
            endian_udword(&mut (*psSaveStructure15).droidTimeStarted);
            endian_udword(&mut (*psSaveStructure15).timeToBuild);
            endian_udword(&mut (*psSaveStructure15).timeStartHold);
            /* STRUCTURE_SAVE_V2 includes OBJECT_SAVE_V19 */
            endian_sdword(&mut (*psSaveStructure15).currentBuildPts);
            endian_udword(&mut (*psSaveStructure15).body);
            endian_udword(&mut (*psSaveStructure15).armour);
            endian_udword(&mut (*psSaveStructure15).resistance);
            endian_udword(&mut (*psSaveStructure15).dummy1);
            endian_udword(&mut (*psSaveStructure15).subjectInc);
            endian_udword(&mut (*psSaveStructure15).timeStarted);
            endian_udword(&mut (*psSaveStructure15).output);
            endian_udword(&mut (*psSaveStructure15).capacity);
            endian_udword(&mut (*psSaveStructure15).quantity);
            /* OBJECT_SAVE_V19 */
            endian_udword(&mut (*psSaveStructure15).id);
            endian_udword(&mut (*psSaveStructure15).x);
            endian_udword(&mut (*psSaveStructure15).y);
            endian_udword(&mut (*psSaveStructure15).z);
            endian_udword(&mut (*psSaveStructure15).direction);
            endian_udword(&mut (*psSaveStructure15).player);
            endian_udword(&mut (*psSaveStructure15).burnStart);
            endian_udword(&mut (*psSaveStructure15).burnDamage);
            xx = (*psSaveStructure15).x >> 7 as libc::c_int;
            yy = (*psSaveStructure15).y >> 7 as libc::c_int
        } else if (*psHeader).version <= 19 as libc::c_int as libc::c_uint {
            memcpy(psSaveStructure17 as *mut libc::c_void,
                   pFileData as *const libc::c_void, sizeOfSaveStruture);
            /* STRUCTURE_SAVE_V17 includes STRUCTURE_SAVE_V15 */
            endian_sword(&mut (*psSaveStructure17).currentPowerAccrued);
            /* STRUCTURE_SAVE_V15 includes STRUCTURE_SAVE_V14 */
			/* STRUCTURE_SAVE_V14 includes STRUCTURE_SAVE_V12 */
			/* STRUCTURE_SAVE_V12 includes STRUCTURE_SAVE_V2 */
            endian_udword(&mut (*psSaveStructure17).factoryInc);
            endian_udword(&mut (*psSaveStructure17).powerAccrued);
            endian_udword(&mut (*psSaveStructure17).droidTimeStarted);
            endian_udword(&mut (*psSaveStructure17).timeToBuild);
            endian_udword(&mut (*psSaveStructure17).timeStartHold);
            /* STRUCTURE_SAVE_V2 includes OBJECT_SAVE_V19 */
            endian_sdword(&mut (*psSaveStructure17).currentBuildPts);
            endian_udword(&mut (*psSaveStructure17).body);
            endian_udword(&mut (*psSaveStructure17).armour);
            endian_udword(&mut (*psSaveStructure17).resistance);
            endian_udword(&mut (*psSaveStructure17).dummy1);
            endian_udword(&mut (*psSaveStructure17).subjectInc);
            endian_udword(&mut (*psSaveStructure17).timeStarted);
            endian_udword(&mut (*psSaveStructure17).output);
            endian_udword(&mut (*psSaveStructure17).capacity);
            endian_udword(&mut (*psSaveStructure17).quantity);
            /* OBJECT_SAVE_V19 */
            endian_udword(&mut (*psSaveStructure17).id);
            endian_udword(&mut (*psSaveStructure17).x);
            endian_udword(&mut (*psSaveStructure17).y);
            endian_udword(&mut (*psSaveStructure17).z);
            endian_udword(&mut (*psSaveStructure17).direction);
            endian_udword(&mut (*psSaveStructure17).player);
            endian_udword(&mut (*psSaveStructure17).burnStart);
            endian_udword(&mut (*psSaveStructure17).burnDamage);
            xx = (*psSaveStructure17).x >> 7 as libc::c_int;
            yy = (*psSaveStructure17).y >> 7 as libc::c_int
        } else if (*psHeader).version <= 20 as libc::c_int as libc::c_uint {
            memcpy(psSaveStructure20 as *mut libc::c_void,
                   pFileData as *const libc::c_void, sizeOfSaveStruture);
            /* STRUCTURE_SAVE_V20 includes OBJECT_SAVE_V20 */
            endian_sdword(&mut (*psSaveStructure20).currentBuildPts);
            endian_udword(&mut (*psSaveStructure20).body);
            endian_udword(&mut (*psSaveStructure20).armour);
            endian_udword(&mut (*psSaveStructure20).resistance);
            endian_udword(&mut (*psSaveStructure20).dummy1);
            endian_udword(&mut (*psSaveStructure20).subjectInc);
            endian_udword(&mut (*psSaveStructure20).timeStarted);
            endian_udword(&mut (*psSaveStructure20).output);
            endian_udword(&mut (*psSaveStructure20).capacity);
            endian_udword(&mut (*psSaveStructure20).quantity);
            endian_udword(&mut (*psSaveStructure20).factoryInc);
            endian_udword(&mut (*psSaveStructure20).powerAccrued);
            endian_udword(&mut (*psSaveStructure20).dummy2);
            endian_udword(&mut (*psSaveStructure20).droidTimeStarted);
            endian_udword(&mut (*psSaveStructure20).timeToBuild);
            endian_udword(&mut (*psSaveStructure20).timeStartHold);
            endian_sword(&mut (*psSaveStructure20).currentPowerAccrued);
            /* OBJECT_SAVE_V20 */
            endian_udword(&mut (*psSaveStructure20).id);
            endian_udword(&mut (*psSaveStructure20).x);
            endian_udword(&mut (*psSaveStructure20).y);
            endian_udword(&mut (*psSaveStructure20).z);
            endian_udword(&mut (*psSaveStructure20).direction);
            endian_udword(&mut (*psSaveStructure20).player);
            endian_udword(&mut (*psSaveStructure20).burnStart);
            endian_udword(&mut (*psSaveStructure20).burnDamage);
            xx = (*psSaveStructure20).x >> 7 as libc::c_int;
            yy = (*psSaveStructure20).y >> 7 as libc::c_int
        } else {
            memcpy(psSaveStructure as *mut libc::c_void,
                   pFileData as *const libc::c_void, sizeOfSaveStruture);
            /* SAVE_STRUCTURE is STRUCTURE_SAVE_V21 */
			/* STRUCTURE_SAVE_V21 includes STRUCTURE_SAVE_V20 */
            endian_udword(&mut (*psSaveStructure).commandId);
            /* STRUCTURE_SAVE_V20 includes OBJECT_SAVE_V20 */
            endian_sdword(&mut (*psSaveStructure).currentBuildPts);
            endian_udword(&mut (*psSaveStructure).body);
            endian_udword(&mut (*psSaveStructure).armour);
            endian_udword(&mut (*psSaveStructure).resistance);
            endian_udword(&mut (*psSaveStructure).dummy1);
            endian_udword(&mut (*psSaveStructure).subjectInc);
            endian_udword(&mut (*psSaveStructure).timeStarted);
            endian_udword(&mut (*psSaveStructure).output);
            endian_udword(&mut (*psSaveStructure).capacity);
            endian_udword(&mut (*psSaveStructure).quantity);
            endian_udword(&mut (*psSaveStructure).factoryInc);
            endian_udword(&mut (*psSaveStructure).powerAccrued);
            endian_udword(&mut (*psSaveStructure).dummy2);
            endian_udword(&mut (*psSaveStructure).droidTimeStarted);
            endian_udword(&mut (*psSaveStructure).timeToBuild);
            endian_udword(&mut (*psSaveStructure).timeStartHold);
            endian_sword(&mut (*psSaveStructure).currentPowerAccrued);
            /* OBJECT_SAVE_V20 */
            endian_udword(&mut (*psSaveStructure).id); //COL_RED;	//512 is forced, since we using 512*512
            endian_udword(&mut (*psSaveStructure).x);
            endian_udword(&mut (*psSaveStructure).y);
            endian_udword(&mut (*psSaveStructure).z);
            endian_udword(&mut (*psSaveStructure).direction);
            endian_udword(&mut (*psSaveStructure).player);
            endian_udword(&mut (*psSaveStructure).burnStart);
            endian_udword(&mut (*psSaveStructure).burnDamage);
            xx = (*psSaveStructure).x >> 7 as libc::c_int;
            yy = (*psSaveStructure).y >> 7 as libc::c_int
        }
        x = xx.wrapping_mul(scale as libc::c_uint);
        while x <
                  xx.wrapping_mul(scale as
                                      libc::c_uint).wrapping_add(scale as
                                                                     libc::c_uint)
              {
            y = yy.wrapping_mul(scale as libc::c_uint);
            while y <
                      yy.wrapping_mul(scale as
                                          libc::c_uint).wrapping_add(scale as
                                                                         libc::c_uint)
                  {
                *backDropSprite.offset((3 as libc::c_int as
                                            libc::c_uint).wrapping_mul(offY.wrapping_add(y).wrapping_mul(512
                                                                                                             as
                                                                                                             libc::c_int
                                                                                                             as
                                                                                                             libc::c_uint).wrapping_add(x).wrapping_add(offX))
                                           as isize) =
                    0xff as libc::c_int as libc::c_uchar;
                //COL_RED;	//
                *backDropSprite.offset((3 as libc::c_int as
                                            libc::c_uint).wrapping_mul(offY.wrapping_add(y).wrapping_mul(512
                                                                                                             as
                                                                                                             libc::c_int
                                                                                                             as
                                                                                                             libc::c_uint).wrapping_add(x).wrapping_add(offX)).wrapping_add(1
                                                                                                                                                                                as
                                                                                                                                                                                libc::c_int
                                                                                                                                                                                as
                                                                                                                                                                                libc::c_uint)
                                           as isize) =
                    0 as libc::c_int as
                        libc::c_uchar; //COL_RED;	//0xff0000 =red...
                *backDropSprite.offset((3 as libc::c_int as
                                            libc::c_uint).wrapping_mul(offY.wrapping_add(y).wrapping_mul(512
                                                                                                             as
                                                                                                             libc::c_int
                                                                                                             as
                                                                                                             libc::c_uint).wrapping_add(x).wrapping_add(offX)).wrapping_add(2
                                                                                                                                                                                as
                                                                                                                                                                                libc::c_int
                                                                                                                                                                                as
                                                                                                                                                                                libc::c_uint)
                                           as isize) =
                    0 as libc::c_int as libc::c_uchar;
                y = y.wrapping_add(1)
            }
            x = x.wrapping_add(1)
        }
        count = count.wrapping_add(1);
        pFileData = pFileData.offset(sizeOfSaveStruture as isize)
    }
    return 1 as libc::c_int;
}
